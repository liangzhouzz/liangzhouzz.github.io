<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>点云计算点密度特征</title>
    <url>/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="一、点云密度介绍"><a href="#一、点云密度介绍" class="headerlink" title="一、点云密度介绍"></a>一、点云密度介绍</h1><p>点云密度反应了点云的密集程度和分布，是点云的重要特征信息；其与采集设备的分辨率，被采集物体的表面材料有关。</p>
<p>广义上的点云密度有两种方法表示：</p>
<p><strong>①距离密度</strong>，即给定需要计算点的数量，统计每个邻近点到该点的距离作为密度；</p>
<p><strong>②点密度</strong>，即给定邻域半径，统计该点领域半径内的点数量作为点密度。</p>
<hr>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>指定搜索半径<code>radius</code>和最小点密度阈值<code>minPts</code>。可以先用<code>cloudcompare</code>查看</li>
<li>用<code>radiusSearch</code>统计种子点的在<code>radius</code>局部点的数量，作为点的密度值<code>densiities</code>。</li>
<li>遍历每个点的密度，满足密度阈值的点放入点集中。</li>
</ol>
<h2 id="2-1指定搜索半径和密度阈值"><a href="#2-1指定搜索半径和密度阈值" class="headerlink" title="2.1指定搜索半径和密度阈值"></a>2.1指定搜索半径和密度阈值</h2><p>这一步可以指定搜索半径和阈值，可以把点云文件导入cloudcompare内查看，以便设置更合适的阈值。</p>
<ul>
<li>导入文件–&gt;Tools–&gt;Other–&gt;Compute geometric features</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827161857964.png" alt="image-20230827161857964"></p>
<ul>
<li>设置半径和勾选要计算的特征即可，这里我们勾选局部邻域内点的数量作为密度。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162216221.png" alt="image-20230827162216221"></p>
<ul>
<li>拖动状态栏即可查看，设置合适的阈值。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162700463.png" alt="image-20230827162700463"></p>
<h2 id="2-2计算点的局部密度"><a href="#2-2计算点的局部密度" class="headerlink" title="2.2计算点的局部密度"></a>2.2计算点的局部密度</h2><p>首先构建<code>kdtree</code>，使用kdtree中的<code>radiusSearch</code>函数搜索种子点指定半径内点的索引<code>nn_indices</code>，然后将<code>nn_indices.size()</code>作为局部密度赋值给<code>densiities</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line"><span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line"><span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"><span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，初始化为零</span></span><br><span class="line">                            </span><br><span class="line"><span class="comment">//nn_in和nn_dists,在算法中用于计算每个点的局部密度，对于每个点通过tree-&gt;ra函数找到其在领域半径内的所有最邻点的索引和距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">        densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3筛选点并进行聚类"><a href="#2-3筛选点并进行聚类" class="headerlink" title="2.3筛选点并进行聚类"></a>2.3筛选点并进行聚类</h2><p>创建<code>visited</code>用于记录点是否已经访问过，当点已经被访问过，或点的密度小于阈值则跳过该点。然后创建一个队列<code>queue</code>用于记录当前聚类的点，<code>queue</code>为先入先出结构。最后得到点云满足阈值条件的的密度聚类<code>cluster</code>。将其放入<code>clusters</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (visited[i] || densiities[i] &lt; minPts)<span class="comment">//该点已经被访问，或点的密度小于minpts，</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">       &#125;</span><br><span class="line">            </span><br><span class="line">       <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">       pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">       std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">       std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">       <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">       q.<span class="built_in">push</span>(i);</span><br><span class="line">       visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">       <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">             <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">             <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">             <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">             q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素用于退出循环</span></span><br><span class="line">             cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">             singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">             std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">             std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">             treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">             &#123;</span><br><span class="line">                   <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                   <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                   &#123;</span><br><span class="line">                           q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                           visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                   &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">		 clusters.<span class="built_in">push_back</span>(cluster);</span><br></pre></td></tr></table></figure>



<h2 id="2-4代码"><a href="#2-4代码" class="headerlink" title="2.4代码"></a>2.4代码</h2><p>总的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> SegByLocalDensity（<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud,</span><br><span class="line">    					std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;&gt;&amp; clusters,</span><br><span class="line">						std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; gappointindices）</span><br><span class="line">&#123;</span><br><span class="line">    	<span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line">		<span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line">        <span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">        std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，并初始化为零</span></span><br><span class="line">                            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">                densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//基于广度优先搜索</span></span><br><span class="line">        std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (visited[i] || densiities[i]&lt; minPts)<span class="comment">//||或逻辑，只有当该点已经被访问，且点的密度大于minpts，才执行下面的处理</span></span><br><span class="line">           &#123;</span><br><span class="line">                     <span class="keyword">continue</span>; </span><br><span class="line">           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">            pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">            std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">            <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);<span class="comment">//对queue的对象在push的时候会调用拷贝对象的拷贝构造函数，插入queue中的是对象的一份拷贝</span></span><br><span class="line">            visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//如果q中没有元素则返回true</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">                    <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">                    <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">                    q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素-----------------用于退出循环</span></span><br><span class="line">                    cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">                    singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">                    std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">                    std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">                    treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">                    &#123;</span><br><span class="line">                            <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                            <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                    q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                                    visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clusters.<span class="built_in">push_back</span>(cluster);</span><br><span class="line">            gappointindices.<span class="built_in">emplace_back</span>(singlegapindices);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-5原始图像"><a href="#2-5原始图像" class="headerlink" title="2.5原始图像"></a><strong>2.5原始图像</strong></h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095757902.png" alt="image-20230803095757902"></p>
<h2 id="2-6处理后的图像"><a href="#2-6处理后的图像" class="headerlink" title="2.6处理后的图像"></a>2.6处理后的图像</h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095812781.png" alt="image-20230803095812781"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>特征提取</tag>
        <tag>点云处理</tag>
      </tags>
  </entry>
  <entry>
    <title>点云基础滤波算法</title>
    <url>/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、点云滤波介绍"><a href="#一、点云滤波介绍" class="headerlink" title="一、点云滤波介绍"></a>一、点云滤波介绍</h1><p>当激光或结构光设备采集的时候会因为被采集物体的表面材料，环境带来许多的噪声点（也叫做离群点），也会因为点云数据冗余，需要进行降采样，便于后续处理数据量的减少。</p>
<p>本文借助PCL开源库，实现基础的点云滤波算法。</p>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="2-1直通滤波"><a href="#2-1直通滤波" class="headerlink" title="2.1直通滤波"></a>2.1直通滤波</h2><p>直通滤波是在给定的通道上（x、y、z等）进行给定区域的滤波，在自动驾驶中一般用来进行地面的滤除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/passthrough.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::PointXYZ minPt, maxPt;</span><br><span class="line">pcl::<span class="built_in">getMinMax3D</span>(*cloud,minPt,maxPt);<span class="comment">//获得输入点云的最大最小边界</span></span><br><span class="line"><span class="comment">//关键配置代码</span></span><br><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt;PassZ;</span><br><span class="line">PassZ.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入点云</span></span><br><span class="line">PassZ.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);<span class="comment">//设置滤波字段名，x方向</span></span><br><span class="line">PassZ.<span class="built_in">setFilterLimits</span>(minPt.z,<span class="number">0</span>);<span class="comment">//设置在过滤方向上的点云</span></span><br><span class="line">PassZ.<span class="built_in">setNegative</span>(<span class="literal">true</span>);<span class="comment">//设置false为保留范围内的点,true为剔除范围内点</span></span><br><span class="line">PassZ.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h2 id="2-2统计滤波"><a href="#2-2统计滤波" class="headerlink" title="2.2统计滤波"></a>2.2统计滤波</h2><p>统计滤波是针对每一个点进行其领域的统计分析，得到该点到其领域点距离的分布特征，过滤掉不满足阈值的离群点，保留内点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt;sor;<span class="comment">//创建过滤器</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入要滤波的点云</span></span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);<span class="comment">//每个点考虑最近邻个数为50</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">1.0</span>);<span class="comment">//设置标准差阈值为1</span></span><br><span class="line"><span class="comment">//这意味着所有距离查询点的平均距离的标准偏差均大于1个标准偏差的所有点都将被标记为离群值并删除。</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud);</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><strong>处理图像</strong></p>
<p><img src="/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/image-20230805160619017.png" alt="image-20230805160619017"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>直通滤波</tag>
        <tag>统计滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
      </tags>
  </entry>
  <entry>
    <title>点云特征识别-圆孔特征识别</title>
    <url>/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>基于点的特征识别算法相对较少，刚好又需要对项目中的圆孔特征进行滤波，故采取<strong>点云密度+RANSAC</strong>对圆孔特征进行识别和滤波。</p>
<ol>
<li>首先，根据采集点云的<strong>密度差异</strong>提取出包含圆孔特征，边界特征的点云集合；</li>
<li>然后，利用<strong>RANSAC</strong>进行圆孔拟合；</li>
<li>最后，获取拟合的圆孔的半径，圆心利用包围盒进行去除。</li>
</ol>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><h2 id="2-1点云密度差异聚类"><a href="#2-1点云密度差异聚类" class="headerlink" title="2.1点云密度差异聚类"></a>2.1点云密度差异聚类</h2><p>计算点云数据的点密度差异，提取出密度差异的特征点云，并进行欧式聚类，具体实现见<a href="https://liangzhouzz.github.io/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/">点云计算点密度特征 | Sifanのblog (liangzhouzz.github.io)</a></p>
<p><strong>原始图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152034159.png" alt="image-20230806152034159" style="zoom:80%;">

<hr>
<p><strong>提取后的图像：</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152143989.png" alt="image-20230806152143989" style="zoom:80%;">



<h2 id="2-2点云聚类"><a href="#2-2点云聚类" class="headerlink" title="2.2点云聚类"></a>2.2点云聚类</h2><p>将经过密度提取后的点云进行聚类，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>; <span class="comment">//创建kdtree</span></span><br><span class="line">kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"></span><br><span class="line">std::vector&lt;pcl::PointIndices&gt;cluster_indices;<span class="comment">//点索引</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;<span class="comment">//创建欧式聚类</span></span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);<span class="comment">//聚类容忍度</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);<span class="comment">//最小聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());<span class="comment">//最大聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(kd_tree);<span class="comment">//搜索方式</span></span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure>

<h2 id="2-3RANSAC拟合圆"><a href="#2-3RANSAC拟合圆" class="headerlink" title="2.3RANSAC拟合圆"></a>2.3RANSAC拟合圆</h2><p><strong>RANSAC</strong>拟合圆，可选择拟合2D圆<code>pcl::SACMODEL_CIRCLE2D</code>或3D圆<code>pcl::SACMODEL_CIRCLE3D</code>，这里选择用3D，RANSAC需传入法向量，对点云进行法向量估计。RANSAC会存在拟合错误的情况，需要对拟合出圆的半径进行限制，限制在其范围内找到目标圆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类创建</span></span><br><span class="line">pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	估计法向量</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ransac</span></span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//设置法向量权重</span></span><br><span class="line">seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br></pre></td></tr></table></figure>



<h2 id="2-4包围盒分割"><a href="#2-4包围盒分割" class="headerlink" title="2.4包围盒分割"></a>2.4包围盒分割</h2><p>根据提取出圆的索引，可以得到其圆心坐标和半径，然后利用最小包围盒进行分割。</p>
<p>拟合出3D圆的参数如下：</p>
<ul>
<li><code>圆心坐标x</code>：value[0]</li>
<li><code>圆心坐标y</code>：value[1]</li>
<li><code>圆心坐标z</code>：value[2]</li>
<li><code>半径r</code>：value[3]</li>
<li><code>法向量nx</code>：value[4]</li>
<li><code>法向量ny</code>：value[5]</li>
<li><code>法向量nz</code>：value[6]</li>
</ul>
<p>设置包围盒的最小点坐标<code>min_pt</code>，和最大点坐标<code>max_pt</code>，然后创建包围盒对象，得到在包围盒内的点云索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">    <span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">    <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">//创建包围盒对象</span></span><br><span class="line">    pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">    crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">    crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">    crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">    crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">    <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">    crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">	<span class="comment">//创建分割对象</span></span><br><span class="line">    pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">    extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">    extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">    extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-5代码实现"><a href="#2-5代码实现" class="headerlink" title="2.5代码实现"></a>2.5代码实现</h2><p>代码汇总：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/sample_consensus/sac_model_circle3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/extract_clusters.h&gt;</span><span class="comment">//提取聚类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/crop_box.h&gt;</span><span class="comment">//包围盒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtractCircle</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//聚类</span></span><br><span class="line">        std::vector&lt;pcl::PointIndices&gt;cluster_indices;</span><br><span class="line">        pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;</span><br><span class="line">        ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);</span><br><span class="line">        ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);</span><br><span class="line">        ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());</span><br><span class="line">        ec.<span class="built_in">setSearchMethod</span>(kd_tree);</span><br><span class="line">        ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        ec.<span class="built_in">extract</span>(cluster_indices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RANSAC拟合</span></span><br><span class="line">        pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">        pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">        pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">        std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> counti=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; indices : cluster_indices)</span><br><span class="line">        &#123;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cluster</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_cir</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::<span class="built_in">copyPointCloud</span>(*cloud,indices.indices,*cluster);</span><br><span class="line">                pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">            	<span class="comment">//	估计法向量</span></span><br><span class="line">                pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">                ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">                ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">                ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line">				<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">                seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">                seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//法向量权重</span></span><br><span class="line">                seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">                seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">                seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">                seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">                seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">                seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br><span class="line">            	<span class="comment">//拟合圆的点数限制，因为很容易会拟合半圆，需根据实际的需求调整，防止拟合半圆</span></span><br><span class="line">                <span class="keyword">if</span> (inliers-&gt;indices.<span class="built_in">size</span>() &lt; <span class="number">80</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">//cerr&lt;&lt;&quot;none&quot;&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                coeff.<span class="built_in">push_back</span>(*coefficients);</span><br><span class="line">                counti++;</span><br><span class="line">            	<span class="comment">//提取</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(inliers);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud_cir);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            	<span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">                <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">            	<span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">                <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">            	<span class="comment">//创建包围盒对象</span></span><br><span class="line">                pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">                crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">                crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">                crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">                crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">                <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">                crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">				<span class="comment">//创建分割对象</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6结果"><a href="#2-6结果" class="headerlink" title="2.6结果"></a>2.6结果</h2><p><strong>RANSAC搜索的对象</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155049673.png" alt="image-20230806155049673" style="zoom:80%;">

<p><strong>包围盒分割图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155158365.png" alt="image-20230806155158365" style="zoom:80%;">]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>滤波</tag>
        <tag>特征识别</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找法</title>
    <url>/2023/09/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
    <content><![CDATA[<h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><ul>
<li>对应<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></li>
<li>升序数组-二分查找-主要思路是分清搜索区间，左闭右闭，还是左闭右开。</li>
<li><strong>区间的开闭</strong>用来判断<code>while</code>的判断条件以及<code>left</code>，<code>right</code>的更新条件。</li>
</ul>
<hr>
<h2 id="1-leetcode-704-二分查找"><a href="#1-leetcode-704-二分查找" class="headerlink" title="1.leetcode-704-二分查找"></a>1.leetcode-704-二分查找</h2><ul>
<li><p><strong>左闭右闭</strong><code>[left, right]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>， right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// while &lt;= 可以想象[1, 1]其中的1 是有效数字</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">//防止溢出</span></span><br><span class="line">    <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">        right = middle - <span class="number">1</span>;<span class="comment">//middle的值已经在if中判断过，所以不需要包含middle</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;<span class="comment">//同理</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> middle;<span class="comment">//相等则返回 middle</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在target</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>左闭右开</strong><code>[left, right)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>， right = nums.<span class="built_in">size</span>();<span class="comment">//右边为开区间</span></span><br><span class="line"><span class="comment">// while &lt; 可以想象[1, 1)其中的1不合法</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">//防止溢出</span></span><br><span class="line">    <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">        right = middle;<span class="comment">//middle的值本来就不包含在区间内</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;<span class="comment">//左闭</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> middle;<span class="comment">//相等则返回 middle</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在target</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-leetcode-2594-修车最少时间"><a href="#2-leetcode-2594-修车最少时间" class="headerlink" title="2.leetcode-2594-修车最少时间"></a>2.leetcode-2594-修车最少时间</h2><p>题目：<a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/?envType=daily-question&envId=2023-09-07">2594. 修车的最少时间 - 力扣（LeetCode）</a></p>
<p>求修车最少时间，先考虑二分法，若解的值域范围内有单调性，就可以使用二分：</p>
<ul>
<li>​	假设t分钟内可以将所有的汽车都修理完，那么大于t分钟也是可行的。</li>
<li>​	假设t分组内不能将所有的汽车都修理完，那么小于t分钟也是不能够的。</li>
</ul>
<p>因此可以枚举一个时间<code>t</code>，那么能力值为<code>r</code>的工人可以修好<code>sqrt(t/r)</code>量汽车，<strong>若所有工人修完的汽车数量大于<code>cars</code>，那么调整右边界为<code>t</code>，否则调整左边界为<code>t+1</code></strong>.</p>
<p>上界可取正无穷。类似与左闭右开</p>
<p><strong>左右区间更新：</strong>为什么右区间更新为<code>m</code>，左区间更新为<code>m + 1</code>？</p>
<ul>
<li>当 <code>check(m)</code> 返回 <code>true</code> 时，<strong>表示当前中间值 <code>m</code> 是一个可能的解</strong>，因此我们将右边界 <code>r</code> 更新为 <code>m</code>。这是因为我们要尝试找到更小的值，以确保我们找到的是最小的满足条件的值。</li>
<li>当 <code>check(m)</code> 返回 <code>false</code> 时，<strong>表示当前中间值 <code>m</code> 不是一个解</strong>，因此我们将左边界 <code>l</code> 更新为 <code>m + 1</code>。这是因为我们知道 <code>m</code> 不是解，所以我们需要将搜索范围向右移动到更大的值，以便寻找可能的解。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">repairCars</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">int</span> cars)</span> </span>&#123;</span><br><span class="line">    ll l = <span class="number">1</span>, r = <span class="number">1ll</span> * ranks[<span class="number">0</span>] * cars * cars;<span class="comment">//左边界为1，右边界为足够大的数-一个工人修完车的时间</span></span><br><span class="line">    <span class="comment">//lambda函数，用于检查给定的时间是否足够来修理至少cars辆汽车</span></span><br><span class="line">    <span class="comment">//[&amp;]表示按引用的方式捕获外部的变量，这里主要是为了要使用ranks</span></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll m) &#123;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : ranks) &#123;</span><br><span class="line">            cnt += <span class="built_in">sqrt</span>(m / x);<span class="comment">//累加当前时间下计算总共修了多少辆汽车</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> cnt &gt;= cars;<span class="comment">//比较能否修理完cars辆汽车，可以则返回true</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">//修车时间二分</span></span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//m：中间值</span></span><br><span class="line">        ll m = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//&gt;&gt;1：右移一位相当于除以二</span></span><br><span class="line">        <span class="comment">//check==1则更新右边界，边界可以修的完</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(m)) &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//更新左边界，边界修不完</span></span><br><span class="line">            l = m + <span class="number">1</span>;<span class="comment">//类似于左边右开 m的值已经判断过所欲不需要继续判断</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> l;<span class="comment">//返回修车最小时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>数组</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数组双指针</title>
    <url>/2023/09/06/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>Leetcode-27移除元素：<a href="https://leetcode.cn/problems/remove-element/">27. 移除元素 - 力扣（LeetCode）</a></p>
<p><strong>相似题目：</strong></p>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串 - 力扣（LeetCode）</a>、</p>
<p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode）</a></p>
<p><strong>关键知识点：</strong></p>
<ul>
<li>数组删除元素本质是<strong>覆盖</strong></li>
<li><code>vector</code>中<code>erase</code> 是<code>O(n)</code>的操作</li>
</ul>
<h2 id="1-leetcode-27"><a href="#1-leetcode-27" class="headerlink" title="1.leetcode-27"></a>1.leetcode-27</h2><p>双指针：一层for循环</p>
<ol>
<li><p><strong>快慢指针</strong>-可以不改变原来数组的位置</p>
<p>快指针：获取新数组的元素的指针，若当时指针的值指向为要覆盖的元素则跳过。</p>
<p>慢指针：需要覆盖的位置的指针。</p>
<p>相对于一个是前方的探子<code>fast</code>，一个在后方部署策略<code>slow</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> slow = <span class="number">0</span>；</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast++)&#123;</span><br><span class="line">	<span class="comment">//判断是否是要覆盖的值</span></span><br><span class="line">    <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">        nums[slow] = nums[fast];<span class="comment">//更新新数组</span></span><br><span class="line">        slow++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>左右指针</strong></p>
<p><code>left</code>指针用于判断当前元素是否是需要覆盖的元素，如果是的话则用<code>right</code>指针指向的元素进行覆盖，并对<code>right</code>进行<code>--</code>，如果不是则进行<code>++</code>迭代。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] == val)&#123;</span><br><span class="line">        nums[left] = num[right];</span><br><span class="line">        right--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left++;<span class="comment">//不是target元素则自加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-leetcode-26"><a href="#2-leetcode-26" class="headerlink" title="2.leetcode-26"></a>2.leetcode-26</h2><p>题目要求<strong>删除重复元素且不改变相对顺序</strong>。</p>
<p>快指针：寻找新数组的元素。</p>
<p>慢指针：新数组元素的集合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="comment">//当数组中快慢指针指向元素相等时，快指针++</span></span><br><span class="line">    <span class="keyword">if</span> (nums[slow] == nums[fast])&#123;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//快慢指针指向元素不相等时，则慢指针保留快指针的元素</span></span><br><span class="line">        nums[++slow] = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h2 id="3-leetcode-283-移动零"><a href="#3-leetcode-283-移动零" class="headerlink" title="3.leetcode-283 移动零"></a>3.leetcode-283 移动零</h2><p>将数组的所有<code>0</code>元素移动到数组末尾，保持非零元素的顺序。</p>
<p>快指针：待处理数组元素，遇到非0的元素则进行交换</p>
<p>慢指针：新的数组，慢指针左边均为非零的数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fast &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//进行快慢指针元素替换</span></span><br><span class="line">        <span class="type">int</span> temp = nums[slow];</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        nums[fast] = nums[slow];</span><br><span class="line">        slow++;</span><br><span class="line">    &#125;</span><br><span class="line">    fast++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-leetcode-844-比较含退格的字符串"><a href="#4-leetcode-844-比较含退格的字符串" class="headerlink" title="4.leetcode-844 比较含退格的字符串"></a>4.leetcode-844 比较含退格的字符串</h2><ul>
<li>题目：文本中含有退格符<code>#</code>比较两个字符串是否相等</li>
<li>思路：<strong>逆序遍历，退格符只会影响前一个字符</strong>。并且用<code>skip</code>表示带删除字符的数量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>, j = t.<span class="built_in">size</span>() - <span class="number">1</span>, skipS = <span class="number">0</span>, skipT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//s字符串的逆序遍历</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            skipS++;<span class="comment">//需要删除字符+1</span></span><br><span class="line">        	i--;<span class="comment">//遍历字符减一</span></span><br><span class="line">    	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	skipS--;<span class="comment">//若skip不为0 则说明当前字符需要删去</span></span><br><span class="line">        	i--;</span><br><span class="line">    	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//退出循环的唯一条件</span></span><br><span class="line">       	 	<span class="keyword">break</span>;<span class="comment">//如果既不为‘#’且skip=0，则跳出循环进行比较</span></span><br><span class="line">    	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//同理</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            skipT++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (skipT &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            skipT--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != t[j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不相等则返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//至少有一个出界</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i--;<span class="comment">//判断完进行迭代</span></span><br><span class="line">    j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>举个栗子：</strong></p>
<p><code>s-&gt;&quot;a##c&quot;</code>和<code>t-&gt;&quot;#a#c&quot;</code></p>
<ol>
<li>第一次循环，两个指针均指向<code>c</code>相等，则进行<code>i--（i = 2）</code>和<code>j--</code></li>
<li>第二次循环<code>s</code>字符串为<code>#</code>，<code>skipT++(1)</code>，<code>i--（i = 1）</code>，进入子循环，依然为<code>#</code>，<code>skipT++(2)</code>和<code>i--(0)</code> ，然后因为<code>skipT &gt;= 0</code>,所以进入 <code>skipT--(1)</code>和<code>i--(-1)</code>，然后退出子<code>while</code></li>
<li>t字符串同理，最后返回<code>true</code></li>
</ol>
<h2 id="5-leetcode-977有序数组的平方"><a href="#5-leetcode-977有序数组的平方" class="headerlink" title="5.leetcode-977有序数组的平方"></a>5.leetcode-977有序数组的平方</h2><p>题目：nums为非递减顺序的数组，要求返回每个数字平方组成的新数组，也为非递减顺序。</p>
<p>法一：用库函数<code>sort()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = nums,<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    nums[i] *= num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> nums;</span><br></pre></td></tr></table></figure>

<p>法二：利用题目中已按照升序排序这个条件 双指针 <strong>用时间换空间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>, pos = n - <span class="number">1</span>; i &lt;= j;) &#123;</span><br><span class="line">    <span class="comment">//前后两个元素比较，若前这元素大于后面的则把放在后面</span></span><br><span class="line">    <span class="keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;</span><br><span class="line">        ans[pos] = nums[i] * nums[i];</span><br><span class="line">        ++i;<span class="comment">//前面元素放在了后面 所以前面进行更新</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ans[pos] = nums[j] * nums[j];<span class="comment">//反之同理</span></span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">    --pos;<span class="comment">//ans元素进行迭代</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;<span class="comment">//用时间换空间</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>leetcode</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针-滑动窗口</title>
    <url>/2023/09/07/%E5%8F%8C%E6%8C%87%E9%92%88-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="双指针-滑动窗口"><a href="#双指针-滑动窗口" class="headerlink" title="双指针-滑动窗口"></a>双指针-滑动窗口</h1><p><strong>思路：</strong>一个<code>for</code>循环中的<code>j</code>表示<strong>起始位置</strong>还是<strong>终止位置</strong>？</p>
<ul>
<li>起始位置：和暴力解法无区别，都要把元素遍历一遍</li>
<li>所以表示的是终止位置：<strong>关键如何移动起始位置？</strong></li>
</ul>
<h2 id="1-leetcode-209-长度最小的子数组"><a href="#1-leetcode-209-长度最小的子数组" class="headerlink" title="1.leetcode-209-长度最小的子数组"></a>1.leetcode-209-长度最小的子数组</h2><p>题目：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p>
<p>返回满足条件最小子数组的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滑动窗口-for循环变量表示终止位置</span></span><br><span class="line"><span class="type">int</span> res = INT32_MAX, n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, start = <span class="number">0</span>, sublength = <span class="number">0</span>;<span class="comment">//初始化起始位置start，长度sublength</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    sum += nums[i];<span class="comment">//更新总和</span></span><br><span class="line">    <span class="comment">//总和大于目标时</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target)&#123;</span><br><span class="line">        sublength = i - start + <span class="number">1</span>;<span class="comment">//计算长度</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, sublength);<span class="comment">//取长度最小值</span></span><br><span class="line">        sum = sum - nums[start];<span class="comment">//进行滑动</span></span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> res == INT32_MAX ? <span class="number">0</span> : res;<span class="comment">//比较res是否有变换，没有则返回0</span></span><br></pre></td></tr></table></figure>





<h2 id="2-leetcode-904-水果成篮"><a href="#2-leetcode-904-水果成篮" class="headerlink" title="2.leetcode-904-水果成篮"></a>2.leetcode-904-水果成篮</h2><p>题目：<a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode）</a></p>
<p>思路：滑动窗口，并且用哈希表存储这个窗口的出现次数</p>
<p>每次将终止位置<code>i</code>移动一个位置，并将<code>fruits[i]</code>加入哈希表，**如果此时哈希表出现超过两个键对则不满足条件，需要不断移动<code>start</code>**，并将<code>fruits[start]</code>从哈希表中移除，直到满足要求。</p>
<p>如果<code>fruits[start]</code>出现次数为<code>0</code>，则要擦除键对。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>, n = fruits.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;<span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    ++cnt[fruits[i]];<span class="comment">//将出现次数记录在哈希表中</span></span><br><span class="line">    <span class="keyword">while</span>(cnt.<span class="built_in">size</span>() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//哈希表中记录的种类大于两个</span></span><br><span class="line">        <span class="keyword">auto</span> it = cnt.<span class="built_in">find</span>(fruits[start]);</span><br><span class="line">        --it-&gt;second;<span class="comment">//减去值</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">            cnt.<span class="built_in">erase</span>(it);<span class="comment">//如果出现次数为零 则擦取键值</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res, i - start + <span class="number">1</span>);<span class="comment">//计算步长</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>



<h2 id="3-leetcode-76-最小覆盖子串-hard"><a href="#3-leetcode-76-最小覆盖子串-hard" class="headerlink" title="3.leetcode-76-最小覆盖子串-hard"></a>3.leetcode-76-最小覆盖子串-hard</h2><p>题目：<a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<p>思路：用两个哈希表，一个<code>cntT</code>表示<code>t</code>中所有的字符以及他们的个数，另一个动态维护<code>s</code>中所有字符以及它们的个数，<strong>如果这个动态表<code>cntS</code>中包含所有<code>cntT</code>中所有的字符，且个数都不少于<code>t</code>哈希表的个数，</strong>则表示当前窗口时可行的，进行左区间的收缩。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tring res = s + <span class="string">&quot;tt&quot;</span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">0</span>, count = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cntS, cntT;<span class="comment">//哈希表创建</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">    ++cntT[c];<span class="comment">//统计t字串中的键对</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    ++cntS[s[i]];<span class="comment">//动态哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (cntT[s[i]] &gt;= cntS[s[i]])&#123;</span><br><span class="line">        <span class="comment">//如果当前T中哈希表大于等于动态哈希表，则说明s[i]字符的数量没有冗余，可以有效增加，若当前字符的出现个数大于t中的个数则出现冗余，不可以增加</span></span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; i &amp;&amp; cntS[s[start]] &gt; cntT[s[start]])&#123;</span><br><span class="line">        <span class="comment">//进行start迭代，当start对应的字符是冗余的即多余目标字符个数</span></span><br><span class="line">        --cntS[s[start]];<span class="comment">//进行数量减少</span></span><br><span class="line">        start++;<span class="comment">//自增</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">//当窗口以满足所有目标字符串大小则进行区间判断和截取</span></span><br><span class="line">        <span class="keyword">if</span> (i - start + <span class="number">1</span> &lt; res.<span class="built_in">size</span>())</span><br><span class="line">            res = s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>);<span class="comment">//小区间迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res == s + <span class="string">&quot;tt&quot;</span> ? <span class="string">&quot;&quot;</span> : res;<span class="comment">//比较</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2023/09/08/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p>思路： 循环不变量—–分清楚区间左闭右开 还是左闭右闭</p>
<h2 id="1-leetcode-59-螺旋矩阵"><a href="#1-leetcode-59-螺旋矩阵" class="headerlink" title="1.leetcode-59-螺旋矩阵"></a>1.leetcode-59-螺旋矩阵</h2><p>题目：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p>
<p>坚持循环不变量–左闭右开</p>
<p><img src="/2023/09/08/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/image-20230908103353646.png" alt="image-20230908103353646"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line"><span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line"><span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line"><span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">    i = startx;</span><br><span class="line">    j = starty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">    <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">        res[startx][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">        res[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">        res[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">        res[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">    startx++;</span><br><span class="line">    starty++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">    offset += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">    res[mid][mid] = count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>





<h2 id="2-leetcode-54-螺旋矩阵"><a href="#2-leetcode-54-螺旋矩阵" class="headerlink" title="2.leetcode-54-螺旋矩阵"></a>2.leetcode-54-螺旋矩阵</h2><p>题目：<a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode）</a>、<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode）</a></p>
<p>思路：<strong>不断定义上下左右边界</strong> </p>
<p>题解：<a href="https://leetcode.cn/problems/spiral-matrix/solutions/7155/cxiang-xi-ti-jie-by-youlookdeliciousc-3/">54. 螺旋矩阵 - 力扣（LeetCode）</a>    THX！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector &lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">if</span>(matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans; <span class="comment">//若数组为空，直接返回答案</span></span><br><span class="line"><span class="type">int</span> upper = <span class="number">0</span>; <span class="comment">//赋值上下左右边界</span></span><br><span class="line"><span class="type">int</span> down = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; ++i) ans.<span class="built_in">push_back</span>(matrix[upper][i]); <span class="comment">//向右移动直到最右</span></span><br><span class="line">    <span class="keyword">if</span>(++ upper &gt; down) <span class="keyword">break</span>; <span class="comment">//重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = upper; i &lt;= down; ++i) ans.<span class="built_in">push_back</span>(matrix[i][right]); <span class="comment">//向下</span></span><br><span class="line">    <span class="keyword">if</span>(-- right &lt; left) <span class="keyword">break</span>; <span class="comment">//重新设定右边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = right; i &gt;= left; --i) ans.<span class="built_in">push_back</span>(matrix[down][i]); <span class="comment">//向左</span></span><br><span class="line">    <span class="keyword">if</span>(-- down &lt; upper) <span class="keyword">break</span>; <span class="comment">//重新设定下边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = down; i &gt;= upper; --i) ans.<span class="built_in">push_back</span>(matrix[i][left]); <span class="comment">//向上</span></span><br><span class="line">    <span class="keyword">if</span>(++ left &gt; right) <span class="keyword">break</span>; <span class="comment">//重新设定左边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>螺旋矩阵</tag>
        <tag>循环</tag>
        <tag>边界确定</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS和DFSleetcode汇总</title>
    <url>/2023/09/09/BFS%E5%92%8CDFSleetcode%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="BFS-DFS"><a href="#BFS-DFS" class="headerlink" title="BFS&amp;DFS"></a>BFS&amp;DFS</h1><p><strong>思路：</strong>构建拓扑序列+深度优先或广度优先</p>
<h2 id="1-leetcode-207-课程表"><a href="#1-leetcode-207-课程表" class="headerlink" title="1.leetcode-207-课程表"></a>1.leetcode-207-课程表</h2><p>题目：<a href="https://leetcode.cn/problems/course-schedule/description/?envType=daily-question&envId=2023-09-09">207. 课程表 - 力扣（LeetCode）</a></p>
<p>题解：<a href="https://leetcode.cn/problems/course-schedule/solutions/359392/ke-cheng-biao-by-leetcode-solution/?envType=daily-question&envId=2023-09-09">207. 课程表 - 力扣（LeetCode）</a></p>
<p><strong>有向图思路：</strong></p>
<ol>
<li>可以用有向图来表示课程间的拓扑关系，用箭头来表示课程之间的修习关系</li>
<li>显然的可以从有向图中得出结论，若图中存在环，则图不存在拓扑排序，无法满足：对于图<code> G</code> 中的任意一条有向边 <code>(u,v)</code>，<code>u</code>在排列中都出现在 <code>v</code> 的前面。因此也不存在一个满足要求的排列。</li>
<li>如果图<code>G</code>是有向无环图，那么它的拓扑排列可能都不止一种。图<code>G</code>包含<code>n</code>个节点却没有任何的边，那么任意一种编号的排列都可以作为拓扑排列。</li>
</ol>
<p><strong>本题思路：</strong></p>
<ul>
<li>将每一门课看作一个节点，</li>
<li>如果想要学习<code>课程A</code>之前必须完成<code>课程B</code>，那么我们从<code>B</code>到<code>A</code>连接一条有向边。这样以来，在拓扑排序中，<code>B</code>一定出现在<code>A</code>的前面。</li>
</ul>
<h3 id="1-1DFS"><a href="#1-1DFS" class="headerlink" title="1.1DFS"></a>1.1DFS</h3><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p>
<ul>
<li><code>「未搜索」</code>：我们还没有搜索到这个节点；</li>
<li><code>「搜索中」</code>：我们搜索过这个节点，但还没有回溯到该节点，<strong>即该节点还没有入栈，还有相邻的节点没有搜索完成</strong>；</li>
<li><code>「已完成」</code>：我们搜索过并且回溯过这个节点，<strong>即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</strong></li>
</ul>
<p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个<code>「未搜索」</code>的节点开始进行深度优先搜索。</p>
<ul>
<li><p>我们将当前搜索的节点 <code>u</code> 标记为<code>「搜索中」</code>，遍历该节点的每一个相邻节点 <code>v</code>：</p>
<p>如果 <code>v</code> 为<code>「未搜索」</code>，那么我们开始搜索 <code>v</code>，待搜索完成回溯到 <code>u</code>；</p>
<p>如果 <code>v</code>为<code>「搜索中」</code>，<strong>那么我们就找到了图中的一个环</strong>，因此是不存在拓扑排序的；</p>
<p>如果 <code>v</code> 为<code>「已完成」</code>，那么说明 <code>v</code>已经在栈中了，而 <code>u</code> 还不在栈中，因此 <code>u </code>无论何时入栈都不会影响到 <code>(u,v)</code> 之前的拓扑关系，以及不用进行任何操作。</p>
</li>
<li><p>当 <code>u</code>的所有相邻节点都为<code>「已完成」</code>时，我们将<code> u</code> 放入栈中，并将其标记为<code>「已完成」</code>。</p>
</li>
</ul>
<p>在整个深度优先搜索的过程结束后，<strong>如果我们没有找到图中的环，那么栈中存储这所有的 <code>n</code> 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</strong></p>
<p><img src="/2023/09/09/BFS%E5%92%8CDFSleetcode%E6%B1%87%E6%80%BB/image-20230909153850172.png" alt="image-20230909153850172"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;<span class="comment">//用于表示课程之间的依赖关系，edge[u]表示课程u是哪些课程的先修课程列表</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;<span class="comment">//用于标记课程的访问状态，0表示未访问，1表示正在访问，2表示已经访问</span></span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;<span class="comment">//返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//深度优先搜索函数，用于检查是否存在环，u表示正在访问的课程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;<span class="comment">//设为1，表示正在访问该课程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;<span class="comment">//遍历u的先修列表edge[u]的课程v</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;<span class="comment">//如果v没有被访问过则递归调用搜索先修课程v</span></span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">//发现了环，直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;<span class="comment">//如果v已经被访问过，则表示存在环</span></span><br><span class="line">                valid = <span class="literal">false</span>;<span class="comment">//设置为false</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;<span class="comment">//标记为2 表示已经访问完毕</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);<span class="comment">//构建有向图</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);<span class="comment">//遍历所有课程，如果存在课程尚未被访问则调用dfs</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1-2BFS"><a href="#1-2BFS" class="headerlink" title="1.2BFS"></a>1.2BFS</h3><p>DFS是<strong>逆向思维</strong>，所以可以<strong>使用BFS来正向的考虑</strong>拓扑排序中最前面的节点，即没有入度的节点。</p>
<p><strong>当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了<code>「没有任何入边的节点」</code>，那么就代表着这门课可以开始学习了。</strong>按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p>
<p><strong>算法设计：</strong></p>
<p>我们使用一个队列来进行广度优先搜索。初始时，所有<code>入度为 0</code> 的节点都被放入队列中，<strong>它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</strong></p>
<p>在广度优先搜索的每一步中，我们取出队首的<code>节点 u</code>：</p>
<ul>
<li><p>我们将<code>u</code>放入答案中；</p>
</li>
<li><p>我们移除 <code>u</code> 的所有出边，也就是将 <code>u</code> 的所有相邻节点的<code>入度减少 1</code>。如果某个相邻节点 <code>v</code>的入度变为<code> 0</code>，那么我们就将 <code>v</code>放入队列中。</p>
</li>
</ul>
<p>在广度优先搜索的过程结束后。如果答案中包含了这 <code>n</code> 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。\</p>
<p><img src="/2023/09/09/BFS%E5%92%8CDFSleetcode%E6%B1%87%E6%80%BB/image-20230909161315935.png" alt="image-20230909161315935"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;<span class="comment">//边的依赖关系，edge[u]表示u作为了多少其他课程的先修课程</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indeg;<span class="comment">//表示每个课程的入度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);<span class="comment">//有向图的构建</span></span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];<span class="comment">//入度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//创建一个拓扑排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);<span class="comment">//如果入度为0，则将该课程加入队列，表示这个课程可以直接学习</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> visited = <span class="number">0</span>;<span class="comment">//用于表示已访问过的课程数量</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();<span class="comment">//每次从队列中取出一个课程</span></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];<span class="comment">//遍历u作为先修课程，减少v的入度</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);<span class="comment">//如果v的入度变为了0，则加入队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;<span class="comment">//判断是否所有课程都已经学完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-leetcode-1462-课程表Ⅳ"><a href="#2-leetcode-1462-课程表Ⅳ" class="headerlink" title="2.leetcode-1462-课程表Ⅳ"></a>2.leetcode-1462-课程表Ⅳ</h2><p><strong>题目：</strong><a href="https://leetcode.cn/problems/course-schedule-iv/description/?envType=daily-question&envId=2023-09-12">1462. 课程表 IV - 力扣（LeetCode）</a></p>
<p><strong>题解：</strong><a href="https://leetcode.cn/problems/course-schedule-iv/?envType=daily-question&envId=2023-09-12">1462. 课程表 IV - 力扣（LeetCode）</a></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(numCourses);<span class="comment">//用于表示课程之间的图，g[i]存储了i的后继课程</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indgree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;<span class="comment">//入度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">isPre</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(numCourses, <span class="literal">false</span>));<span class="comment">//表示课程x是否是课程y的先决条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : prerequisites) &#123;</span><br><span class="line">            ++indgree[p[<span class="number">1</span>]];<span class="comment">//图的建立</span></span><br><span class="line">            g[p[<span class="number">0</span>]].<span class="built_in">push_back</span>(p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indgree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);<span class="comment">//将度为0的课程加入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ne : g[cur]) &#123;<span class="comment">//遍历g[cur]中的每个直接后继课程</span></span><br><span class="line">                isPre[cur][ne] = <span class="literal">true</span>;<span class="comment">//置为true</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">                    isPre[i][ne] = isPre[i][ne] | isPre[i][cur];</span><br><span class="line">                &#125;</span><br><span class="line">                --indgree[ne];<span class="comment">//减少入度</span></span><br><span class="line">                <span class="keyword">if</span> (indgree[ne] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(ne);<span class="comment">//如果度为0 加入队列进行下一轮处理</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成拓扑排序后，ispre含有了所有课程之间的先决条件关系</span></span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; res;<span class="comment">//用于存储所有查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; query : queries) &#123;</span><br><span class="line">            <span class="comment">//遍历每个查询，存储结果</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(isPre[query[<span class="number">0</span>]][query[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>BFS &amp; DFS</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2023/09/11/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="1-链表的定义"><a href="#1-链表的定义" class="headerlink" title="1.链表的定义"></a>1.链表的定义</h1><p>链表在内存中的排列不是连续的</p>
<p>在自己面试时，ACM模式下，需要自己构造链表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//节点上存储的元素</span></span><br><span class="line">    ListNode *next;<span class="comment">//指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span> (<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/11/%E9%93%BE%E8%A1%A8/image-20230911093747449.png" alt="image-20230911093747449"></p>
<h1 id="2-leetcode-203-移除链表的元素"><a href="#2-leetcode-203-移除链表的元素" class="headerlink" title="2.leetcode-203-移除链表的元素"></a>2.leetcode-203-移除链表的元素</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong>虚拟头节点—–解决删除头节点问题，new一个新节点</p>
<p><img src="/2023/09/11/%E9%93%BE%E8%A1%A8/image-20230911100121215.png" alt="image-20230911100121215"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">//定义虚拟头指针</span></span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//指向下下个节点</span></span><br><span class="line">                <span class="keyword">delete</span> temp;<span class="comment">//删除内存</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;<span class="comment">//获取新的头指针</span></span><br><span class="line">        <span class="keyword">delete</span> dummyHead;<span class="comment">//删除头指针</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-leetcode-707-设计链表"><a href="#3-leetcode-707-设计链表" class="headerlink" title="3.leetcode-707-设计链表"></a>3.leetcode-707-设计链表</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong>五个任务-<strong>统一使用虚拟头节点。</strong></p>
<ol>
<li><p>获取第<code>n</code>个节点</p>
<p><code>n</code>是从<code>0</code>开始的，<code>n&lt;0</code>，<code>n&gt;size - 1</code>都是不合法的。</p>
<p><code>while (n)&#123;cur = cur -&gt;next; n--;&#125;</code></p>
</li>
<li><p>头部插入节点</p>
<p>先定义一个新的链表节点。正确的顺序：先指向<code>dummyhead-&gt;next</code>，然后再让<code>dummyhead-&gt;</code>指向<code>newnode</code>。</p>
<p><img src="/2023/09/11/%E9%93%BE%E8%A1%A8/image-20230911103242170.png" alt="image-20230911103242170"></p>
</li>
<li><p>尾部插入节点</p>
<p>找尾部<code>while(cur-&gt; != NULL)</code>循环条件。</p>
<p><code>cur-&gt;next = newnode;</code></p>
</li>
<li><p>第<code>n</code>个节点前插入节点</p>
<p><code>cur</code>一定指向第<code>n</code>个节点前一个节点。<strong>一定保证第<code>n</code>个节点是<code>cur-&gt;next</code>！！</strong>才能保证和之前插入一样。</p>
<p><code>while(n--)</code></p>
</li>
<li><p>删除第<code>n</code>个节点</p>
<p>合法性判断。一定保证第<code>n</code>个节点是<code>cur-&gt;next``while(n--)</code></p>
</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义链表结果</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);<span class="comment">//定义虚拟头节点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边界判断</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; _size - <span class="number">1</span> || index &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        LinkedNode* cur = _dummyNode;<span class="comment">//从原来的头节点开始遍历 </span></span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;<span class="comment">//进行迭代 可用index =0 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;next-&gt;val;<span class="comment">//返回值 第index个永远是cur-&gt;next指向的</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyNode-&gt;next;</span><br><span class="line">        _dummyNode-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = _dummyNode;<span class="comment">//代入空链表判断</span></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在第index个节点之前插入一个新节点，例如index为0，那么新节点作为链表的新头节点</span></span><br><span class="line">    <span class="comment">//如果index等于链表的长度，则说明是新节点是新尾节点</span></span><br><span class="line">    <span class="comment">//如果index大于链表的长度，则返回kong</span></span><br><span class="line">    <span class="comment">//如果index小于0，则在头部插入节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) <span class="keyword">return</span>;<span class="comment">//大于链表</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;<span class="comment">//小于0</span></span><br><span class="line"></span><br><span class="line">        LinkedNode* cur = _dummyNode;<span class="comment">//注意！！！！ 可以用index=0判断</span></span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;<span class="comment">//轮询要插入的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;<span class="comment">//先让新节点指向next</span></span><br><span class="line">        cur-&gt;next = newNode;<span class="comment">//在进行cur的替换</span></span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除第n个节点，如果index大于链表则直接return，index从0开始</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        LinkedNode* cur = _dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* temp = cur-&gt;next;<span class="comment">//要删除的节点</span></span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//delete命令指示释放了temp指针原本所指的那部分内存，</span></span><br><span class="line">        <span class="comment">//被delete后的指针temp的值（地址）并非就是NULL，而是随机值。也就是被delete后，</span></span><br><span class="line">        <span class="comment">//如果不再加上一句temp=nullptr,temp会成为乱指的野指针</span></span><br><span class="line">        <span class="comment">//如果之后的程序不小心使用了temp，会指向难以预想的内存空间</span></span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = _dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h1 id="4-leetcode-206-反转链表"><a href="#4-leetcode-206-反转链表" class="headerlink" title="4.leetcode-206-反转链表"></a>4.leetcode-206-反转链表</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ol>
<li><p><strong>双指针</strong></p>
<p>双指针：<code>pre</code>和<code>cur</code>。</p>
<p>初始化：<code>cur = head</code>，<code>pre = NULL</code></p>
<p>遍历：<code>while(cur != NULL)</code> 临时指针<code>temp</code>先保存<code>cur-&gt;next</code>，当前的<code>cur-&gt;next = pre</code>;<code>cur = pre</code>；<code> cur = temp</code>。先移动<code>pre</code>，后移动<code>cur</code></p>
<p>返回：<code>return pre</code></p>
<p><img src="/2023/09/11/%E9%93%BE%E8%A1%A8/image-20230912105333603.png" alt="image-20230912105333603"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;<span class="comment">//初始化</span></span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;<span class="comment">//循环条件 cur不为null</span></span><br><span class="line">            ListNode* temp = cur-&gt;next;<span class="comment">//临时指针用于暂存cur的下一个节点</span></span><br><span class="line">            cur-&gt;next = pre;<span class="comment">//初始节点反转后作为尾节点 将当前cur的next指向null</span></span><br><span class="line">            pre = cur;<span class="comment">//更新值</span></span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
<li><p>**递归 **—-按照双指针解法延申</p>
<p>递归函数：<code>reverse(cur, pre)</code></p>
<p>退出条件：<code>if(cur == NULL)</code> <code>return pre;</code></p>
<p>递归写法：<code>temp = cur-&gt;next;</code></p>
<p>​					<code>cur-&gt;next = pre;</code></p>
<p>​					<code>reverse(temp, cur);</code></p>
<p>主函数中初始化：<code>reverse(head, NULL)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是省略了这两步</span></span><br><span class="line">        <span class="comment">// pre = cur;</span></span><br><span class="line">        <span class="comment">// cur = temp;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 和双指针法初始化是一样的逻辑</span></span><br><span class="line">        <span class="comment">// ListNode* cur = head;</span></span><br><span class="line">        <span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>, head);<span class="comment">//!!!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="5-leetcode-24-两两交换链表中的节点"><a href="#5-leetcode-24-两两交换链表中的节点" class="headerlink" title="5.leetcode-24-两两交换链表中的节点"></a>5.leetcode-24-两两交换链表中的节点</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong>操作的指针一定要在交换节点的<strong>前一个节点</strong>，</p>
<p>终止条件：<code>while(cur -&gt; next != null &amp;&amp; cur-&gt;next-&gt;next != null)</code>，注意判断顺序，先判断一个next 可能存在next为空指针，造成空指针异常。</p>
<p>交换步骤：<code>temp = cur -&gt; next</code>; <code>temp1 = cur -&gt;next -&gt;next -&gt; next</code></p>
<p><img src="/2023/09/11/%E9%93%BE%E8%A1%A8/image-20230913104059134.png" alt="image-20230913104059134"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">//虚拟头节点</span></span><br><span class="line">        dummy_head-&gt;next = head;<span class="comment">//指向头节点</span></span><br><span class="line">        ListNode* cur = dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;<span class="comment">//终止条件！！！</span></span><br><span class="line">            <span class="comment">//直接模拟交换过程就好</span></span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            ListNode* temp1 = cur-&gt;next-&gt;next-&gt;next;<span class="comment">//!!!</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;<span class="comment">//第一次，可以看示意图</span></span><br><span class="line">            cur-&gt;next-&gt;next = temp;<span class="comment">//第二次</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = temp1;<span class="comment">//第三次</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;<span class="comment">//cur迭代，指向交换元素的上一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h1 id="6-leetcode-19-删除链表的倒数第N个节点"><a href="#6-leetcode-19-删除链表的倒数第N个节点" class="headerlink" title="6.leetcode-19-删除链表的倒数第N个节点"></a>6.leetcode-19-删除链表的倒数第N个节点</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>删除节点—&gt;操作指针一定要指向前一个节点</li>
<li>虚拟头节点</li>
<li>快慢指针，<code>fast</code>先移动<code>n+1步</code>，然后<code>fast</code>和<code>slow</code>一起动，直到<code>fast</code>指向<code>NULL</code>.</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">//虚拟头节点</span></span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* fast = dummyHead; </span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        n++;<span class="comment">//用于让fast多走一步</span></span><br><span class="line">        <span class="keyword">while</span> (n-- &amp;&amp; fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;<span class="comment">//快指针先走 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;<span class="comment">//一起走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行交换</span></span><br><span class="line">        ListNode* temp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;<span class="comment">//防止temp成为野指针</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)—-&gt;n是要删除第n个节点</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="7-面试题02-07-链表相交"><a href="#7-面试题02-07-链表相交" class="headerlink" title="7.面试题02.07-链表相交"></a>7.面试题02.07-链表相交</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>求两个链表交点节点的指针</li>
<li>交点不是数值相等<strong>而是指针相等！！!</strong></li>
<li>先求出两个链表的长度，然算出插值，然后让<code>curA</code>移动到和<code>curB</code>末尾对齐的位置，此时进行判断，不相同则同时向后移动。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="comment">//求链表长度</span></span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新赋值</span></span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">//让curA为最长链表的头 lenA为长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span>(curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//长度差</span></span><br><span class="line">        <span class="type">int</span> gap  = lenA - lenB;</span><br><span class="line">        <span class="comment">//移动a与b尾部对齐</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;<span class="comment">//指针相等 ---不是数值相等喔</span></span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n+m)遍历两个链表的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
<h1 id="8-leetcode-142-环形链表Ⅱ"><a href="#8-leetcode-142-环形链表Ⅱ" class="headerlink" title="8.leetcode-142-环形链表Ⅱ"></a>8.leetcode-142-环形链表Ⅱ</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a></p>
<p><strong>解法一：</strong></p>
<ul>
<li>遍历链表，用哈希表存储节点出现的次数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        unordered_map&lt;ListNode*, <span class="type">int</span>&gt;cnt;<span class="comment">//构建哈希表</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cnt[cur]++;<span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">if</span> (cnt[cur] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;<span class="comment">//重复出现则返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)遍历节点</li>
<li>空间复杂度：O(n)将链表每个节点存在哈希表中</li>
</ul>
<p><strong>法二—双指针：</strong><a href="https://www.bilibili.com/video/BV1if4y1d7ob/?vd_source=fa4d4e7f9b99f8e27a2b9dca08ea044a">把环形链表讲清楚！ 如何判断环形链表？如何找到环形链表的入口？ LeetCode：142.环形链表II_哔哩哔哩_bilibili</a></p>
<p>用快慢指针降低空间复杂度！！！</p>
<p>链表无环则不可能相遇，有环必定相遇！</p>
<p>快指针走两个节点，慢指针走一个节点。相对于慢指针，快指针每次移动一个节点。</p>
<p>要求<code>x</code>入口处节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至他们相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题</title>
    <url>/2023/09/13/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里记录一下leetcode中每日一题。</p>
<h1 id="1-leetcode-2596-检查骑士巡视方案-20230913"><a href="#1-leetcode-2596-检查骑士巡视方案-20230913" class="headerlink" title="1.leetcode-2596-检查骑士巡视方案-20230913"></a>1.leetcode-2596-检查骑士巡视方案-20230913</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/check-knight-tour-configuration/description/?envType=daily-question&envId=2023-09-12">2596. 检查骑士巡视方案 - 力扣（LeetCode）</a></p>
<p><strong>题解：</strong><a href="https://leetcode.cn/problems/check-knight-tour-configuration/solutions/2431329/jian-cha-qi-shi-xun-shi-fang-an-by-leetc-iw17/?envType=daily-question&envId=2023-09-12">2596. 检查骑士巡视方案 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong>要求骑士<code>日</code>字移动。—-&gt;检测每一次跳跃的行动路径是否为<code>日</code>字。</p>
<p>​			<code>grid[i][j]</code>的值表示第几个访问的顺序</p>
<p><img src="/2023/09/13/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20230913101938885.png" alt="image-20230913101938885"></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidGrid</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//看骑手是否从左上角出发</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//array&lt;int,2&gt;表示元素为int，大小为2的数组，即数组中有两个元素</span></span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">indices</span>(n * n);<span class="comment">//长度为n*n的数组 存放grid的顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                indices[grid[i][j]] = &#123;i, j&#125;;<span class="comment">//遍历存放grid顺序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; indices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//检查每一次跳跃起点和终点的坐标插值</span></span><br><span class="line">            <span class="type">int</span> dx = <span class="built_in">abs</span>(indices[i][<span class="number">0</span>] - indices[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> dy = <span class="built_in">abs</span>(indices[i][<span class="number">1</span>] - indices[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (dx * dy != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//判断积是否为二，不为2则不为日字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度：</strong>时间复杂度为O(n^2)——–&gt;嵌套循环</p>
<p>​				空间复杂度为O(n^2)——–&gt;二维数组 indices；</p>
<h1 id="2-leetcode-1222-可以攻击国王的皇后-20230914"><a href="#2-leetcode-1222-可以攻击国王的皇后-20230914" class="headerlink" title="2.leetcode-1222-可以攻击国王的皇后-20230914"></a>2.leetcode-1222-可以攻击国王的皇后-20230914</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/queens-that-can-attack-the-king/description/?envType=daily-question&envId=2023-09-14">1222. 可以攻击国王的皇后 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>枚举每个<code>皇后</code>是否在<code>国王</code>的<code>八个方向</code>上，若在，选择<code>最近</code>那个说明可以攻击到国王。</li>
<li>通过相减皇后与国王的坐标值<code>(x, y) = (qx - kx, qy - ky)</code>，那么当<code>x = 0</code>或<code>y = 0</code>或<code>|x| = |y|</code>，则说明皇后可以攻击到国王。</li>
<li>设置符号函数<code>sgn(x)</code>，<code>x &gt; 0</code>时为<code>1</code>，<code>x &lt; 0</code>时为<code>-1</code>，<code>x = 0</code>时为<code>0</code>，所以皇后的方向可以表示为<code>(sgn(x), sgn(y))</code>。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">queensAttacktheKing</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queens, vector&lt;<span class="type">int</span>&gt;&amp; king) &#123;</span><br><span class="line">        <span class="keyword">auto</span> sgn = [](<span class="type">int</span> x) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : (x == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">-1</span>);</span><br><span class="line">        &#125;;<span class="comment">//lambda函数，用作判断方向</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = queens.<span class="built_in">size</span>(), kx = king[<span class="number">0</span>], ky = king[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//哈希表 用于存储可以攻击国王的皇后位置，和他们之间的距离</span></span><br><span class="line">        <span class="comment">//键是int 表示方向，值是pair存储位置和距离如果是&lt;int, int&gt;----&gt;[int, int]</span></span><br><span class="line">        <span class="comment">//如果是&lt;vector&lt;int&gt;,int&gt;----&gt;[vector&lt;int&gt;,int]前面存储坐标。</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, pair&lt;vector&lt;<span class="type">int</span>&gt;,<span class="type">int</span>&gt;&gt; candidates;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; queen : queens) &#123;<span class="comment">//循环遍历</span></span><br><span class="line">            <span class="type">int</span> qx = queen[<span class="number">0</span>], qy = queen[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> x = qx - kx, y = qy - ky;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span> || <span class="built_in">abs</span>(x) == <span class="built_in">abs</span>(y)) &#123;</span><br><span class="line">                <span class="type">int</span> dx = <span class="built_in">sgn</span>(x), dy = <span class="built_in">sgn</span>(y);<span class="comment">//计算符号</span></span><br><span class="line">                <span class="type">int</span> key = dx * <span class="number">10</span> +dy;<span class="comment">//生成唯一的标识方向</span></span><br><span class="line">                <span class="keyword">if</span> (!candidates.<span class="built_in">count</span>(key) || candidates[key].second &gt; <span class="built_in">abs</span>(x) + <span class="built_in">abs</span>(y)) &#123;			<span class="comment">//如果当前方向没有被记录，或被记录 但是距离比之前更短则更新哈希表</span></span><br><span class="line">                    candidates[key] = &#123;queen, <span class="built_in">abs</span>(x) + <span class="built_in">abs</span>(y)&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, value]: candidates) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(value.first);<span class="comment">//遍历哈希表，将结果放入返回数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)—–&gt;遍历queens数组n</li>
<li>空间复杂度：O(1)—–&gt;哈希表</li>
</ul>
<h1 id="3-leetcode-198-打家劫舍-20230916"><a href="#3-leetcode-198-打家劫舍-20230916" class="headerlink" title="3.leetcode-198-打家劫舍-20230916"></a>3.leetcode-198-打家劫舍-20230916</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/house-robber/?envType=daily-question&envId=2023-09-16">198. 打家劫舍 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong><a href="https://leetcode.cn/problems/house-robber/solutions/138131/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/?envType=daily-question&envId=2023-09-16">198. 打家劫舍 - 力扣（LeetCode）</a></p>
<ul>
<li>动态规划DP：定义子问题—-&gt;写出子问题的递推关系—-&gt;确定DP数组的计算顺序—-&gt;空间优化</li>
<li>原问题：从全部房间中能偷到的最大金额<code>f(n)</code>。子问题：从<code>k</code>个房间中能偷到的最大金额<code>f(k)</code>。</li>
<li>。。。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//边界</span></span><br><span class="line">      &#125;</span><br><span class="line">		</span><br><span class="line">      <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">//方便对齐 dp[1]表示第一间房屋nums[0] </span></span><br><span class="line">      vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="number">0</span>);<span class="comment">//n+1大小 0初始化 </span></span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//没有房屋可以盗窃</span></span><br><span class="line">      dp[<span class="number">1</span>] = nums[<span class="number">0</span>];<span class="comment">//只有一个房屋可以盗窃</span></span><br><span class="line">      <span class="comment">//从第二个数组开始遍历，数组下标为1 - n-1</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//dp[i-1]表示不盗窃当前的房屋，nums[i-1]表示盗窃当前房屋与dp数组下标差了1 </span></span><br><span class="line">        <span class="comment">//dp[n-2]表示在前两个房屋处的最大财产值，就是选择dp[n-1]，还是dp[n-2]加上当前房屋的价值</span></span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], nums[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n];<span class="comment">//返回最大财产值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)遍历数组</li>
<li>空间复杂度：O(n) 维护dp数组</li>
</ul>
<p><strong>对空间复杂度进行优化：</strong></p>
<ul>
<li><p>不需要保存dp的全部子结果</p>
</li>
<li><p>只需要用两个变量保存子问题的结果</p>
</li>
<li><p><img src="/2023/09/13/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/image-20230917095711405.png" alt="dp空间优化"></p>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次循环，计算“偷到当前房子为止的最大金额”</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">        <span class="comment">// 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">        <span class="comment">// dp[k] = max&#123; dp[k-1], dp[k-2] + i &#125;</span></span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">max</span>(curr, prev + i);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = temp;</span><br><span class="line">        <span class="comment">// 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)遍历数组</li>
<li>空间复杂度：O(1)创建整型变量</li>
</ul>
<h1 id="4-leetcode-213-打家劫舍Ⅱ-20230917"><a href="#4-leetcode-213-打家劫舍Ⅱ-20230917" class="headerlink" title="4.leetcode-213-打家劫舍Ⅱ-20230917"></a>4.leetcode-213-打家劫舍Ⅱ-20230917</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/house-robber-ii/description/?envType=daily-question&envId=2023-09-17">213. 打家劫舍 II - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>房屋首尾相连</li>
<li>如果偷盗了第一间房屋，则不能偷盗最后一间，因此偷盗范围是第一间到倒数第二间<code>[0, n-2]</code></li>
<li>如果偷盗了最后一间房屋，则不能偷盗第一间，因此偷盗范围是第二间到最后一间<code>[1, n-1]</code></li>
<li>分别用前一天的DP计算最大金额，作为返回值。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> first  = nums[start], second = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);<span class="comment">//first第一间房屋价值，second表示当前房屋的最大价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = second;<span class="comment">//保存旧的second值 下一次迭代需要用到</span></span><br><span class="line">            <span class="comment">//first+nums[i]前两个房屋被盗+当前房屋被盗，</span></span><br><span class="line">            <span class="comment">//second 前一个房屋被盗</span></span><br><span class="line">            second = <span class="built_in">max</span>(first + nums[i], second);</span><br><span class="line">            first = temp;<span class="comment">//迭代 first 向后移动一位 画图既可以理解</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];<span class="comment">//一个房屋则返回第一间</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);<span class="comment">//两间房屋，返回最大价值那间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不满足上面条件则比较[0,n-2]和[1,n-1]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robRange</span>(nums, <span class="number">0</span>, n - <span class="number">2</span>), <span class="built_in">robRange</span>(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n) 遍历数据</li>
<li>空间复杂度：O(1)创建first 和second整型变量</li>
</ul>
<h1 id="5-leetcode-337-打家劫舍Ⅲ-20230918"><a href="#5-leetcode-337-打家劫舍Ⅲ-20230918" class="headerlink" title="5.leetcode-337-打家劫舍Ⅲ-20230918"></a>5.leetcode-337-打家劫舍Ⅲ-20230918</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/house-robber-iii/description/?envType=daily-question&envId=2023-09-18">337. 打家劫舍 III - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<p>用<code>f(o)</code>表示选择<code>o</code>节点情况下最大价值，<code>g(o)</code>表示不选择<code>o</code>节点情况下<code>o</code>节点最大价值，<code>l</code>和<code>r</code>代表<code>o</code>的左右子节点。</p>
<ul>
<li>当<code>o</code>被选中时，<code>o</code>的左右孩子都不能被选中，故<code>o</code>被选中情况下子树上被选中点的最大权值和相加，即<code>f(o)=g(l)+g(r)</code>。</li>
<li>当<code>o</code>不被选中时，<code>o</code>的左右孩子可以被选中，也可以不被选中，对于某个具体的孩子<code>x</code>，它对<code>o</code>的贡献是<code>x</code>被选中或不被选中情况下的权值和的最大值。<code>g(x)=max&#123;f(l), g(l)&#125;+max&#123;f(r),g(r)&#125;</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体 用于表示在给定节点为根的子树中可以获取的最大值两种情况</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubtreeStatus</span> &#123;</span><br><span class="line">    <span class="type">int</span> selected;<span class="comment">//选择当前节点</span></span><br><span class="line">    <span class="type">int</span> notselected;<span class="comment">//不选择当前节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SubtreeStatus <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="built_in">dfs</span>(node-&gt;left);<span class="comment">//递归计算左右子树</span></span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        <span class="type">int</span> selected = node-&gt;val + l.notselected + r.notselected;<span class="comment">//当前节点被选择的值计算 当前节点的值+左右子节点不被选择的值</span></span><br><span class="line">        <span class="type">int</span> notselected = <span class="built_in">max</span>(l.selected, l.notselected) + <span class="built_in">max</span>(r.selected, r.notselected);<span class="comment">//当前节点不被选择，则计算左右子节点被选择与不被选择最大值之和</span></span><br><span class="line">        <span class="keyword">return</span> &#123;selected, notselected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rootStatus = <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rootStatus.selected, rootStatus.notselected);<span class="comment">//比较最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度：</strong>O(n)对二叉树做一次后序遍历。</li>
<li><strong>空间复杂度：</strong>O(n)递归使用栈空间。、</li>
</ul>
<h1 id="6-leetcode-2560-打家劫舍Ⅳ-20230919"><a href="#6-leetcode-2560-打家劫舍Ⅳ-20230919" class="headerlink" title="6.leetcode-2560-打家劫舍Ⅳ-20230919"></a>6.leetcode-2560-打家劫舍Ⅳ-20230919</h1><p><strong>题目：</strong>[2560. 打家劫舍 IV - 力扣（LeetCode）](<a href="https://leetcode.cn/problems/house-robber-iv/?envType=daily-question&envId=Invalid">https://leetcode.cn/problems/house-robber-iv/?envType=daily-question&amp;envId=Invalid</a> Date)</p>
<p><strong>思路:</strong></p>
<p><strong>最小化最大值问题（窃取房间的最大金额定义为窃取能力 求最小的窃取能力）——&gt;二分法</strong></p>
<p>假设小偷偷取房屋的最大金额为<code>y</code>，显然<code>y∈[nums_min, nums_max]</code>，设<code>f(y)</code>为在最大金额<code>y</code>情况下，小偷可以偷盗房间的数目，<code>f(y)</code>的计算方式为：</p>
<ul>
<li>记当前偷取的房屋数目为<code>count</code>，遍历数组<code>nums</code>，假设当前遍历的房屋的金额为<code>x</code>，若<code>x&lt;y</code>成立，且上一遍历，那么令<code>count+1</code>，表示该房屋被偷取，遍历之后<code>f(y)=count</code>，显然<code>f(y)</code>是非递减函数。</li>
</ul>
<p>使用二分查找的方法，找到满足<code>f(y)&gt;k</code>的最小<code>y</code>，即题目所求的最小窃取能力</p>
<ul>
<li>初始化<code>lower = nums_min</code>，<code>upper = nums_max</code>;</li>
<li>令<code>middle = (lower+upper) /2</code>，如果<code>f(middle) &gt;= k</code>，那么<code>upper = middle - 1</code>；否则<code>lower = middle + 1</code>；</li>
<li>当<code>lower &lt;= upper</code>时，继续执行<code>步骤2</code>；否则返回<code>lower</code>为结果。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCapability</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lower = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//最大最小值获取</span></span><br><span class="line">        <span class="type">int</span> upper = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//二分法</span></span><br><span class="line">        <span class="keyword">while</span> (lower &lt;= upper) &#123;</span><br><span class="line">            <span class="type">int</span> middle = (lower + upper) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> visited = <span class="literal">false</span>;<span class="comment">//访问标志</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &lt;= middle &amp;&amp; !visited) &#123;</span><br><span class="line">                    <span class="comment">//x&lt;middle且visited = false</span></span><br><span class="line">                    count++;<span class="comment">//表示已经访问了一个满足条件的元素</span></span><br><span class="line">                    visited = <span class="literal">true</span>;<span class="comment">//用于判断相邻元素是否已经被偷盗，若为true则不能继续偷盗</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    visited = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count与k进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt;= k) &#123;</span><br><span class="line">                upper = middle - <span class="number">1</span>;<span class="comment">// &lt;= middle的值已经判断过了</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lower = middle + <span class="number">1</span>;<span class="comment">//同理 &gt;=middle的值已经判断过了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lower;<span class="comment">//返回lower 满足k个房屋的最小偷盗金额发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(nlogT) n是数组大小， T是最大与最小值之差 O(logT)为二分查找的次数，O(n)为数组遍历时间</li>
<li>空间复杂度：O(1)</li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2023/09/18/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p><strong>哈希表：</strong>根据关键码的值而直接进行访问的数据结构。</p>
<p>一般的哈希表都是用来快速判断一个元素是否出现在集合里</p>
<p>常见哈希结构：详细见<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84">代码随想录 (programmercarl.com)</a></p>
<p><img src="/2023/09/18/%E5%93%88%E5%B8%8C%E8%A1%A8/image-20230918104630195.png" alt="image-20230918104630195"></p>
<h1 id="2-leetcode-242-有效的字母异位词"><a href="#2-leetcode-242-有效的字母异位词" class="headerlink" title="2.leetcode-242-有效的字母异位词"></a>2.leetcode-242-有效的字母异位词</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li>利用一个哈希表对s中字符进行存储，然后对t中字符进行删减 若最后哈希表中存在小于0或大于1的值则返回false。</li>
<li>其实可以用普通数组 因为字母26个元素数量比较少，用数组就可以实现。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(s.size())</span></span>;<span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cnt[s[i]]++;<span class="comment">//存储s中的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cnt[t[i]]--;<span class="comment">//减去t中的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, val] : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; <span class="number">0</span> || val &lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)遍历字符串</li>
<li>空间复杂度：O(n)哈希表</li>
</ul>
<h1 id="3-leetcode-349-两个数组的交集"><a href="#3-leetcode-349-两个数组的交集" class="headerlink" title="3.leetcode-349-两个数组的交集"></a>3.leetcode-349-两个数组的交集</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集 - 力扣（LeetCode）</a></p>
<p><strong>思路：</strong></p>
<ul>
<li><p>因为<code>nums.size()∈[0, 1000]</code>，所以直接使用数组，并且<code>res</code>返回值必须是唯一的，所新建访问数组，判断是否已经添加到<code>res</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(<span class="number">1000</span>, <span class="number">0</span>)</span></span>;<span class="comment">//访问数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">1000</span>, <span class="number">0</span>)</span></span>;<span class="comment">//计数数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums1) &#123;</span><br><span class="line">            cnt[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[x] &gt;= <span class="number">1</span> &amp;&amp; visited[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//判断是否存在在nums2中，并且还未访问过</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(x);</span><br><span class="line">                visited[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li><input disabled type="checkbox"> 时间复杂度：O(m+n)两次数组循环</li>
<li><input disabled type="checkbox"> 空间复杂度：O(n)数组创建</li>
</ul>
</li>
<li><p>正常解法：如果没有传入数组大小的限制，则用<code>unordered_set</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集 去重！！！</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;<span class="comment">//传入nums1的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="comment">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">//find迭代器查找，若找到元素则返回一个指向该元素的迭代器</span></span><br><span class="line">                <span class="comment">//若不存在 则返回nums_Set.end()</span></span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析：</p>
<ul>
<li><p><input disabled type="checkbox"> 
时间复杂度：O(mn)遍历数组并查找元素</p>
</li>
<li><p><input disabled type="checkbox"> 
空间复杂度：O(n)哈希表</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>点云多尺度滤波</title>
    <url>/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>在降采样中想要充分保留边界信息，但是采用体素降采样，均匀降采样等，都是对<strong>全局</strong>的点云信息进行降采样，无法做到<strong>分区域</strong>的降采样。因此对点云的<code>曲率</code>进行估计，作为额外的补充信息对点云进行降采样。即对点云做<strong>条件滤波</strong>。曲率信息作为滤波条件。</p>
<p><strong>运行环境：</strong><code>Ubuntu18.04</code> + <code>PCL1.11</code></p>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>估计点云的法向量和曲率</li>
<li>对点云法向量和曲率进行字段连接</li>
<li>根据曲率大小进行分区域降采样</li>
</ol>
<h2 id="2-1估计点云的法向量和曲率"><a href="#2-1估计点云的法向量和曲率" class="headerlink" title="2.1估计点云的法向量和曲率"></a>2.1估计点云的法向量和曲率</h2><p>利用PCL库对点云的法向量和曲率进行估计。要注意根据实际的情况设置合适的点云<code>邻域半径</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::NormalEstimationOMP&lt;pcl::PointXYZ,pcl::Normal&gt;n;</span><br><span class="line">pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">n.<span class="built_in">setViewPoint</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">n.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">n.<span class="built_in">setNumberOfThreads</span>(<span class="number">4</span>);</span><br><span class="line">n.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">n.<span class="built_in">setRadiusSearch</span>(<span class="number">1</span>);<span class="comment">//设置邻域半径</span></span><br><span class="line">n.<span class="built_in">compute</span>(*normals);</span><br></pre></td></tr></table></figure>



<h2 id="2-2字段连接"><a href="#2-2字段连接" class="headerlink" title="2.2字段连接"></a>2.2字段连接</h2><p>利用<code>concatenateFields</code>将点云的法向量与曲率信息连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointNormal&gt;::<span class="function">Ptr <span class="title">cnormals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointNormal&gt;)</span></span>;</span><br><span class="line">pcl::<span class="built_in">concatenateFields</span>(*cloud,*normals,*cnormals);<span class="comment">//连接字段</span></span><br></pre></td></tr></table></figure>



<h2 id="2-3分区域滤波"><a href="#2-3分区域滤波" class="headerlink" title="2.3分区域滤波"></a>2.3分区域滤波</h2><p>设置合理的曲率阈值<code>cur_threshold</code>，遍历点云，将点云放入不同的点云集合<code>clouddownsample_1</code>和<code>clouddownsample_2</code>，分别设置不同的降采样尺度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">clouddownsample_1</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">clouddownsample_2</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cnormals-&gt;points.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">  <span class="keyword">if</span> (cnormals-&gt;<span class="built_in">at</span>(i).curvature &gt; cur_threshold)&#123;<span class="comment">//阈值判断</span></span><br><span class="line">    clouddownsample_1-&gt;points.<span class="built_in">emplace_back</span>(cloud-&gt;points[i]);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    clouddownsample_2-&gt;points.<span class="built_in">emplace_back</span>(cloud-&gt;points[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置必要的信息</span></span><br><span class="line">clouddownsample_1-&gt;width = clouddownsample_1-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">clouddownsample_1-&gt;height = <span class="number">1</span>;</span><br><span class="line">clouddownsample_1-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line">clouddownsample_2-&gt;width = clouddownsample_2-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">clouddownsample_2-&gt;height = <span class="number">1</span>;</span><br><span class="line">clouddownsample_2-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大尺度降采样</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_add</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="type">float</span> leftSize = <span class="number">0.25f</span>;<span class="comment">//尺度设置</span></span><br><span class="line">pcl::VoxelGrid&lt;pcl::PointXYZ&gt; down;</span><br><span class="line">down.<span class="built_in">setInputCloud</span> (clouddownsample_2);</span><br><span class="line">down.<span class="built_in">setLeafSize</span> (leftSize, leftSize, leftSize);</span><br><span class="line">down.<span class="built_in">filter</span> (*clouddownsample_2);</span><br><span class="line"></span><br><span class="line">*cloud_add = *clouddownsample_1 + *clouddownsample_2;<span class="comment">//合并降采样后的点云</span></span><br></pre></td></tr></table></figure>



<h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><h2 id="3-1原始图像"><a href="#3-1原始图像" class="headerlink" title="3.1原始图像"></a>3.1原始图像</h2><p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918150913761.png" alt="原始图像"></p>
<h2 id="3-2曲率估计图像"><a href="#3-2曲率估计图像" class="headerlink" title="3.2曲率估计图像"></a>3.2曲率估计图像</h2><p>曲率高的地方为边界。</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151009863.png" alt="曲率估计图像"></p>
<h2 id="3-3降采样图像"><a href="#3-3降采样图像" class="headerlink" title="3.3降采样图像"></a>3.3降采样图像</h2><p>边界信息较好的保留了下来</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151106060.png" alt="image-20230918151106060"></p>
<h2 id="3-4不足"><a href="#3-4不足" class="headerlink" title="3.4不足"></a>3.4不足</h2><p>整体对曲率估计时的<code>邻域半径设置</code>比较敏感，若设置过小，极易受到噪声点的干扰，如下图的曲率估计。</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151458899.png" alt="image-20230918151458899"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
        <tag>多尺度</tag>
        <tag>C++</tag>
        <tag>条件滤波</tag>
      </tags>
  </entry>
</search>
