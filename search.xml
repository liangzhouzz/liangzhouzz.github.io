<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>点云计算点密度特征</title>
    <url>/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="一、点云密度介绍"><a href="#一、点云密度介绍" class="headerlink" title="一、点云密度介绍"></a>一、点云密度介绍</h1><p>点云密度反应了点云的密集程度和分布，是点云的重要特征信息；其与采集设备的分辨率，被采集物体的表面材料有关。</p>
<p>广义上的点云密度有两种方法表示：</p>
<p><strong>①距离密度</strong>，即给定需要计算点的数量，统计每个邻近点到该点的距离作为密度；</p>
<p><strong>②点密度</strong>，即给定邻域半径，统计该点领域半径内的点数量作为点密度。</p>
<hr>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>指定搜索半径<code>radius</code>和最小点密度阈值<code>minPts</code>。可以先用<code>cloudcompare</code>查看</li>
<li>用<code>radiusSearch</code>统计种子点的在<code>radius</code>局部点的数量，作为点的密度值<code>densiities</code>。</li>
<li>遍历每个点的密度，满足密度阈值的点放入点集中。</li>
</ol>
<h2 id="2-1指定搜索半径和密度阈值"><a href="#2-1指定搜索半径和密度阈值" class="headerlink" title="2.1指定搜索半径和密度阈值"></a>2.1指定搜索半径和密度阈值</h2><p>这一步可以指定搜索半径和阈值，可以把点云文件导入cloudcompare内查看，以便设置更合适的阈值。</p>
<ul>
<li>导入文件–&gt;Tools–&gt;Other–&gt;Compute geometric features</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827161857964.png" alt="image-20230827161857964"></p>
<ul>
<li>设置半径和勾选要计算的特征即可，这里我们勾选局部邻域内点的数量作为密度。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162216221.png" alt="image-20230827162216221"></p>
<ul>
<li>拖动状态栏即可查看，设置合适的阈值。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162700463.png" alt="image-20230827162700463"></p>
<h2 id="2-2计算点的局部密度"><a href="#2-2计算点的局部密度" class="headerlink" title="2.2计算点的局部密度"></a>2.2计算点的局部密度</h2><p>首先构建<code>kdtree</code>，使用kdtree中的<code>radiusSearch</code>函数搜索种子点指定半径内点的索引<code>nn_indices</code>，然后将<code>nn_indices.size()</code>作为局部密度赋值给<code>densiities</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line"><span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line"><span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"><span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，初始化为零</span></span><br><span class="line">                            </span><br><span class="line"><span class="comment">//nn_in和nn_dists,在算法中用于计算每个点的局部密度，对于每个点通过tree-&gt;ra函数找到其在领域半径内的所有最邻点的索引和距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">        densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3筛选点并进行聚类"><a href="#2-3筛选点并进行聚类" class="headerlink" title="2.3筛选点并进行聚类"></a>2.3筛选点并进行聚类</h2><p>创建<code>visited</code>用于记录点是否已经访问过，当点已经被访问过，或点的密度小于阈值则跳过该点。然后创建一个队列<code>queue</code>用于记录当前聚类的点，<code>queue</code>为先入先出结构。最后得到点云满足阈值条件的的密度聚类<code>cluster</code>。将其放入<code>clusters</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (visited[i] || densiities[i] &lt; minPts)<span class="comment">//该点已经被访问，或点的密度小于minpts，</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">       &#125;</span><br><span class="line">            </span><br><span class="line">       <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">       pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">       std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">       std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">       <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">       q.<span class="built_in">push</span>(i);</span><br><span class="line">       visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">       <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">             <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">             <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">             <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">             q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素用于退出循环</span></span><br><span class="line">             cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">             singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">             std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">             std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">             treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">             &#123;</span><br><span class="line">                   <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                   <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                   &#123;</span><br><span class="line">                           q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                           visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                   &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">		 clusters.<span class="built_in">push_back</span>(cluster);</span><br></pre></td></tr></table></figure>



<h2 id="2-4代码"><a href="#2-4代码" class="headerlink" title="2.4代码"></a>2.4代码</h2><p>总的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> SegByLocalDensity（<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud,</span><br><span class="line">    					std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;&gt;&amp; clusters,</span><br><span class="line">						std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; gappointindices）</span><br><span class="line">&#123;</span><br><span class="line">    	<span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line">		<span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line">        <span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">        std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，并初始化为零</span></span><br><span class="line">                            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">                densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//基于广度优先搜索</span></span><br><span class="line">        std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (visited[i] || densiities[i]&lt; minPts)<span class="comment">//||或逻辑，只有当该点已经被访问，且点的密度大于minpts，才执行下面的处理</span></span><br><span class="line">           &#123;</span><br><span class="line">                     <span class="keyword">continue</span>; </span><br><span class="line">           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">            pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">            std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">            <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);<span class="comment">//对queue的对象在push的时候会调用拷贝对象的拷贝构造函数，插入queue中的是对象的一份拷贝</span></span><br><span class="line">            visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//如果q中没有元素则返回true</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">                    <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">                    <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">                    q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素-----------------用于退出循环</span></span><br><span class="line">                    cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">                    singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">                    std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">                    std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">                    treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">                    &#123;</span><br><span class="line">                            <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                            <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                    q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                                    visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clusters.<span class="built_in">push_back</span>(cluster);</span><br><span class="line">            gappointindices.<span class="built_in">emplace_back</span>(singlegapindices);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-5原始图像"><a href="#2-5原始图像" class="headerlink" title="2.5原始图像"></a><strong>2.5原始图像</strong></h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095757902.png" alt="image-20230803095757902"></p>
<h2 id="2-6处理后的图像"><a href="#2-6处理后的图像" class="headerlink" title="2.6处理后的图像"></a>2.6处理后的图像</h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095812781.png" alt="image-20230803095812781"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>特征提取</tag>
        <tag>点云处理</tag>
      </tags>
  </entry>
  <entry>
    <title>点云基础滤波算法</title>
    <url>/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、点云滤波介绍"><a href="#一、点云滤波介绍" class="headerlink" title="一、点云滤波介绍"></a>一、点云滤波介绍</h1><p>当激光或结构光设备采集的时候会因为被采集物体的表面材料，环境带来许多的噪声点（也叫做离群点），也会因为点云数据冗余，需要进行降采样，便于后续处理数据量的减少。</p>
<p>本文借助PCL开源库，实现基础的点云滤波算法。</p>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="2-1直通滤波"><a href="#2-1直通滤波" class="headerlink" title="2.1直通滤波"></a>2.1直通滤波</h2><p>直通滤波是在给定的通道上（x、y、z等）进行给定区域的滤波，在自动驾驶中一般用来进行地面的滤除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/passthrough.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::PointXYZ minPt, maxPt;</span><br><span class="line">pcl::<span class="built_in">getMinMax3D</span>(*cloud,minPt,maxPt);<span class="comment">//获得输入点云的最大最小边界</span></span><br><span class="line"><span class="comment">//关键配置代码</span></span><br><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt;PassZ;</span><br><span class="line">PassZ.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入点云</span></span><br><span class="line">PassZ.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);<span class="comment">//设置滤波字段名，x方向</span></span><br><span class="line">PassZ.<span class="built_in">setFilterLimits</span>(minPt.z,<span class="number">0</span>);<span class="comment">//设置在过滤方向上的点云</span></span><br><span class="line">PassZ.<span class="built_in">setNegative</span>(<span class="literal">true</span>);<span class="comment">//设置false为保留范围内的点,true为剔除范围内点</span></span><br><span class="line">PassZ.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h2 id="2-2统计滤波"><a href="#2-2统计滤波" class="headerlink" title="2.2统计滤波"></a>2.2统计滤波</h2><p>统计滤波是针对每一个点进行其领域的统计分析，得到该点到其领域点距离的分布特征，过滤掉不满足阈值的离群点，保留内点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt;sor;<span class="comment">//创建过滤器</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入要滤波的点云</span></span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);<span class="comment">//每个点考虑最近邻个数为50</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">1.0</span>);<span class="comment">//设置标准差阈值为1</span></span><br><span class="line"><span class="comment">//这意味着所有距离查询点的平均距离的标准偏差均大于1个标准偏差的所有点都将被标记为离群值并删除。</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud);</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><strong>处理图像</strong></p>
<p><img src="/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/image-20230805160619017.png" alt="image-20230805160619017"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>直通滤波</tag>
        <tag>统计滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
      </tags>
  </entry>
  <entry>
    <title>点云特征识别-圆孔特征识别</title>
    <url>/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>基于点的特征识别算法相对较少，刚好又需要对项目中的圆孔特征进行滤波，故采取<strong>点云密度+RANSAC</strong>对圆孔特征进行识别和滤波。</p>
<ol>
<li>首先，根据采集点云的<strong>密度差异</strong>提取出包含圆孔特征，边界特征的点云集合；</li>
<li>然后，利用<strong>RANSAC</strong>进行圆孔拟合；</li>
<li>最后，获取拟合的圆孔的半径，圆心利用包围盒进行去除。</li>
</ol>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><h2 id="2-1点云密度差异聚类"><a href="#2-1点云密度差异聚类" class="headerlink" title="2.1点云密度差异聚类"></a>2.1点云密度差异聚类</h2><p>计算点云数据的点密度差异，提取出密度差异的特征点云，并进行欧式聚类，具体实现见<a href="https://liangzhouzz.github.io/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/">点云计算点密度特征 | Sifanのblog (liangzhouzz.github.io)</a></p>
<p><strong>原始图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152034159.png" alt="image-20230806152034159" style="zoom:80%;">

<hr>
<p><strong>提取后的图像：</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152143989.png" alt="image-20230806152143989" style="zoom:80%;">



<h2 id="2-2点云聚类"><a href="#2-2点云聚类" class="headerlink" title="2.2点云聚类"></a>2.2点云聚类</h2><p>将经过密度提取后的点云进行聚类，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>; <span class="comment">//创建kdtree</span></span><br><span class="line">kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"></span><br><span class="line">std::vector&lt;pcl::PointIndices&gt;cluster_indices;<span class="comment">//点索引</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;<span class="comment">//创建欧式聚类</span></span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);<span class="comment">//聚类容忍度</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);<span class="comment">//最小聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());<span class="comment">//最大聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(kd_tree);<span class="comment">//搜索方式</span></span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure>

<h2 id="2-3RANSAC拟合圆"><a href="#2-3RANSAC拟合圆" class="headerlink" title="2.3RANSAC拟合圆"></a>2.3RANSAC拟合圆</h2><p><strong>RANSAC</strong>拟合圆，可选择拟合2D圆<code>pcl::SACMODEL_CIRCLE2D</code>或3D圆<code>pcl::SACMODEL_CIRCLE3D</code>，这里选择用3D，RANSAC需传入法向量，对点云进行法向量估计。RANSAC会存在拟合错误的情况，需要对拟合出圆的半径进行限制，限制在其范围内找到目标圆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类创建</span></span><br><span class="line">pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	估计法向量</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ransac</span></span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//设置法向量权重</span></span><br><span class="line">seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br></pre></td></tr></table></figure>



<h2 id="2-4包围盒分割"><a href="#2-4包围盒分割" class="headerlink" title="2.4包围盒分割"></a>2.4包围盒分割</h2><p>根据提取出圆的索引，可以得到其圆心坐标和半径，然后利用最小包围盒进行分割。</p>
<p>拟合出3D圆的参数如下：</p>
<ul>
<li><code>圆心坐标x</code>：value[0]</li>
<li><code>圆心坐标y</code>：value[1]</li>
<li><code>圆心坐标z</code>：value[2]</li>
<li><code>半径r</code>：value[3]</li>
<li><code>法向量nx</code>：value[4]</li>
<li><code>法向量ny</code>：value[5]</li>
<li><code>法向量nz</code>：value[6]</li>
</ul>
<p>设置包围盒的最小点坐标<code>min_pt</code>，和最大点坐标<code>max_pt</code>，然后创建包围盒对象，得到在包围盒内的点云索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">    <span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">    <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">//创建包围盒对象</span></span><br><span class="line">    pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">    crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">    crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">    crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">    crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">    <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">    crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">	<span class="comment">//创建分割对象</span></span><br><span class="line">    pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">    extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">    extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">    extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-5代码实现"><a href="#2-5代码实现" class="headerlink" title="2.5代码实现"></a>2.5代码实现</h2><p>代码汇总：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/sample_consensus/sac_model_circle3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/extract_clusters.h&gt;</span><span class="comment">//提取聚类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/crop_box.h&gt;</span><span class="comment">//包围盒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtractCircle</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//聚类</span></span><br><span class="line">        std::vector&lt;pcl::PointIndices&gt;cluster_indices;</span><br><span class="line">        pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;</span><br><span class="line">        ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);</span><br><span class="line">        ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);</span><br><span class="line">        ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());</span><br><span class="line">        ec.<span class="built_in">setSearchMethod</span>(kd_tree);</span><br><span class="line">        ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        ec.<span class="built_in">extract</span>(cluster_indices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RANSAC拟合</span></span><br><span class="line">        pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">        pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">        pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">        std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> counti=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; indices : cluster_indices)</span><br><span class="line">        &#123;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cluster</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_cir</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::<span class="built_in">copyPointCloud</span>(*cloud,indices.indices,*cluster);</span><br><span class="line">                pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">            	<span class="comment">//	估计法向量</span></span><br><span class="line">                pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">                ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">                ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">                ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line">				<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">                seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">                seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//法向量权重</span></span><br><span class="line">                seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">                seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">                seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">                seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">                seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">                seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br><span class="line">            	<span class="comment">//拟合圆的点数限制，因为很容易会拟合半圆，需根据实际的需求调整，防止拟合半圆</span></span><br><span class="line">                <span class="keyword">if</span> (inliers-&gt;indices.<span class="built_in">size</span>() &lt; <span class="number">80</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">//cerr&lt;&lt;&quot;none&quot;&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                coeff.<span class="built_in">push_back</span>(*coefficients);</span><br><span class="line">                counti++;</span><br><span class="line">            	<span class="comment">//提取</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(inliers);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud_cir);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            	<span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">                <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">            	<span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">                <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">            	<span class="comment">//创建包围盒对象</span></span><br><span class="line">                pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">                crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">                crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">                crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">                crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">                <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">                crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">				<span class="comment">//创建分割对象</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6结果"><a href="#2-6结果" class="headerlink" title="2.6结果"></a>2.6结果</h2><p><strong>RANSAC搜索的对象</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155049673.png" alt="image-20230806155049673" style="zoom:80%;">

<p><strong>包围盒分割图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155158365.png" alt="image-20230806155158365" style="zoom:80%;">]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>滤波</tag>
        <tag>特征识别</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找法</title>
    <url>/2023/09/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
    <content><![CDATA[<h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><ul>
<li>对应<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></li>
<li>升序数组-二分查找-主要思路是分清搜索区间，左闭右闭，还是左闭右开。</li>
<li><strong>区间的开闭</strong>用来判断<code>while</code>的判断条件以及<code>left</code>，<code>right</code>的更新条件。</li>
</ul>
<hr>
<ul>
<li><p><strong>左闭右闭</strong><code>[left, right]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>， right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// while &lt;= 可以想象[1, 1]其中的1 是有效数字</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">//防止溢出</span></span><br><span class="line">    <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">        right = middle - <span class="number">1</span>;<span class="comment">//middle的值已经在if中判断过，所以不需要包含middle</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;<span class="comment">//同理</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> middle;<span class="comment">//相等则返回 middle</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在target</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>左闭右开</strong><code>[left, right)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>， right = nums.<span class="built_in">size</span>();<span class="comment">//右边为开区间</span></span><br><span class="line"><span class="comment">// while &lt; 可以想象[1, 1)其中的1不合法</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">//防止溢出</span></span><br><span class="line">    <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">        right = middle;<span class="comment">//middle的值本来就不包含在区间内</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;<span class="comment">//左闭</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> middle;<span class="comment">//相等则返回 middle</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在target</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
