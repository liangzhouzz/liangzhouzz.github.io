<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>点云计算点密度特征</title>
    <url>/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="一、点云密度介绍"><a href="#一、点云密度介绍" class="headerlink" title="一、点云密度介绍"></a>一、点云密度介绍</h1><p>点云密度反应了点云的密集程度和分布，是点云的重要特征信息；其与采集设备的分辨率，被采集物体的表面材料有关。</p>
<p>广义上的点云密度有两种方法表示：</p>
<p><strong>①距离密度</strong>，即给定需要计算点的数量，统计每个邻近点到该点的距离作为密度；</p>
<p><strong>②点密度</strong>，即给定邻域半径，统计该点领域半径内的点数量作为点密度。</p>
<hr>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>指定搜索半径<code>radius</code>和最小点密度阈值<code>minPts</code>。可以先用<code>cloudcompare</code>查看</li>
<li>用<code>radiusSearch</code>统计种子点的在<code>radius</code>局部点的数量，作为点的密度值<code>densiities</code>。</li>
<li>遍历每个点的密度，满足密度阈值的点放入点集中。</li>
</ol>
<h2 id="2-1指定搜索半径和密度阈值"><a href="#2-1指定搜索半径和密度阈值" class="headerlink" title="2.1指定搜索半径和密度阈值"></a>2.1指定搜索半径和密度阈值</h2><p>这一步可以指定搜索半径和阈值，可以把点云文件导入cloudcompare内查看，以便设置更合适的阈值。</p>
<ul>
<li>导入文件–&gt;Tools–&gt;Other–&gt;Compute geometric features</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827161857964.png" alt="image-20230827161857964"></p>
<ul>
<li>设置半径和勾选要计算的特征即可，这里我们勾选局部邻域内点的数量作为密度。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162216221.png" alt="image-20230827162216221"></p>
<ul>
<li>拖动状态栏即可查看，设置合适的阈值。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162700463.png" alt="image-20230827162700463"></p>
<h2 id="2-2计算点的局部密度"><a href="#2-2计算点的局部密度" class="headerlink" title="2.2计算点的局部密度"></a>2.2计算点的局部密度</h2><p>首先构建<code>kdtree</code>，使用kdtree中的<code>radiusSearch</code>函数搜索种子点指定半径内点的索引<code>nn_indices</code>，然后将<code>nn_indices.size()</code>作为局部密度赋值给<code>densiities</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line"><span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line"><span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"><span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，初始化为零</span></span><br><span class="line">                            </span><br><span class="line"><span class="comment">//nn_in和nn_dists,在算法中用于计算每个点的局部密度，对于每个点通过tree-&gt;ra函数找到其在领域半径内的所有最邻点的索引和距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">        densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3筛选点并进行聚类"><a href="#2-3筛选点并进行聚类" class="headerlink" title="2.3筛选点并进行聚类"></a>2.3筛选点并进行聚类</h2><p>创建<code>visited</code>用于记录点是否已经访问过，当点已经被访问过，或点的密度小于阈值则跳过该点。然后创建一个队列<code>queue</code>用于记录当前聚类的点，<code>queue</code>为先入先出结构。最后得到点云满足阈值条件的的密度聚类<code>cluster</code>。将其放入<code>clusters</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (visited[i] || densiities[i] &lt; minPts)<span class="comment">//该点已经被访问，或点的密度小于minpts，</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">       &#125;</span><br><span class="line">            </span><br><span class="line">       <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">       pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">       std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">       std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">       <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">       q.<span class="built_in">push</span>(i);</span><br><span class="line">       visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">       <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">             <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">             <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">             <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">             q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素用于退出循环</span></span><br><span class="line">             cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">             singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">             std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">             std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">             treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">             &#123;</span><br><span class="line">                   <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                   <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                   &#123;</span><br><span class="line">                           q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                           visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                   &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">		 clusters.<span class="built_in">push_back</span>(cluster);</span><br></pre></td></tr></table></figure>



<h2 id="2-4代码"><a href="#2-4代码" class="headerlink" title="2.4代码"></a>2.4代码</h2><p>总的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> SegByLocalDensity（<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud,</span><br><span class="line">    					std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;&gt;&amp; clusters,</span><br><span class="line">						std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; gappointindices）</span><br><span class="line">&#123;</span><br><span class="line">    	<span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line">		<span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line">        <span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">        std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，并初始化为零</span></span><br><span class="line">                            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">                densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//基于广度优先搜索</span></span><br><span class="line">        std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (visited[i] || densiities[i]&lt; minPts)<span class="comment">//||或逻辑，只有当该点已经被访问，且点的密度大于minpts，才执行下面的处理</span></span><br><span class="line">           &#123;</span><br><span class="line">                     <span class="keyword">continue</span>; </span><br><span class="line">           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">            pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">            std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">            <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);<span class="comment">//对queue的对象在push的时候会调用拷贝对象的拷贝构造函数，插入queue中的是对象的一份拷贝</span></span><br><span class="line">            visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//如果q中没有元素则返回true</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">                    <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">                    <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">                    q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素-----------------用于退出循环</span></span><br><span class="line">                    cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">                    singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">                    std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">                    std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">                    treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">                    &#123;</span><br><span class="line">                            <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                            <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                    q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                                    visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clusters.<span class="built_in">push_back</span>(cluster);</span><br><span class="line">            gappointindices.<span class="built_in">emplace_back</span>(singlegapindices);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-5原始图像"><a href="#2-5原始图像" class="headerlink" title="2.5原始图像"></a><strong>2.5原始图像</strong></h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095757902.png" alt="image-20230803095757902"></p>
<h2 id="2-6处理后的图像"><a href="#2-6处理后的图像" class="headerlink" title="2.6处理后的图像"></a>2.6处理后的图像</h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095812781.png" alt="image-20230803095812781"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>特征提取</tag>
        <tag>点云处理</tag>
      </tags>
  </entry>
  <entry>
    <title>点云基础滤波算法</title>
    <url>/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、点云滤波介绍"><a href="#一、点云滤波介绍" class="headerlink" title="一、点云滤波介绍"></a>一、点云滤波介绍</h1><p>当激光或结构光设备采集的时候会因为被采集物体的表面材料，环境带来许多的噪声点（也叫做离群点），也会因为点云数据冗余，需要进行降采样，便于后续处理数据量的减少。</p>
<p>本文借助PCL开源库，实现基础的点云滤波算法。</p>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="2-1直通滤波"><a href="#2-1直通滤波" class="headerlink" title="2.1直通滤波"></a>2.1直通滤波</h2><p>直通滤波是在给定的通道上（x、y、z等）进行给定区域的滤波，在自动驾驶中一般用来进行地面的滤除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/passthrough.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::PointXYZ minPt, maxPt;</span><br><span class="line">pcl::<span class="built_in">getMinMax3D</span>(*cloud,minPt,maxPt);<span class="comment">//获得输入点云的最大最小边界</span></span><br><span class="line"><span class="comment">//关键配置代码</span></span><br><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt;PassZ;</span><br><span class="line">PassZ.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入点云</span></span><br><span class="line">PassZ.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);<span class="comment">//设置滤波字段名，x方向</span></span><br><span class="line">PassZ.<span class="built_in">setFilterLimits</span>(minPt.z,<span class="number">0</span>);<span class="comment">//设置在过滤方向上的点云</span></span><br><span class="line">PassZ.<span class="built_in">setNegative</span>(<span class="literal">true</span>);<span class="comment">//设置false为保留范围内的点,true为剔除范围内点</span></span><br><span class="line">PassZ.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h2 id="2-2统计滤波"><a href="#2-2统计滤波" class="headerlink" title="2.2统计滤波"></a>2.2统计滤波</h2><p>统计滤波是针对每一个点进行其领域的统计分析，得到该点到其领域点距离的分布特征，过滤掉不满足阈值的离群点，保留内点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt;sor;<span class="comment">//创建过滤器</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入要滤波的点云</span></span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);<span class="comment">//每个点考虑最近邻个数为50</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">1.0</span>);<span class="comment">//设置标准差阈值为1</span></span><br><span class="line"><span class="comment">//这意味着所有距离查询点的平均距离的标准偏差均大于1个标准偏差的所有点都将被标记为离群值并删除。</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud);</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><strong>处理图像</strong></p>
<p><img src="/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/image-20230805160619017.png" alt="image-20230805160619017"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>直通滤波</tag>
        <tag>统计滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
      </tags>
  </entry>
  <entry>
    <title>点云特征识别-圆孔特征识别</title>
    <url>/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>基于点的特征识别算法相对较少，刚好又需要对项目中的圆孔特征进行滤波，故采取<strong>点云密度+RANSAC</strong>对圆孔特征进行识别和滤波。</p>
<ol>
<li>首先，根据采集点云的<strong>密度差异</strong>提取出包含圆孔特征，边界特征的点云集合；</li>
<li>然后，利用<strong>RANSAC</strong>进行圆孔拟合；</li>
<li>最后，获取拟合的圆孔的半径，圆心利用包围盒进行去除。</li>
</ol>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><h2 id="2-1点云密度差异聚类"><a href="#2-1点云密度差异聚类" class="headerlink" title="2.1点云密度差异聚类"></a>2.1点云密度差异聚类</h2><p>计算点云数据的点密度差异，提取出密度差异的特征点云，并进行欧式聚类，具体实现见<a href="https://liangzhouzz.github.io/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/">点云计算点密度特征 | Sifanのblog (liangzhouzz.github.io)</a></p>
<p><strong>原始图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152034159.png" alt="image-20230806152034159" style="zoom:80%;">

<hr>
<p><strong>提取后的图像：</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152143989.png" alt="image-20230806152143989" style="zoom:80%;">



<h2 id="2-2点云聚类"><a href="#2-2点云聚类" class="headerlink" title="2.2点云聚类"></a>2.2点云聚类</h2><p>将经过密度提取后的点云进行聚类，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>; <span class="comment">//创建kdtree</span></span><br><span class="line">kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"></span><br><span class="line">std::vector&lt;pcl::PointIndices&gt;cluster_indices;<span class="comment">//点索引</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;<span class="comment">//创建欧式聚类</span></span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);<span class="comment">//聚类容忍度</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);<span class="comment">//最小聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());<span class="comment">//最大聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(kd_tree);<span class="comment">//搜索方式</span></span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure>

<h2 id="2-3RANSAC拟合圆"><a href="#2-3RANSAC拟合圆" class="headerlink" title="2.3RANSAC拟合圆"></a>2.3RANSAC拟合圆</h2><p><strong>RANSAC</strong>拟合圆，可选择拟合2D圆<code>pcl::SACMODEL_CIRCLE2D</code>或3D圆<code>pcl::SACMODEL_CIRCLE3D</code>，这里选择用3D，RANSAC需传入法向量，对点云进行法向量估计。RANSAC会存在拟合错误的情况，需要对拟合出圆的半径进行限制，限制在其范围内找到目标圆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类创建</span></span><br><span class="line">pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	估计法向量</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ransac</span></span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//设置法向量权重</span></span><br><span class="line">seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br></pre></td></tr></table></figure>



<h2 id="2-4包围盒分割"><a href="#2-4包围盒分割" class="headerlink" title="2.4包围盒分割"></a>2.4包围盒分割</h2><p>根据提取出圆的索引，可以得到其圆心坐标和半径，然后利用最小包围盒进行分割。</p>
<p>拟合出3D圆的参数如下：</p>
<ul>
<li><code>圆心坐标x</code>：value[0]</li>
<li><code>圆心坐标y</code>：value[1]</li>
<li><code>圆心坐标z</code>：value[2]</li>
<li><code>半径r</code>：value[3]</li>
<li><code>法向量nx</code>：value[4]</li>
<li><code>法向量ny</code>：value[5]</li>
<li><code>法向量nz</code>：value[6]</li>
</ul>
<p>设置包围盒的最小点坐标<code>min_pt</code>，和最大点坐标<code>max_pt</code>，然后创建包围盒对象，得到在包围盒内的点云索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">    <span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">    <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">//创建包围盒对象</span></span><br><span class="line">    pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">    crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">    crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">    crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">    crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">    <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">    crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">	<span class="comment">//创建分割对象</span></span><br><span class="line">    pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">    extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">    extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">    extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-5代码实现"><a href="#2-5代码实现" class="headerlink" title="2.5代码实现"></a>2.5代码实现</h2><p>代码汇总：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/sample_consensus/sac_model_circle3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/extract_clusters.h&gt;</span><span class="comment">//提取聚类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/crop_box.h&gt;</span><span class="comment">//包围盒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtractCircle</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//聚类</span></span><br><span class="line">        std::vector&lt;pcl::PointIndices&gt;cluster_indices;</span><br><span class="line">        pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;</span><br><span class="line">        ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);</span><br><span class="line">        ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);</span><br><span class="line">        ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());</span><br><span class="line">        ec.<span class="built_in">setSearchMethod</span>(kd_tree);</span><br><span class="line">        ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        ec.<span class="built_in">extract</span>(cluster_indices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RANSAC拟合</span></span><br><span class="line">        pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">        pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">        pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">        std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> counti=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; indices : cluster_indices)</span><br><span class="line">        &#123;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cluster</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_cir</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::<span class="built_in">copyPointCloud</span>(*cloud,indices.indices,*cluster);</span><br><span class="line">                pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">            	<span class="comment">//	估计法向量</span></span><br><span class="line">                pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">                ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">                ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">                ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line">				<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">                seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">                seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//法向量权重</span></span><br><span class="line">                seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">                seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">                seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">                seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">                seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">                seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br><span class="line">            	<span class="comment">//拟合圆的点数限制，因为很容易会拟合半圆，需根据实际的需求调整，防止拟合半圆</span></span><br><span class="line">                <span class="keyword">if</span> (inliers-&gt;indices.<span class="built_in">size</span>() &lt; <span class="number">80</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">//cerr&lt;&lt;&quot;none&quot;&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                coeff.<span class="built_in">push_back</span>(*coefficients);</span><br><span class="line">                counti++;</span><br><span class="line">            	<span class="comment">//提取</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(inliers);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud_cir);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            	<span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">                <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">            	<span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">                <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">            	<span class="comment">//创建包围盒对象</span></span><br><span class="line">                pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">                crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">                crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">                crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">                crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">                <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">                crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">				<span class="comment">//创建分割对象</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6结果"><a href="#2-6结果" class="headerlink" title="2.6结果"></a>2.6结果</h2><p><strong>RANSAC搜索的对象</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155049673.png" alt="image-20230806155049673" style="zoom:80%;">

<p><strong>包围盒分割图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155158365.png" alt="image-20230806155158365" style="zoom:80%;">]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>滤波</tag>
        <tag>特征识别</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找法</title>
    <url>/2023/09/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
    <content><![CDATA[<h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><ul>
<li>对应<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></li>
<li>升序数组-二分查找-主要思路是分清搜索区间，左闭右闭，还是左闭右开。</li>
<li><strong>区间的开闭</strong>用来判断<code>while</code>的判断条件以及<code>left</code>，<code>right</code>的更新条件。</li>
</ul>
<hr>
<h2 id="1-leetcode-704-二分查找"><a href="#1-leetcode-704-二分查找" class="headerlink" title="1.leetcode-704-二分查找"></a>1.leetcode-704-二分查找</h2><ul>
<li><p><strong>左闭右闭</strong><code>[left, right]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>， right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// while &lt;= 可以想象[1, 1]其中的1 是有效数字</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">//防止溢出</span></span><br><span class="line">    <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">        right = middle - <span class="number">1</span>;<span class="comment">//middle的值已经在if中判断过，所以不需要包含middle</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;<span class="comment">//同理</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> middle;<span class="comment">//相等则返回 middle</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在target</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>左闭右开</strong><code>[left, right)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>， right = nums.<span class="built_in">size</span>();<span class="comment">//右边为开区间</span></span><br><span class="line"><span class="comment">// while &lt; 可以想象[1, 1)其中的1不合法</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">//防止溢出</span></span><br><span class="line">    <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">        right = middle;<span class="comment">//middle的值本来就不包含在区间内</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;<span class="comment">//左闭</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> middle;<span class="comment">//相等则返回 middle</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在target</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-leetcode-2594-修车最少时间"><a href="#2-leetcode-2594-修车最少时间" class="headerlink" title="2.leetcode-2594-修车最少时间"></a>2.leetcode-2594-修车最少时间</h2><p>题目：<a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/?envType=daily-question&envId=2023-09-07">2594. 修车的最少时间 - 力扣（LeetCode）</a></p>
<p>求修车最少时间，先考虑二分法，若解的值域范围内有单调性，就可以使用二分：</p>
<ul>
<li>​	假设t分钟内可以将所有的汽车都修理完，那么大于t分钟也是可行的。</li>
<li>​	假设t分组内不能将所有的汽车都修理完，那么小于t分钟也是不能够的。</li>
</ul>
<p>因此可以枚举一个时间<code>t</code>，那么能力值为<code>r</code>的工人可以修好<code>sqrt(t/r)</code>量汽车，<strong>若所有工人修完的汽车数量大于<code>cars</code>，那么调整右边界为<code>t</code>，否则调整左边界为<code>t+1</code></strong>.</p>
<p>上界可取正无穷。类似与左闭右开</p>
<p><strong>左右区间更新：</strong>为什么右区间更新为<code>m</code>，左区间更新为<code>m + 1</code>？</p>
<ul>
<li>当 <code>check(m)</code> 返回 <code>true</code> 时，<strong>表示当前中间值 <code>m</code> 是一个可能的解</strong>，因此我们将右边界 <code>r</code> 更新为 <code>m</code>。这是因为我们要尝试找到更小的值，以确保我们找到的是最小的满足条件的值。</li>
<li>当 <code>check(m)</code> 返回 <code>false</code> 时，<strong>表示当前中间值 <code>m</code> 不是一个解</strong>，因此我们将左边界 <code>l</code> 更新为 <code>m + 1</code>。这是因为我们知道 <code>m</code> 不是解，所以我们需要将搜索范围向右移动到更大的值，以便寻找可能的解。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">repairCars</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">int</span> cars)</span> </span>&#123;</span><br><span class="line">    ll l = <span class="number">1</span>, r = <span class="number">1ll</span> * ranks[<span class="number">0</span>] * cars * cars;<span class="comment">//左边界为1，右边界为足够大的数-一个工人修完车的时间</span></span><br><span class="line">    <span class="comment">//lambda函数，用于检查给定的时间是否足够来修理至少cars辆汽车</span></span><br><span class="line">    <span class="comment">//[&amp;]表示按引用的方式捕获外部的变量，这里主要是为了要使用ranks</span></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](ll m) &#123;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : ranks) &#123;</span><br><span class="line">            cnt += <span class="built_in">sqrt</span>(m / x);<span class="comment">//累加当前时间下计算总共修了多少辆汽车</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> cnt &gt;= cars;<span class="comment">//比较能否修理完cars辆汽车，可以则返回true</span></span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="comment">//修车时间二分</span></span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">//m：中间值</span></span><br><span class="line">        ll m = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//&gt;&gt;1：右移一位相当于除以二</span></span><br><span class="line">        <span class="comment">//check==1则更新右边界，边界可以修的完</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(m)) &#123;</span><br><span class="line">            r = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//更新左边界，边界修不完</span></span><br><span class="line">            l = m + <span class="number">1</span>;<span class="comment">//类似于左边右开 m的值已经判断过所欲不需要继续判断</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> l;<span class="comment">//返回修车最小时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>数组</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数组双指针</title>
    <url>/2023/09/06/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>Leetcode-27移除元素：<a href="https://leetcode.cn/problems/remove-element/">27. 移除元素 - 力扣（LeetCode）</a></p>
<p><strong>相似题目：</strong></p>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串 - 力扣（LeetCode）</a>、</p>
<p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方 - 力扣（LeetCode）</a></p>
<p><strong>关键知识点：</strong></p>
<ul>
<li>数组删除元素本质是<strong>覆盖</strong></li>
<li><code>vector</code>中<code>erase</code> 是<code>O(n)</code>的操作</li>
</ul>
<h2 id="1-leetcode-27"><a href="#1-leetcode-27" class="headerlink" title="1.leetcode-27"></a>1.leetcode-27</h2><p>双指针：一层for循环</p>
<ol>
<li><p><strong>快慢指针</strong>-可以不改变原来数组的位置</p>
<p>快指针：获取新数组的元素的指针，若当时指针的值指向为要覆盖的元素则跳过。</p>
<p>慢指针：需要覆盖的位置的指针。</p>
<p>相对于一个是前方的探子<code>fast</code>，一个在后方部署策略<code>slow</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> slow = <span class="number">0</span>；</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast++)&#123;</span><br><span class="line">	<span class="comment">//判断是否是要覆盖的值</span></span><br><span class="line">    <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">        nums[slow] = nums[fast];<span class="comment">//更新新数组</span></span><br><span class="line">        slow++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>左右指针</strong></p>
<p><code>left</code>指针用于判断当前元素是否是需要覆盖的元素，如果是的话则用<code>right</code>指针指向的元素进行覆盖，并对<code>right</code>进行<code>--</code>，如果不是则进行<code>++</code>迭代。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] == val)&#123;</span><br><span class="line">        nums[left] = num[right];</span><br><span class="line">        right--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left++;<span class="comment">//不是target元素则自加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-leetcode-26"><a href="#2-leetcode-26" class="headerlink" title="2.leetcode-26"></a>2.leetcode-26</h2><p>题目要求<strong>删除重复元素且不改变相对顺序</strong>。</p>
<p>快指针：寻找新数组的元素。</p>
<p>慢指针：新数组元素的集合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="comment">//当数组中快慢指针指向元素相等时，快指针++</span></span><br><span class="line">    <span class="keyword">if</span> (nums[slow] == nums[fast])&#123;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//快慢指针指向元素不相等时，则慢指针保留快指针的元素</span></span><br><span class="line">        nums[++slow] = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h2 id="3-leetcode-283-移动零"><a href="#3-leetcode-283-移动零" class="headerlink" title="3.leetcode-283 移动零"></a>3.leetcode-283 移动零</h2><p>将数组的所有<code>0</code>元素移动到数组末尾，保持非零元素的顺序。</p>
<p>快指针：待处理数组元素，遇到非0的元素则进行交换</p>
<p>慢指针：新的数组，慢指针左边均为非零的数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fast &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//进行快慢指针元素替换</span></span><br><span class="line">        <span class="type">int</span> temp = nums[slow];</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        nums[fast] = nums[slow];</span><br><span class="line">        slow++;</span><br><span class="line">    &#125;</span><br><span class="line">    fast++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-leetcode-844-比较含退格的字符串"><a href="#4-leetcode-844-比较含退格的字符串" class="headerlink" title="4.leetcode-844 比较含退格的字符串"></a>4.leetcode-844 比较含退格的字符串</h2><ul>
<li>题目：文本中含有退格符<code>#</code>比较两个字符串是否相等</li>
<li>思路：<strong>逆序遍历，退格符只会影响前一个字符</strong>。并且用<code>skip</code>表示带删除字符的数量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>, j = t.<span class="built_in">size</span>() - <span class="number">1</span>, skipS = <span class="number">0</span>, skipT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//s字符串的逆序遍历</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            skipS++;<span class="comment">//需要删除字符+1</span></span><br><span class="line">        	i--;<span class="comment">//遍历字符减一</span></span><br><span class="line">    	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	skipS--;<span class="comment">//若skip不为0 则说明当前字符需要删去</span></span><br><span class="line">        	i--;</span><br><span class="line">    	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//退出循环的唯一条件</span></span><br><span class="line">       	 	<span class="keyword">break</span>;<span class="comment">//如果既不为‘#’且skip=0，则跳出循环进行比较</span></span><br><span class="line">    	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//同理</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            skipT++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (skipT &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            skipT--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != t[j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不相等则返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//至少有一个出界</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i--;<span class="comment">//判断完进行迭代</span></span><br><span class="line">    j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>举个栗子：</strong></p>
<p><code>s-&gt;&quot;a##c&quot;</code>和<code>t-&gt;&quot;#a#c&quot;</code></p>
<ol>
<li>第一次循环，两个指针均指向<code>c</code>相等，则进行<code>i--（i = 2）</code>和<code>j--</code></li>
<li>第二次循环<code>s</code>字符串为<code>#</code>，<code>skipT++(1)</code>，<code>i--（i = 1）</code>，进入子循环，依然为<code>#</code>，<code>skipT++(2)</code>和<code>i--(0)</code> ，然后因为<code>skipT &gt;= 0</code>,所以进入 <code>skipT--(1)</code>和<code>i--(-1)</code>，然后退出子<code>while</code></li>
<li>t字符串同理，最后返回<code>true</code></li>
</ol>
<h2 id="5-leetcode-977有序数组的平方"><a href="#5-leetcode-977有序数组的平方" class="headerlink" title="5.leetcode-977有序数组的平方"></a>5.leetcode-977有序数组的平方</h2><p>题目：nums为非递减顺序的数组，要求返回每个数字平方组成的新数组，也为非递减顺序。</p>
<p>法一：用库函数<code>sort()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = nums,<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    nums[i] *= num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> nums;</span><br></pre></td></tr></table></figure>

<p>法二：利用题目中已按照升序排序这个条件 双指针 <strong>用时间换空间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>, pos = n - <span class="number">1</span>; i &lt;= j;) &#123;</span><br><span class="line">    <span class="comment">//前后两个元素比较，若前这元素大于后面的则把放在后面</span></span><br><span class="line">    <span class="keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;</span><br><span class="line">        ans[pos] = nums[i] * nums[i];</span><br><span class="line">        ++i;<span class="comment">//前面元素放在了后面 所以前面进行更新</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ans[pos] = nums[j] * nums[j];<span class="comment">//反之同理</span></span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">    --pos;<span class="comment">//ans元素进行迭代</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;<span class="comment">//用时间换空间</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>leetcode</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针-滑动窗口</title>
    <url>/2023/09/07/%E5%8F%8C%E6%8C%87%E9%92%88-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="双指针-滑动窗口"><a href="#双指针-滑动窗口" class="headerlink" title="双指针-滑动窗口"></a>双指针-滑动窗口</h1><p><strong>思路：</strong>一个<code>for</code>循环中的<code>j</code>表示<strong>起始位置</strong>还是<strong>终止位置</strong>？</p>
<ul>
<li>起始位置：和暴力解法无区别，都要把元素遍历一遍</li>
<li>所以表示的是终止位置：<strong>关键如何移动起始位置？</strong></li>
</ul>
<h2 id="1-leetcode-209-长度最小的子数组"><a href="#1-leetcode-209-长度最小的子数组" class="headerlink" title="1.leetcode-209-长度最小的子数组"></a>1.leetcode-209-长度最小的子数组</h2><p>题目：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p>
<p>返回满足条件最小子数组的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滑动窗口-for循环变量表示终止位置</span></span><br><span class="line"><span class="type">int</span> res = INT32_MAX, n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, start = <span class="number">0</span>, sublength = <span class="number">0</span>;<span class="comment">//初始化起始位置start，长度sublength</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    sum += nums[i];<span class="comment">//更新总和</span></span><br><span class="line">    <span class="comment">//总和大于目标时</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target)&#123;</span><br><span class="line">        sublength = i - start + <span class="number">1</span>;<span class="comment">//计算长度</span></span><br><span class="line">        res = <span class="built_in">min</span>(res, sublength);<span class="comment">//取长度最小值</span></span><br><span class="line">        sum = sum - nums[start];<span class="comment">//进行滑动</span></span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> res == INT32_MAX ? <span class="number">0</span> : res;<span class="comment">//比较res是否有变换，没有则返回0</span></span><br></pre></td></tr></table></figure>





<h2 id="2-leetcode-904-水果成篮"><a href="#2-leetcode-904-水果成篮" class="headerlink" title="2.leetcode-904-水果成篮"></a>2.leetcode-904-水果成篮</h2><p>题目：<a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode）</a></p>
<p>思路：滑动窗口，并且用哈希表存储这个窗口的出现次数</p>
<p>每次将终止位置<code>i</code>移动一个位置，并将<code>fruits[i]</code>加入哈希表，**如果此时哈希表出现超过两个键对则不满足条件，需要不断移动<code>start</code>**，并将<code>fruits[start]</code>从哈希表中移除，直到满足要求。</p>
<p>如果<code>fruits[start]</code>出现次数为<code>0</code>，则要擦除键对。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>, n = fruits.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;<span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    ++cnt[fruits[i]];<span class="comment">//将出现次数记录在哈希表中</span></span><br><span class="line">    <span class="keyword">while</span>(cnt.<span class="built_in">size</span>() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//哈希表中记录的种类大于两个</span></span><br><span class="line">        <span class="keyword">auto</span> it = cnt.<span class="built_in">find</span>(fruits[start]);</span><br><span class="line">        --it-&gt;second;<span class="comment">//减去值</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">            cnt.<span class="built_in">erase</span>(it);<span class="comment">//如果出现次数为零 则擦取键值</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res, i - start + <span class="number">1</span>);<span class="comment">//计算步长</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>



<h2 id="3-leetcode-76-最小覆盖子串-hard"><a href="#3-leetcode-76-最小覆盖子串-hard" class="headerlink" title="3.leetcode-76-最小覆盖子串-hard"></a>3.leetcode-76-最小覆盖子串-hard</h2><p>题目：<a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<p>思路：用两个哈希表，一个<code>cntT</code>表示<code>t</code>中所有的字符以及他们的个数，另一个动态维护<code>s</code>中所有字符以及它们的个数，<strong>如果这个动态表<code>cntS</code>中包含所有<code>cntT</code>中所有的字符，且个数都不少于<code>t</code>哈希表的个数，</strong>则表示当前窗口时可行的，进行左区间的收缩。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tring res = s + <span class="string">&quot;tt&quot;</span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">0</span>, count = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cntS, cntT;<span class="comment">//哈希表创建</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">    ++cntT[c];<span class="comment">//统计t字串中的键对</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    ++cntS[s[i]];<span class="comment">//动态哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (cntT[s[i]] &gt;= cntS[s[i]])&#123;</span><br><span class="line">        <span class="comment">//如果当前T中哈希表大于等于动态哈希表，则说明s[i]字符的数量没有冗余，可以有效增加，若当前字符的出现个数大于t中的个数则出现冗余，不可以增加</span></span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; i &amp;&amp; cntS[s[start]] &gt; cntT[s[start]])&#123;</span><br><span class="line">        <span class="comment">//进行start迭代，当start对应的字符是冗余的即多余目标字符个数</span></span><br><span class="line">        --cntS[s[start]];<span class="comment">//进行数量减少</span></span><br><span class="line">        start++;<span class="comment">//自增</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">//当窗口以满足所有目标字符串大小则进行区间判断和截取</span></span><br><span class="line">        <span class="keyword">if</span> (i - start + <span class="number">1</span> &lt; res.<span class="built_in">size</span>())</span><br><span class="line">            res = s.<span class="built_in">substr</span>(start, i - start + <span class="number">1</span>);<span class="comment">//小区间迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res == s + <span class="string">&quot;tt&quot;</span> ? <span class="string">&quot;&quot;</span> : res;<span class="comment">//比较</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2023/09/08/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p>思路： 循环不变量—–分清楚区间左闭右开 还是左闭右闭</p>
<h2 id="1-leetcode-59-螺旋矩阵"><a href="#1-leetcode-59-螺旋矩阵" class="headerlink" title="1.leetcode-59-螺旋矩阵"></a>1.leetcode-59-螺旋矩阵</h2><p>题目：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II - 力扣（LeetCode）</a></p>
<p>坚持循环不变量–左闭右开</p>
<p><img src="/2023/09/08/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/image-20230908103353646.png" alt="image-20230908103353646"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line"><span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line"><span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line"><span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">    i = startx;</span><br><span class="line">    j = starty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">    <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">        res[startx][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">        res[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">        res[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">    <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">        res[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">    startx++;</span><br><span class="line">    starty++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">    offset += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">    res[mid][mid] = count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>





<h2 id="2-leetcode-54-螺旋矩阵"><a href="#2-leetcode-54-螺旋矩阵" class="headerlink" title="2.leetcode-54-螺旋矩阵"></a>2.leetcode-54-螺旋矩阵</h2><p>题目：<a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode）</a>、<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/">剑指 Offer 29. 顺时针打印矩阵 - 力扣（LeetCode）</a></p>
<p>思路：<strong>不断定义上下左右边界</strong> </p>
<p>题解：<a href="https://leetcode.cn/problems/spiral-matrix/solutions/7155/cxiang-xi-ti-jie-by-youlookdeliciousc-3/">54. 螺旋矩阵 - 力扣（LeetCode）</a>    THX！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector &lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">if</span>(matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans; <span class="comment">//若数组为空，直接返回答案</span></span><br><span class="line"><span class="type">int</span> upper = <span class="number">0</span>; <span class="comment">//赋值上下左右边界</span></span><br><span class="line"><span class="type">int</span> down = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right; ++i) ans.<span class="built_in">push_back</span>(matrix[upper][i]); <span class="comment">//向右移动直到最右</span></span><br><span class="line">    <span class="keyword">if</span>(++ upper &gt; down) <span class="keyword">break</span>; <span class="comment">//重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = upper; i &lt;= down; ++i) ans.<span class="built_in">push_back</span>(matrix[i][right]); <span class="comment">//向下</span></span><br><span class="line">    <span class="keyword">if</span>(-- right &lt; left) <span class="keyword">break</span>; <span class="comment">//重新设定右边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = right; i &gt;= left; --i) ans.<span class="built_in">push_back</span>(matrix[down][i]); <span class="comment">//向左</span></span><br><span class="line">    <span class="keyword">if</span>(-- down &lt; upper) <span class="keyword">break</span>; <span class="comment">//重新设定下边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = down; i &gt;= upper; --i) ans.<span class="built_in">push_back</span>(matrix[i][left]); <span class="comment">//向上</span></span><br><span class="line">    <span class="keyword">if</span>(++ left &gt; right) <span class="keyword">break</span>; <span class="comment">//重新设定左边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>螺旋矩阵</tag>
        <tag>循环</tag>
        <tag>边界确定</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS和DFSleetcode汇总</title>
    <url>/2023/09/09/BFS%E5%92%8CDFSleetcode%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="BFS-DFS"><a href="#BFS-DFS" class="headerlink" title="BFS&amp;DFS"></a>BFS&amp;DFS</h1><p><strong>思路：</strong>构建拓扑序列+深度优先或广度优先</p>
<h2 id="1-leetcode-207-课程表"><a href="#1-leetcode-207-课程表" class="headerlink" title="1.leetcode-207-课程表"></a>1.leetcode-207-课程表</h2><p>题目：<a href="https://leetcode.cn/problems/course-schedule/description/?envType=daily-question&envId=2023-09-09">207. 课程表 - 力扣（LeetCode）</a></p>
<p>题解：<a href="https://leetcode.cn/problems/course-schedule/solutions/359392/ke-cheng-biao-by-leetcode-solution/?envType=daily-question&envId=2023-09-09">207. 课程表 - 力扣（LeetCode）</a></p>
<p><strong>有向图思路：</strong></p>
<ol>
<li>可以用有向图来表示课程间的拓扑关系，用箭头来表示课程之间的修习关系</li>
<li>显然的可以从有向图中得出结论，若图中存在环，则图不存在拓扑排序，无法满足：对于图<code> G</code> 中的任意一条有向边 <code>(u,v)</code>，<code>u</code>在排列中都出现在 <code>v</code> 的前面。因此也不存在一个满足要求的排列。</li>
<li>如果图<code>G</code>是有向无环图，那么它的拓扑排列可能都不止一种。图<code>G</code>包含<code>n</code>个节点却没有任何的边，那么任意一种编号的排列都可以作为拓扑排列。</li>
</ol>
<p><strong>本题思路：</strong></p>
<ul>
<li>将每一门课看作一个节点，</li>
<li>如果想要学习<code>课程A</code>之前必须完成<code>课程B</code>，那么我们从<code>B</code>到<code>A</code>连接一条有向边。这样以来，在拓扑排序中，<code>B</code>一定出现在<code>A</code>的前面。</li>
</ul>
<h3 id="1-1DFS"><a href="#1-1DFS" class="headerlink" title="1.1DFS"></a>1.1DFS</h3><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p>
<ul>
<li><code>「未搜索」</code>：我们还没有搜索到这个节点；</li>
<li><code>「搜索中」</code>：我们搜索过这个节点，但还没有回溯到该节点，<strong>即该节点还没有入栈，还有相邻的节点没有搜索完成</strong>；</li>
<li><code>「已完成」</code>：我们搜索过并且回溯过这个节点，<strong>即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</strong></li>
</ul>
<p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个<code>「未搜索」</code>的节点开始进行深度优先搜索。</p>
<ul>
<li><p>我们将当前搜索的节点 <code>u</code> 标记为<code>「搜索中」</code>，遍历该节点的每一个相邻节点 <code>v</code>：</p>
<p>如果 <code>v</code> 为<code>「未搜索」</code>，那么我们开始搜索 <code>v</code>，待搜索完成回溯到 <code>u</code>；</p>
<p>如果 <code>v</code>为<code>「搜索中」</code>，<strong>那么我们就找到了图中的一个环</strong>，因此是不存在拓扑排序的；</p>
<p>如果 <code>v</code> 为<code>「已完成」</code>，那么说明 <code>v</code>已经在栈中了，而 <code>u</code> 还不在栈中，因此 <code>u </code>无论何时入栈都不会影响到 <code>(u,v)</code> 之前的拓扑关系，以及不用进行任何操作。</p>
</li>
<li><p>当 <code>u</code>的所有相邻节点都为<code>「已完成」</code>时，我们将<code> u</code> 放入栈中，并将其标记为<code>「已完成」</code>。</p>
</li>
</ul>
<p>在整个深度优先搜索的过程结束后，<strong>如果我们没有找到图中的环，那么栈中存储这所有的 <code>n</code> 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</strong></p>
<p><img src="/2023/09/09/BFS%E5%92%8CDFSleetcode%E6%B1%87%E6%80%BB/image-20230909153850172.png" alt="image-20230909153850172"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;<span class="comment">//用于表示课程之间的依赖关系，edge[u]表示课程u是哪些课程的先修课程列表</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;<span class="comment">//用于标记课程的访问状态，0表示未访问，1表示正在访问，2表示已经访问</span></span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;<span class="comment">//返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//深度优先搜索函数，用于检查是否存在环，u表示正在访问的课程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;<span class="comment">//设为1，表示正在访问该课程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;<span class="comment">//遍历u的先修列表edge[u]的课程v</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;<span class="comment">//如果v没有被访问过则递归调用搜索先修课程v</span></span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">//发现了环，直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;<span class="comment">//如果v已经被访问过，则表示存在环</span></span><br><span class="line">                valid = <span class="literal">false</span>;<span class="comment">//设置为false</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;<span class="comment">//标记为2 表示已经访问完毕</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);<span class="comment">//构建有向图</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);<span class="comment">//遍历所有课程，如果存在课程尚未被访问则调用dfs</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="1-2BFS"><a href="#1-2BFS" class="headerlink" title="1.2BFS"></a>1.2BFS</h3><p>DFS是<strong>逆向思维</strong>，所以可以<strong>使用BFS来正向的考虑</strong>拓扑排序中最前面的节点，即没有入度的节点。</p>
<p><strong>当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了<code>「没有任何入边的节点」</code>，那么就代表着这门课可以开始学习了。</strong>按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p>
<p><strong>算法设计：</strong></p>
<p>我们使用一个队列来进行广度优先搜索。初始时，所有<code>入度为 0</code> 的节点都被放入队列中，<strong>它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</strong></p>
<p>在广度优先搜索的每一步中，我们取出队首的<code>节点 u</code>：</p>
<ul>
<li><p>我们将<code>u</code>放入答案中；</p>
</li>
<li><p>我们移除 <code>u</code> 的所有出边，也就是将 <code>u</code> 的所有相邻节点的<code>入度减少 1</code>。如果某个相邻节点 <code>v</code>的入度变为<code> 0</code>，那么我们就将 <code>v</code>放入队列中。</p>
</li>
</ul>
<p>在广度优先搜索的过程结束后。如果答案中包含了这 <code>n</code> 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。\</p>
<p><img src="/2023/09/09/BFS%E5%92%8CDFSleetcode%E6%B1%87%E6%80%BB/image-20230909161315935.png" alt="image-20230909161315935"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;<span class="comment">//边的依赖关系，edge[u]表示u作为了多少其他课程的先修课程</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indeg;<span class="comment">//表示每个课程的入度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);<span class="comment">//有向图的构建</span></span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];<span class="comment">//入度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//创建一个拓扑排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);<span class="comment">//如果入度为0，则将该课程加入队列，表示这个课程可以直接学习</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> visited = <span class="number">0</span>;<span class="comment">//用于表示已访问过的课程数量</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();<span class="comment">//每次从队列中取出一个课程</span></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];<span class="comment">//遍历u作为先修课程，减少v的入度</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);<span class="comment">//如果v的入度变为了0，则加入队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;<span class="comment">//判断是否所有课程都已经学完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>BFS &amp; DFS</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
</search>
