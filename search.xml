<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>点云计算点密度特征</title>
    <url>/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="1-点云密度介绍"><a href="#1-点云密度介绍" class="headerlink" title="1.点云密度介绍"></a>1.点云密度介绍</h1><h1 id="一、点云密度介绍"><a href="#一、点云密度介绍" class="headerlink" title="一、点云密度介绍"></a>一、点云密度介绍</h1><p>点云密度反应了点云的密集程度和分布，是点云的重要特征信息；其与采集设备的分辨率，被采集物体的表面材料有关。</p>
<p>广义上的点云密度有两种方法表示：</p>
<p><strong>①距离密度</strong>，即给定需要计算点的数量，统计每个邻近点到该点的距离作为密度；</p>
<p><strong>②点密度</strong>，即给定邻域半径，统计该点领域半径内的点数量作为点密度。</p>
<hr>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="2-1代码"><a href="#2-1代码" class="headerlink" title="2.1代码"></a>2.1代码</h2><p>这里主要介绍点云的点密度计算，距离密度同理即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> SegByLocalDensity（<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud,</span><br><span class="line">    					std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;&gt;&amp; clusters,</span><br><span class="line">						std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; gappointindices）</span><br><span class="line">&#123;</span><br><span class="line">    	<span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line">		<span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line">        <span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">        std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，并初始化为零</span></span><br><span class="line">                            </span><br><span class="line">        <span class="comment">//nn_in和nn_dists,在算法中用于计算每个点的局部密度，对于每个点通过tree-&gt;ra函数找到其在领域半径内的所有最邻点的索引和距离</span></span><br><span class="line">        <span class="comment">//然后根据最邻点的数量计算出该点的局部密度存储在densities中</span></span><br><span class="line">        <span class="comment">//计算每个点的局部密度，通过nn_indices.size可以获得当前邻居数量，将这个数量作为局部密度作为当前点的密度的densities[]</span></span><br><span class="line">        <span class="comment">//用于后面判断是否满足聚类条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">                densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities，最终转换为每个点的densities</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//基于广度优先搜索</span></span><br><span class="line">        std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (visited[i] || densiities[i]&lt; minPts)<span class="comment">//||或逻辑，只有当该点已经被访问，且点的密度大于minpts，才执行下面的处理</span></span><br><span class="line">           &#123;</span><br><span class="line">                     <span class="keyword">continue</span>; </span><br><span class="line">           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">            pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">            std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">            <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);<span class="comment">//对queue的对象在push的时候会调用拷贝对象的拷贝构造函数，插入queue中的是对象的一份拷贝</span></span><br><span class="line">            visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//如果q中没有元素则返回true</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">                    <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">                    <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">                    q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素-----------------用于退出循环</span></span><br><span class="line">                    cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">                    singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">                    std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">                    std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">                    treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">                    &#123;</span><br><span class="line">                            <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                            <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                    q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                                    visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clusters.<span class="built_in">push_back</span>(cluster);</span><br><span class="line">            gappointindices.<span class="built_in">emplace_back</span>(singlegapindices);</span><br><span class="line">           <span class="comment">// gappointndices.push_back(singlegapindices);、</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-2原始图像"><a href="#2-2原始图像" class="headerlink" title="2.2原始图像"></a><strong>2.2原始图像</strong></h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095757902.png" alt="image-20230803095757902"></p>
<h2 id="2-3处理后的图像"><a href="#2-3处理后的图像" class="headerlink" title="2.3处理后的图像"></a>2.3处理后的图像</h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095812781.png" alt="image-20230803095812781"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>特征提取</tag>
        <tag>点云处理</tag>
      </tags>
  </entry>
  <entry>
    <title>点云基础滤波算法</title>
    <url>/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、点云滤波介绍"><a href="#一、点云滤波介绍" class="headerlink" title="一、点云滤波介绍"></a>一、点云滤波介绍</h1><p>当激光或结构光设备采集的时候会因为被采集物体的表面材料，环境带来许多的噪声点（也叫做离群点），也会因为点云数据冗余，需要进行降采样，便于后续处理数据量的减少。</p>
<p>本文借助PCL开源库，实现基础的点云滤波算法。</p>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="2-1直通滤波"><a href="#2-1直通滤波" class="headerlink" title="2.1直通滤波"></a>2.1直通滤波</h2><p>直通滤波是在给定的通道上（x、y、z等）进行给定区域的滤波，在自动驾驶中一般用来进行地面的滤除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/passthrough.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::PointXYZ minPt, maxPt;</span><br><span class="line">pcl::<span class="built_in">getMinMax3D</span>(*cloud,minPt,maxPt);<span class="comment">//获得输入点云的最大最小边界</span></span><br><span class="line"><span class="comment">//关键配置代码</span></span><br><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt;PassZ;</span><br><span class="line">PassZ.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入点云</span></span><br><span class="line">PassZ.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);<span class="comment">//设置滤波字段名，x方向</span></span><br><span class="line">PassZ.<span class="built_in">setFilterLimits</span>(minPt.z,<span class="number">0</span>);<span class="comment">//设置在过滤方向上的点云</span></span><br><span class="line">PassZ.<span class="built_in">setNegative</span>(<span class="literal">true</span>);<span class="comment">//设置false为保留范围内的点,true为剔除范围内点</span></span><br><span class="line">PassZ.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h2 id="2-2统计滤波"><a href="#2-2统计滤波" class="headerlink" title="2.2统计滤波"></a>2.2统计滤波</h2><p>统计滤波是针对每一个点进行其领域的统计分析，得到该点到其领域点距离的分布特征，过滤掉不满足阈值的离群点，保留内点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt;sor;<span class="comment">//创建过滤器</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入要滤波的点云</span></span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);<span class="comment">//每个点考虑最近邻个数为50</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">1.0</span>);<span class="comment">//设置标准差阈值为1</span></span><br><span class="line"><span class="comment">//这意味着所有距离查询点的平均距离的标准偏差均大于1个标准偏差的所有点都将被标记为离群值并删除。</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud);</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><strong>处理图像</strong></p>
<p><img src="/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/image-20230805160619017.png" alt="image-20230805160619017"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>直通滤波</tag>
        <tag>统计滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
      </tags>
  </entry>
  <entry>
    <title>点云特征识别-圆孔特征识别</title>
    <url>/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>基于点的特征识别算法相对较少，刚好又需要对项目中的圆孔特征进行滤波，故提出了基于<strong>点云密度+RANSAC</strong>的圆孔特征识别滤波算法。首先根据点云的密度差异提取出包含圆孔特征，边界特征的点云集合，然后利用RANSAC进行圆孔拟合，最后获取拟合的圆孔的大小利用包围盒进行去除。</p>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><h2 id="2-1点云密度差异聚类"><a href="#2-1点云密度差异聚类" class="headerlink" title="2.1点云密度差异聚类"></a>2.1点云密度差异聚类</h2><p>计算点云数据的点密度差异，提取出密度大的特征点云，并进行聚类，具体实现见<a href="https://liangzhouzz.github.io/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/">点云计算点密度特征 | Sifanのblog (liangzhouzz.github.io)</a></p>
<p><strong>原始图像</strong></p>
<p><img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152034159.png" alt="image-20230806152034159"></p>
<hr>
<p><strong>提取后的图像：</strong></p>
<p><img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152143989.png" alt="image-20230806152143989"></p>
<h2 id="2-2RANSAC拟合圆"><a href="#2-2RANSAC拟合圆" class="headerlink" title="2.2RANSAC拟合圆"></a>2.2RANSAC拟合圆</h2><p>待补充。。。</p>
<h2 id="2-3包围盒分割"><a href="#2-3包围盒分割" class="headerlink" title="2.3包围盒分割"></a>2.3包围盒分割</h2><p>待补充。。。</p>
<h2 id="2-4代码实现"><a href="#2-4代码实现" class="headerlink" title="2.4代码实现"></a>2.4代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/sample_consensus/sac_model_circle3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/extract_clusters.h&gt;</span><span class="comment">//提取聚类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/crop_box.h&gt;</span><span class="comment">//包围盒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtractCircle</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//聚类</span></span><br><span class="line">        std::vector&lt;pcl::PointIndices&gt;cluster_indices;</span><br><span class="line">        pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;</span><br><span class="line">        ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);</span><br><span class="line">        ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);</span><br><span class="line">        ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());</span><br><span class="line">        ec.<span class="built_in">setSearchMethod</span>(kd_tree);</span><br><span class="line">        ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        ec.<span class="built_in">extract</span>(cluster_indices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RANSAC拟合</span></span><br><span class="line">        pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">        pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">        pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">        std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> counti=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; indices : cluster_indices)</span><br><span class="line">        &#123;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cluster</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_cir</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::<span class="built_in">copyPointCloud</span>(*cloud,indices.indices,*cluster);</span><br><span class="line">                pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">            	<span class="comment">//	估计法向量</span></span><br><span class="line">                pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">                ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">                ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">                ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line">				<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">                seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">                seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//法向量权重</span></span><br><span class="line">                seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">                seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">                seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">                seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">                seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">                seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br><span class="line">            	<span class="comment">//拟合圆的点数限制，因为很容易会拟合半圆，需根据实际的需求调整，防止拟合半圆</span></span><br><span class="line">                <span class="keyword">if</span> (inliers-&gt;indices.<span class="built_in">size</span>() &lt; <span class="number">80</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">//cerr&lt;&lt;&quot;none&quot;&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                coeff.<span class="built_in">push_back</span>(*coefficients);</span><br><span class="line">                counti++;</span><br><span class="line">            	<span class="comment">//提取</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(inliers);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud_cir);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            	<span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">                <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">            	<span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">                <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">            	<span class="comment">//创建包围盒对象</span></span><br><span class="line">                pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">                crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">                crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">                crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">                crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">                <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">                crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">				<span class="comment">//创建分割对象</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5结果"><a href="#2-5结果" class="headerlink" title="2.5结果"></a>2.5结果</h2><p><strong>RANSAC搜索的对象</strong></p>
<p><img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155049673.png" alt="image-20230806155049673"></p>
<p><strong>包围盒分割图像</strong></p>
<p><img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155158365.png" alt="image-20230806155158365"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>滤波</tag>
        <tag>特征识别</tag>
      </tags>
  </entry>
</search>
